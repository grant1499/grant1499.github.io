---
title: Linux基础课笔记（十三）
date: 2021-10-10 09:50:30
tags:
  - Linux
categories:
  - Linux
mathjax: false
copyright: true
---

# 1：lesson7

## 1.1：文件输入输出重定向

参考文章： https://www.linuxprobe.com/basic-learning-03.html。（很棒！）

<!--more-->

文件输入输出重定向在Linux基础课笔记（七）中讲解过了。

简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。

**标准输入重定向（STDIN，文件描述符为0）**：默认从键盘输入，也可从其他文件或命令中输入。

**标准输出重定向（STDOUT，文件描述符为1）**：默认输出到屏幕。

**错误输出重定向（STDERR，文件描述符为2）**：默认输出到屏幕。

**输入重定向表：**

| 符号                 | 作用                                         |
| -------------------- | -------------------------------------------- |
| 命令 < 文件          | 将文件作为命令的标准输入                     |
| 命令 << 分界符       | 从标准输入中读入，直到遇见分界符才停止       |
| 命令 < 文件1 > 文件2 | 将文件1作为命令的标准输入并将标准输出到文件2 |

**输出重定向表：**

| 符号                               | 作用                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| 命令 > 文件                        | 将标准输出重定向到一个文件中（清空原有文件的数据）           |
| 命令 2> 文件                       | 将错误输出重定向到一个文件中（清空原有文件的数据）           |
| 命令 >> 文件                       | 将标准输出重定向到一个文件中（追加到原有内容的后面）         |
| 命令 2>> 文件                      | 将错误输出重定向到一个文件中（追加到原有内容的后面）         |
| 命令 >> 文件 2>&1 或 命令 &>> 文件 | 将标准输出与错误输出共同写入到文件中（追加到原有内容的后面） |

标准输出的文件描述“1”可以省略，错误输出的文件描述“2”不能省略。

## 1.2：管道

管道：类似于文件重定向，**可以将前一个命令的stdout重定向到下一个命令的stdin**。

**注意点：**

1. 管道命令仅处理stdout，会忽略stderr。
2. 管道右边的命令必须能接受stdin。
3. 多个管道命令可以串联。

与文件重定向的区别：

- 文件重定向左边为命令，右边为文件。
- 管道左右两边均为命令，左边有stdout，右边有stdin。

举例：

统计当前目录下所有python文件的总行数，其中find、xargs、wc等命令可以参考常用命令内容。

```shell
find . -name '*.py' | xargs cat | wc -l
# xargs命令将find的标准输出作为文件参数串给cat
# 注意：标准输入和文件参数不一样，cat命令接收标准输入会原样输出，接收文件参数才会输出文件内容
```

## 1.3：命令行通配符与常用转义字符

 Linux系统中的通配符及含义：

| 通配符      | 含义           |
| ----------- | -------------- |
| *           | 任意字符       |
| ?           | 单个任意字符   |
| [a-z]       | 单个小写字母   |
| [A-Z]       | 单个大写字母   |
| [a-Z]       | 单个字母       |
| [0-9]       | 单个数字       |
| [[:alpha:]] | 任意字母       |
| [[:upper:]] | 任意大写字母   |
| [[:lower:]] | 任意小写字母   |
| [[:digit:]] | 所有数字       |
| [[:alnum:]] | 任意字母加数字 |
| [[:punct:]] | 标点符号       |

```shell
[root@linuxprobe ~]# ls -l /dev/sda*  以sda开头

[root@linuxprobe ~]# ls -l /dev/sda?  sda + 单个任意字符

[root@linuxprobe ~]# ls -l /dev/sda[0-9] sda + 0到9中单个数字

[root@linuxprobe ~]# ls -l /dev/sda[135] sda + 1,3,5中单个数字

[root@linuxprobe ~]# touch {AA,BB,CC}.conf  配合大括号使用

[root@linuxprobe ~]# echo file{1,2,3,4,5}
```

4个最常用的转义字符如下所示。

**反斜杠（\）**：使反斜杠后面的一个变量变为单纯的字符。

**单引号（' '）**：转义其中所有的变量为单纯的字符串。

**双引号（" "）**：保留其中的变量属性，不进行转义处理。

**反引号（\` `）**：把其中的命令执行后返回结果。

这里给大家总结一个简单小技巧，虽然可能不够严谨，但绝对简单：**如果参数中出现了空格，就加双引号；如果参数中没有空格，那就不用加双引号**。

## 1.4：重要的环境变量

Linux系统中会用很多环境变量来记录**配置信息**。

在Linux系统中，变量名称一般都是大写的，命令则都是小写的，这是一种约定俗成的规范。

环境变量类似于全局变量，可以被各个进程访问到。我们可以通过修改环境变量来方便地修改系统配置。

查看环境变量：

```shell
列出当前环境下的所有环境变量：
env  # 显示当前用户的变量
set  # 显示当前shell的变量，包括当前用户的变量
export  # 显示当前导出成用户变量的shell变量

输出某个环境变量的值：
echo $PATH
```

环境变量的定义修改删除请参照Linux基础课笔记（三）。

为了将对环境变量的修改应用到未来所有环境下，可以将修改命令放到`~/.bashrc`文件中。
修改完`~/.bashrc`文件后，记得执行`source ~/.bashrc`，来将修改应用到当前的bash环境下。

为何将修改命令放到`~/.bashrc`，就可以确保修改会影响未来所有的环境呢？

- 每次启动bash，都会先执行`~/.bashrc`。
- 每次ssh登陆远程服务器，都会启动一个bash命令行给我们。
- 每次tmux新开一个pane，都会启动一个bash命令行给我们。
- 所以未来所有新开的环境都会加载我们修改的内容。

**常见的环境变量：**

`HOME`：用户的家目录。

`PATH`：可执行文件（命令）的存储路径。路径与路径之间用:分隔。当某个可执行文件同时出现在多个路径中时，会选择从左到右数第一个路径中的执行。**下列所有存储路径的环境变量，均采用从左到右的优先顺序。**

`LD_LIBRARY_PATH`：用于指定动态链接库(.so文件)的路径，其内容是以冒号分隔的路径列表。

`C_INCLUDE_PATH`：C语言的头文件路径，内容是以冒号分隔的路径列表。

`CPLUS_INCLUDE_PATH`：CPP的头文件路径，内容是以冒号分隔的路径列表。

`PYTHONPATH`：Python导入包的路径，内容是以冒号分隔的路径列表。

`JAVA_HOME`：jdk的安装目录。

`CLASSPATH`：存放Java导入类的路径，内容是以冒号分隔的路径列表。

**给命令取别名：**

可以用alias命令来创建一个属于自己的命令别名，语法格式为“alias别名=命令”。若要取消一个命令别名，则是用unalias命令，语法格式为“unalias别名”。

```shell
alias la='ls -A'
alias l='ls -CF'
unalias rm
```

