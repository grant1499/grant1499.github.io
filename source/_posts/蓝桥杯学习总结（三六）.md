---
title: 蓝桥杯学习总结（三六）
tags:
  - 蓝桥杯
  - 竞赛
  - 背包问题
categories:
  - - C++
  - - 算法
mathjax: true
copyright: true
abbrlink: 8e52910a
date: 2021-06-26 15:05:48
---

### 2.习题

#### 2.1 acwing.1226. 包子凑数

第八届蓝桥杯省赛C++A/B组,第八届蓝桥杯省赛JAVAA/B组

<!--more-->

```C++
小明几乎每天早晨都会在一家包子铺吃早餐。
他发现这家包子铺有 N 种蒸笼，其中第 i 种蒸笼恰好能放 Ai 个包子。
每种蒸笼都有非常多笼，可以认为是无限笼。
每当有顾客想买 X 个包子，卖包子的大叔就会迅速选出若干笼包子来，使得这若干笼中恰好一共有 X 个包子。
比如一共有 3 种蒸笼，分别能放 3、4 和 5 个包子。
当顾客想买 11 个包子时，大叔就会选 2 笼 3 个的再加 1 笼 5 个的（也可能选出 1 笼 3 个的再加 2 笼 4 个的）。
当然有时包子大叔无论如何也凑不出顾客想买的数量。
比如一共有 3 种蒸笼，分别能放 4、5 和 6 个包子。
而顾客想买 7 个包子时，大叔就凑不出来了。
小明想知道一共有多少种数目是包子大叔凑不出来的。

输入格式
第一行包含一个整数 N。
接下来 N 行，每行包含一个整数 Ai。

输出格式
输出一个整数代表答案。
如果凑不出的数目有无限多个，输出INF。

数据范围
1≤N≤100,
1≤Ai≤100
输入样例1：
2
4
5
输出样例1：
6
输入样例2：
2
4
6
输出样例2：
INF
样例解释
对于样例1，凑不出的数目包括： 1, 2, 3, 6, 7, 11。
对于样例2，所有奇数都凑不出来，所以有无限多个。
```

思路：

参考题解：https://www.acwing.com/solution/content/17888/。

和[1205. 买不到的数目](https://www.acwing.com/problem/content/1207/)有相似的地方，一样会用到裴蜀定理。

由1205得到结论：（可以当公式记忆）

> 如果 a,b 均是正整数且互质，那么由 ax+by,x≥0,y≥0不能凑出的最大数是 (a−1)(b−1)−1=a*b - a - b.

题目一看，是个**组合问题**，是**完全背包问题**的变形：有几个物品，每个物品无限个，每个物品选任意个，能否凑到某个重量。

任意两个数的组合必定是他们gcd的倍数，同样可以推广到更多数：如果这些数的gcd是d，那么他们的组合是d的倍数。**如果d不是1**，那么必然有无限个数无法被组合出来，答案是INF；**如果d是1**，那么两个数a,b，最大不能表示出来的数是：(a−1)(b−1)−1。当数字更多的时候，这个上界必然更小（可选的数字变多了），而99和98是100内最大的互质的数，所以这个上界选择10000。

那么下面的事情就是看这么多数中有多少个不能被组合出来，回到了刚开始分析的完全背包问题：

忘记了[完全背包问题](https://www.grantdrew.top/posts/141c4cb6.html#2-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98)的复习一下。

1.状态定义:
$d p(i, j)$ 表示前选 $i$ 项物品任意个，重量为 $j$, 属性为能否达到重量 $j($ true $/$ false $)$

2.状态转移:
集合分析法：由最后不同的一步来划分集合，在重量为 $j$ 的时候，第 $i$ 个物品**选了几件**。 $d p(i, j)=d p(i-1, j)\|d p(i-1, j-w(i))\| \ldots \| d p(i-1, j-k * w(i))(k<=j / w(i))$
但是, 完全背包问题有个特殊的地方，那就是状态重叠： $d p(i, j-w(i))$ 是由 $d p(i-1, j-w(i))\|d p(i-1, j-2 * w(i)) \ldots\| d p(i-1, j-k * w(i))(k<=j /w(i))$
转移过来, 仔细看上下两个式子就会发现 $d p(i, j-w(i))$ 的状态就是 $d p(i, j)$ 后面一大部分。
所以最终方程为 $: d p(i, j)=d p(i-1, j) \| d p(i, j-w(i))(w(i)<=j)$。

取“或”，因为只要有一种情况能凑出来就能达到，dp(i,j)是true。

算法1：完全背包二维做法。

```C++
#include <cstdio>
#include <algorithm>
using namespace std;

const int N = 105,M = 10000;// 无法被组合出的数上限是10000
int n;
int a[N];
bool dp[N][M];

int gcd(int a,int b){
    return b ? gcd(b,a%b) : a;
}
int main(){
    scanf("%d",&n);
    int d = 0;
    for (int i = 1;i <= n;i++){
        scanf("%d",&a[i]);
        d = gcd(d,a[i]);// 求a数组的最大公约数
    }

    if (d != 1) puts("INF");
    else{
        dp[0][0] = true;// dp[0][0]初始化为true，重量为0一定能组合出来，什么都不选
        for (int i = 1;i <= n;i++)
            for (int j = 0;j <= M;j++){// j从0开始枚举
                dp[i][j] = dp[i-1][j];
                if (j >= a[i]) dp[i][j] |= dp[i][j-a[i]];
            }
        
        int res = 0;
        for (int j = 1;j <= M;j++){// j从1开始枚举，因为j=0肯定能组合出来
            if (!dp[n][j]) res++;
        }
        printf("%d\n",res);
    }
    return 0;
}
```

算法2：完全背包一维优化。（DP数组只依赖2层，第2维计算j只依赖比它小的数，可以一维优化）

```C++
#include <cstdio>
#include <algorithm>
using namespace std;

const int N = 105,M = 10000;// 无法被组合出的数上限是10000
int n;
int a[N];
bool dp[M];

int gcd(int a,int b){
    return b ? gcd(b,a%b) : a;
}
int main(){
    scanf("%d",&n);
    int d = 0;
    for (int i = 1;i <= n;i++){
        scanf("%d",&a[i]);
        d = gcd(d,a[i]);
    }

    if (d != 1) puts("INF");
    else{
        dp[0] = true;// dp[0][0]初始化为true，重量为0一定能组合出来，什么都不选
        for (int i = 1;i <= n;i++)// 一维优化，j直接从a[i]开始枚举
            for (int j = a[i];j <= M;j++) dp[j] |= dp[j-a[i]];
        
        int res = 0;
        for (int j = 1;j <= M;j++){
            if (!dp[j]) res++;
        }
        printf("%d\n",res);
    }
    return 0;
}
```

#### 2.2 acwing.1070. 括号配对

《信息学奥赛一本通》

```C++
Hecy 又接了个新任务：BE 处理。
BE 中有一类被称为 GBE。
以下是 GBE 的定义：
空表达式是 GBE
如果表达式 A 是 GBE，则 [A] 与 (A) 都是 GBE
如果 A 与 B 都是 GBE，那么 AB 是 GBE
下面给出一个 BE，求至少添加多少字符能使这个 BE 成为 GBE。
注意：BE 是一个仅由(、)、[、]四种字符中的若干种构成的字符串。

输入格式
输入仅一行，为字符串 BE。

输出格式
输出仅一个整数，表示增加的最少字符数。

数据范围
对于所有输入字符串，其长度小于100。

输入样例：
[])
输出样例：
1
```

思路：