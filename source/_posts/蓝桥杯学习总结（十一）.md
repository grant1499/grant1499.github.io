---
title: 蓝桥杯学习总结（十一）
date: 2021-04-29 09:39:49
tags: [蓝桥杯,竞赛,DP,背包问题]
categories: 
	- [C++]
	- [算法]
mathjax: true
copyright: true
---

### 2.简单DP

动态规划（Dynamic Programming，DP）是一种用来解决一类**最优化问题**的算法思想。

背包问题是一类经典的DP问题，灵活多变。

[背包问题模板整理点这里](https://valen.blog.csdn.net/article/details/87878853?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control)

<!--more-->

#### 2.1 acwing.2. 01背包问题（背包九讲 , 模板题）

```C++
有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。
第 i 件物品的体积是 vi，价值是 wi。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

输入格式
第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。
接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。

输出格式
输出一个整数，表示最大价值。

数据范围
0<N,V≤1000
0<vi,wi≤1000
输入样例
4 5
1 2
2 4
3 4
4 5
输出样例：
8
```

思路：

参考1：y总视频讲解，参考2：《算法笔记》，参考3：《LeetCode 101》刷题指南

如果采用暴力枚举每一件物品放或者不放进背包，有两种选择，所以时间复杂度为$O(2^n)$，非常大。

接下来考虑**动态规划**求解。

##### 先尝试二维解法。

我们可以定义一个二维数组dp存储最大价值，其中`dp[i][j]` 表示前i 件物品体积不超过j （**即此时背包容量**

**为j**）的情况下能达到的最大价值。

在我们遍历到第i 件物品时，在当前背包总容量为j 的情况下，

1. 如果我们不将物品i 放入背包，那么`dp[i][j]= dp[i-1][j]`，即前i 个物品的最大价值等于只取前i-1 个

   物品时的最大价值；

2. 如果我们将物品i 放入背包，假设第i 件物品体积为wi，价值为vi，那么我们得到

   `dp[i][j] = dp[i-1][j-w[i]] + v[i]`。我们只需在遍历过程中对这两种情况取最大值即可，总时间复杂度和空间复杂度都为$O(NV)$。

综合上面提到的2种选择策略，我们可以得到状态转移方程：

`dp[i][j] = max{dp[i-1][j],dp[i-1][j-w[i]] + v[i]}`

确定初始化边界，`dp[0][0] = 0	`.

注意**理解误区**：

`dp[i][j]`里的`i`不是表示选择了前i个物品，而是表示对前i个物品做出两中策略的选择；

里面的`j`不是表示当前物品的总体积等于j，而是表示前i 件物品体积不超过j 。

这里给出一位大佬的解释：

```C++
无论 j 表示体积正好是 j 还是 不超过 j ，它的式子都是一样的 j - v[i]， 但是理解不同而已。
有一点不同就是：如果 j 表示体积正好是 j 的话，那么答案就需要遍历求max。如果表示的是 不超过 j 的话，答案就是 f[n][m] 。
如果只考虑第1件物品的话，应该只有 f[1][ v[1] ] = w[1] 其他的都是不存在最大质量的（都为0）。
但是按照 原来的初始化的话，f数组的第一行：f[1][ v[1] - v ] = v[1]（而这样的式子却代表的是 j 表示不超过 j 的情况、可以把两种情况的 f 数组画出来）
所以我认为：
1、j 表示 体积正好为 j ：需要 f[1][ v[1] ] = w[1]，其余的赋值为零。这样得到的数组 f 才能被解释赋予意义。答案就需要遍历求max。
2、j 表示 体积不超过 j ：式子不变，初始化不变，只是求答案不需要遍历，答案就是 f[n][m]。
```

再贴一位大佬的题解：（十分详细了）https://www.acwing.com/solution/content/1374/

代码：

```C++
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 1010;
int dp[N][N]; // dp[0][0] = 0
int v[N],w[N];
int n,m;

int main(){
    cin >> n >> m;
    
    for (int i = 1;i <= n;i++) cin >> v[i] >> w[i];
    
    for (int i = 1;i <= n;i++)
        for (int j = 0;j <= m;j++){
            dp[i][j] = dp[i-1][j];
            if (j - v[i] >= 0){
                dp[i][j] = max(dp[i-1][j],dp[i-1][j-v[i]]+w[i]);
            }
        }
    
    cout << dp[n][m];
    return 0;
}
```

##### 再尝试一维优化。

我们可以进一步对0-1 背包进行空间优化，将空间复杂度降低为$O(V)$。时间复杂度已经不能再优化了。

![image-20210430213638586](蓝桥杯学习总结（十一）/image-20210430213638586.png)

这里可以发现我们`dp[i][j]`永远只依赖于上一排左边的信息，之前算过的其他物品都不需要再使用。因此我

们可以去掉dp 矩阵的第一个维度，在考虑物品i 时变成dp[j]= max(dp[j], dp[j-w] + v)。这里要注意我们在遍

历每一行的时候必须**逆向遍历**，这样才能够调用上一行物品i-1 时dp[j-w] 的值；若按照从左往右的顺序进行正

向遍历，则dp[j-w] 的值在遍历到j 之前就已经被更新成物品i 的值了。

从二维变成一维，相当于把二维中第一个维度变成循环滚动只有1行的数组dp[N]。

如果我们仍然从左往右计算dp[j]，那么可能存在污染，因为后面的数据根据前面递推而来，在滚动的时候可能要用到dp[i-1]（即上一次循环的数据时，实际上这个位置的数据已经在这次循环时被更新过了，用到的是dp[i]的数据，那么就出错了。

只有通过逆序枚举v，即从右往左滚动数组，这次计算dp[i]时依然根据上次循环递推而来，而且dp[i-v[i]]并没有被污染，才能得到正确结果。

模拟过程：https://www.acwing.com/activity/content/code/content/625657/

我们注意到在处理数据时，我们是一个物品一个物品，一个一个体积的枚举。

因此我们可以不必开两个数组记录体积和价值，而是边输入边处理。

代码：

```C++
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 1010;
int dp[N];
int n,m;
int v,w;
int main(){
    cin >> n >> m;
    for (int i = 1;i <= n;i++){
        cin >> v >> w; // 边输入边处理
        for (int j = m;j >= v;j--){
            dp[j] = max(dp[j],dp[j-v]+w);
        }
    }    
    cout << dp[m];
    return 0;
}
```

