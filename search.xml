<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ STL与Java util对比</title>
    <url>/posts/4c2b5dfd.html</url>
    <content><![CDATA[<h2 id="常用容器操作"><a href="#常用容器操作" class="headerlink" title="常用容器操作"></a>常用容器操作</h2><h3 id="1-vector-和-ArrayList"><a href="#1-vector-和-ArrayList" class="headerlink" title="1.vector 和 ArrayList"></a>1.vector 和 ArrayList</h3><span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a; - ArrayList&lt;Integer&gt; a = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">size() - size()  <span class="comment">// 返回元素个数</span></span><br><span class="line">empty() - isEmpty()  <span class="comment">// 返回是否为空</span></span><br><span class="line">clear() - clear  <span class="comment">// 清空</span></span><br><span class="line">front()/back() - get(<span class="number">0</span>)/get(a.size() - <span class="number">1</span>)</span><br><span class="line">push_back()/pop_back() - add()/remove(a.size() - <span class="number">1</span>)</span><br><span class="line">begin()/end() - iterator()</span><br><span class="line">[] - get()</span><br><span class="line">支持比较运算 - 不支持比较运算</span><br><span class="line">    </span><br><span class="line">ArrayList 的遍历：</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i++) a.get(i);</span><br><span class="line"></span><br><span class="line">Iterator&lt;Integer&gt; iterator = <span class="built_in">list</span>.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) iterator.next()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num : a) num;</span><br></pre></td></tr></table></figure>

<h3 id="2-pair-和-Pair（Java-需要-import-javafx-util-Pair-，目前-acwing-不支持）"><a href="#2-pair-和-Pair（Java-需要-import-javafx-util-Pair-，目前-acwing-不支持）" class="headerlink" title="2.pair 和 Pair（Java 需要 import javafx.util.Pair ，目前 acwing 不支持）"></a>2.pair 和 Pair（Java 需要 import javafx.util.Pair ，目前 acwing 不支持）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p = <span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">2</span>); - Pair&lt;Integer, Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">1</span>, <span class="number">2</span>); </span><br><span class="line">first - getKey() <span class="comment">// 第一个元素</span></span><br><span class="line">second - getValue() <span class="comment">// 第二个元素</span></span><br><span class="line">支持比较运算 - 不支持比较运算</span><br></pre></td></tr></table></figure>

<h3 id="3-string-和-String"><a href="#3-string-和-String" class="headerlink" title="3.string 和 String"></a>3.string 和 String</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> a = <span class="string">&quot;yxc&quot;</span>; - String b = <span class="string">&quot;hqh&quot;</span>;</span><br><span class="line">size()/length() - length()  <span class="comment">// 返回字符串长度</span></span><br><span class="line">empty()</span><br><span class="line">clear()</span><br><span class="line">substr(起始下标，(子串长度)) - substring(起始下标，(终止下标 + <span class="number">1</span>)) <span class="comment">// 返回子串</span></span><br><span class="line">c_str()  <span class="comment">// 返回字符串所在字符数组的起始地址</span></span><br><span class="line">支持加法运算 - 支持加法运算</span><br></pre></td></tr></table></figure>

<h3 id="4-queue-stack-deque-和-Deque-有两个实现类，一般使用-ArrayDeque"><a href="#4-queue-stack-deque-和-Deque-有两个实现类，一般使用-ArrayDeque" class="headerlink" title="4.queue, stack, deque 和 Deque (有两个实现类，一般使用 ArrayDeque)"></a>4.queue, stack, deque 和 Deque (有两个实现类，一般使用 ArrayDeque)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>, 队列</span><br><span class="line">   size() - size()</span><br><span class="line">   empty() - isEmpty()</span><br><span class="line">   push() - offer()  <span class="comment">// 向队尾插入一个元素</span></span><br><span class="line">   front() - peek()  <span class="comment">// 返回队头元素</span></span><br><span class="line">   back()  <span class="comment">// 返回队尾元素</span></span><br><span class="line">   pop() - poll()  <span class="comment">// 弹出队头元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>, 栈</span><br><span class="line">   size() - size()</span><br><span class="line">   empty() - isEmpty()</span><br><span class="line">   push() - push()  <span class="comment">// 向栈顶插入一个元素</span></span><br><span class="line">   top() - peek()  <span class="comment">// 返回栈顶元素</span></span><br><span class="line">   pop() - pop()  <span class="comment">// 弹出栈顶元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>, 双端队列</span><br><span class="line">   size() - size()</span><br><span class="line">   empty() - isEmpty()</span><br><span class="line">   clear() - clear()</span><br><span class="line">   front()/back() - getFirst()/getLast()</span><br><span class="line">   push_back()/pop_back() - offerLast()/pollLast()</span><br><span class="line">   push_front()/pop_front() - offerFirst()/pollFirst()</span><br><span class="line">   begin()/end() - iterator()</span><br><span class="line">   []</span><br><span class="line"></span><br><span class="line">作者：我要番茄锅</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/2180/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h3 id="5-priority-queue-和-PriorityQueue"><a href="#5-priority-queue-和-PriorityQueue" class="headerlink" title="5.priority_queue 和 PriorityQueue"></a>5.priority_queue 和 PriorityQueue</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">默认是大根堆 - 默认是小根堆</span><br><span class="line">push() - offer()  <span class="comment">// 插入一个元素</span></span><br><span class="line">top() - peek()  <span class="comment">// 返回堆顶元素</span></span><br><span class="line">pop() - poll() <span class="comment">// 弹出堆顶元素</span></span><br><span class="line"></span><br><span class="line">PriorityQueue 定义成大根堆的方式：</span><br><span class="line">PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br></pre></td></tr></table></figure>

<h3 id="6-unordered-set-和-HashSet"><a href="#6-unordered-set-和-HashSet" class="headerlink" title="6.unordered_set 和 HashSet"></a>6.unordered_set 和 HashSet</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">size() - size()</span><br><span class="line">empty() - isEmpty()</span><br><span class="line">clear() - clear()</span><br><span class="line">insert() - add  <span class="comment">// 插入一个数</span></span><br><span class="line">find() - contains()  <span class="comment">// 查找一个数</span></span><br><span class="line">erase() - remove() <span class="comment">// 删除元素</span></span><br></pre></td></tr></table></figure>

<h3 id="7-unordered-map-和-HashMap"><a href="#7-unordered-map-和-HashMap" class="headerlink" title="7.unordered_map 和 HashMap"></a>7.unordered_map 和 HashMap</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">size() - size()</span><br><span class="line">empty() - isEmpty()</span><br><span class="line">clear() - clear()</span><br><span class="line">insert() - put() <span class="comment">// 插入的数是一个 pair</span></span><br><span class="line">find() - get(key) <span class="comment">// 查找一个 pair</span></span><br><span class="line">erase() - remove() <span class="comment">// 删除元素</span></span><br><span class="line">    - containsKey(key)/containsValue(value) <span class="comment">// 判断元素是否在集合中</span></span><br><span class="line">    - entrySet() <span class="comment">// 返回一个包含所有节点的集合</span></span><br><span class="line">    - keySet() <span class="comment">// 返回一个包含所有键的集合</span></span><br><span class="line">    - values() <span class="comment">// 返回一个包含所有值的集合</span></span><br><span class="line">    - getOrDefault(key, <span class="keyword">default</span> value) <span class="comment">// 返回指定 key 的 value，若 key 不存在 则返回 default value</span></span><br><span class="line">    - putIfAbsent(key, value) <span class="comment">// 如果集合中没有该 key 对应的节点，则插入</span></span><br></pre></td></tr></table></figure>

<p>作者：我要番茄锅<br>链接：<a href="https://www.acwing.com/blog/content/2180/">https://www.acwing.com/blog/content/2180/</a><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>Java util</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中algorithm头文件下的常用函数总结</title>
    <url>/posts/d38917ef.html</url>
    <content><![CDATA[<p>这块内容在STL的文章中都已经介绍过了，但还是单独提下algorithm的内容。</p>
<p>参考自：<a href="https://blog.csdn.net/qq_39445165/article/details/94721121">https://blog.csdn.net/qq_39445165/article/details/94721121</a></p>
<p>详细内容可以参照《算法笔记》。</p>
<span id="more"></span>

<h2 id="①-max、min和abs函数，下面是具体的代码："><a href="#①-max、min和abs函数，下面是具体的代码：" class="headerlink" title="① max、min和abs函数，下面是具体的代码："></a>① max、min和abs函数，下面是具体的代码：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">-2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, max(x, y), min(x, y));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, <span class="built_in">abs</span>(x), <span class="built_in">abs</span>(y));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="②-swap函数，下面是具体的代码："><a href="#②-swap函数，下面是具体的代码：" class="headerlink" title="② swap函数，下面是具体的代码："></a>② swap函数，下面是具体的代码：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">-2</span>;</span><br><span class="line">	swap(x, y);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, x, y);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="③-reverse函数"><a href="#③-reverse函数" class="headerlink" title="③ reverse函数"></a>③ reverse函数</h2><p>reverse（it，it2）可以将数组指针在[it，it2）之间的元素或者容器的迭代器在[it，it2）范围内的元素进行翻转，具体的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>&#125;;</span><br><span class="line">	reverse(arr, arr + <span class="number">8</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="④-next-permutation函数"><a href="#④-next-permutation函数" class="headerlink" title="④ next_permutation函数"></a>④ next_permutation函数</h2><p>使用这个函数可以生成给定序列在全排列中的下一个排列，并且生成的排列是从小到大进行排序的，具体的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">	<span class="comment">//使用C++中的net_permutation函数生成数组的全排列</span></span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d%d%d%d\n&quot;</span>, arr[<span class="number">0</span>], arr[<span class="number">1</span>], arr[<span class="number">2</span>], arr[<span class="number">3</span>]);</span><br><span class="line">	&#125;<span class="keyword">while</span>(next_permutation(arr, arr + <span class="number">4</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="⑤-fill函数"><a href="#⑤-fill函数" class="headerlink" title="⑤ fill函数"></a>⑤ fill函数</h2><p>fill函数可以将数组或者是容器中的某一区间赋予某个相同的值，与memset函数不同的是，这里的赋值可以是数组类型对应范围中的任意值，具体的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>&#125;;</span><br><span class="line">	fill(arr, arr + <span class="number">8</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C++入门笔记（一）</title>
    <url>/posts/1eaad404.html</url>
    <content><![CDATA[<h2 id="1-头文件的防卫式声明"><a href="#1-头文件的防卫式声明" class="headerlink" title="1.头文件的防卫式声明"></a>1.头文件的防卫式声明</h2><p><img src="/posts/1eaad404/image-20210201104338919.png" alt="image-20210201104338919"></p>
<p>写头文件时，非常建议按这种格式写防卫式声明。</p>
<span id="more"></span>

<h2 id="2-基本数据类型"><a href="#2-基本数据类型" class="headerlink" title="2.基本数据类型"></a>2.基本数据类型</h2><p>五种主要的数据类型如下：（其中bool是C语言所没有的）</p>
<p>其实还有别的。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>布尔型</td>
<td>bool</td>
</tr>
<tr>
<td>字符型</td>
<td>char</td>
</tr>
<tr>
<td>整型</td>
<td>int</td>
</tr>
<tr>
<td>浮点型</td>
<td>float</td>
</tr>
<tr>
<td>双浮点型</td>
<td>double</td>
</tr>
</tbody></table>
<p>一些基本类型可以使用一个或多个类型修饰符进行修饰：</p>
<ul>
<li><p>signed</p>
</li>
<li><p>unsigned</p>
</li>
<li><p>short</p>
</li>
<li><p>long</p>
</li>
<li><p>long long</p>
<p><img src="/posts/1eaad404/image-20210202171246995.png" alt="image-20210202171246995"></p>
</li>
</ul>
<p><strong>注意：</strong>不同系统会有所差异，一字节为 8 位。</p>
<p><strong>注意：</strong>long int 8 个字节，int 都是 4 个字节，早期的 C 编译器定义了 long int 占用 4 个字节，int 占用 2 个字节，新版的 C/C++ 标准兼容了早期的这一设定。</p>
<p>bool ： 1个字节 ： 取值范围（false和true，小写）</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>位</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>1 个字节</td>
<td>-128 到 127 或者 0 到 255</td>
</tr>
<tr>
<td>unsigned char</td>
<td>1 个字节</td>
<td>0 到 255</td>
</tr>
<tr>
<td>signed char</td>
<td>1 个字节</td>
<td>-128 到 127</td>
</tr>
<tr>
<td>int</td>
<td>4 个字节</td>
<td>-2147483648 到 2147483647</td>
</tr>
<tr>
<td>unsigned int</td>
<td>4 个字节</td>
<td>0 到 4294967295</td>
</tr>
<tr>
<td>signed int</td>
<td>4 个字节</td>
<td>-2147483648 到 2147483647</td>
</tr>
<tr>
<td>short int</td>
<td>2 个字节</td>
<td>-32768 到 32767</td>
</tr>
<tr>
<td>unsigned short int</td>
<td>2 个字节</td>
<td>0 到 65,535</td>
</tr>
<tr>
<td>signed short int</td>
<td>2 个字节</td>
<td>-32768 到 32767</td>
</tr>
<tr>
<td>long int</td>
<td>8 个字节</td>
<td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td>signed long int</td>
<td>8 个字节</td>
<td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td>unsigned long int</td>
<td>8 个字节</td>
<td>0 到 18,446,744,073,709,551,615</td>
</tr>
<tr>
<td>float</td>
<td>4 个字节</td>
<td>精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字)</td>
</tr>
<tr>
<td>double</td>
<td>8 个字节</td>
<td>双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字)</td>
</tr>
<tr>
<td>long double</td>
<td>16 个字节</td>
<td>长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。</td>
</tr>
<tr>
<td>wchar_t</td>
<td>2 或 4 个字节</td>
<td>1 个宽字符</td>
</tr>
</tbody></table>
<p><strong>注意：</strong>C++中有字符串常量，但是基本类型中却没有字符串变量。</p>
<p><img src="/posts/1eaad404/image-20210202172025668.png" alt="image-20210202172025668"></p>
<p><img src="/posts/1eaad404/image-20210202172115612.png" alt="image-20210202172115612"></p>
<h2 id="3-类型别名"><a href="#3-类型别名" class="headerlink" title="3.类型别名"></a>3.类型别名</h2><h3 id="typedef-声明"><a href="#typedef-声明" class="headerlink" title="typedef 声明"></a>typedef 声明</h3><p>您可以使用 <strong>typedef</strong> 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> type newname; </span><br></pre></td></tr></table></figure>

<p>例如，下面的语句会告诉编译器，feet 是 int 的另一个名称：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> feet;</span><br></pre></td></tr></table></figure>

<p>现在，下面的声明是完全合法的，它创建了一个整型变量 distance：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">feet distance;</span><br></pre></td></tr></table></figure>

<h3 id="using"><a href="#using" class="headerlink" title="using"></a>using</h3><p>语法格式：<code>using 新类型名 = 已有类型名;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Area = <span class="keyword">double</span>; <span class="comment">// 这和typename类似</span></span><br><span class="line">Area a = <span class="number">10.10</span>; <span class="comment">// Area相当于double</span></span><br></pre></td></tr></table></figure>

<h2 id="4-枚举类型"><a href="#4-枚举类型" class="headerlink" title="4.枚举类型"></a>4.枚举类型</h2><p>不限定作用域枚举类型。</p>
<p><img src="/posts/1eaad404/image-20210203121020706.png" alt="image-20210203121020706"></p>
<p>枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。</p>
<p>如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓”枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。</p>
<p>创建枚举，需要使用关键字 <strong>enum</strong>。枚举类型的一般形式为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> 枚举名&#123;</span> </span><br><span class="line">     标识符[=整型常数], </span><br><span class="line">     标识符[=整型常数], </span><br><span class="line">... </span><br><span class="line">    标识符[=整型常数]</span><br><span class="line">&#125; 枚举变量;</span><br></pre></td></tr></table></figure>

<p>如果枚举没有初始化, 即省掉”=整型常数”时, 则从第一个标识符开始。</p>
<p>例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 “blue”。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> &#123;</span> red, green, blue &#125; c;</span><br><span class="line">c = blue;</span><br></pre></td></tr></table></figure>

<p>默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，<strong>green</strong> 的值为 5。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> &#123;</span> red, green=<span class="number">5</span>, blue &#125;;</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>blue</strong> 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。</p>
<p><strong>注意</strong>：整数值不能直接赋值给枚举变量，如果需要将整数值赋值给枚举变量，应进行强制类型转换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">GameResult</span>&#123;</span>WIN,LOSE,TIE,CANCEL&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GameResult result;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">GameResult</span> <span class="title">omit</span> =</span> CANCEL; <span class="comment">// 这两种声明枚举变量的方式相同</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> count = WIN; count &lt;= CANCEL; count++)</span><br><span class="line">	&#123;</span><br><span class="line">		result = GameResult(count); <span class="comment">// 将int型变量count强制转换为GameResult</span></span><br><span class="line">        <span class="comment">// 等价于result = (GameResult)count;</span></span><br><span class="line">		<span class="keyword">if</span> (result == omit) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The game was cancelled&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The game was played&quot;</span>;</span><br><span class="line">			<span class="keyword">if</span> (result == WIN) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;and we won!&quot;</span>;</span><br><span class="line">			<span class="keyword">if</span> (result == LOSE) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;and we lost.&quot;</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment">The game was playedand we won!</span></span><br><span class="line"><span class="comment">The game was playedand we lost.</span></span><br><span class="line"><span class="comment">The game was played</span></span><br><span class="line"><span class="comment">The game was cancelled</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="5-auto类型与decltype类型"><a href="#5-auto类型与decltype类型" class="headerlink" title="5.auto类型与decltype类型"></a>5.auto类型与decltype类型</h2><p>当变量类型名称太长时，可以使用auto进行简化。</p>
<p><img src="/posts/1eaad404/image-20210203124857742.png" alt="image-20210203124857742"></p>
<p><img src="/posts/1eaad404/image-20210203125001245.png" alt="image-20210203125001245"></p>
<h2 id="6-const修饰变量称为符号常量"><a href="#6-const修饰变量称为符号常量" class="headerlink" title="6.const修饰变量称为符号常量"></a>6.const修饰变量称为符号常量</h2><p><img src="/posts/1eaad404/image-20210202173012524.png" alt="image-20210202173012524"></p>
<h2 id="7-sizeof运算符与位运算"><a href="#7-sizeof运算符与位运算" class="headerlink" title="7.sizeof运算符与位运算"></a>7.sizeof运算符与位运算</h2><p><strong>sizeof运算符</strong></p>
<p>语法格式：<code>sizeof(类型名)</code>或者<code>sizeof 表达式</code></p>
<p>结果值： 类型名或表达式的结果所占有的字节数。</p>
<p>例如：<code>sizeof(short)  sizeof x</code></p>
<p><strong>位运算</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>按位与（&amp;）</span><br><span class="line">运算规则：将两个运算量的每一个位进行逻辑与操作。</span><br><span class="line">    <span class="number">3</span> : <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">    <span class="number">5</span> : <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">________________________</span><br><span class="line"><span class="number">3</span> &amp; <span class="number">5</span> : <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">相同位的两个数字都为<span class="number">1</span>，则为<span class="number">1</span>；若有一个不为<span class="number">1</span>，则为<span class="number">0</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>按位或（|）</span><br><span class="line">运算规则：将两个运算量的每一个位进行逻辑或操作。</span><br><span class="line">    <span class="number">3</span> : <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">    <span class="number">5</span> : <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">________________________</span><br><span class="line"><span class="number">3</span> | <span class="number">5</span> : <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">相同位只要一个为<span class="number">1</span>即为<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>按位异或（^）</span><br><span class="line">运算规则：两个操作数进行异或，若对应位相同，该位为<span class="number">0</span>，否则为<span class="number">1</span>。</span><br><span class="line">        <span class="number">0</span> <span class="number">7</span> <span class="number">1</span> : <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">        <span class="number">0</span> <span class="number">5</span> <span class="number">2</span> : <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">_______________________________</span><br><span class="line"><span class="number">0</span> <span class="number">7</span> <span class="number">1</span> ^ <span class="number">0</span> <span class="number">5</span> <span class="number">2</span> : <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">相同位不同则为<span class="number">1</span>，相同则为<span class="number">0</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>按位取反 （~）</span><br><span class="line">运算规则：将一个二进制数按位取反。</span><br><span class="line"><span class="number">3</span> : <span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">~<span class="number">3</span>: <span class="number">1111</span> <span class="number">1100</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/1eaad404/image-20210203113233625.png" alt="image-20210203113233625"></p>
<p><img src="/posts/1eaad404/image-20210203113607711.png" alt="image-20210203113607711"></p>
<p><img src="/posts/1eaad404/image-20210203114610229.png" alt="image-20210203114610229"></p>
<p><img src="/posts/1eaad404/image-20210203114904249.png" alt="image-20210203114904249"></p>
<p><strong>移位运算：</strong></p>
<p>右移运算分为：逻辑右移和算术右移。</p>
<p>有符号数右移时，高位补符号位，如果是负数，补1，是整数则补0.</p>
<p>算术右移相当于除以2的效果；左移相当于乘以2的效果。</p>
<h2 id="8-运算符的优先级与结合性表"><a href="#8-运算符的优先级与结合性表" class="headerlink" title="8.运算符的优先级与结合性表"></a>8.运算符的优先级与结合性表</h2><p>不需要背，需要时查阅即可。</p>
<p><img src="/posts/1eaad404/image-20210203115510900.png" alt="image-20210203115510900"></p>
<h2 id="9-类型转换"><a href="#9-类型转换" class="headerlink" title="9.类型转换"></a>9.类型转换</h2><p><img src="/posts/1eaad404/image-20210203115727659.png" alt="image-20210203115727659"></p>
<p><img src="/posts/1eaad404/image-20210203115801913.png" alt="image-20210203115801913"></p>
<p><img src="/posts/1eaad404/image-20210203115952100.png" alt="image-20210203115952100"></p>
<p><strong>注意</strong>：<code>(int)a</code>和<code>int(a)</code>这两种方法都是等价的。</p>
<p><img src="/posts/1eaad404/image-20210203120004165.png" alt="image-20210203120004165"></p>
<h2 id="10-I-O流"><a href="#10-I-O流" class="headerlink" title="10.I/O流"></a>10.I/O流</h2><p>我们很少用到这种格式控制，可以用printf来代替格式化输出。</p>
<p><img src="/posts/1eaad404/image-20210203120254795.png" alt="image-20210203120254795"></p>
<h2 id="11-引用类型"><a href="#11-引用类型" class="headerlink" title="11.引用类型"></a>11.引用类型</h2><p>引用是一种特殊类型的变量，可以被认为是另一个变量的别名。</p>
<p>引用可以作为形参，实现形实结合。</p>
<p>引用是双向传递的！！</p>
<p><strong>注意两点：</strong></p>
<ul>
<li>声明一个引用时，必须同时对它进行初始化，使它指向一个已存在的对象；</li>
<li>一旦一个引用被初始化，就不能再指向其他对象。</li>
</ul>
<p><img src="/posts/1eaad404/image-20210203140838883.png" alt="image-20210203140838883"></p>
<h2 id="12-含有可变参数的函数"><a href="#12-含有可变参数的函数" class="headerlink" title="*12.含有可变参数的函数"></a>*12.含有可变参数的函数</h2><p><img src="/posts/1eaad404/image-20210203142030769.png" alt="image-20210203142030769"></p>
<p><img src="/posts/1eaad404/image-20210203142053872.png" alt="image-20210203142053872"></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++入门</tag>
      </tags>
  </entry>
  <entry>
    <title>C++入门笔记（七）</title>
    <url>/posts/c1f7bea.html</url>
    <content><![CDATA[<h2 id="1-类类型与系统预定义类型之间的转换"><a href="#1-类类型与系统预定义类型之间的转换" class="headerlink" title="1.类类型与系统预定义类型之间的转换"></a>1.类类型与系统预定义类型之间的转换</h2><p>这个标题很教科书，让人搞不懂，通俗的讲就是用户自己定义的类对象与内置的像int、double之类的数据之间的转换。</p>
<span id="more"></span>

<p>给出两篇参考文章：</p>
<ol>
<li><a href="https://blog.csdn.net/zhulinzhulinlin/article/details/80031029">https://blog.csdn.net/zhulinzhulinlin/article/details/80031029</a></li>
<li><a href="https://blog.csdn.net/SlowIsFastLemon/article/details/104250213">https://blog.csdn.net/SlowIsFastLemon/article/details/104250213</a></li>
</ol>
<h3 id="1-1转换构造函数-预定义类型转换成类类型"><a href="#1-1转换构造函数-预定义类型转换成类类型" class="headerlink" title="1.1转换构造函数:预定义类型转换成类类型"></a>1.1转换构造函数:预定义类型转换成类类型</h3><p>用转换构造函数可以将一个指定类型的数据转换为类的对象。但是不能反过来将一个类的对象转换为一个其他</p>
<p>类型的数据(例如将一个Complex类对象转换成double类型数据)。</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">double</span> real;</span><br><span class="line">        <span class="keyword">double</span> imag;</span><br><span class="line">        C() &#123;&#125;</span><br><span class="line">        C(<span class="keyword">double</span> i, <span class="keyword">double</span> r) &#123; real = i; imag = r; &#125;</span><br><span class="line">        C(<span class="keyword">double</span> r) &#123;<span class="comment">//转换构造函数</span></span><br><span class="line">            real = r; imag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        C <span class="keyword">operator</span> +(C &amp;c1)</span><br><span class="line">        &#123;</span><br><span class="line">            C tem;</span><br><span class="line">            tem.real = c1.real + <span class="keyword">this</span>-&gt;real;</span><br><span class="line">            tem.imag = c1.imag + <span class="keyword">this</span>-&gt;imag;</span><br><span class="line">            <span class="keyword">return</span> tem;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*friend C operator +(C &amp;c1, C&amp;c2)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            C tem;</span></span><br><span class="line"><span class="comment">            tem.real = c1.real + c2.real;</span></span><br><span class="line"><span class="comment">            tem.imag = c1.imag + c2.imag;</span></span><br><span class="line"><span class="comment">            return tem;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">C <span class="title">c1</span><span class="params">(<span class="number">1.1</span>, <span class="number">2.2</span>)</span></span>;</span><br><span class="line">    C c2,c3;</span><br><span class="line">    <span class="function">C <span class="title">c4</span><span class="params">(<span class="number">9.2</span>)</span></span>;</span><br><span class="line">    <span class="comment">//不同调用转换构造函数的方式</span></span><br><span class="line">    c2= C(<span class="number">2.3</span>) + c1;<span class="comment">//C（2.3）调用转换构造函数</span></span><br><span class="line">    c3 = <span class="number">4</span>;<span class="comment">//调用转换构造函数</span></span><br><span class="line">    <span class="comment">// C trans(int a)</span></span><br><span class="line">    <span class="comment">// &#123; return a&#125;</span></span><br><span class="line">    <span class="comment">//  该方式也调用转换构造函数 int-&gt;C </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//b = a + C(2.3);//出错，+重载函数必须为friend</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c1.real &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; c1.imag &lt;&lt; <span class="string">&quot;i&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C(2.1)和C c(2.1)两种方式都可以调用转换构造函数。第一种方式会生成一个临时对象。</p>
<ul>
<li>先声明一个类。</li>
<li>在类中定义一个<strong>只有一个参数</strong>的构造函数，参数是待转换类型的数据。</li>
<li>凡是需要将系统预定义的数据类型转换为类类型的都要用到转换构造函数。</li>
<li>其中要注意的是在C++的类中，用单个实参来调用的构造函数默认定义了从形参类型到该类类型的一个隐式转换。可以写一个类测试一下 如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        A()&#123;&#125;;</span><br><span class="line">        A(<span class="keyword">int</span> a) :a(a) &#123;&#125;</span><br><span class="line">    <span class="comment">//加上explicit关键字的可以防止类构造函数的隐式自动转换</span></span><br><span class="line">    <span class="comment">//那么下面test= 3会报错</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A test;</span><br><span class="line">    test= <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//执行test=3时跳转到A(int a) :a(a) &#123;&#125; ,将3-&gt;A类型</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; test.a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2explicit关键字"><a href="#1-2explicit关键字" class="headerlink" title="1.2explicit关键字"></a>1.2explicit关键字</h3><p>作用就是<strong>防止类构造函数的隐式自动转换</strong>。</p>
<ul>
<li><p>工程中通过explicit关键字杜绝编译器的转换尝试。</p>
</li>
<li><p>转换构造函数被explicit修饰时只能进行显示转换。</p>
<p><img src="/posts/c1f7bea/image-20210415111019594.png" alt="image-20210415111019594"></p>
</li>
</ul>
<p>explicit在下面两种情况下有效：</p>
<ul>
<li>类的构造函数只有一个参数时；</li>
<li>类的构造函数中除了第一个参数以外，其他参数都有默认值的时候。(第一个参数可以有默认值，也可以没有)</li>
</ul>
<p>google C++规范中也约定所有单参数的构造函数都必须是显示的，即使用explicit关键字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mValue;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test()</span><br><span class="line">    &#123;</span><br><span class="line">        mValue = <span class="number">0</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> i)</span><span class="comment">// 只能显式转换</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mValue = i;</span><br><span class="line">    &#125;   </span><br><span class="line">    Test <span class="keyword">operator</span> + (<span class="keyword">const</span> Test&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Test <span class="title">ret</span><span class="params">(mValue + p.mValue)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    Test t;    </span><br><span class="line">    t = <span class="keyword">static_cast</span>&lt;Test&gt;(<span class="number">5</span>);    <span class="comment">// t = Test(5);</span></span><br><span class="line">    </span><br><span class="line">    Test r;  </span><br><span class="line">    r = t + <span class="keyword">static_cast</span>&lt;Test&gt;(<span class="number">10</span>);   <span class="comment">// r = t + Test(10);</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r.value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3类型转换函数-类类型转换成其他类型（系统预定义类型）"><a href="#1-3类型转换函数-类类型转换成其他类型（系统预定义类型）" class="headerlink" title="1.3类型转换函数:类类型转换成其他类型（系统预定义类型）"></a>1.3类型转换函数:类类型转换成其他类型（系统预定义类型）</h3><p>作用：将一个类的对象转换为<strong>其他类型</strong>的数据。这里的其他类型不仅仅指系统预定义类型。</p>
<p>格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">operator</span> 目标类型()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> 目标类型的数据；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型转换函数<strong>没有返回类型</strong>，但是要return 目标类型的数据，<strong>没有参数</strong>，只能定义为类的成员函数。</p>
<p>这样做导致的结果是：类型转换函数看起来没有返回值类型，其实是隐式地指明了返回值类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        A() &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> a)</span> :<span class="title">a</span><span class="params">(a)</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span><span class="comment">//类型转换函数</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">test</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="comment">//用法1</span></span><br><span class="line">    <span class="keyword">int</span> d = test;</span><br><span class="line">    <span class="comment">//用法2</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">2</span> + <span class="keyword">int</span>(test);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>类型转换函数只能定义为成员函数，不能定义为友元函数</li>
<li>一个类可以定义多个类型转换函数，但是要避免二义性</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++入门</tag>
      </tags>
  </entry>
  <entry>
    <title>C++入门笔记（三）</title>
    <url>/posts/63a29b8e.html</url>
    <content><![CDATA[<h2 id="1-C-在非OOP方面的扩充"><a href="#1-C-在非OOP方面的扩充" class="headerlink" title="1.C++在非OOP方面的扩充"></a>1.C++在非OOP方面的扩充</h2><p><img src="/posts/63a29b8e/image-20210309223740177.png" alt="image-20210309223740177"></p>
<span id="more"></span>

<h2 id="2-函数重载回顾"><a href="#2-函数重载回顾" class="headerlink" title="2.函数重载回顾"></a>2.函数重载回顾</h2><p>注意：下图爆红代码，编译器无法正确匹配函数（存在多义性）。</p>
<p><img src="/posts/63a29b8e/image-20210309230013279.png" alt="image-20210309230013279"></p>
<p>正常运行。</p>
<p><img src="/posts/63a29b8e/image-20210309230508180.png" alt="image-20210309230508180"></p>
<h2 id="3-作用域运算符"><a href="#3-作用域运算符" class="headerlink" title="3.作用域运算符::"></a>3.作用域运算符<code>::</code></h2><p><img src="/posts/63a29b8e/image-20210309230703134.png" alt="image-20210309230703134"></p>
<h2 id="4-new和delete"><a href="#4-new和delete" class="headerlink" title="4.new和delete"></a>4.new和delete</h2><p><img src="/posts/63a29b8e/image-20210309230729654.png" alt="image-20210309230729654"></p>
<p>说明：这里p已经声明为int*指针，不需要特意强调new int，编译器会自动识别。</p>
<p><img src="/posts/63a29b8e/image-20210313184252878.png" alt="image-20210313184252878"></p>
<h2 id="5-引用"><a href="#5-引用" class="headerlink" title="5.引用"></a>5.引用</h2><p>不允许建立void类型的引用，因为void本质上不是一个类型；</p>
<p>不能建立数组的引用，不能建立引用的引用。</p>
<p>demo1:</p>
<p><img src="/posts/63a29b8e/image-20210313185008444.png" alt="image-20210313185008444"></p>
<p>demo2:</p>
<p><img src="/posts/63a29b8e/image-20210313185039548.png" alt="image-20210313185039548"></p>
<h2 id="6-对象数组与数组指针"><a href="#6-对象数组与数组指针" class="headerlink" title="6.对象数组与数组指针"></a>6.对象数组与数组指针</h2><h3 id="对象数组及其初始化"><a href="#对象数组及其初始化" class="headerlink" title="对象数组及其初始化"></a>对象数组及其初始化</h3><p>demo1：</p>
<p><img src="/posts/63a29b8e/image-20210316203312632.png" alt="image-20210316203312632"></p>
<p>demo2：</p>
<p><img src="/posts/63a29b8e/image-20210316203415021.png" alt="image-20210316203415021"></p>
<p>demo3：</p>
<p><img src="/posts/63a29b8e/image-20210316203445931.png" alt="image-20210316203445931"></p>
<p>demo4：</p>
<p><img src="/posts/63a29b8e/image-20210316203536971.png" alt="image-20210316203536971"></p>
<h3 id="对象指针"><a href="#对象指针" class="headerlink" title="对象指针"></a>对象指针</h3><p><img src="/posts/63a29b8e/image-20210316203610938.png" alt="image-20210316203610938"></p>
<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>作用基本同Java的this（这里其实没必要加上）</p>
<p><img src="/posts/63a29b8e/image-20210316203645915.png" alt="image-20210316203645915"></p>
<h2 id="7-向函数传递对象"><a href="#7-向函数传递对象" class="headerlink" title="7.向函数传递对象"></a>7.向函数传递对象</h2><p><img src="/posts/63a29b8e/image-20210316203831986.png" alt="image-20210316203831986"></p>
<p><img src="/posts/63a29b8e/image-20210316203924539.png" alt="image-20210316203924539"></p>
<h2 id="8-构造函数与析构函数的执行次序"><a href="#8-构造函数与析构函数的执行次序" class="headerlink" title="8.构造函数与析构函数的执行次序"></a>8.构造函数与析构函数的执行次序</h2><ul>
<li><p>构造函数在对象被创建时调用，析构函数在对象被删除前调用。</p>
</li>
<li><p>后调用的对象先调用析构函数，与构造函数的执行顺序相反。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Point(<span class="keyword">int</span> xx = <span class="number">0</span>, <span class="keyword">int</span> yy = <span class="number">0</span>) &#123; <span class="comment">// 构造函数</span></span><br><span class="line">		x = xx;</span><br><span class="line">		y = yy;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line">	&#125;</span><br><span class="line">    ~Point();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line">Point::~Point()&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;this:%d\n&quot;</span>,<span class="keyword">this</span>-&gt;x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Point p1(1,1), p2(2,2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">this:2</span></span><br><span class="line"><span class="comment">this:1*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++入门</tag>
      </tags>
  </entry>
  <entry>
    <title>C++入门笔记（九）</title>
    <url>/posts/81b972f6.html</url>
    <content><![CDATA[<h2 id="1-纯虚函数与抽象类"><a href="#1-纯虚函数与抽象类" class="headerlink" title="1.纯虚函数与抽象类"></a>1.纯虚函数与抽象类</h2><h3 id="1-1纯虚函数"><a href="#1-1纯虚函数" class="headerlink" title="1.1纯虚函数"></a>1.1纯虚函数</h3><p><strong>首先：强调一个概念</strong></p>
<p>定义一个函数为虚函数，不代表函数为不被实现的函数。</p>
<p>定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。</p>
<p>定义一个函数为纯虚函数，才代表函数没有被实现。</p>
<p>定义纯虚函数是为了<strong>实现一个接口</strong>，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。</p>
<span id="more"></span>

<p><img src="/posts/81b972f6/image-20210415131524794.png" alt="image-20210415131524794"></p>
<h3 id="1-2抽象类"><a href="#1-2抽象类" class="headerlink" title="1.2抽象类"></a>1.2抽象类</h3><p>类似Java中抽象方法与抽象类的区别，只是在基类中说明，具体实现交给派生类。</p>
<p><img src="/posts/81b972f6/image-20210415131904033.png" alt="image-20210415131904033"></p>
<p><img src="/posts/81b972f6/image-20210415131917288.png" alt="image-20210415131917288"></p>
<h3 id="1-3应用抽象类建立栈与队列"><a href="#1-3应用抽象类建立栈与队列" class="headerlink" title="1.3应用抽象类建立栈与队列"></a>1.3应用抽象类建立栈与队列</h3><p>两种类型的表(list)：栈与队列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span>&#123;</span> <span class="comment">// 声明一个抽象类</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">list</span>* head; <span class="comment">// 表头指针</span></span><br><span class="line">        <span class="built_in">list</span>* tail; <span class="comment">// 表尾指针</span></span><br><span class="line">        <span class="built_in">list</span>* next;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="built_in">list</span>()&#123;</span><br><span class="line">            head=tail=next=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">(<span class="keyword">int</span> i)</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">retrieve</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span>:</span><span class="keyword">public</span> <span class="built_in">list</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">store</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">retrieve</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queue::store</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; <span class="comment">// 定义虚函数</span></span><br><span class="line">    <span class="built_in">list</span>* item;</span><br><span class="line">    item = <span class="keyword">new</span> <span class="built_in">queue</span>;</span><br><span class="line">    <span class="keyword">if</span> (!item)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Allocation error\n&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    item-&gt;num = i;</span><br><span class="line">    <span class="keyword">if</span> (tail) tail-&gt;next = item;</span><br><span class="line">    tail = item;</span><br><span class="line">    item-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!head) head = tail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue::retrieve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">list</span>* p;</span><br><span class="line">    <span class="keyword">if</span> (!head)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;list empty\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i = head-&gt;num;</span><br><span class="line">    p = head;</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stack</span>:</span><span class="keyword">public</span> <span class="built_in">list</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">store</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">retrieve</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stack::store</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>* item;</span><br><span class="line">    item = <span class="keyword">new</span> <span class="built_in">stack</span>;</span><br><span class="line">    <span class="keyword">if</span> (!item)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Allocation error\n&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    item-&gt;num = i;</span><br><span class="line">    <span class="keyword">if</span> (head) item-&gt;next = head;</span><br><span class="line">    head = item;</span><br><span class="line">    <span class="keyword">if</span> (!tail) tail = head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack::retrieve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">list</span>* p;</span><br><span class="line">    <span class="keyword">if</span> (!head)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;list empty\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i = head-&gt;num;</span><br><span class="line">    p = head;</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>* p; <span class="comment">// 定义指向抽象类list的指针p</span></span><br><span class="line">    <span class="built_in">queue</span> q_ob;</span><br><span class="line">    p = &amp;q_ob; <span class="comment">// p指向queue对象q_ob</span></span><br><span class="line">    p-&gt;store(<span class="number">1</span>);</span><br><span class="line">    p-&gt;store(<span class="number">2</span>);</span><br><span class="line">    p-&gt;store(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;queue:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i ++) <span class="built_in">cout</span> &lt;&lt; p-&gt;retrieve();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">stack</span> s_ob;</span><br><span class="line">    p = &amp;s_ob;</span><br><span class="line">    p-&gt;store(<span class="number">1</span>);</span><br><span class="line">    p-&gt;store(<span class="number">2</span>);</span><br><span class="line">    p-&gt;store(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;stack:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i ++) <span class="built_in">cout</span> &lt;&lt; p-&gt;retrieve();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++入门</tag>
        <tag>抽象类</tag>
      </tags>
  </entry>
  <entry>
    <title>C++入门笔记（二）</title>
    <url>/posts/2ebc38dc.html</url>
    <content><![CDATA[<h2 id="1-内联函数"><a href="#1-内联函数" class="headerlink" title="1.内联函数"></a>1.内联函数</h2><p>声明内联函数使用inline关键字。</p>
<p>编译时在调用处用函数体进行替换，这样可以节省参数传递，控制转移等开销。</p>
<span id="more"></span>

<p><img src="/posts/2ebc38dc/image-20210203143637716.png" alt="image-20210203143637716"></p>
<p><strong>强调：inline只是对编译器的建议，具体如何处理取决于编译器。</strong></p>
<p>没有用inline修饰的函数也可能被编译为内联。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.1415926535798954</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">calArea</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> PI * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> r = <span class="number">3.0</span>;</span><br><span class="line">	<span class="keyword">double</span> area = calArea(r);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; area &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-constexpr函数（C-11新特性）"><a href="#2-constexpr函数（C-11新特性）" class="headerlink" title="2.constexpr函数（C++11新特性）"></a>2.constexpr函数（C++11新特性）</h2><p>constexpr：也即常量表达式。</p>
<p>语法规定：constexpr修饰的函数在其所有参数都是constexpr时一定返回constexpr。</p>
<p>C++11规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mf=<span class="number">20</span>;		<span class="comment">//20是常量表达式</span></span><br><span class="line">constexper <span class="keyword">int</span> limit=mf+<span class="number">1</span>;	<span class="comment">//mf+1是常量表达式</span></span><br><span class="line">constxper <span class="keyword">int</span> sz=size();	<span class="comment">//只有当size是一个constxper函数时才是一条正确的声明语句</span></span><br></pre></td></tr></table></figure>

<p>不能用普通函数作为constexpr变量的初始值，只能用constexpr函数去初始化constexpr变量。这种函数足够简单，以使得编译时就可以计算其结果。</p>
<p><strong>一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型。</strong></p>
<p>constexpr函数是指能用于常量表达式的函数。该函数要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">new_sz</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> foo = new_sz();</span><br></pre></td></tr></table></figure>

<p>在对变量foo初始化时，编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数。</p>
<p>constexpr函数体内也可以包含其它语句，只要这些语句在运行时不执行任何操作就行。例如，constexpr函数中可以有空语句、类型别名以及using声明。</p>
<h2 id="3-函数重载（重要）"><a href="#3-函数重载（重要）" class="headerlink" title="3.函数重载（重要）"></a>3.函数重载（重要）</h2><p><img src="/posts/2ebc38dc/image-20210203145400561.png" alt="image-20210203145400561"></p>
<p><img src="/posts/2ebc38dc/image-20210203145500712.png" alt="image-20210203145500712"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumOfSquare</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a * a + b * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两个函数同名，只是参数类型和返回类型不同，功能类似</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sumOfSquare</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a * a + b * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m, n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; sumOfSquare(m, n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">double</span> x, y;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; sumOfSquare(x, y) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-OOP的几大基本特点"><a href="#4-OOP的几大基本特点" class="headerlink" title="4.OOP的几大基本特点"></a>4.OOP的几大基本特点</h2><h3 id="4-1抽象"><a href="#4-1抽象" class="headerlink" title="4.1抽象"></a>4.1抽象</h3><p><img src="/posts/2ebc38dc/image-20210203150448563.png" alt="image-20210203150448563"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span> : <span class="comment">// 类的外部访问接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span> newH,<span class="keyword">int</span> newM,<span class="keyword">int</span> newS)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showTime</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>: <span class="comment">// 数据隐藏在类的内部</span></span><br><span class="line">    <span class="keyword">int</span> hour,minute,second;</span><br><span class="line">&#125;; <span class="comment">// 记得末尾的;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2封装"><a href="#4-2封装" class="headerlink" title="4.2封装"></a>4.2封装</h3><p><img src="/posts/2ebc38dc/image-20210203150758714.png" alt="image-20210203150758714"></p>
<h3 id="4-3继承"><a href="#4-3继承" class="headerlink" title="4.3继承"></a>4.3继承</h3><p>在已有类的基础上，进行扩展形成新的类。</p>
<h3 id="4-4多态"><a href="#4-4多态" class="headerlink" title="4.4多态"></a>4.4多态</h3><p>同一名称，采用不同的功能来实现。</p>
<p>目的：达到行为的标识统一，减少程序中标识符的个数。</p>
<h2 id="5-类和对象的定义"><a href="#5-类和对象的定义" class="headerlink" title="5.类和对象的定义"></a>5.类和对象的定义</h2><p>定义类的对象，才可以通过对象使用类中定义的功能。</p>
<h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><p><img src="/posts/2ebc38dc/image-20210203151526209.png" alt="image-20210203151526209"></p>
<p>无论数据成员还是函数成员都可以分成以上三大类。</p>
<p>在类的定义中，不同属性的成员可以按任意顺序出现，修饰访问属性的关键字也可以多次出现。</p>
<p><strong>但是一个成员只能有一种访问属性。</strong></p>
<h3 id="公有类型成员"><a href="#公有类型成员" class="headerlink" title="公有类型成员"></a>公有类型成员</h3><p>在关键字public后面声明，他们是类与外部的接口，任何外部函数都可以访问公有型数据和函数。</p>
<h3 id="私有类型成员"><a href="#私有类型成员" class="headerlink" title="私有类型成员"></a>私有类型成员</h3><p>在关键字private后面声明，只允许本类中的函数访问，而类外部的任何函数都不能访问。</p>
<p>如果紧跟在类名称的后面声明私有成员，则关键字private可以省略。</p>
<h3 id="保护类型成员"><a href="#保护类型成员" class="headerlink" title="保护类型成员"></a>保护类型成员</h3><p>与private类似，具体差别详见后面。</p>
<h3 id="定义对象"><a href="#定义对象" class="headerlink" title="定义对象"></a>定义对象</h3><p>语法格式： 类名  对象名;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Clock myClock;</span><br></pre></td></tr></table></figure>

<h3 id="访问成员"><a href="#访问成员" class="headerlink" title="访问成员"></a>访问成员</h3><p>类中成员之间可以直接使用，成员名互相访问。</p>
<p>从类外访问成员使用“对象名.成员名”方式来访问public成员。</p>
<h3 id="类的成员函数"><a href="#类的成员函数" class="headerlink" title="类的成员函数"></a>类的成员函数</h3><p>在类的成员函数中，可以访问到类的全部成员。</p>
<p><img src="/posts/2ebc38dc/image-20210203154639070.png" alt="image-20210203154639070"></p>
<p><img src="/posts/2ebc38dc/image-20210203154703412.png" alt="image-20210203154703412"></p>
<p>与普通函数不同的是，实现成员函数时要指明类的名称。可以在类的内部或者外部实现。</p>
<p>成员函数可以定义在类定义内部，或者单独使用<strong>范围解析运算符 ::</strong> 来定义。在类定义中定义的成员函数把函数声明为<strong>内联</strong>的，即便没有使用 inline 标识符。所以您可以按照如下方式定义 <code>getVolume()</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">double</span> length;      <span class="comment">// 长度</span></span><br><span class="line">      <span class="keyword">double</span> breadth;     <span class="comment">// 宽度</span></span><br><span class="line">      <span class="keyword">double</span> height;      <span class="comment">// 高度</span></span><br><span class="line">   </span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getVolume</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>您也可以在类的外部使用<strong>范围解析运算符 ::</strong> 定义该函数，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Box::getVolume</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span> newH = <span class="number">0</span>, <span class="keyword">int</span> newM = <span class="number">0</span>, <span class="keyword">int</span> newS = <span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showTime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">	<span class="keyword">int</span> hour, minute, second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clock::setTime</span><span class="params">(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS)</span> </span>&#123;</span><br><span class="line">	hour = newH;</span><br><span class="line">	minute = newM;</span><br><span class="line">	second = newS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clock::showTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; hour &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; minute &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Clock myClock;<span class="comment">// 定义对象</span></span><br><span class="line">	myClock.setTime(<span class="number">8</span>, <span class="number">30</span>, <span class="number">30</span>);<span class="comment">// 使用对象</span></span><br><span class="line">	myClock.showTime();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-构造函数"><a href="#6-构造函数" class="headerlink" title="6.构造函数"></a>6.构造函数</h2><p>构造函数时是类中的特殊成员函数，用于描述初始化算法。</p>
<p><strong>构造函数的作用就是在对象被创建时利用特定的值构造对象，将对象初始化为一个特定的状态。</strong></p>
<p><strong>与一般函数的重要区别</strong>：函数名与类名相同，不能定义返回值类型，没有return语句。</p>
<p><img src="/posts/2ebc38dc/image-20210204210411325.png" alt="image-20210204210411325"></p>
<p><img src="/posts/2ebc38dc/image-20210204210603157.png" alt="image-20210204210603157"></p>
<p>如果类中没有写构造函数，编译器会自动生成一个隐含的默认构造函数，该构造函数的参数列表和函数体皆为空。</p>
<p><img src="/posts/2ebc38dc/image-20210204211618472.png" alt="image-20210204211618472"></p>
<p><img src="/posts/2ebc38dc/image-20210204211726359.png" alt="image-20210204211726359"></p>
<h3 id="构造函数初始化列表"><a href="#构造函数初始化列表" class="headerlink" title="构造函数初始化列表"></a><strong>构造函数初始化列表</strong></h3><p>构造函数初始化列表以一个冒号开始，接着是以逗号分隔的数据成员列表，每个数据成员后面跟一个放在括号中的初始化式。</p>
<p><strong>对于const修饰的数据成员和引用类型的数据成员，不允许直接用赋值语句赋值</strong>，只能通过构造函数的初始化列表进行初始化。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">float</span> b;</span><br><span class="line">    <span class="comment">//构造函数初始化列表</span></span><br><span class="line">    CExample(): a(<span class="number">0</span>),b(<span class="number">8.8</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="comment">//构造函数内部赋值</span></span><br><span class="line">    CExample()</span><br><span class="line">    &#123;</span><br><span class="line">        a=<span class="number">0</span>;</span><br><span class="line">        b=<span class="number">8.8</span>;</span><br><span class="line">    &#125;<span class="comment">// 两个构造函数的结果是一样的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example 1</span></span><br><span class="line"><span class="comment">// 类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Clock(<span class="keyword">int</span> newH,<span class="keyword">int</span> newM,<span class="keyword">int</span> newS);<span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span> newH,<span class="keyword">int</span> newM,<span class="keyword">int</span> newS)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showTime</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> hour,minute,second;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 构造函数的实现1,初始化列表</span></span><br><span class="line">Clock::Clock(<span class="keyword">int</span> newH,<span class="keyword">int</span> newM,<span class="keyword">int</span> newS):</span><br><span class="line">hour(newH),minute(newM),second(newS)&#123;</span><br><span class="line">    <span class="comment">// 将newH赋值给hour初始化，等价于在函数体中对应赋值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造函数的实现2,一般方式，等价的</span></span><br><span class="line"><span class="comment">//Clock::Clock(int newH,int newM,int newS)&#123;</span></span><br><span class="line"><span class="comment">//    hour = newH;minute = newM;second = newS;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Clock <span class="title">c</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    c.showTime();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Clock(<span class="keyword">int</span> newH,<span class="keyword">int</span> newM,<span class="keyword">int</span> newS);</span><br><span class="line">    Clock();<span class="comment">// 默认构造函数，经验告诉我们最好加上</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span> newH,<span class="keyword">int</span> newM,<span class="keyword">int</span> newS)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showTime</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> hour,minute,second;</span><br><span class="line">&#125;;</span><br><span class="line">Clock::Clock():hour(<span class="number">0</span>),minute(<span class="number">0</span>),second(<span class="number">0</span>)&#123;&#125;<span class="comment">// 默认构造函数的实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Clock <span class="title">c1</span><span class="params">(<span class="number">8</span>,<span class="number">10</span>,<span class="number">0</span>)</span></span>;<span class="comment">// 调用有参数的构造函数</span></span><br><span class="line">    Clock c2;<span class="comment">// 调用无参数的构造函数</span></span><br><span class="line">    c1.showTime();</span><br><span class="line">    c2.showTime();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a><strong>委托构造函数</strong></h3><p>作用：省事，方便修改。在类的继承中会用到，子类的构造函数调用父类的构造函数。</p>
<p><img src="/posts/2ebc38dc/image-20210204220622695.png" alt="image-20210204220622695"></p>
<h3 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h3><p>系统会自动生成一个默认的复制构造函数，复制出完全相同的新对象。</p>
<p><img src="/posts/2ebc38dc/image-20210204221028604-1617715750285.png" alt="image-20210204221028604"></p>
<p>我们只能使用这里的引用进行复制，而不让它对指向的对象进行修改。</p>
<p>这样既能传参又能保证安全性。</p>
<p><img src="/posts/2ebc38dc/image-20210204221610258.png" alt="image-20210204221610258"></p>
<p><img src="/posts/2ebc38dc/image-20210204221758899.png" alt="image-20210204221758899"></p>
<p><img src="/posts/2ebc38dc/image-20210204222349707.png" alt="image-20210204222349707"></p>
<p>有点小难呢，举个栗子吧：</p>
<p><strong>调用复制构造函数的三种情况：</strong></p>
<p>（1）用类的一个对象去初始化另一个对象；</p>
<p>（2）如果函数的形参是类的对象，调用函数时，进行形参和实参的结合；</p>
<p>（3）如果函数的返回值是类的对象，函数执行完成返回调用者。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Point(<span class="keyword">int</span> xx = <span class="number">0</span>, <span class="keyword">int</span> yy = <span class="number">0</span>) &#123; <span class="comment">// 构造函数</span></span><br><span class="line">		x = xx;</span><br><span class="line">		y = yy;</span><br><span class="line">	&#125;</span><br><span class="line">	Point(<span class="keyword">const</span> Point&amp; p);<span class="comment">// 复制构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point::Point(<span class="keyword">const</span> Point&amp; p) &#123;</span><br><span class="line">	x = p.x;</span><br><span class="line">	y = p.y;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Calling the copy constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; p.getX() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Point a;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Point a;<span class="comment">// 对象a</span></span><br><span class="line">	<span class="function">Point <span class="title">b</span><span class="params">(a)</span></span>;<span class="comment">// 情况1，用a初始化b，第一次调用复制构造函数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; b.getX() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	fun1(b);<span class="comment">// 情况2，对象b作为fun1的实参，第二次调用复制构造函数</span></span><br><span class="line">	b = fun2();<span class="comment">//  情况3，函数的返回值是类对象，第三次调用复制构造函数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; b.getX() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>情况3下，a是fun2()的局部对象，离开建立它的函数fun2后就消亡了，编译器在处理这种情况时会创建一个无名临时变量，生存期在<code>b = fun2();</code>中。</p>
<h2 id="7-析构函数"><a href="#7-析构函数" class="headerlink" title="7.析构函数"></a>7.析构函数</h2><p>它完成对象被删除前的一些清理工作。</p>
<p>如果程序中未声明析构函数，编译器会自动产生一个默认的构造函数，函数体为空。</p>
<p>它的名称由类名前加“~”构成，<strong>没有参数和返回值</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Point(<span class="keyword">int</span> xx = <span class="number">0</span>, <span class="keyword">int</span> yy = <span class="number">0</span>) &#123; <span class="comment">// 构造函数</span></span><br><span class="line">		x = xx;</span><br><span class="line">		y = yy;</span><br><span class="line">	&#125;</span><br><span class="line">    ~Point(); </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line">Point::~Point()&#123;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++入门</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>C++入门笔记（五）</title>
    <url>/posts/bb1147ac.html</url>
    <content><![CDATA[<h2 id="1常类型"><a href="#1常类型" class="headerlink" title="1常类型"></a>1常类型</h2><span id="more"></span>

<h3 id="1-1常引用"><a href="#1-1常引用" class="headerlink" title="1.1常引用"></a>1.1常引用</h3><p><img src="/posts/bb1147ac/image-20210326195826852.png" alt="image-20210326195826852"></p>
<p>如果用常引用作为形参，便不会修改实参。</p>
<h3 id="1-2常对象"><a href="#1-2常对象" class="headerlink" title="1.2常对象"></a>1.2常对象</h3><p><img src="/posts/bb1147ac/image-20210326203559729.png" alt="image-20210326203559729"></p>
<p><img src="/posts/bb1147ac/image-20210326203730026.png" alt="image-20210326203730026"></p>
<h3 id="1-3常对象成员"><a href="#1-3常对象成员" class="headerlink" title="1.3常对象成员"></a>1.3常对象成员</h3><h4 id="1-3-1常数据成员"><a href="#1-3-1常数据成员" class="headerlink" title="1.3.1常数据成员"></a>1.3.1常数据成员</h4><p><img src="/posts/bb1147ac/image-20210326203907290.png" alt="image-20210326203907290"></p>
<p>如果在一个类中声明了常数据成员，那么构造函数就只能通过成员初始化列表对该数据成员进行初始化，而其他任何函数都不能对该成员赋值。</p>
<p>一旦对常数据成员初始化后，它的值就不能改了。</p>
<h4 id="1-3-2常成员函数"><a href="#1-3-2常成员函数" class="headerlink" title="1.3.2常成员函数"></a>1.3.2常成员函数</h4><p><img src="/posts/bb1147ac/image-20210326204233223.png" alt="image-20210326204233223"></p>
<p><img src="/posts/bb1147ac/image-20210326204455146.png" alt="image-20210326204455146"></p>
<p>常成员函数不能更新对象的数据成员，也不能调用该类中的普通成员函数，这就保证它就一定不会更新数据成员的值。</p>
<p><img src="/posts/bb1147ac/image-20210326204642137.png" alt="image-20210326204642137"></p>
<h2 id="2派生类与继承"><a href="#2派生类与继承" class="headerlink" title="2派生类与继承"></a>2派生类与继承</h2><p><img src="/posts/bb1147ac/image-20210326220105829.png" alt="image-20210326220105829"></p>
<p><strong>示例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; age &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; sex &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		<span class="built_in">string</span> name;</span><br><span class="line">		<span class="keyword">int</span> age;</span><br><span class="line">		<span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span> <span class="keyword">public</span> Person&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; department &lt;&lt; salary&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="built_in">string</span> department;</span><br><span class="line">		<span class="keyword">float</span> salary;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>protected关键字修饰保护数据成员，可以被本类的成员函数访问，也可以被本类的派生类的成员函数访问，类以外的任何访问都是非法的，它是半隐藏的。</p>
<p>Employee类（派生类，子类）继承了Person类（基类，父类），public代表公有继承。</p>
<p>如果不显式地给出继承方式，则默认为私有方式继承。</p>
<p><img src="/posts/bb1147ac/image-20210326205705011.png" alt="image-20210326205705011"></p>
<p>派生类把基类的全部成员（除构造函数和析构函数之外）接收过来。</p>
<p>调整从基类接收来的成员：</p>
<ul>
<li>一方面改变基类成员在派生类中的访问属性，主要通过派生类声明时的继承方式来控制；</li>
<li>另一方面对基类的成员进行重定义，在派生类中声明一个与基类成员同名的成员，这时会覆盖基类的成员。</li>
</ul>
<h3 id="2-1基类成员在派生类中的访问属性"><a href="#2-1基类成员在派生类中的访问属性" class="headerlink" title="2.1基类成员在派生类中的访问属性"></a><strong>2.1基类成员在派生类中的访问属性</strong></h3><p><img src="/posts/bb1147ac/image-20210326212627017.png" alt="image-20210326212627017"></p>
<h3 id="2-2派生类对基类成员的访问规则"><a href="#2-2派生类对基类成员的访问规则" class="headerlink" title="2.2派生类对基类成员的访问规则"></a><strong>2.2派生类对基类成员的访问规则</strong></h3><p>派生类对基类的访问形式主要有两种：</p>
<ul>
<li>内部访问：派生类中新增的成员函数对于基类继承来的成员的访问；</li>
<li>对象访问：在派生类外部，通过对象进行访问。</li>
</ul>
<h4 id="2-2-1私有继承的访问规则"><a href="#2-2-1私有继承的访问规则" class="headerlink" title="2.2.1私有继承的访问规则"></a>2.2.1私有继承的访问规则</h4><p><img src="/posts/bb1147ac/image-20210326214408609.png" alt="image-20210326214408609"></p>
<h4 id="2-2-2公有继承的访问规则"><a href="#2-2-2公有继承的访问规则" class="headerlink" title="2.2.2公有继承的访问规则"></a>2.2.2公有继承的访问规则</h4><p><img src="/posts/bb1147ac/image-20210326214426371.png" alt="image-20210326214426371"></p>
<h4 id="2-2-3保护继承的访问规则"><a href="#2-2-3保护继承的访问规则" class="headerlink" title="2.2.3保护继承的访问规则"></a>2.2.3保护继承的访问规则</h4><p><img src="/posts/bb1147ac/image-20210326214439701.png" alt="image-20210326214439701"></p>
<h3 id="2-3派生类构造和析构函数"><a href="#2-3派生类构造和析构函数" class="headerlink" title="2.3派生类构造和析构函数"></a>2.3派生类构造和析构函数</h3><p>创建对象：先执行基类构造函数，再执行派生类的构造函数；</p>
<p>销毁对象：先执行派生类的析构函数，再执行基类的析构函数。</p>
<p><img src="/posts/bb1147ac/image-20210326214829763.png" alt="image-20210326214829763"></p>
<p><img src="/posts/bb1147ac/image-20210326214944702.png" alt="image-20210326214944702"></p>
<h3 id="3多重继承"><a href="#3多重继承" class="headerlink" title="3多重继承"></a>3多重继承</h3><p><img src="/posts/bb1147ac/image-20210326215234476.png" alt="image-20210326215234476"></p>
<p><strong>多重继承的构造函数</strong></p>
<p><img src="/posts/bb1147ac/image-20210326215339284.png" alt="image-20210326215339284"></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++入门</tag>
      </tags>
  </entry>
  <entry>
    <title>C++入门笔记（八）</title>
    <url>/posts/fb7453a9.html</url>
    <content><![CDATA[<h2 id="1-虚函数"><a href="#1-虚函数" class="headerlink" title="1.虚函数"></a>1.虚函数</h2><p>参考文章：<a href="https://www.jianshu.com/p/d07e0ac0ba3c?from=singlemessage">https://www.jianshu.com/p/d07e0ac0ba3c?from=singlemessage</a></p>
<p>在基类中，虚函数被virtual关键字修饰，并在派生类中重新被定义。</p>
<p>作用：允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类的同名函数。</p>
<p>虚函数与Java中的覆盖同属于运行（动态）多态。</p>
<span id="more"></span>

<p>与Java中的覆盖类似，在派生类重新定义时，函数原型（函数类型、函数名、参数个数和类型顺序），都必须与基类中的原型完全相同。</p>
<p>当一个成员函数被定义为虚函数之后，其派生类中符合虚函数特点的同名函数会自动成为虚函数，所以在派生类中重新定义虚函数时，virtual可以写或不写，但为了阅读方便，最好每一层都加上。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// 基类 Father</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Father::display()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在函数中调用了，子类覆盖基类的函数display()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fatherShowDisplay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类Son</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span><span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重写基类中的display()函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Son::display()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Son son;                    <span class="comment">// 子类对象</span></span><br><span class="line">    son.fatherShowDisplay();    <span class="comment">// 通过基类中未被覆盖的函数，想调用子类中覆盖的display函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与Java类似，如果父类中有m1，m2两个方法。子类覆盖了m2方法。那么如果调用m1，则m1中调用的m2会是子类中定义的m2。</p>
<p>虚函数必须是成员函数，且不能是友元函数或静态函数，因为它的调用依赖特定的对象来决定。</p>
<p><strong>通过对象名和点运算调用是静态联编，只有通过基类指针的方式才是运行多态。</strong></p>
<p><img src="/posts/fb7453a9/image-20210415115503800.png" alt="image-20210415115503800"></p>
<p><img src="/posts/fb7453a9/image-20210415115608054.png" alt="image-20210415115608054"></p>
<p>对比上面两张图，一个定义虚函数，一个没有，很容易就理解虚函数的作用。</p>
<p>下图也是，左边定义了虚函数，右边没有定义。</p>
<p><img src="/posts/fb7453a9/image-20210415115650383.png" alt="image-20210415115650383"></p>
<p><img src="/posts/fb7453a9/image-20210415115658294.png" alt="image-20210415115658294"></p>
<p><img src="/posts/fb7453a9/image-20210415115705660.png" alt="image-20210415115705660"></p>
<h2 id="2-虚析构函数"><a href="#2-虚析构函数" class="headerlink" title="2.虚析构函数"></a>2.虚析构函数</h2><p><img src="/posts/fb7453a9/image-20210415124307380.png" alt="image-20210415124307380"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ~B()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;call ~B()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> B&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ~D()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;call ~D()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    D obj;</span><br><span class="line">    <span class="comment">/*call ~D()</span></span><br><span class="line"><span class="comment">	call ~B()*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先调用派生类的析构函数，再调用基类的析构函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ~B()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;call ~B()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> B&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ~D()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;call ~D()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B* p;</span><br><span class="line">    p = <span class="keyword">new</span> D; <span class="comment">// 基类指针p指向无名派生类对象</span></span><br><span class="line">    <span class="keyword">delete</span> p; <span class="comment">// 撤销无名对象，释放动态空间</span></span><br><span class="line">    <span class="comment">//call ~B()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/fb7453a9/image-20210415125758286.png" alt="image-20210415125758286"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~B()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;call ~B()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> B&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ~D()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;call ~D()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B* p;</span><br><span class="line">    p = <span class="keyword">new</span> D; <span class="comment">// 基类指针p指向无名派生类对象</span></span><br><span class="line">    <span class="keyword">delete</span> p; <span class="comment">// 撤销无名对象，释放动态空间</span></span><br><span class="line">    <span class="comment">/*call ~B()</span></span><br><span class="line"><span class="comment">    call ~D()*/</span></span><br><span class="line">    <span class="comment">// 通过虚析构函数实现了动态多态</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/fb7453a9/image-20210415130027582.png" alt="image-20210415130027582"></p>
<h2 id="3-虚函数与重载函数的关系"><a href="#3-虚函数与重载函数的关系" class="headerlink" title="3.虚函数与重载函数的关系"></a>3.虚函数与重载函数的关系</h2><p><img src="/posts/fb7453a9/image-20210415130603412.png" alt="image-20210415130603412"></p>
<p><img src="/posts/fb7453a9/image-20210415130624719.png" alt="image-20210415130624719"></p>
<h2 id="4-虚函数与多重继承"><a href="#4-虚函数与多重继承" class="headerlink" title="4.虚函数与多重继承"></a>4.虚函数与多重继承</h2><p><img src="/posts/fb7453a9/image-20210415130918576.png" alt="image-20210415130918576"></p>
<p><img src="/posts/fb7453a9/image-20210415131012252.png" alt="image-20210415131012252"></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++入门</tag>
        <tag>虚函数</tag>
      </tags>
  </entry>
  <entry>
    <title>C++入门笔记（六）</title>
    <url>/posts/de1f0c75.html</url>
    <content><![CDATA[<h2 id="1-虚基类"><a href="#1-虚基类" class="headerlink" title="1.虚基类"></a>1.虚基类</h2><p>在多条继承路径上有一个公共的基类,在这些路径中的某几条汇合处，这个公共的基类就会产生多个实例(或多个副本)，若只想保存这个基类的一个实例，<strong>可以将这个公共基类说明为虚基类</strong>。</p>
<span id="more"></span>

<p><img src="/posts/de1f0c75/image-20210404174942521.png" alt="image-20210404174942521"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base0</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Base0(<span class="keyword">int</span> var):var0(var)&#123;&#125;</span><br><span class="line">        <span class="keyword">int</span> var0;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">fun0</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Member of Base0&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> Base0&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Base1(<span class="keyword">int</span> var):Base0(var)&#123;&#125;</span><br><span class="line">        <span class="keyword">int</span> var1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> Base0&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Base2(<span class="keyword">int</span> var):Base0(var)&#123;&#125;</span><br><span class="line">        <span class="keyword">int</span> var2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base1,<span class="keyword">public</span> Base2&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 需要给最远的基类Base0传参</span></span><br><span class="line">        Derived(<span class="keyword">int</span> var):Base0(var),Base1(var),Base2(var)&#123;&#125;</span><br><span class="line">        <span class="keyword">int</span> var;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Member of Derived&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    d.var0 = <span class="number">2</span>; <span class="comment">// 直接访问虚基类的数据成员</span></span><br><span class="line">    d.fun0(); <span class="comment">// 直接访问虚基类的函数成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建立对象时，由最远的派生类的构造函数调用虚基类的构造函数进行初始化。该派生类的其他基类对虚基类的构造函数的调用都自动忽略。</p>
<p>构造函数调用顺序</p>
<ul>
<li><p>先调用虚基类的构造函数，再调用非虚基类的构造函数，最后调用派生类的构造函数</p>
</li>
<li><p>对于多个虚基类或非虚基类，先左后右，自上而下</p>
</li>
</ul>
<h2 id="2-基类与派生类对象之间的赋值兼容关系"><a href="#2-基类与派生类对象之间的赋值兼容关系" class="headerlink" title="2.基类与派生类对象之间的赋值兼容关系"></a>2.基类与派生类对象之间的赋值兼容关系</h2><p><strong>在需要基类对象的任何地方，都可以使用公有派生类的对象来替代。</strong></p>
<ol>
<li>派生类的对象可以隐含（自动）转换为基类对象</li>
<li>派生类的对象可以初始化基类的引用</li>
<li>派生类的指针可以隐含转换为基类的指针</li>
<li>若函数的形参是基类对象或基类对象的引用，在调用函数时可以用派生类对象作为实参</li>
</ol>
<p>在替代之后，派生类对象就可以作为基类对象使用，但只能使用从基类继承的成员。</p>
<p><img src="/posts/de1f0c75/image-20210404190957863.png" alt="image-20210404190957863"></p>
<h2 id="3-多态性"><a href="#3-多态性" class="headerlink" title="3.多态性"></a>3.多态性</h2><h3 id="3-1多态的分类"><a href="#3-1多态的分类" class="headerlink" title="3.1多态的分类"></a>3.1多态的分类</h3><p>C++里的多态包括了静态多态和动态多态。</p>
<p><img src="/posts/de1f0c75/image-20210404191316120.png" alt="image-20210404191316120"></p>
<p><img src="/posts/de1f0c75/image-20210404191332961.png" alt="image-20210404191332961"></p>
<h3 id="3-2运算符重载（重要）"><a href="#3-2运算符重载（重要）" class="headerlink" title="3.2运算符重载（重要）"></a>3.2运算符重载（重要）</h3><p>运算符重载通过创建<u>运算符重载函数</u>来实现，包括：类外的普通函数、类的成员函数和友元函数。</p>
<p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Box <span class="keyword">operator</span>+(<span class="keyword">const</span> Box&amp;);</span><br></pre></td></tr></table></figure>

<p>声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Box <span class="keyword">operator</span>+(<span class="keyword">const</span> Box&amp;, <span class="keyword">const</span> Box&amp;);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作为类成员函数的运算符重载函数</span></span><br><span class="line"><span class="comment">// 重载 + 运算符，用于把两个 Box 对象相加</span></span><br><span class="line">Box <span class="keyword">operator</span>+(<span class="keyword">const</span> Box&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    Box box;</span><br><span class="line">    box.length = <span class="keyword">this</span>-&gt;length + b.length;</span><br><span class="line">    box.breadth = <span class="keyword">this</span>-&gt;breadth + b.breadth;</span><br><span class="line">    box.height = <span class="keyword">this</span>-&gt;height + b.height;</span><br><span class="line">    <span class="keyword">return</span> box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把两个对象相加，得到 Box3</span></span><br><span class="line">Box3 = Box1 + Box2;</span><br></pre></td></tr></table></figure>

<h4 id="可重载运算符-不可重载运算符"><a href="#可重载运算符-不可重载运算符" class="headerlink" title="可重载运算符/不可重载运算符"></a>可重载运算符/不可重载运算符</h4><p>下面是可重载的运算符列表：</p>
<table>
<thead>
<tr>
<th>双目算术运算符</th>
<th>+ (加)，-(减)，*(乘)，/(除)，% (取模)</th>
</tr>
</thead>
<tbody><tr>
<td>关系运算符</td>
<td>==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于)，&lt;=(小于等于)，&gt;=(大于等于)</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>||(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)</td>
</tr>
<tr>
<td>单目运算符</td>
<td>+ (正)，-(负)，*(指针)，&amp;(取地址)</td>
</tr>
<tr>
<td>自增自减运算符</td>
<td>++(自增)，–(自减)</td>
</tr>
<tr>
<td>位运算符</td>
<td>| (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>=, +=, -=, *=, /= , % = , &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;=</td>
</tr>
<tr>
<td>空间申请与释放</td>
<td>new, delete, new[ ] , delete[]</td>
</tr>
<tr>
<td>其他运算符</td>
<td><code>()</code>(函数调用)，<code>-&gt;</code>(成员访问)，<code>,</code>(逗号)，<code>[]</code>(下标)</td>
</tr>
</tbody></table>
<p>下面是不可重载的运算符列表：</p>
<ul>
<li><code>.</code>：成员访问运算符</li>
<li><code>.*</code>,<code> -&gt;*</code>：成员指针访问运算符</li>
<li><code>::</code>：域运算符</li>
<li><code>sizeof</code>：长度运算符</li>
<li><code>?:</code>：条件运算符</li>
<li><code>#</code>： 预处理符号</li>
</ul>
<p>补充：</p>
<p><img src="/posts/de1f0c75/image-20210412125715522.png" alt="image-20210412125715522"></p>
<p><img src="/posts/de1f0c75/image-20210412125814210.png" alt="image-20210412125814210"></p>
<p><img src="/posts/de1f0c75/image-20210412125906936.png" alt="image-20210412125906936"></p>
<h4 id="对于-和-的重载"><a href="#对于-和-的重载" class="headerlink" title="对于++和- -的重载"></a>对于++和- -的重载</h4><p>前缀形式重载调用 Check operator ++ () ，后缀形式重载调用 operator ++ (int)。</p>
<p>后缀形式中的int形参不起任何作用，只是为了区分前置和后置++或- -。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重载前缀递增运算符（ ++ ）</span></span><br><span class="line">Time <span class="keyword">operator</span>++ ()  </span><br><span class="line">&#123;</span><br><span class="line">    ++minutes;          <span class="comment">// 对象加 1</span></span><br><span class="line">    <span class="keyword">if</span>(minutes &gt;= <span class="number">60</span>)  </span><br><span class="line">    &#123;</span><br><span class="line">        ++hours;</span><br><span class="line">        minutes -= <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Time(hours, minutes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载后缀递增运算符（ ++ ）</span></span><br><span class="line">Time <span class="keyword">operator</span>++( <span class="keyword">int</span> )         </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 保存原始值</span></span><br><span class="line">    <span class="function">Time <span class="title">T</span><span class="params">(hours, minutes)</span></span>;</span><br><span class="line">    <span class="comment">// 对象加 1</span></span><br><span class="line">    ++minutes;                    </span><br><span class="line">    <span class="keyword">if</span>(minutes &gt;= <span class="number">60</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ++hours;</span><br><span class="line">        minutes -= <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回旧的原始值</span></span><br><span class="line">    <span class="keyword">return</span> T; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++入门</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title>C++入门笔记（十一）</title>
    <url>/posts/cbdb2df7.html</url>
    <content><![CDATA[<h2 id="1-异常处理"><a href="#1-异常处理" class="headerlink" title="1.异常处理"></a>1.异常处理</h2><p>C++处理异常的机制由：检查、抛出和捕获组成，与其他语言类似。</p>
<p>分别由3种语句完成：try、throw、和catch。</p>
<span id="more"></span>

<p><img src="/posts/cbdb2df7/image-20210416223423799.png" alt="image-20210416223423799"></p>
<p><img src="/posts/cbdb2df7/image-20210416223434097.png" alt="image-20210416223434097"></p>
<p>异常处理的例子：</p>
<p><img src="/posts/cbdb2df7/image-20210416223616929.png" alt="image-20210416223616929"> <img src="/posts/cbdb2df7/image-20210416223812578.png" alt="image-20210416223812578"></p>
<h2 id="2-C-为什么要建立自己的I-O系统"><a href="#2-C-为什么要建立自己的I-O系统" class="headerlink" title="2.C++为什么要建立自己的I/O系统"></a>2.C++为什么要建立自己的I/O系统</h2><p><img src="/posts/cbdb2df7/image-20210428132831602.png" alt="image-20210428132831602"></p>
<p><img src="/posts/cbdb2df7/image-20210428132843718.png" alt="image-20210428132843718"></p>
<h2 id="3-C-的输入输出流"><a href="#3-C-的输入输出流" class="headerlink" title="3.C++的输入输出流"></a>3.C++的输入输出流</h2><p>在C++中,<strong>“流”指的是数据从一个源流到一个目的的抽象</strong>,它负责在数据的生产者(源)和数据的消费者(目的)</p>
<p>之间建立联系,并管理数据的流动。</p>
<p>从流中提取数据称为输入操作；向流中添加数据称为输出操作。</p>
<p>C++编译系统带有一个<strong>I/O流类库</strong>。在I/O流类库中包含许多用于输入输出的类,称为流类。用流类定义的对象称</p>
<p>为<strong>流对象</strong>。</p>
<p><img src="/posts/cbdb2df7/image-20210428133057533.png" alt="image-20210428133057533"></p>
<p>I/O流类库中包含了许多用于输入输出操作的类,</p>
<p> ios是抽象基类,输入流类istream和输出流类ostream是通过单继承从基类ios派生而来的,</p>
<p>输入输出流类iostream是通过多继承从类istream和ostream派生而来的。</p>
<p><img src="/posts/cbdb2df7/image-20210428133204523.png" alt="image-20210428133204523"></p>
<ul>
<li>标准输入流 (流对象) cin</li>
<li>标准输出流(流对象) cout</li>
<li>非缓冲型的标准出错流 (流对象) cerr（简单了解）</li>
<li>缓冲型的标准出错流 (流对象) clog（简单了解）</li>
</ul>
<p><img src="/posts/cbdb2df7/image-20210428133318072.png" alt="image-20210428133318072"></p>
<h2 id="4-输入输出流的成员函数"><a href="#4-输入输出流的成员函数" class="headerlink" title="4.输入输出流的成员函数"></a>4.输入输出流的成员函数</h2><p><img src="/posts/cbdb2df7/image-20210428133504829.png" alt="image-20210428133504829"></p>
<p><img src="/posts/cbdb2df7/image-20210428133515520.png" alt="image-20210428133515520"></p>
<p><img src="/posts/cbdb2df7/image-20210428133527883.png" alt="image-20210428133527883"></p>
<p><img src="/posts/cbdb2df7/image-20210428133559247.png" alt="image-20210428133559247"></p>
<p><img src="/posts/cbdb2df7/image-20210428133616059.png" alt="image-20210428133616059"></p>
<p><img src="/posts/cbdb2df7/image-20210428133630746.png" alt="image-20210428133630746"></p>
<p><img src="/posts/cbdb2df7/image-20210428133645045.png" alt="image-20210428133645045"></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++入门</tag>
        <tag>异常</tag>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title>C++入门笔记（十二）</title>
    <url>/posts/fbcdc12f.html</url>
    <content><![CDATA[<h2 id="1-输入输出运算符的实现原理"><a href="#1-输入输出运算符的实现原理" class="headerlink" title="1.输入输出运算符的实现原理"></a>1.输入输出运算符的实现原理</h2><p><strong>对输入输出运算符的重载是关键知识点。</strong></p>
<span id="more"></span>

<p><img src="/posts/fbcdc12f/image-20210428134441249.png" alt="image-20210428134441249"></p>
<p><img src="/posts/fbcdc12f/image-20210428134501051.png" alt="image-20210428134501051"></p>
<p><img src="/posts/fbcdc12f/image-20210428134708619.png" alt="image-20210428134708619"></p>
<p><img src="/posts/fbcdc12f/image-20210428134723588.png" alt="image-20210428134723588"></p>
<h2 id="2-预定义的操纵符输入输出格式控制"><a href="#2-预定义的操纵符输入输出格式控制" class="headerlink" title="2.预定义的操纵符输入输出格式控制"></a>2.预定义的操纵符输入输出格式控制</h2><p>除了操纵符，还有<strong>流成员函数</strong>可以控制输入输出格式，这里就不说了。</p>
<p>有关C++输入输出的完整内容可以参考<a href="https://www.runoob.com/cplusplus/cpp-basic-input-output.html">菜鸟教程</a>。</p>
<p><img src="/posts/fbcdc12f/image-20210428140029182.png" alt="image-20210428140029182"></p>
<p><img src="/posts/fbcdc12f/image-20210428140136067.png" alt="image-20210428140136067"></p>
<p><img src="/posts/fbcdc12f/image-20210428140208904.png" alt="image-20210428140208904"></p>
<p><img src="/posts/fbcdc12f/image-20210428140236225.png" alt="image-20210428140236225"></p>
<h2 id="3-自定义操纵符输入输出格式控制"><a href="#3-自定义操纵符输入输出格式控制" class="headerlink" title="3.自定义操纵符输入输出格式控制"></a>3.自定义操纵符输入输出格式控制</h2><p><img src="/posts/fbcdc12f/image-20210428135006688.png" alt="image-20210428135006688"></p>
<p><img src="/posts/fbcdc12f/image-20210428135030374.png" alt="image-20210428135030374"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入流操纵符函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">istream&amp; <span class="title">input</span><span class="params">(istream&amp; in)</span></span>&#123;</span><br><span class="line">    in &gt;&gt; hex;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter number using hex format:&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; input &gt;&gt; i;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hex:&quot;</span> &lt;&lt; hex &lt;&lt; i &lt;&lt; <span class="string">&quot;-----dec:&quot;</span> &lt;&lt; dec &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Enter number using hex format:23ae</span></span><br><span class="line"><span class="comment">hex:23ae-----dec:9134*/</span></span><br></pre></td></tr></table></figure>

<h2 id="4-重载输入输出运算符"><a href="#4-重载输入输出运算符" class="headerlink" title="4.重载输入输出运算符"></a>4.重载输入输出运算符</h2><p>注意：</p>
<p><strong>重载输入输出运算符不能是所操作类的成员函数，但可以是该类的友元函数或普通函数。</strong><img src="/posts/fbcdc12f/image-20210428141954272.png" alt="image-20210428141954272"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重载插入运算符</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coord</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Coord(<span class="keyword">int</span> i = <span class="number">0</span>,<span class="keyword">int</span> j = <span class="number">0</span>)&#123;</span><br><span class="line">        x = i,y = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; stream,Coord&amp; ob);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; stream,Coord&amp; ob)&#123;</span><br><span class="line">    stream &lt;&lt; ob.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; ob.y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Coord a(55,56),b(100,200);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/fbcdc12f/image-20210428142554403.png" alt="image-20210428142554403"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// // 重载插入与提取运算符</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Three_d</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Three_d(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)&#123;</span><br><span class="line">        x = a,y = b,z = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; output,Three_d ob);</span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt; (istream&amp; input,Three_d&amp; ob);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; output,Three_d ob)&#123;</span><br><span class="line">    output &lt;&lt; ob.x &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    output &lt;&lt; ob.y &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    output &lt;&lt; ob.z &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt; (istream&amp; input,Three_d&amp; ob)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter x,y,z value:&quot;</span>;</span><br><span class="line">    input &gt;&gt; ob.x;</span><br><span class="line">    input &gt;&gt; ob.y;</span><br><span class="line">    input &gt;&gt; ob.z;</span><br><span class="line">    <span class="keyword">return</span> input;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Three_d <span class="title">obj</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; obj;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; obj;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-文件的输入输出"><a href="#5-文件的输入输出" class="headerlink" title="5.文件的输入输出"></a>5.文件的输入输出</h2><p>文件的两种形式：</p>
<p><img src="/posts/fbcdc12f/image-20210428143750640.png" alt="image-20210428143750640"></p>
<p>为什么文本形式会多一个字节？</p>
<p>因为要做一些转码处理，换行转为回车换行。</p>
<p><img src="/posts/fbcdc12f/image-20210428144315193.png" alt="image-20210428144315193"></p>
<p><img src="/posts/fbcdc12f/image-20210428144339078.png" alt="image-20210428144339078"></p>
<p><img src="/posts/fbcdc12f/image-20210428144432437.png" alt="image-20210428144432437"></p>
<p><img src="/posts/fbcdc12f/image-20210428144447690.png" alt="image-20210428144447690"></p>
<p><img src="/posts/fbcdc12f/image-20210428144508143.png" alt="image-20210428144508143"></p>
<p>文件的关闭：<code>out.close();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 写文件与读文件</span></span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;f2.txt&quot;</span>)</span></span>;<span class="comment">// 不存在会新建</span></span><br><span class="line">    <span class="keyword">if</span> (!fout)&#123; <span class="comment">// 文件打开失败时fout返回0</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cannot open output file\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fout &lt;&lt; <span class="number">10</span> &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt;hex&lt;&lt;<span class="number">100</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    fout.close();</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">&quot;f2.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!fin)&#123; <span class="comment">// 文件打开失败时fin返回0</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cannot open input file\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">80</span>];</span><br><span class="line">    <span class="keyword">while</span> (fin)&#123;</span><br><span class="line">        fin.getline(str,<span class="number">80</span>);<span class="comment">// 读入信息赋值给str</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fin.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">10 64\n*/</span></span><br></pre></td></tr></table></figure>

<p>提一点，C++的多行注释最好写成<code>/**/</code>，而不要写成<code>//</code>。在某种情况下，注释会与“/”产生一些奇怪的BUG。</p>
<h2 id="6-命名空间"><a href="#6-命名空间" class="headerlink" title="6.命名空间"></a>6.命名空间</h2><p>也就是namespace。</p>
<p><img src="/posts/fbcdc12f/image-20210428150001654.png" alt="image-20210428150001654"></p>
<p><img src="/posts/fbcdc12f/image-20210428150013044.png" alt="image-20210428150013044"></p>
<p><img src="/posts/fbcdc12f/image-20210428150026666.png" alt="image-20210428150026666"></p>
<p><img src="/posts/fbcdc12f/image-20210428150050936.png" alt="image-20210428150050936"></p>
<p><img src="/posts/fbcdc12f/image-20210428150114048.png" alt="image-20210428150114048"></p>
<h2 id="7-补充"><a href="#7-补充" class="headerlink" title="7.补充"></a>7.补充</h2><p>C++入门笔记系列就到这结束了！</p>
<p>大佬两万字总结《C++ Primer》要点：<a href="https://mp.weixin.qq.com/s/05IdvsA3NtOJwheu1ljqSQ">https://mp.weixin.qq.com/s/05IdvsA3NtOJwheu1ljqSQ</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++入门</tag>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title>C++入门笔记（十）</title>
    <url>/posts/48b5732.html</url>
    <content><![CDATA[<h2 id="1-什么是模板"><a href="#1-什么是模板" class="headerlink" title="1.什么是模板"></a>1.什么是模板</h2><p><img src="/posts/48b5732/image-20210416202641797.png" alt="image-20210416202641797"></p>
<span id="more"></span>

<p>为什么要使用模板？</p>
<p>因为使用重载还是有重复代码，使用模板可以写一个通用的函数适用多种不同的数据类型。</p>
<p><img src="/posts/48b5732/image-20210416213008855.png" alt="image-20210416213008855"></p>
<h2 id="2-函数模板与模板函数"><a href="#2-函数模板与模板函数" class="headerlink" title="2.函数模板与模板函数"></a>2.函数模板与模板函数</h2><p><strong>函数模板</strong>就是建立一个通用函数，其函数返回类型和形参类型不具体指定，用一个虚拟类型来代表。</p>
<p>在调用函数时系统会根据实参的类型（模板实参）来取代模板中的虚拟类型从而实现不同的函数功能。</p>
<p><img src="/posts/48b5732/image-20210416213921364.png" alt="image-20210416213921364"></p>
<p>使用函数模板时必须将类型参数实例化，类型参数前要加上关键字typename或者class，推荐加上typename，class容易与类搞混。</p>
<p><strong>typename后面的类型参数必须实例化。</strong></p>
<p><img src="/posts/48b5732/image-20210416215058349.png" alt="image-20210416215058349"></p>
<p><img src="/posts/48b5732/image-20210416215118498.png" alt="image-20210416215118498"></p>
<p><strong>实际上函数模板提供了一类函数的抽象，它经过实例化而生成的具体函数成为模板函数。</strong></p>
<p><img src="/posts/48b5732/image-20210416215300861.png" alt="image-20210416215300861"></p>
<p>定义两种类型参数的函数模板：</p>
<p><img src="/posts/48b5732/image-20210416215736766.png" alt="image-20210416215736766"></p>
<p>注意点：</p>
<p><img src="/posts/48b5732/image-20210416215654841.png" alt="image-20210416215654841"></p>
<p>重载的函数模板例子：</p>
<p><img src="/posts/48b5732/image-20210416215918724.png" alt="image-20210416215918724"></p>
<p>函数模板与同名的非模板函数也能重载。</p>
<p>这时的调用顺序是：先寻找一个参数完全匹配的非模板函数，找到了就调用它，否则寻找一个匹配的函数模板，实例化产生模板函数，调用它。</p>
<p><img src="/posts/48b5732/image-20210416220231627.png" alt="image-20210416220231627"></p>
<h2 id="3-类模板与模板类"><a href="#3-类模板与模板类" class="headerlink" title="3.类模板与模板类"></a>3.类模板与模板类</h2><p><strong>类模板</strong>就是建立一个通用类，其数据成员、成员函数的返回类型和形参类型不具体指定，用一个虚拟类型来代表。使用类模板定义对象时，系统会根据实参的类型来取代模板中的虚拟类型从而实现了不同类的功能。</p>
<p><img src="/posts/48b5732/image-20210416220749449.png" alt="image-20210416220749449"></p>
<p>还是建议使用typename关键字。</p>
<p><img src="/posts/48b5732/image-20210416222050662.png" alt="image-20210416222050662"></p>
<p><img src="/posts/48b5732/image-20210416222039232.png" alt="image-20210416222039232"></p>
<p><img src="/posts/48b5732/image-20210416222122639.png" alt="image-20210416222122639"></p>
<p>用数组实现的栈的例子：</p>
<p><img src="/posts/48b5732/image-20210416222507375.png" alt="image-20210416222507375"></p>
<p>含有两个类型参数的模板类的例子：</p>
<p><img src="/posts/48b5732/image-20210416222605659.png" alt="image-20210416222605659"></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++入门</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>C++入门笔记（四）</title>
    <url>/posts/d48f82eb.html</url>
    <content><![CDATA[<h2 id="1-静态成员"><a href="#1-静态成员" class="headerlink" title="1.静态成员"></a>1.静态成员</h2><h3 id="1-1静态数据成员"><a href="#1-1静态数据成员" class="headerlink" title="1.1静态数据成员"></a>1.1静态数据成员</h3><p>在某些情况下，我们需要在类中使用作用类似全局变量的变量，这时会用到静态数据成员。</p>
<p>静态数据成员类似于Java中的类变量（静态变量），随类一起加载。</p>
<span id="more"></span>

<p>OOP中有着”类属性“的概念。<strong>也就是说，如果某个属性为整个类所共有，不属于任何一个具体的对象，则采用static关键字修饰。</strong></p>
<p>静态成员在每一个类只有一个副本，有该类的所有对象共同维护和使用，从而实现同一类不同对象的数据共享。</p>
<ul>
<li>如何初始化静态数据成员？</li>
</ul>
<p>它的初始化应在类外单独进行，而且应在定义对象之前。一般在main函数之前和定义对象之后初始化。</p>
<p>语法：<code>int Student::count = 0;</code> –&gt; 数据类型   类名：：静态数据成员名   =   初始值；</p>
<ul>
<li>如何访问静态数据成员？</li>
</ul>
<p>1.类名：：静态数据成员名</p>
<p>2.对象名.静态数据成员名</p>
<p>3.对象指针-&gt;静态数据成员名</p>
<p>注意：私有静态数据成员不能在类外直接访问，必须通过公有的（静态）成员函数访问。</p>
<p><strong>示例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Student()&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入学生的学号、姓名、成绩：\n&quot;</span>;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; id &gt;&gt; name &gt;&gt; score;</span><br><span class="line">			stuNum ++;</span><br><span class="line">			sumScore += score;</span><br><span class="line">			averScore = sumScore/stuNum;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">showIfmation</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; id +<span class="string">&quot; &quot;</span>+name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showsumScore</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; stuNum&lt;&lt;<span class="string">&quot;个学生的总分为:&quot;</span>&lt;&lt;sumScore &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showaverScore</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; stuNum&lt;&lt;<span class="string">&quot;个学生的平均为:&quot;</span>&lt;&lt;averScore &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		~Student()&#123;</span><br><span class="line">			stuNum--;</span><br><span class="line">			sumScore -= score;</span><br><span class="line">			averScore = sumScore/stuNum;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="built_in">string</span> name,id;</span><br><span class="line">		<span class="keyword">double</span> score; </span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">int</span> stuNum;</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">double</span> sumScore,averScore;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 静态数据成员初始化 </span></span><br><span class="line"><span class="keyword">int</span> Student::stuNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> Student::sumScore = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">double</span> Student::averScore = <span class="number">0.0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Student s1,s2,s3;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;学生信息为：\n&quot;</span>;</span><br><span class="line">	s1.showIfmation();</span><br><span class="line">	s2.showIfmation();</span><br><span class="line">	s3.showIfmation();</span><br><span class="line">	Student::showsumScore();</span><br><span class="line">	s1.showsumScore();<span class="comment">// 两种访问静态数据成员方式</span></span><br><span class="line">	Student::showaverScore();</span><br><span class="line">	s3.showaverScore();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2静态成员函数"><a href="#1-2静态成员函数" class="headerlink" title="1.2静态成员函数"></a>1.2静态成员函数</h3><p><img src="/posts/d48f82eb/image-20210326185129994.png" alt="image-20210326185129994"></p>
<p><strong>示例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Cat(<span class="keyword">double</span> w);</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">total_disp</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">double</span> weight;</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">double</span> total_weight;</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">double</span> total_number;</span><br><span class="line">&#125;;</span><br><span class="line">Cat::Cat(<span class="keyword">double</span> w)&#123;</span><br><span class="line">	weight = w;</span><br><span class="line">	total_weight += w;</span><br><span class="line">	total_number ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cat::display</span><span class="params">()</span></span>&#123; <span class="comment">// 定义静态成员函数不需要加上static</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;This cat&#x27;s weight is:&quot;</span> &lt;&lt; weight &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cat::total_disp</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;total_number is:&quot;</span>&lt;&lt;total_number&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;total_weight is:&quot;</span>&lt;&lt;total_weight&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> Cat::total_weight = <span class="number">0</span>; <span class="comment">// 静态数据成员初始化</span></span><br><span class="line"><span class="keyword">double</span> Cat::total_number = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Cat w1(0.5),w2(0.6);</span><br><span class="line">	w1.display();</span><br><span class="line">	w2.display();</span><br><span class="line">	Cat::total_disp();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>补充说明</strong></p>
<ol>
<li>一般情形，用于访问静态数据成员；</li>
<li>私有静态成员函数不能做类外的函数和对象访问；</li>
<li>使用静态成员函数的一个原因是，可以用在建立对象之前调用它，已处理静态数据成员；</li>
<li>编译系统将静态成员函数限定为内部链接，与其他文件中的同名函数不会冲突；</li>
<li>静态成员函数与非静态成员函数的重要区别：前者没有this指针，而后者有this指针。</li>
</ol>
<h2 id="2友元函数"><a href="#2友元函数" class="headerlink" title="2友元函数"></a>2友元函数</h2><p>类的主要特点之一就是隐藏和封装。C++中的友元为数据隐藏这堵不透明的墙开了一个小洞，也就是一扇通向私有（保护）成员的后门。</p>
<p><img src="/posts/d48f82eb/image-20210326193745049.png" alt="image-20210326193745049"></p>
<p>友元函数不是当前类的成员函数，但它可以访问该类所有成员。</p>
<p><strong>示例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Girl(<span class="built_in">string</span> n,<span class="keyword">int</span> d):</span><br><span class="line">		name(n),age(d)&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">disp</span><span class="params">(Girl&amp;)</span></span>;<span class="comment">// 声明友元函数</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="built_in">string</span> name;</span><br><span class="line">		<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disp</span><span class="params">(Girl&amp; x)</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;girl&#x27;s name is:&quot;</span> &lt;&lt; x.name &lt;&lt; <span class="string">&quot;,age is:&quot;</span> &lt;&lt; x.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Girl <span class="title">g</span><span class="params">(<span class="string">&quot;xiaoli&quot;</span>,<span class="number">18</span>)</span></span>;</span><br><span class="line">	disp(g);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>补充说明</strong></p>
<ol>
<li>在类的外部定义友元函数时，不必像成员函数那样加上<code>类名::</code>；</li>
<li>友元函数不是类的成员，不能直接访问对象的数据成员，也不能通过this指针访问，它必须通过作为入口参数传递进来的对象名（或对象指针、引用）来访问该对象的数据成员；</li>
</ol>
<h2 id="3类的组合"><a href="#3类的组合" class="headerlink" title="3类的组合"></a>3类的组合</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Score</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Score(<span class="keyword">double</span> c = <span class="number">0</span>,<span class="keyword">double</span> m = <span class="number">0</span>,<span class="keyword">double</span> e = <span class="number">0</span>);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">double</span> chinese,math,english;</span><br><span class="line">&#125;;</span><br><span class="line">Score::Score(<span class="keyword">double</span> c,<span class="keyword">double</span> m,<span class="keyword">double</span> e):</span><br><span class="line">	chinese(c),math(m),english(e)&#123;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Score::show</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;chinese:&quot;</span>&lt;&lt;chinese &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;math:&quot;</span>&lt;&lt;math &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;english:&quot;</span>&lt;&lt;english&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Student(<span class="built_in">string</span> n,<span class="built_in">string</span> i,<span class="keyword">double</span> a,<span class="keyword">double</span> b,<span class="keyword">double</span> c);</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="built_in">string</span> name,id;</span><br><span class="line">		Score s;</span><br><span class="line">&#125;;</span><br><span class="line">Student::Student(<span class="built_in">string</span> n,<span class="built_in">string</span> i,<span class="keyword">double</span> a,<span class="keyword">double</span> b,<span class="keyword">double</span> c):</span><br><span class="line">	name(n),id(i),s(a,b,c)&#123; <span class="comment">// 注意这里的初始化列表</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::show</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;id:&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	s.show();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Student <span class="title">s1</span><span class="params">(<span class="string">&quot;小明&quot;</span>,<span class="string">&quot;1001&quot;</span>,<span class="number">97</span>,<span class="number">78</span>,<span class="number">81</span>)</span></span>;</span><br><span class="line">	s1.show();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用构造函数时：先对内部嵌套对象按照声明顺序调用，最后调用类的构造函数；</p>
<p>调用析构函数时：与构造函数顺序相反。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++入门</tag>
      </tags>
  </entry>
  <entry>
    <title>C++抽象类与模板类的应用</title>
    <url>/posts/633af201.html</url>
    <content><![CDATA[<h2 id="1-抽象类的应用"><a href="#1-抽象类的应用" class="headerlink" title="1.抽象类的应用"></a>1.抽象类的应用</h2><p><img src="/posts/633af201/image-20210421233258943.png" alt="image-20210421233258943"></p>
<span id="more"></span>

<p>C++程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _USE_MATH_DEFINES <span class="comment">// 使用M_PI </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="title">calcSurface</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="title">calcVolume</span><span class="params">()</span> </span>= <span class="number">0</span>;	</span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sphere</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Sphere(<span class="keyword">double</span> _r):r(_r)&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcSurface</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">4</span>*M_PI*r*r;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcVolume</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">4</span>*r*r*r*M_PI/<span class="number">3</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">double</span> r;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cylinder</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Cylinder(<span class="keyword">int</span> _r,<span class="keyword">int</span> _h):r(_r),h(_h)&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcSurface</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> r*r*<span class="number">2</span>*M_PI+<span class="number">2</span>*M_PI*r*h;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcVolume</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> r*r*M_PI*h;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">double</span> r;</span><br><span class="line">		<span class="keyword">double</span> h;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cube</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Cube(<span class="keyword">double</span> _a):a(_a)&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcSurface</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">6</span>*a*a;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcVolume</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> a*a*a;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">double</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Sphere <span class="title">s</span><span class="params">(<span class="number">4.5</span>)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Surface:&quot;</span>&lt;&lt;s.calcSurface();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;, Volume:&quot;</span>&lt;&lt;s.calcVolume()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;---------------------------------\n&quot;</span>;</span><br><span class="line">	<span class="function">Cylinder <span class="title">c1</span><span class="params">(<span class="number">4.3</span>,<span class="number">1.2</span>)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Surface:&quot;</span>&lt;&lt;c1.calcSurface();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;, Volume:&quot;</span>&lt;&lt;c1.calcVolume()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;---------------------------------\n&quot;</span>;</span><br><span class="line">	<span class="function">Cube <span class="title">c2</span><span class="params">(<span class="number">9.0</span>)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Surface:&quot;</span>&lt;&lt;c2.calcSurface();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;, Volume:&quot;</span>&lt;&lt;c2.calcVolume()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-模板类的应用"><a href="#2-模板类的应用" class="headerlink" title="2.模板类的应用"></a>2.模板类的应用</h2><p><img src="/posts/633af201/image-20210421233409708.png" alt="image-20210421233409708"></p>
<p>C++程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Set</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Set() &#123;</span><br><span class="line">        t[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Set(T num[N]) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(t, num, <span class="keyword">sizeof</span>(T) * N);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++, size++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[i] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;有%d个元素：&quot;</span>, size);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) <span class="built_in">cout</span> &lt;&lt; t[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Set <span class="keyword">operator</span>+(Set &amp;s);</span><br><span class="line">    Set <span class="keyword">operator</span>-(Set &amp;s);</span><br><span class="line">    Set <span class="keyword">operator</span>*(Set &amp;s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T t[N];</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Set&lt;T&gt; Set&lt;T&gt;::<span class="keyword">operator</span>+(Set&lt;T&gt; &amp;s) &#123;</span><br><span class="line">    Set&lt;T&gt; temp;</span><br><span class="line">    <span class="built_in">memcpy</span>(temp.t, t, <span class="keyword">sizeof</span>(T) * size);</span><br><span class="line">    <span class="keyword">int</span> k = size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.t[i] == temp.t[j]) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">false</span>) temp.t[k++] = s.t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    temp.size = k;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Set&lt;T&gt; Set&lt;T&gt;::<span class="keyword">operator</span>-(Set&lt;T&gt; &amp;s) &#123;</span><br><span class="line">    Set&lt;T&gt; temp;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.size; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[i] == s.t[j]) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">false</span>) temp.t[k++] = t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    temp.size = k;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Set&lt;T&gt; Set&lt;T&gt;::<span class="keyword">operator</span>*(Set&lt;T&gt; &amp;s) &#123;</span><br><span class="line">    Set&lt;T&gt; temp;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.size; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[i] == s.t[j]) temp.t[k++] = s.t[j];</span><br><span class="line">        &#125;</span><br><span class="line">    temp.size = k;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[N] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> b[N] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    Set&lt;int&gt; A(a), B(b), C, D, E;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A:&quot;</span>;</span><br><span class="line">    A.show();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B:&quot;</span>;</span><br><span class="line">    B.show();</span><br><span class="line">    C = A + B; <span class="comment">// 并</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A和B的并集:&quot;</span>;</span><br><span class="line">    C.show();</span><br><span class="line">    D = A * B; <span class="comment">// 交</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A和B的交集:&quot;</span>;</span><br><span class="line">    D.show();</span><br><span class="line">    E = A - B; <span class="comment">// 差</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A和B的差集:&quot;</span>;</span><br><span class="line">    E.show();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>抽象类</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>C++的输入输出速度比较</title>
    <url>/posts/48fab36.html</url>
    <content><![CDATA[<p>下面对C++中的一些常用输入输出方式速度进行比较。</p>
<span id="more"></span>

<p>众所周知，使用printf/scanf的速度会比cin/cout快上不少。</p>
<p>关于输出换行（回车）的几种方式：</p>
<p>1.cout &lt;&lt; endl;</p>
<p>2.puts(“”);</p>
<p>3.printf(“\n”);</p>
<p>4.putchar(10);</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1290ms</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 19ms</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 10ms</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 10ms</span></span><br></pre></td></tr></table></figure>

<p>结论：</p>
<p><code>printf(&quot;\n&quot;);</code>和<code>putchar(10);</code>最快，两者差距不大；</p>
<p><code>puts(&quot;&quot;);</code>比上面的稍慢；</p>
<p><code>cout &lt;&lt; endl;</code>最慢，用时较长。</p>
<p>据大佬总结的endl的好处：</p>
<ul>
<li>endl好处是能一直刷新流，因为要刷新适合一些交互题；</li>
<li>而且如果是大工程，endl更容易方便debug</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++竞赛语法总结（一）</title>
    <url>/posts/5397030f.html</url>
    <content><![CDATA[<h2 id="1-acwing656-钞票和硬币"><a href="#1-acwing656-钞票和硬币" class="headerlink" title="1.acwing656.钞票和硬币"></a>1.acwing656.钞票和硬币</h2><p>读取一个带有两个小数位的浮点数，这代表货币价值。</p>
<p>在此之后，将该值分解为多种钞票与硬币的和，每种面值的钞票和硬币使用数量不限，要求使用的钞票和硬币的数量尽可能少。</p>
<span id="more"></span>

<p>钞票的面值是100,50,20,10,5,2。</p>
<p>硬币的面值是1,0.50,0.25,0.10,0.05和0.01。</p>
<p>输入格式</p>
<p>输入一个浮点数N。</p>
<p>输出格式</p>
<p>参照输出样例，输出每种面值的钞票和硬币的需求数量。</p>
<p>数据范围</p>
<p>0≤N≤1000000.00</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">576.73</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">NOTAS:</span><br><span class="line"><span class="number">5</span> nota(s) de R$ <span class="number">100.00</span></span><br><span class="line"><span class="number">1</span> nota(s) de R$ <span class="number">50.00</span></span><br><span class="line"><span class="number">1</span> nota(s) de R$ <span class="number">20.00</span></span><br><span class="line"><span class="number">0</span> nota(s) de R$ <span class="number">10.00</span></span><br><span class="line"><span class="number">1</span> nota(s) de R$ <span class="number">5.00</span></span><br><span class="line"><span class="number">0</span> nota(s) de R$ <span class="number">2.00</span></span><br><span class="line">MOEDAS:</span><br><span class="line"><span class="number">1</span> moeda(s) de R$ <span class="number">1.00</span></span><br><span class="line"><span class="number">1</span> moeda(s) de R$ <span class="number">0.50</span></span><br><span class="line"><span class="number">0</span> moeda(s) de R$ <span class="number">0.25</span></span><br><span class="line"><span class="number">2</span> moeda(s) de R$ <span class="number">0.10</span></span><br><span class="line"><span class="number">0</span> moeda(s) de R$ <span class="number">0.05</span></span><br><span class="line"><span class="number">3</span> moeda(s) de R$ <span class="number">0.01</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取一个浮点数，表示货币价值，将他分解为多种钞票和硬币的和，尽可能少的钞票和硬币数量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,c;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;b);</span><br><span class="line">    a = (<span class="keyword">int</span>)b;</span><br><span class="line">    c = <span class="number">100</span>*b - <span class="number">100</span>*a;<span class="comment">// 注意这里</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NOTAS:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d nota(s) de R$ 100.00\n&quot;</span>,a/<span class="number">100</span>);</span><br><span class="line">    a %= <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d nota(s) de R$ 50.00\n&quot;</span>,a/<span class="number">50</span>);</span><br><span class="line">    a %= <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d nota(s) de R$ 20.00\n&quot;</span>,a/<span class="number">20</span>);</span><br><span class="line">    a %= <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d nota(s) de R$ 10.00\n&quot;</span>,a/<span class="number">10</span>);</span><br><span class="line">    a %= <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d nota(s) de R$ 5.00\n&quot;</span>,a/<span class="number">5</span>);</span><br><span class="line">    a %= <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d nota(s) de R$ 2.00\n&quot;</span>,a/<span class="number">2</span>);</span><br><span class="line">    a %= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MOEDAS:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d moeda(s) de R$ 1.00\n&quot;</span>,a/<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d moeda(s) de R$ 0.50\n&quot;</span>,c/<span class="number">50</span>);</span><br><span class="line">    c %= <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d moeda(s) de R$ 0.25\n&quot;</span>,c/<span class="number">25</span>);</span><br><span class="line">    c %= <span class="number">25</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d moeda(s) de R$ 0.10\n&quot;</span>,c/<span class="number">10</span>);</span><br><span class="line">    c %= <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d moeda(s) de R$ 0.05\n&quot;</span>,c/<span class="number">5</span>);</span><br><span class="line">    c %= <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d moeda(s) de R$ 0.01&quot;</span>,c/<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-acwing610-工资和奖金"><a href="#2-acwing610-工资和奖金" class="headerlink" title="2.acwing610.工资和奖金"></a>2.acwing610.工资和奖金</h2><p>请你编写一个程序，给定你一个销售人员的名字，底薪以及月销售额。</p>
<p>请你计算他的月收入是多少。</p>
<p>已知月收入等于底薪加15%的月销售额。</p>
<p>所有数据保留两位小数。</p>
<p>输入格式</p>
<p>输入第一行包含一个由大写字母构成的长度不超过10的字符串，表示销售人员的名字。</p>
<p>第二行包含一个浮点数，表示该人员的底薪。</p>
<p>第三行包含一个浮点数，表示该人员的月销售额。</p>
<p>输出格式</p>
<p>输出格式为“TOTAL = R$ X”，X为该人员月收入。</p>
<p>数据范围</p>
<p>0≤底薪，月销售额≤10000.00</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JOAO</span><br><span class="line">500.00</span><br><span class="line">1230.30</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TOTAL &#x3D; R$ 684.54</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重点在读取字符串的区别</span></span><br><span class="line"><span class="comment">// solution 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a,b;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s %lf %lf&quot;</span>,s,&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TOTAL = R$ %.2lf&quot;</span>,a+<span class="number">0.15</span>*b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//solution 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TOTAL = R$ %.2lf&quot;</span>,x+<span class="number">0.15</span>*y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-解题新思路"><a href="#3-解题新思路" class="headerlink" title="3.解题新思路"></a>3.解题新思路</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换a和b,c的值使a,b,c按从大到小排列</span></span><br><span class="line"><span class="comment">// solution 1</span></span><br><span class="line"><span class="keyword">if</span> (a &lt; b)</span><br><span class="line">    &#123;</span><br><span class="line">        t = a;a = b;b = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; c)</span><br><span class="line">    &#123;</span><br><span class="line">        t = b;b = c;c = t;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">        &#123;</span><br><span class="line">            t = a;a = b;b = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// solution 2</span></span><br><span class="line">&lt;algorithm&gt;</span><br><span class="line"><span class="keyword">if</span> (a &lt; b) swap(a,b);</span><br><span class="line"><span class="keyword">if</span> (a &lt; c) swap(a,c);</span><br><span class="line"><span class="keyword">if</span> (b &lt; c) swap(b,c);</span><br></pre></td></tr></table></figure>

<h2 id="4-acwing668-游戏时间2"><a href="#4-acwing668-游戏时间2" class="headerlink" title="4.acwing668.游戏时间2"></a>4.acwing668.游戏时间2</h2><p>读取四个整数A,B,C,D，用来表示游戏的开始时间和结束时间。</p>
<p>其中A和B为开始时刻的小时和分钟数，C和D为结束时刻的小时和分钟数。</p>
<p>请你计算游戏的持续时间。</p>
<p>比赛最短持续1分钟，最长持续24小时。</p>
<p>输入格式</p>
<p>共一行，包含四个整数A,B,C,D。</p>
<p>输出格式</p>
<p>输出格式为“O JOGO DUROU X HORA(S) E Y MINUTO(S)”，表示游戏共持续了X小时Y分钟。</p>
<p>数据范围</p>
<p>0≤A,C≤23<br>        0≤B,D≤59</p>
<p>输入样例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 8 9 10</span><br></pre></td></tr></table></figure>

<p>输出样例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O JOGO DUROU 2 HORA(S) E 2 MINUTO(S)</span><br></pre></td></tr></table></figure>

<p>输入样例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 7 7 7</span><br></pre></td></tr></table></figure>

<p>输出样例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O JOGO DUROU 24 HORA(S) E 0 MINUTO(S)</span><br></pre></td></tr></table></figure>

<p>输入样例3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 10 8 9</span><br></pre></td></tr></table></figure>

<p>输出样例3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O JOGO DUROU 0 HORA(S) E 59 MINUTO(S)</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取游戏的开始和结束小时和分钟数，估算持续时间</span></span><br><span class="line"><span class="comment">//注意一些样例的特殊性</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c,d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line">    b+=a*<span class="number">60</span>,d+=c*<span class="number">60</span>;</span><br><span class="line">    a=(d-b+<span class="number">24</span>*<span class="number">60</span>)%(<span class="number">24</span>*<span class="number">60</span>); </span><br><span class="line">    a=(a)?(a):(<span class="number">24</span>*<span class="number">60</span>);<span class="comment">// 当a=0时，a变成24*60，处理特殊样例</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;O JOGO DUROU %d HORA(S) E %d MINUTO(S)\n&quot;</span>,a/<span class="number">60</span>,a%<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-acwing663-简单排序"><a href="#5-acwing663-简单排序" class="headerlink" title="5.acwing663.简单排序"></a>5.acwing663.简单排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入三个数对他们升序排列每行输出一个数，接着一个空行，按原顺序每行输出一个数</span></span><br><span class="line"><span class="comment">// solution 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">    x=max(a,max(b,c));</span><br><span class="line">    y=min(a,min(b,c));</span><br><span class="line">    z=a+b+c-x-y;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;z&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// solution 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c,t,d,e,f;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    d = a;e = b;f = c;</span><br><span class="line">    <span class="keyword">if</span> (a&lt;b)</span><br><span class="line">    &#123;</span><br><span class="line">        t = a;a = b;b = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b&lt;c)</span><br><span class="line">    &#123;</span><br><span class="line">        t = b;b = c;c = t;</span><br><span class="line">        <span class="keyword">if</span> (a&lt;b)</span><br><span class="line">        &#123;</span><br><span class="line">            t = a;a = b;b = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d\n%d\n\n&quot;</span>,c,b,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d\n%d\n&quot;</span>,d,e,f);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// solution 2</span></span><br><span class="line">&lt;algorithm&gt;</span><br><span class="line"><span class="keyword">if</span> (a &lt; b) swap(a,b);</span><br><span class="line"><span class="keyword">if</span> (a &lt; c) swap(a,c);</span><br><span class="line"><span class="keyword">if</span> (b &lt; c) swap(b,c);</span><br></pre></td></tr></table></figure>

<h2 id="6-acwing714-连续奇数和1"><a href="#6-acwing714-连续奇数和1" class="headerlink" title="6.acwing714.连续奇数和1"></a>6.acwing714.连续奇数和1</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给定两整数x和y，输出他们之间（不包括x，y）的所有奇数和</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y,sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) swap(x,y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x + <span class="number">1</span>;i &lt; y;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i%<span class="number">2</span>) sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意：-1%2 = -1,-3%2 = -1,-2%2 = 0</span></span><br></pre></td></tr></table></figure>

<h2 id="7-acwing721-递增序列"><a href="#7-acwing721-递增序列" class="headerlink" title="7.acwing721.递增序列"></a>7.acwing721.递增序列</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取一系列的整数X，对于每个X，输出一个1,2,…,X的序列</span></span><br><span class="line"><span class="comment">//其中最后一个为0，其他的均为正整数,对于最后一行的整数0，不作任何处理</span></span><br><span class="line"><span class="comment">//solution 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; x,x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= x;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//solution 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);<span class="comment">// 输出字符串，遇&#x27;\0&#x27;停止，自动加换行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//~scanf(&quot;%d&quot;,&amp;n)等价于scanf(&quot;%d&quot;,&amp;n) != -1(EOF)</span></span><br></pre></td></tr></table></figure>

<h2 id="8-acwing710-六个奇数"><a href="#8-acwing710-六个奇数" class="headerlink" title="8.acwing710.六个奇数"></a>8.acwing710.六个奇数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取一个整数X，输出X之后的6个奇数，如果X也是奇数，那么它也算作6个奇数之一</span></span><br><span class="line"><span class="comment">//每个数占一行</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x, j = <span class="number">0</span>; j &lt; <span class="number">6</span>; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            j ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-acwing719-连续奇数和2"><a href="#9-acwing719-连续奇数和2" class="headerlink" title="9.acwing719.连续奇数和2"></a>9.acwing719.连续奇数和2</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入N对整数对X,Y，对于每对X,Y，请你求出它们之间（不包括X和Y）的所有奇数的和</span></span><br><span class="line"><span class="comment">//solution 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) swap(x,y);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x + <span class="number">1</span>;i &lt; y;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>) sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//solution 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> x,y,ans,t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=(x&lt;y?x:y)+<span class="number">1</span>;i&lt;(x&gt;y?x:y);i++) <span class="keyword">if</span>(i&amp;<span class="number">1</span>) ans+=i;</span><br><span class="line">        <span class="comment">//i&amp;1 用于判断奇偶，为真是奇数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-acwing717-简单斐波那契"><a href="#10-acwing717-简单斐波那契" class="headerlink" title="10.acwing717.简单斐波那契"></a>10.acwing717.简单斐波那契</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下数列0 1 1 2 3 5 8 13 21 …被称为斐波纳契数列</span></span><br><span class="line"><span class="comment">//在一行中输出斐波那契数列的前N项，数字之间用空格隔开</span></span><br><span class="line"><span class="comment">//solution 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>,b = <span class="number">1</span>,c = a + b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;0 &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;1 &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,c);</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">            c = a+b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//better edition</span></span><br><span class="line"><span class="comment">//solution 2 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,a,b=<span class="number">1</span>,c;<span class="comment">// 这里a自动初始化为0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a);</span><br><span class="line">        c=a+b;</span><br><span class="line">        a=b,b=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>竞赛语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++竞赛语法总结（七）</title>
    <url>/posts/4122ace1.html</url>
    <content><![CDATA[<h2 id="1-acwing-66-两个链表的第一个公共结点"><a href="#1-acwing-66-两个链表的第一个公共结点" class="headerlink" title="1.acwing.66.两个链表的第一个公共结点"></a>1.acwing.66.两个链表的第一个公共结点</h2><p><u>这几道链表题大多来自《剑指offer》，都不太会啊！</u></p>
<p>输入两个链表，找出它们的第一个公共结点。</p>
<p>当不存在公共结点时，返回空结点。</p>
<span id="more"></span>

<p>样例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给出两个链表如下所示：</span><br><span class="line">A：        a1 → a2</span><br><span class="line">                   ↘</span><br><span class="line">                     c1 → c2 → c3</span><br><span class="line">                   ↗            </span><br><span class="line">B:     b1 → b2 → b3</span><br><span class="line"></span><br><span class="line">输出第一个公共结点c1</span><br></pre></td></tr></table></figure>

<p><img src="/posts/4122ace1/image-20210213203133692.png" alt="image-20210213203133692"></p>
<p><img src="/posts/4122ace1/image-20210213203516385.png" alt="image-20210213203516385"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">findFirstCommonNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* p = headA;ListNode* q = headB;</span><br><span class="line">        <span class="keyword">while</span> (p != q) <span class="comment">// 直到p，q走到公共结点或同时为空时跳出</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p) p = p-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> p = headB;</span><br><span class="line">            <span class="keyword">if</span> (q) q = q-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> q = headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-acwing-29-删除链表中的重复结点"><a href="#2-acwing-29-删除链表中的重复结点" class="headerlink" title="2.acwing.29.删除链表中的重复结点"></a>2.acwing.29.删除链表中的重复结点</h2><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留。</p>
<p>样例11</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</span><br><span class="line"></span><br><span class="line">输出：1-&gt;2-&gt;5</span><br></pre></td></tr></table></figure>

<p>样例2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;1-&gt;1-&gt;2-&gt;3</span><br><span class="line"></span><br><span class="line">输出：2-&gt;3</span><br></pre></td></tr></table></figure>

<p><strong>算法：(线性扫描) O(n)</strong><br>为了方便处理边界情况，我们定义一个虚拟元素 dummy指向链表头节点。<br>然后从前往后扫描整个链表，每次扫描元素相同的一段，如果这段中的元素个数多于1个，则将整段元素直接删除。</p>
<p><strong>时间复杂度</strong><br>整个链表只扫描一遍，所以时间复杂度是 O(n)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);<span class="comment">// 定义虚拟头结点避免特判第一个结点被删除的情况</span></span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* p = dummy;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> q = p-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (q-&gt;next &amp;&amp; p-&gt;next-&gt;val == q-&gt;next-&gt;val) q = q-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;next == q) p = q;</span><br><span class="line">            <span class="keyword">else</span> p-&gt;next = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-C-STL容器"><a href="#3-C-STL容器" class="headerlink" title="3.C++ STL容器"></a>3.C++ STL容器</h2><p>STL是提高C++编写效率的一个利器。                                                                                                            ——yxc</p>
<p>最后两章要背的东西比较多！</p>
<h3 id="3-1-include-lt-vector-gt"><a href="#3-1-include-lt-vector-gt" class="headerlink" title="3.1 #include &lt;vector&gt;"></a>3.1 <code>#include &lt;vector&gt;</code></h3><p>vector是<strong>变长数组，支持随机访问，不支持在任意位置O(1)插入</strong>。为了保证效率，元素的增删一般应该在末尾进行。 </p>
<h4 id="3-1-1-声明"><a href="#3-1-1-声明" class="headerlink" title="3.1.1  声明"></a>3.1.1  声明</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;    头文件</span></span></span><br><span class="line"></span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;       相当于一个长度动态变化的<span class="keyword">int</span>数组</span><br><span class="line"></span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b[<span class="number">233</span>];   相当于第一维长<span class="number">233</span>，第二位长度动态变化的<span class="keyword">int</span>数组</span><br><span class="line"></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">rec</span>&#123;</span>…&#125;;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">vector</span>&lt;rec&gt; c;       自定义的结构体类型也可以保存在<span class="built_in">vector</span>中</span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-size-empty"><a href="#3-1-2-size-empty" class="headerlink" title="3.1.2 size/empty"></a>3.1.2 size/empty</h4><p>size函数返回vector的实际长度（包含的元素个数），empty函数返回一个bool类型，表明vector是否为空，为空返回true，否则返回false。二者的时间复杂度都是O(1)。</p>
<p><strong>所有的STL容器都支持这两个方法，含义也相同</strong>，之后我们就不再重复给出。 </p>
<h4 id="3-1-3-clear"><a href="#3-1-3-clear" class="headerlink" title="3.1.3 clear"></a>3.1.3 clear</h4><p>​       clear函数把vector清空。 </p>
<h4 id="3-1-4-迭代器-iterator"><a href="#3-1-4-迭代器-iterator" class="headerlink" title="3.1.4 迭代器(iterator)"></a>3.1.4 迭代器(iterator)</h4><p>​       <strong>迭代器就像STL容器的“指针”</strong>，可以用星号“*”操作符解除引用。</p>
<p>​       一个保存int的vector的迭代器声明方法为：</p>
<p>​       <code>vector&lt;int&gt;::iterator it;</code></p>
<p>vector的迭代器是“随机访问迭代器”，可以把vector的迭代器与一个整数相加减，其行为和指针的移动类似。可以把vector的两个迭代器相减，其结果也和指针相减类似，得到两个迭代器对应下标之间的距离。 </p>
<h4 id="3-1-5-begin-end–-begin-end"><a href="#3-1-5-begin-end–-begin-end" class="headerlink" title="3.1.5 begin/end–[begin,end)"></a>3.1.5 begin/end–[begin,end)</h4><p>begin函数返回指向vector中第一个元素的迭代器。例如a是一个非空的vector，则<code>*a.begin()</code>与a[0]的作用相同。</p>
<p><strong>所有的容器都可以视作一个“前闭后开”的结构</strong>，end函数返回vector的尾部，即第n个元素再往后的“边界”。<code>*a.end()</code>与a[n]都是越界访问，其中n=<code>a.size()</code>。</p>
<p>下面两份代码都遍历了<code>vector&lt;int&gt; a</code>，并输出它的所有元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> I = <span class="number">0</span>; I &lt; a.size(); I ++) <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = a.begin(); it != a.end(); it ++) <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-6-front-back"><a href="#3-1-6-front-back" class="headerlink" title="3.1.6 front/back"></a>3.1.6 front/back</h4><p>​       front函数返回vector的第一个元素，等价于<code>*a.begin()</code> 和 a[0]。</p>
<p>​       back函数返回vector的最后一个元素，等价于<code>*==a.end()</code> 和 <code>a[a.size() – 1]</code>。 </p>
<h4 id="3-1-7-push-back-和-pop-back"><a href="#3-1-7-push-back-和-pop-back" class="headerlink" title="3.1.7  push_back() 和 pop_back()"></a>3.1.7  push_back() 和 pop_back()</h4><p><code>a.push_back(x)</code> 把元素x插入到vector a的尾部。</p>
<p><u>在数组结尾插入时间复杂度是O(1)，在数组开头插入时间复杂度是O(n)。</u></p>
<p> <code>b.pop_back()</code> 删除vector a的最后一个元素。</p>
<h4 id="3-1-8-实例"><a href="#3-1-8-实例" class="headerlink" title="3.1.8 实例"></a>3.1.8 实例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.front() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; *a.begin() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 3种等价写法</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.back() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a[a.size()<span class="number">-1</span>] &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// a.end()在最后一个元素之后的位置，索引会越界</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3种迭代vector的方法</span></span><br><span class="line">    <span class="comment">// solution 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; a.size();i ++) <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// solution 2，迭代器用到较少，太麻烦，只是介绍语法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = a.begin();it != a.end();it ++) <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="comment">// for (auto it = ...)简化</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// solution 3，常用</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : a) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">   	a.push_back(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x:a) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 1 2 3 4</span></span><br><span class="line">    </span><br><span class="line">    a.pop_back();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x:a) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 1 2 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-include-lt-queue-gt"><a href="#3-2-include-lt-queue-gt" class="headerlink" title="3.2 #include &lt;queue&gt; "></a>3.2 <code>#include &lt;queue&gt; </code></h3><p>头文件queue主要包括循环队列queue和优先队列priority_queue两个容器。 </p>
<p>没有clear函数。</p>
<p><strong>先进先出(FIFO)，队头插入，队尾删除。</strong></p>
<p>优先队列：</p>
<ul>
<li>定义大根堆时结构体要重载小于号&lt;；</li>
<li>定义小根堆时结构体要重载大于号&gt;；</li>
</ul>
<h4 id="3-2-1-声明"><a href="#3-2-1-声明" class="headerlink" title="3.2.1 声明"></a>3.2.1 声明</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">rec</span>&#123;</span>…&#125;; <span class="built_in">queue</span>&lt;rec&gt; q;    <span class="comment">//在优先队列中，结构体rec中必须定义小于号</span></span><br><span class="line"></span><br><span class="line">       <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; q;    <span class="comment">// 大根堆，每次返回最大值</span></span><br><span class="line"></span><br><span class="line">       <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;   <span class="comment">// 小根堆，每次返回最小值</span></span><br><span class="line"></span><br><span class="line">       <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;<span class="comment">// pair是二元组</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-循环队列-queue"><a href="#3-2-2-循环队列-queue" class="headerlink" title="3.2.2 循环队列 queue"></a>3.2.2 循环队列 queue</h4><p>​       push 从队尾插入</p>
<p>​       pop 从队头弹出</p>
<p>​       front 返回队头元素</p>
<p>​       back 返回队尾元素 </p>
<h4 id="3-2-3-优先队列-priority-queue"><a href="#3-2-3-优先队列-priority-queue" class="headerlink" title="3.2.3 优先队列 priority_queue"></a>3.2.3 优先队列 priority_queue</h4><p>​       push 把元素插入堆</p>
<p>​       pop 删除堆顶元素</p>
<p>​       top 查询堆顶元素（最大值）</p>
<h4 id="3-2-4-实例"><a href="#3-2-4-实例" class="headerlink" title="3.2.4 实例"></a>3.2.4 实例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    a.push(<span class="number">1</span>);<span class="comment">// 从队尾插入</span></span><br><span class="line">    a.push(<span class="number">2</span>);</span><br><span class="line">    a.push(<span class="number">3</span>);</span><br><span class="line">    a.pop();<span class="comment">// 弹出队头元素1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.front() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 返回队头2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.back() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 返回队尾3</span></span><br><span class="line">    a = <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;();<span class="comment">// 重新初始化以清空队列</span></span><br><span class="line">    <span class="comment">// 因为队列，栈容器没有clear函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">double</span>&gt; q;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; b;<span class="comment">// 大根堆</span></span><br><span class="line">    b.push(<span class="number">2</span>);</span><br><span class="line">    b.push(<span class="number">4</span>);</span><br><span class="line">    b.push(<span class="number">8</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b.top() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 取最大值8</span></span><br><span class="line">    b.pop();<span class="comment">// 删除最大值，无返回值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b.top() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; x;<span class="comment">// 小根堆</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Rec</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Rec&amp; t) <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a &lt; t.a;<span class="comment">// 没有重载&quot;&lt;&quot;时插入元素会报错</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;Rec&gt; s;<span class="comment">// 大根堆重载&lt;</span></span><br><span class="line">    s.push(&#123;<span class="number">1</span>,<span class="number">2</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Res</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>&gt; (<span class="keyword">const</span> Res&amp; t) <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a &gt; t.a;<span class="comment">// 没有重载&quot;&gt;&quot;时插入元素会报错</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;Res,<span class="built_in">vector</span>&lt;Res&gt;,greater&lt;Res&gt;&gt; n;<span class="comment">// 小根堆重载&gt;</span></span><br><span class="line">    n.push(&#123;<span class="number">1</span>,<span class="number">2</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;Rec&gt; v;</span><br><span class="line">    v.push(&#123;<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-include-lt-stack-gt"><a href="#3-3-include-lt-stack-gt" class="headerlink" title="3.3 #include &lt;stack&gt;"></a>3.3 <code>#include &lt;stack&gt;</code></h3><p>头文件stack包含栈。声明和前面的容器类似。</p>
<p>没有clear函数。</p>
<p><strong>先进后出(FILO)，栈顶插入，栈顶删除</strong></p>
<p>push 向栈顶插入</p>
<p>pop 弹出栈顶元素</p>
<p>top 取栈顶元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    stk.push(<span class="number">1</span>);</span><br><span class="line">    stk.push(<span class="number">8</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stk.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    stk.pop();</span><br><span class="line">    stk.push(<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stk.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">12*/</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-include-lt-deque-gt"><a href="#3-4-include-lt-deque-gt" class="headerlink" title="3.4 #include &lt;deque&gt;"></a>3.4 <code>#include &lt;deque&gt;</code></h3><p>双端队列deque是一个支持在两端高效插入或删除元素的连续线性存储空间。它就像是vector和queue的结合。<strong>与vector相比，deque在头部增删元素仅需要O(1)的时间；与queue相比，deque像数组一样支持随机访问。运行效率会比stack和vector慢。</strong></p>
<p>[] 随机访问</p>
<p>begin/end，返回deque的头/尾迭代器，<strong>左闭右开</strong></p>
<p>front/back 队头/队尾元素</p>
<p>push_back 从队尾入队</p>
<p>push_front 从队头入队</p>
<p>pop_back 从队尾出队</p>
<p>pop_front 从队头出队</p>
<p>clear 清空队列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    a.push_back(<span class="number">1</span>),a.push_front(<span class="number">2</span>);</span><br><span class="line">    a.push_back(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *a.begin() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; *a.end() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.front() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    a.pop_back(),a.pop_front();</span><br><span class="line">    a.clear();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">2 17367376</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">2 3*/</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>竞赛语法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>C++竞赛语法总结（三）</title>
    <url>/posts/2e9f4c85.html</url>
    <content><![CDATA[<h2 id="1-scanf-函数"><a href="#1-scanf-函数" class="headerlink" title="1.scanf()函数"></a>1.scanf()函数</h2><p><strong>scanf()函数接收输入数据时，遇以下情况结束一个数据的输入：</strong> </p>
<p>① 遇空格、“回车”、“跳格”键。<br>        ② 遇宽度结束。<br>        ③ 遇非法输入。</p>
<p><strong>cin遇到空格或者回车也会结束读取！！！</strong></p>
<p><strong>scanf接收包含空格的字符串</strong></p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">80</span>]; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入：I love you!<br>        输出：I<br>        原因：scanf遇空格结束读取。</p>
<h2 id="2-ASCII码"><a href="#2-ASCII码" class="headerlink" title="2.ASCII码"></a>2.ASCII码</h2><p>每个常用字符都对应一个-128~127的数字，二者之间可以相互转化。</p>
<table>
<thead>
<tr>
<th>ASCII码</th>
<th>字符</th>
</tr>
</thead>
<tbody><tr>
<td>48</td>
<td>‘0’</td>
</tr>
<tr>
<td>65</td>
<td>‘A’</td>
</tr>
<tr>
<td>97</td>
<td>‘a’</td>
</tr>
</tbody></table>
<h2 id="3-字符数组"><a href="#3-字符数组" class="headerlink" title="3.字符数组"></a>3.字符数组</h2><h3 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h3><p>字符串就是字符数组加上==结束符’\0’==。没有’\0’不算字符串，只是普通的字符数组。</p>
<p>可以使用字符串来初始化字符数组，但此时要注意，每个字符串结尾会暗含一个’\0’字符，因此字符数组的长度至少要比字符串的长度多1！</p>
<p><img src="/posts/2e9f4c85/image-20210101141628559.png" alt="image-20210101141628559"></p>
<p>这里第二、三种初始化方式是等价的。</p>
<h3 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 输入：abc</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出：</span></span><br><span class="line"><span class="comment">    abc</span></span><br><span class="line"><span class="comment">    a </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 这样就可以让读取的字符串的数组从1开始</span></span><br><span class="line"><span class="comment">// 使用scanf函数有同样的效果,scanf(&quot;%s&quot;,s + 1)</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3"><a href="#3-3" class="headerlink" title="3.3"></a>3.3</h3><h4 id="3-3-1"><a href="#3-3-1" class="headerlink" title="3.3.1"></a>3.3.1</h4><p>读入一行字符串（包括空格），可以使用gets函数，但由于它不安全，已经被淘汰。</p>
<h4 id="3-3-2"><a href="#3-3-2" class="headerlink" title="3.3.2"></a>3.3.2</h4><p>现在使用fgets函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line">fgets(s,<span class="number">100</span>,<span class="built_in">stdin</span>);</span><br></pre></td></tr></table></figure>

<p>原型  <code>char *  fgets(char * s, int n,FILE *stream);</code></p>
<p>  参数：</p>
<p>​     s: 字符型指针，指向存储读入数据的缓冲区的地址。</p>
<p>​     n: 从流中读入n-1个字符</p>
<p>​     stream ： 指向读取的流。</p>
<p>  返回值：</p>
<ol>
<li>​     当n&lt;=0 时返回NULL，即空指针。</li>
<li>​     当n=1 时，返回空串””。</li>
<li>​     如果读入成功，则返回缓冲区的地址。</li>
<li>​     如果读入错误或遇到文件结尾(EOF)，则返回NULL。</li>
</ol>
<h4 id="3-3-3"><a href="#3-3-3" class="headerlink" title="3.3.3"></a>3.3.3</h4><p>在用fgets(..)读入数据时，先定义一个字符数组或字符指针，如果定义了字符指针 ，那么一定要初始化。</p>
<p>​    example:</p>
<p>​       char s[100]; //可以。</p>
<p>​       char *s;  //不可以，因为只是声明了一个指针。但并没有为它分配内存缓冲区。</p>
<p>​       所以，如果要用指针，则  <code>char *s=(char*)malloc(100*sizeof(char));</code> 为其分配内存空间,c++中用<code>char *s=new char [100];</code>    如果未分配内存空间，编译时不会检查出问题，但运行时会出现未知错误。。</p>
<h4 id="3-3-4"><a href="#3-3-4" class="headerlink" title="3.3.4"></a>3.3.4</h4><p>fgets(…)读入文本行时的两种情况。</p>
<p>​     1.   如果n大于一行的字符串长度，那么当读到字符串末尾的换行符时，fgets(..)会返回。并且在s的最后插入字符串结束标志’\0’。 而s缓冲区剩余的位置不会再填充。</p>
<p>​      example：</p>
<p>​       123abc</p>
<p>​       fgets(s,10,fp);</p>
<p>​       此时，读入七个字符，123abc\n,实际上还有最后的’\0’,所以，strlen(s)=7; 如果要去除末尾的\n，s[strlen(s)-1]=’\0’;便可。</p>
<p>​     2.   如果n小于等于一行的字符串的长度，那么读入n-1个字符，此时并没有读入\n因为并没有到行尾 ，同样在最后会插入’\0’.</p>
<p>​     example:</p>
<p>​      123abc</p>
<p>​      char  s[5];</p>
<p>​      fgets(s,5,fp);</p>
<p>​      这时读入4个字符，123a,并没有换行符，所以strlen(s)=4.</p>
<h3 id="3-4"><a href="#3-4" class="headerlink" title="3.4"></a>3.4</h3><p>用getline函数来读取字符串中的空格。（定义在头文件中）</p>
<p>getline 函数如下所示：</p>
<p>getline(cin, inputLine);</p>
<p>其中 cin 是正在读取的输入流，而 inputLine 是接收输入字符串的 string 变量的名称。</p>
<p>注意：第二个参数不能是字符数组，必须是string变量！！<u>它将继续读取，直到它读取至最大指定的字符数，或直到按下了回车键。</u></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="built_in">string</span> city;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Please enter your name: &quot;</span>;</span><br><span class="line">getline(<span class="built_in">cin</span>, name);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the city you live in: &quot;</span>;</span><br><span class="line">getline(<span class="built_in">cin</span>, city);<span class="comment">// 上一次用户输入的&#x27;\n&#x27;被去除了，没有读入city</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, &quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You live in &quot;</span> &lt;&lt; city &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出如下</span></span><br><span class="line">Please enter your name: John Doe</span><br><span class="line">Enter the city you live in: Chicago</span><br><span class="line">Hello, John Doe</span><br><span class="line">You live in Chicago</span><br></pre></td></tr></table></figure>

<p>补充：getline()中读入结束的回车后，结束符不放入缓存区，会将读入的\n直接去除，下一个输入前，缓冲区为空，并不会因为回车留下\n。而cin的结束后，以及getchar()此类的读入结束后,按下回车或者使用空格读入下一个，此时按下的回车或空格会还在缓存区,继续用getline()就会出现前面所提到的情况。</p>
<p>scanf函数并不会清空缓冲区回车！！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用scanf过滤空格</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">30</span>],c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;\n%c&quot;</span>,&amp;c);</span><br></pre></td></tr></table></figure>

<h3 id="3-5"><a href="#3-5" class="headerlink" title="3.5"></a>3.5</h3><p>cin.getline函数。</p>
<p>与 getline 一样，cin.getline 允许读取包含空格的字符串。它将继续读取，直到它读取至最大指定的字符数，或直到按下了回车键。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">cin</span>.getline(s,<span class="number">100</span>);<span class="comment">// 最多读取99个字符，最后一个位置放&#x27;\0&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-6"><a href="#3-6" class="headerlink" title="3.6"></a>3.6</h3><p>puts函数。（引入)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> name[] = <span class="string">&quot;asaf&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,name);</span><br><span class="line"><span class="built_in">puts</span>(name);<span class="comment">// 两者是完全等价的</span></span><br></pre></td></tr></table></figure>

<h2 id="4-字符数组常用操作"><a href="#4-字符数组常用操作" class="headerlink" title="4.字符数组常用操作"></a>4.字符数组常用操作</h2><p>下面几个函数需要引入头文件:</p>
<p><code>#include &lt;string.h&gt;</code>  或者也可以</p>
<p>(1)  strlen(str)，求字符串的长度，注意：不包括最后的’\0’</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自己实现代码</span></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;s[i];i++) len++;<span class="comment">// 用s[i]作为判断条件，因为&#x27;\0&#x27;代表停止</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>(2)  strcmp(a, b)，比较两个字符串的大小，a &lt; b 返回-1，a == b 返回0，a &gt; b返回1。这里的比较方式是字典序！</p>
<p>(3)  strcpy(a, b)，将字符串b复制给从a开始的字符数组。</p>
<h2 id="5-acwing772-只出现一次的字符"><a href="#5-acwing772-只出现一次的字符" class="headerlink" title="5.acwing772.只出现一次的字符"></a>5.acwing772.只出现一次的字符</h2><p><img src="/posts/2e9f4c85/image-20210101155001628.png" alt="image-20210101155001628"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 巧妙的做法</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;<span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">    <span class="keyword">int</span> s[<span class="number">300</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> &amp;c : str) s[c]++;<span class="comment">// 遍历string</span></span><br><span class="line">    <span class="keyword">char</span> p = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> &amp;c: str)<span class="comment">// 注意这里还是遍历str，不是s</span></span><br><span class="line">        <span class="comment">// 因为题目要求第一个出现的满足要求的字符</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[c] == <span class="number">1</span>) &#123;p = c;<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">-1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;no&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-acwing763-循环相克令"><a href="#6-acwing763-循环相克令" class="headerlink" title="6.acwing763.循环相克令"></a>6.acwing763.循环相克令</h2><p><img src="/posts/2e9f4c85/image-20210101170937824.png" alt="image-20210101170937824"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原解法，太过低效，直接暴力枚举</span></span><br><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">// 这行代码最后紧跟着include</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">&quot;Hunter&quot;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">&quot;Bear&quot;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> a,b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">int</span> x = get(a),y = get(b);</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="built_in">puts</span>(<span class="string">&quot;Tie&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((y+<span class="number">1</span>)%<span class="number">3</span> == x) <span class="built_in">puts</span>(<span class="string">&quot;Player1&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Player2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 巧妙的解题思路，利用字母的长度之差，读题能力实在佩服</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> x, y;</span><br><span class="line">    <span class="keyword">while</span> (n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">int</span> a = x.size(), b = y.size();</span><br><span class="line">        <span class="keyword">if</span> (a - b == <span class="number">-1</span> || a - b == <span class="number">-2</span> || a - b == <span class="number">3</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Player1&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a == b)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Tie&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Player2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：黄</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/15253/</span></span><br><span class="line">来源：AcWing</span><br></pre></td></tr></table></figure>

<h2 id="7-acwing765-字符串加空格"><a href="#7-acwing765-字符串加空格" class="headerlink" title="7.acwing765.字符串加空格"></a>7.acwing765.字符串加空格</h2><p>给定一个字符串，在字符串的每个字符之间都加一个空格。</p>
<p>输出修改后的新字符串。</p>
<p>输入格式<br>共一行，包含一个字符串。注意字符串中可能包含空格。</p>
<p>输出格式<br>输出增加空格后的字符串。</p>
<p>数据范围<br>1≤字符串长度≤100</p>
<p>样例<br>输入样例：<br><code>test case</code><br>输出样例：<br><code>t e s t   c a s e</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历字符串的非常巧妙的做法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    getline(<span class="built_in">cin</span>, a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> &amp;c : a) <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 遍历字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-acwing773-字符串插入"><a href="#8-acwing773-字符串插入" class="headerlink" title="8.acwing773.字符串插入"></a>8.acwing773.字符串插入</h2><p>有两个不包含空白字符的字符串str和substr，str的字符个数不超过10，substr的字符个数为3（字符个数不包括字符串结尾处的’\0’。）</p>
<p>将substr插入到str中ASCII码最大的那个字符后面，若有多个最大则只考虑第一个。</p>
<p>输入格式</p>
<p>输入包括若干行，每一行为一组测试数据，格式为</p>
<p>str substr</p>
<p> 输出格式</p>
<p>对于每一组测试数据，输出插入之后的字符串。</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abcab eee</span><br><span class="line">12343 555</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abceeeab</span><br><span class="line">12345553</span><br></pre></td></tr></table></figure>

<p>关于substr的说明：</p>
<ol start="0">
<li><p>用途：一种构造string的方法</p>
</li>
<li><p>形式：s.substr(pos, n)</p>
</li>
<li><p>解释：返回一个string，包含s中从pos开始的n个字符的拷贝（pos的默认值是0，n的默认值是s.size() - pos，即不加参数会默认拷贝整个s）<br>当只有一个数字pos表示从下标为pos开始一直到结尾</p>
</li>
<li><p>补充：若pos的值超过了string的大小，则substr函数会抛出一个out_of_range异常；若pos+n的值超过了string的大小，则substr会调整n的值，只拷贝到string的末尾</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">string</span> s = <span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.substr(<span class="number">0</span>,<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span> &lt;&lt; s.substr(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 第一个参数代表下标，第二个参数代表长度（可以不加）</span></span><br><span class="line"><span class="comment">/*    输出如下</span></span><br><span class="line"><span class="comment"> 012</span></span><br><span class="line"><span class="comment">3456789</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原解法TLE了，超时，写错了</span></span><br><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> a,b;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; a.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[p]) p = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a.substr(<span class="number">0</span>,p + <span class="number">1</span>) + b + a.substr(p + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 题解2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">11</span>], substr[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s %s&quot;</span>, str, substr) != EOF)&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = str[<span class="number">0</span>], res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] &gt; cnt) cnt = str[i], res = i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == cnt) <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= res; i ++)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; str[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(substr); i++)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; substr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = res + <span class="number">1</span>; i &lt; <span class="built_in">strlen</span>(str); i++)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; str[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：zhiling</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/2913/</span></span><br><span class="line">来源：AcWing</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>竞赛语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++竞赛语法总结（二）</title>
    <url>/posts/6381efd7.html</url>
    <content><![CDATA[<h2 id="1-acwing725-完全数"><a href="#1-acwing725-完全数" class="headerlink" title="1.acwing725.完全数"></a>1.acwing725.完全数</h2><p>一个整数，除了本身以外的其他所有约数的和如果等于该数，那么我们就称这个整数为完全数。</p>
<p>例如，6就是一个完全数，因为它的除了本身以外的其他约数的和为 1+2+3 = 6。</p>
<p>现在，给定你N个整数，请你依次判断这些数是否是完全数。</p>
<p>每个测试用例输出一个结果，每个结果占一行。</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意这样时间复杂度太大，会超时</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">while</span> (n--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x,sum = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; x;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (x%i == <span class="number">0</span>) sum += i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (sum == x) <span class="built_in">printf</span>(<span class="string">&quot;%d is perfect\n&quot;</span>,x);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d is not perfect\n&quot;</span>,x);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化版本</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">while</span> (n--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x,sum = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i*i &lt;= x;i++)<span class="comment">// 减少循环次数</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (x%i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; x) sum += i;</span><br><span class="line">                <span class="keyword">if</span> (i != x/i &amp;&amp; x/i &lt; x) sum += x/i; <span class="comment">// 关键步骤</span></span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (sum == x) <span class="built_in">printf</span>(<span class="string">&quot;%d is perfect\n&quot;</span>,x);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d is not perfect\n&quot;</span>,x);</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特别解法"><a href="#特别解法" class="headerlink" title="特别解法"></a>特别解法</h3><p>有点数学基础的人都应该知道100000000内的完全数没有几个……</p>
<p>数学部分<br>100000000100000000内的完全数有6,28,496,8128,335503366,28,496,8128,33550336.所以说多背一点数字是很有用的</p>
<p>既然这道题可以直接O(1)O(1)解决,我们不妨来说一下完全数的各种性质以备于各种毒瘤的算法竞赛.</p>
<p>完全数比较重要的几个性质<br>(也是我只知道的几个性质)</p>
<p>所有完全数都是三角形数<br>目前截止发现的所有完全数都以66或2828结尾<br>到现在为止,数学家们一共发现了4848个完全数,且4848个完全数全部是偶数<br>如果有人们没有找到的奇完全数,则它一定可以写成12p+112p+1或36p+936p+9的形式,而且pp是素数<br>奇完全数一定大于1030010300<br>完全数的约数的倒数之和为调和数<br>完全数可以表示成连续奇数的立方和<br>完全数可以表示成22的连续自然数的次幂之和,且这些自然数的数量必定是素数<br>完全数计算法<br>若2p−1是素数(亦称其为梅森素数),则2p−1∗(2p−1)是完全数.</p>
<p>时间复杂度<br>这里数据小了一点,对于每个数据时间复杂度为O(1)O(1).<br>数据再大我都不怕,反正现在找到48个不如个map然后映射一个布尔类不就好了!</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">6</span> || n == <span class="number">28</span> || n == <span class="number">496</span> || n == <span class="number">8128</span> || n == <span class="number">33550336</span>)  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; is perfect&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; is not perfect&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-错误小提示"><a href="#2-错误小提示" class="headerlink" title="2.错误小提示"></a>2.错误小提示</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误写法，第二句不会执行，很容易犯错</span></span><br><span class="line"><span class="keyword">if</span> (...) xxx; xxx;</span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="number">1.</span><span class="keyword">if</span> (...) &#123;xxx; xxx;&#125;</span><br><span class="line"><span class="number">2.</span><span class="keyword">if</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">    xxx; xxx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3.</span><span class="keyword">if</span>() xxx,xxx;</span><br></pre></td></tr></table></figure>

<h2 id="3-acwing727-菱形"><a href="#3-acwing727-菱形" class="headerlink" title="3.acwing727.菱形"></a>3.acwing727.菱形</h2><p><img src="/posts/6381efd7/image-20201230171526383-1610606143859.png" alt="image-20201230171526383"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">abs</span>(i-n/<span class="number">2</span>) + <span class="built_in">abs</span>(j-n/<span class="number">2</span>) &lt;= n/<span class="number">2</span>)<span class="comment">// abs函数求绝对值</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);<span class="comment">// 漏掉这里就只能打印右半边图形</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致思路：来自于y总讲解。根据图形特点，这是一个正方形中的菱形，离正方形中心的曼哈顿距离&lt;= n/2的点打印*，其他点打印空格。</p>
<p>例如在平面上，坐标(x1,y1)的i点与坐标(x2,y2)的j点的曼哈顿距离为：</p>
<p><code>d(i,j)=|X1-X2|+|Y1-Y2|.</code></p>
<h2 id="4-高精度浮点数运算问题"><a href="#4-高精度浮点数运算问题" class="headerlink" title="4.高精度浮点数运算问题"></a>4.高精度浮点数运算问题</h2><p>如果进行了一系列对浮点数的运算，精度可能变得不准确，这时运算之前、之后的浮点数可能不相等，但实际上是相等的，只是因为精度丢失。看例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">sqrt</span>(<span class="number">3</span>) * <span class="built_in">sqrt</span>(<span class="number">3</span>) != <span class="number">3</span>) <span class="built_in">puts</span>(<span class="string">&quot;!!!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>结果我们会发现显示！！！，说明精度丢失了，但实际结果应该相等。</p>
<p>解决方案如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当两个浮点数相差足够小时，我们可以认为他们相等</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(<span class="built_in">sqrt</span>(<span class="number">3</span>) * <span class="built_in">sqrt</span>(<span class="number">3</span>) - <span class="number">3</span>) &lt; eps) <span class="built_in">puts</span>(<span class="string">&quot;相等&quot;</span>);</span><br><span class="line"><span class="comment">// double fabs(double x)，fabs用于求绝对值</span></span><br></pre></td></tr></table></figure>

<p>这时我们便会发现显示相等了。</p>
<h2 id="5-数组的初始化"><a href="#5-数组的初始化" class="headerlink" title="5.数组的初始化"></a>5.数组的初始化</h2><p>注意一下：</p>
<p><img src="/posts/6381efd7/image-20201230191009315.png" alt="image-20201230191009315"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将数组全部初始化为0的写法</span></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">// 很常用</span></span><br></pre></td></tr></table></figure>

<p>切记：定义在函数内部（包括main函数）的数组，如果不初始化，则是随机的。</p>
<p>知识点：放在函数内部的数组空间存放在栈里，如果栈的空间不够，则可能会出现段错误。</p>
<p>但放在函数外部的数组空间存放在堆里，只要不超过内存限制，可以定的比较大。比如可以放main函数之外。</p>
<p>定义在函数外部的数组，如果不初始化，则是全部默认为0的。</p>
<p>这就是局部变量和全局变量的区别。</p>
<p>注意数组下标越界的问题，会导致段错误！</p>
<h2 id="6-练习题-旋转数组"><a href="#6-练习题-旋转数组" class="headerlink" title="6.练习题.旋转数组"></a>6.练习题.旋转数组</h2><p>输入一个n，再输入n个整数。将这个数组顺时针旋转k(k &lt;= n)次，最后将结果输出。</p>
<p>相关题目：<a href="https://www.acwing.com/problem/content/description/818/">acwing.816. 数组翻转</a>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般做法，有两重循环</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (k--)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> t = a[n<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-2</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i+<span class="number">1</span>] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	a[<span class="number">0</span>] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/6381efd7/image-20201230194748915.png" alt="image-20201230194748915"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更巧妙的做法，只有一重循环</span></span><br><span class="line"><span class="comment">//reverse函数用于反转在[first,last)范围内的顺序（包括first指向的元素，不包括last指向的元素），reverse函数没有返回值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">reverse(a,a + n);<span class="comment">// 翻转a[0]到a[n-1]的n个数</span></span><br><span class="line">reverse(a,a + k);<span class="comment">// 翻转a[0]到a[k-1]的k个数</span></span><br><span class="line">reverse(a + k,a + n);</span><br></pre></td></tr></table></figure>

<p><u>注意：reverse函数的参数是左闭右开的。</u></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//演示reverse函数</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,b[<span class="number">3</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">	reverse(a,a+<span class="number">1</span>);<span class="comment">// 翻转1个数</span></span><br><span class="line">	reverse(b,b+<span class="number">2</span>);<span class="comment">// 翻转2个数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++) <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++) <span class="built_in">cout</span> &lt;&lt; b[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出如下</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">    </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="7-acwing743-数组中的行"><a href="#7-acwing743-数组中的行" class="headerlink" title="7.acwing743.数组中的行"></a>7.acwing743.数组中的行</h2><p>输入一个二维数组<code>M[12][12]</code>，根据输入的要求，求出二维数组中某一行的元素的平均值或元素的和。</p>
<p> <strong>输入格式</strong></p>
<p>第一行输入整数L，表示所求的具体行数（行数从0开始计数）。</p>
<p>第二行包含一个大写字母，若为’S’，则表示需要求出第 L 行的元素的和，若为’M’，则表示需要求出第 L 行的元素的平均值。</p>
<p>接下来12行，每行包含12个用空格隔开的浮点数，表示这个二维数组，其中第 i+1 行的第 j+1 个数表示数组元素<code>M[i][j]</code>。输出一个数，表示所求的平均数或元素的和的值，保留一位小数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">char</span> op;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; op;</span><br><span class="line">    <span class="keyword">double</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">12</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> a;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">            <span class="keyword">if</span>(i==l) s+=a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,op==<span class="string">&#x27;S&#x27;</span> ? s : s/<span class="number">12</span>);<span class="comment">//简化操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-acwing749-数组的上方区域"><a href="#8-acwing749-数组的上方区域" class="headerlink" title="8.acwing749.数组的上方区域"></a>8.acwing749.数组的上方区域</h2><p><img src="/posts/6381efd7/image-20201230222858583.png" alt="image-20201230222858583"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">    <span class="keyword">double</span> a,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">12</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;i&amp;&amp;i+j&lt;<span class="number">11</span>)res+=a;<span class="comment">//关键是找到绿色方块的分布规律，两块区域的交集</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,c==<span class="string">&#x27;S&#x27;</span>?res:res/<span class="number">30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-acwing753-平方矩阵-I"><a href="#9-acwing753-平方矩阵-I" class="headerlink" title="9.acwing753.平方矩阵 I"></a>9.acwing753.平方矩阵 I</h2><p><img src="/posts/6381efd7/image-20201230225943900.png" alt="image-20201230225943900"></p>
<p><img src="/posts/6381efd7/image-20201230230029361.png" alt="image-20201230230029361"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这题不会做，困难</span></span><br><span class="line"><span class="comment">// 主要思路就是求到上下左右四条边的最小值，找到规律就不难</span></span><br><span class="line"><span class="comment">// y总解法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,up,down,left,right;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n,n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                up = i;down = n-i+<span class="number">1</span>;left = j;right = n-j+<span class="number">1</span>;<span class="comment">// 这四个变量还可以省略</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; min(min(up,down),min(left,right)) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-acwing756-蛇形矩阵"><a href="#10-acwing756-蛇形矩阵" class="headerlink" title="10.acwing756.蛇形矩阵"></a>10.acwing756.蛇形矩阵</h2><p><img src="/posts/6381efd7/image-20201231183222306.png" alt="image-20201231183222306"><img src="/posts/6381efd7/image-20210101111311064.png" alt="image-20210101111311064"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 来自于微软面试题，尝试写了一小段，没完成</span></span><br><span class="line"><span class="comment">// 有一定难度</span></span><br><span class="line"><span class="comment">// y总解题思路</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res[<span class="number">100</span>][<span class="number">100</span>];<span class="comment">// 小细节，定义为全局变量默认初始化为0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dy[] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;<span class="comment">// 定义横纵坐标偏移量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>,y = <span class="number">0</span>,d = <span class="number">0</span>,k = <span class="number">1</span>;k &lt;= n*m;k++)</span><br><span class="line">        <span class="comment">// d用于确定前进方向，开始时向右走</span></span><br><span class="line">    &#123;</span><br><span class="line">        res[x][y] = k;</span><br><span class="line">        <span class="keyword">int</span> a = x + dx[d],b = y + dy[d];</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m || res[a][b])</span><br><span class="line">        <span class="comment">// 判断是否出界，或者已经遍历过，未遍历过res[a][b] == 0</span></span><br><span class="line">        <span class="comment">// 符合条件则将方向顺时针旋转90度</span></span><br><span class="line">        &#123;</span><br><span class="line">            d = (d + <span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">            a = x + dx[d],b = y + dy[d];</span><br><span class="line">        &#125;</span><br><span class="line">        x = a,y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; res[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题解2，紫书</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">150</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));<span class="comment">// 初始化数组a为0</span></span><br><span class="line">    <span class="comment">// 作用是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;       <span class="comment">//初始坐标坐标，（0,0） </span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;            <span class="comment">//初始化第一个数 </span></span><br><span class="line">    a[x][y] = cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cnt &lt; n * m ) </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">//用下一笔的位置来判断</span></span><br><span class="line">        <span class="comment">//向右， 符合条件，则填入下一笔。____提前预判  </span></span><br><span class="line">        <span class="keyword">while</span> (y + <span class="number">1</span> &lt; m &amp;&amp; !a[x][y + <span class="number">1</span>]) a[x][ ++ y] = ++ cnt;</span><br><span class="line">        <span class="comment">//向下 </span></span><br><span class="line">        <span class="keyword">while</span> (x + <span class="number">1</span> &lt; n &amp;&amp; !a[x + <span class="number">1</span>][y]) a[ ++ x][y] = ++ cnt;</span><br><span class="line">        <span class="comment">//向左</span></span><br><span class="line">        <span class="keyword">while</span> (y - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !a[x][y - <span class="number">1</span>]) a[x][ -- y] = ++ cnt;</span><br><span class="line">        <span class="comment">//向上</span></span><br><span class="line">        <span class="keyword">while</span> (x - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !a[x - <span class="number">1</span>][y]) a[ -- x][y] = ++ cnt;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; a[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：大锤</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/12905/</span></span><br><span class="line">来源：AcWing</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>竞赛语法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>C++竞赛语法总结（五）</title>
    <url>/posts/f62c90a7.html</url>
    <content><![CDATA[<h2 id="1-acwing-779-最长公共字符串后缀"><a href="#1-acwing-779-最长公共字符串后缀" class="headerlink" title="1.acwing.779.最长公共字符串后缀"></a>1.acwing.779.最长公共字符串后缀</h2><p><strong>注：字符串这一章知识点比较多，有点难，要经常复习消化。</strong></p>
<p>输入格式</p>
<p>由若干组输入组成。</p>
<p>每组输入的第一行是一个整数N。</p>
<p>N为0时表示输入结束，否则后面会继续有N行输入，每行是一个字符串（字符串内不含空白符）。</p>
<p>每个字符串的长度不超过200。</p>
<p>输出格式</p>
<p>共一行，为N个字符串的最长公共后缀（可能为空）。</p>
<span id="more"></span>

<p>数据范围</p>
<p>1≤N≤200</p>
<p>输入样例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line">baba</span><br><span class="line">aba</span><br><span class="line">cba</span><br><span class="line"><span class="number">2</span></span><br><span class="line">aa</span><br><span class="line">cc</span><br><span class="line"><span class="number">2</span></span><br><span class="line">aa</span><br><span class="line">a</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ba</span><br><span class="line"></span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解，通过循环枚举后缀长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">210</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">string</span> str[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n,n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; str[i];</span><br><span class="line">            <span class="keyword">if</span> (len &gt; str[i].size()) len = str[i].size();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> success = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">bool</span> is_same = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= len;j ++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (str[<span class="number">0</span>][str[<span class="number">0</span>].size() - j] != str[i][str[i].size() - j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        is_same = <span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!is_same)</span><br><span class="line">                &#123;</span><br><span class="line">                    success = <span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (success) <span class="keyword">break</span>;</span><br><span class="line">            len --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; str[<span class="number">0</span>].substr(str[<span class="number">0</span>].size() - len) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-static静态关键字修饰变量"><a href="#2-static静态关键字修饰变量" class="headerlink" title="2.static静态关键字修饰变量"></a>2.static静态关键字修饰变量</h2><h3 id="2-1-修饰局部变量"><a href="#2-1-修饰局部变量" class="headerlink" title="2.1 修饰局部变量"></a>2.1 修饰局部变量</h3><p>用于函数内部修饰变量。<strong>相当于在函数内部开了一个只有该函数能用的全局变量。</strong></p>
<p>调用堆空间，和全局变量有相同之处，未初始化时默认为0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>; <span class="comment">// note:1</span></span><br><span class="line">	<span class="comment">//int i = 1;  // note:2</span></span><br><span class="line">	i += <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们总结一下，静态局部变量的特点（括号内为note:2,也就是局部变量的对比）：</p>
<p>（1）该变量在全局数据区分配内存(局部变量在栈区分配内存);<br>        （2）静态局部变量在程序执行到该对象的声明处时被首次初始化，<strong>即以后的函数调用不再进行初始化</strong>(局部变量每次函数调用都会被初始化);<br>        （3）静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0(局部变量不会被初始化);<br>        （4）它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，也就是不能在函数体外面使用它(局部变量在栈区，在函数结束后立即释放内存);</p>
<h3 id="2-2-修饰全局变量"><a href="#2-2-修饰全局变量" class="headerlink" title="2.2 修饰全局变量"></a>2.2 修饰全局变量</h3><p>定义在函数体之外，用于修饰全局变量，表示该变量只在本文件可见。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;  <span class="comment">//note:3</span></span><br><span class="line"><span class="comment">//int i = 1;  //note:4</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i += <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上我们就可以得出静态全局变量的特点：</p>
<p>静态全局变量不能被其它文件所用(全局变量可以);<br>其它文件中可以定义相同名字的变量，不会发生冲突(自然了，因为static隔离了文件，其它文件使用相同的名字的变量，也跟它没关系了);</p>
<h3 id="2-3-修饰函数"><a href="#2-3-修饰函数" class="headerlink" title="2.3 修饰函数"></a>2.3 修饰函数</h3><p>表明该函数只在同一文件中调用。</p>
<p>其它文件中可以定义相同名字的函数，不会发生冲突;</p>
<h2 id="3-函数引用"><a href="#3-函数引用" class="headerlink" title="3.函数引用"></a>3.函数引用</h2><p>当函数的形参为引用类型时，对形参的修改会影响实参的值。使用引用的作用：避免拷贝、让函数返回额外信息。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> &amp;x,&amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x = <span class="number">10</span>;y = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) <span class="keyword">return</span> x; <span class="comment">// 修改形参会影响实参的值</span></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max(a,b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// input:3 4</span></span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment">20</span></span><br><span class="line"><span class="comment">10 20</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="4-函数的参数"><a href="#4-函数的参数" class="headerlink" title="4.函数的参数"></a>4.函数的参数</h2><h3 id="4-1-数组参数"><a href="#4-1-数组参数" class="headerlink" title="4.1 数组参数"></a>4.1 数组参数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明、定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> a[])</span> <span class="comment">// 一维数组可省略</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> a[][<span class="number">4</span>])</span> <span class="comment">// 二维数组可省略第一个参数，第二个不可以</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> a[][<span class="number">4</span>][<span class="number">3</span>][<span class="number">4</span>])</span> <span class="comment">// 多维数组可省略第一个参数，后面的多不可以</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 调用函数</span></span></span><br><span class="line"><span class="function"><span class="title">output</span><span class="params">(a)</span></span>; <span class="comment">// 注意不要写成a[]或a[][4]这种形式</span></span><br></pre></td></tr></table></figure>

<p>数组的传递是引用传递，对形参的修改会影响实参的值。</p>
<h3 id="4-2-默认参数"><a href="#4-2-默认参数" class="headerlink" title="4.2 默认参数"></a>4.2 默认参数</h3><p>默认参数只能放在位置参数的后面，允许有多个默认参数和全部是默认参数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo(<span class="number">5</span>);<span class="comment">// 不加参数则执行默认参数</span></span><br><span class="line">    foo(<span class="number">5</span>,<span class="number">3</span>);<span class="comment">// 加了参数则按照加的参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment">5 10</span></span><br><span class="line"><span class="comment">5 3*/</span></span><br></pre></td></tr></table></figure>

<h2 id="5-acwing-817-数组去重"><a href="#5-acwing-817-数组去重" class="headerlink" title="5.acwing.817.数组去重"></a>5.acwing.817.数组去重</h2><p>给定一个长度为n的数组a，请你编写一个函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_unique_count</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>;  <span class="comment">// 返回数组前n个数中的不同数的个数</span></span><br></pre></td></tr></table></figure>

<p>输入格式</p>
<p>第一行包含一个整数n。</p>
<p>第二行包含n个整数，表示数组a。</p>
<p>输出格式</p>
<p>共一行，包含一个整数表示数组中不同数的个数。</p>
<p>数据范围</p>
<p>1≤n≤1000</p>
<p>输入样例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我的暴力做法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1001</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_unique_count</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[a[i]] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i]) cnt ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> a[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; get_unique_count(a,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unique</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> is_exist = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (a[j] == a[i])</span><br><span class="line">            &#123;</span><br><span class="line">                is_exist = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (!is_exist) cnt ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; unique(a, n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/activity/content/code/content/275258/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h2 id="6-acwing-818-数组排序"><a href="#6-acwing-818-数组排序" class="headerlink" title="6.acwing.818.数组排序"></a>6.acwing.818.数组排序</h2><p>给定一个长度为n的数组a以及两个整数 l 和 r，请你编写一个函数，<code>void sort(int a[], int l, int r)</code>，将a[l] ~ a[r]从小到大排序。</p>
<p>输出排好序的数组a。</p>
<p>输入格式<br>第一行包含三个整数n，l，r。</p>
<p>第二行包含n个整数，表示数组a。</p>
<p>输出格式<br>共一行，包含n个整数，表示排序完成后的数组a。</p>
<p>数据范围<br>0≤l≤r&lt;n≤1000<br>输入样例：<br>5 2 4<br>4 5 1 3 2<br>输出样例：<br>4 5 1 2 3</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// select sort,最简单的排序，y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l;i &lt;= r;i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt;= r;j ++)</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[i]) swap(a[j],a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,l,r;<span class="keyword">int</span> a[<span class="number">1001</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    sort(a,l,r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// bubble sort,参考的这位dalao的做法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l;i &lt; r;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = l;j &lt; r -i + l;j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t = a[j];</span><br><span class="line">                a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,l,r;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">1001</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;n;i ++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    sort(a,l,r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">作者：Struggle</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/13638/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h2 id="7-acwing-821-跳台阶"><a href="#7-acwing-821-跳台阶" class="headerlink" title="7.acwing.821.跳台阶"></a>7.acwing.821.跳台阶</h2><p>这题并不难，只是没有认真思考。</p>
<p><strong>蓝鲸dalao题解</strong></p>
<p>题目描述<br>一个楼梯共有n级台阶，每次可以走一级或者两级，问从第0级台阶走到第n级台阶一共有多少种方案。</p>
<p>输入格式<br>共一行，包含一个整数n。</p>
<p>输出格式<br>共一行，包含一个整数，表示方案数。</p>
<p>数据范围<br>1≤n≤15</p>
<p>样例<br>输入样例：<br>5<br>输出样例：<br>8<br>解题思路<br>先自己手动列举一下，</p>
<table>
<thead>
<tr>
<th>台阶/级</th>
<th>步数/步</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>5</td>
<td>8</td>
</tr>
<tr>
<td>6</td>
<td>13</td>
</tr>
</tbody></table>
<p>根据以上列举，不难发现，这TM就是一斐波那契数列！</p>
<p><strong>算法1</strong><br>递归<br>说人话就是到这一级的步数等于到上一级的方案数和上上级的方案数，<br>而第一级台阶方案数为1，第二级台阶方案数为2，后面的步骤就是有手就行了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">C++ 代码</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dg</span><span class="params">(<span class="keyword">int</span> dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep == <span class="number">1</span>)  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (dep == <span class="number">2</span>)  <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">//终止条件</span></span><br><span class="line">    <span class="keyword">return</span> dg(dep - <span class="number">1</span>) + dg(dep - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dg(n)); <span class="comment">//用递归</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法2</strong><br>for循环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">C++代码</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">15</span>; i++) <span class="comment">//不要管他丫的，一共就15个，肝就对了</span></span><br><span class="line">        a[i] = a[i - <span class="number">1</span>] + a[i - <span class="number">2</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：蓝鲸</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/11022/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p><strong>y总题解</strong></p>
<p>先画出递归搜索树：（枚举n=5的所有情况）</p>
<p><img src="/posts/f62c90a7/image-20210207141503611.png" alt="image-20210207141503611"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == n) ans ++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        f(k + <span class="number">1</span>);</span><br><span class="line">        f(k + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    f(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-acwing-823-排列"><a href="#8-acwing-823-排列" class="headerlink" title="8.acwing.823.排列"></a>8.acwing.823.排列</h2><p><strong>有点难度！要逐步分析！用VScode单步调试分析，画递归搜索树分析！！！</strong></p>
<p>给定一个整数n，将数字1~n排成一排，将会有很多种排列方法。</p>
<p>现在，请你按照字典序将所有的排列方法输出。</p>
<p>输入格式</p>
<p>共一行，包含一个整数n。</p>
<p>输出格式</p>
<p>按字典序输出所有排列方案，每个方案占一行。</p>
<p>数据范围</p>
<p>1≤n≤9</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">2 1 3</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure>

<p>首先画出<strong>深度遍历搜索树</strong>！！！用到深度遍历的思想。</p>
<p><img src="/posts/f62c90a7/image-20210207183231960.png" alt="image-20210207183231960"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> nums[],<span class="keyword">bool</span> st[])</span><span class="comment">// u是填充的位数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="built_in">cout</span> &lt;&lt; nums[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">            <span class="keyword">if</span> (!st[i])</span><br><span class="line">            &#123;</span><br><span class="line">                st[i] = <span class="literal">true</span>;</span><br><span class="line">                nums[u] = i;</span><br><span class="line">                dfs(u + <span class="number">1</span>,nums,st);</span><br><span class="line">                st[i] = <span class="literal">false</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> nums[N];</span><br><span class="line">    <span class="keyword">bool</span> st[N] = &#123;<span class="number">0</span>&#125;;<span class="comment">// 初始化为false</span></span><br><span class="line">    dfs(<span class="number">1</span>,nums,st);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意：当输入输出比较多时，用scanf和printf会快很多</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>竞赛语法</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>C++竞赛语法总结（八）</title>
    <url>/posts/b64984a2.html</url>
    <content><![CDATA[<p>(续上文)</p>
<hr>
<h3 id="3-5-include-lt-set-gt"><a href="#3-5-include-lt-set-gt" class="headerlink" title="3.5 #include &lt;set&gt; "></a>3.5 <code>#include &lt;set&gt; </code></h3><p>头文件set主要包括set和multiset两个容器，分别是“有序集合”和“有序多重集合”，<strong>即前者的元素不能重复，而后者可以包含若干个相等的元素</strong>。set和multiset的内部实现是一棵红黑树，它们支持的函数基本相同。 </p>
<span id="more"></span>

<h4 id="3-5-1-声明"><a href="#3-5-1-声明" class="headerlink" title="3.5.1 声明"></a>3.5.1 声明</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rec</span>&#123;</span>…&#125;; <span class="built_in">set</span>&lt;rec&gt; s;   <span class="comment">// 结构体rec中必须定义小于号</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">double</span>&gt; s;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-2-size-empty-clear"><a href="#3-5-2-size-empty-clear" class="headerlink" title="3.5.2 size/empty/clear"></a>3.5.2 size/empty/clear</h4><p>​    与vector类似 </p>
<h4 id="3-5-3-迭代器"><a href="#3-5-3-迭代器" class="headerlink" title="3.5.3 迭代器"></a>3.5.3 迭代器</h4><p>set和multiset的迭代器称为“双向访问迭代器”，不*<em>支持“随机访问”，支持星号(</em>)解除引用，仅支持”++”和–“两个与算术相关的操作**。</p>
<p>设it是一个迭代器，例如<code>set&lt;int&gt;::iterator it;</code></p>
<p>若把<code>it++</code>，则it会指向“下一个”元素。这里的“下一个”元素是指在元素从小到大排序的结果中，排在it下一名的元素。同理，若把<code>it--</code>，则it将会指向排在“上一个”的元素。</p>
<h4 id="3-5-4-begin-end"><a href="#3-5-4-begin-end" class="headerlink" title="3.5.4 begin/end"></a>3.5.4 begin/end</h4><ul>
<li>返回集合的首、尾迭代器，时间复杂度均为O(1)。</li>
<li>s.begin() 是指向集合中最小元素的迭代器。</li>
<li>s.end() 是指向集合中最大元素的下一个位置的迭代器。<strong>换言之，就像vector一样，是一个“前闭后开”的形式</strong>。<strong>因此–s.end()是指向集合中最大元素的迭代器</strong>。</li>
</ul>
<h4 id="3-5-6-insert"><a href="#3-5-6-insert" class="headerlink" title="3.5.6 insert"></a>3.5.6 insert</h4><ul>
<li>s.insert(x)把一个元素x插入到集合s中，时间复杂度为O($logn$)。</li>
<li>在set中，若元素已存在，则不会重复插入该元素，对集合的状态无影响。</li>
</ul>
<h4 id="3-5-7-find"><a href="#3-5-7-find" class="headerlink" title="3.5.7 find"></a>3.5.7 find</h4><p>s.find(x) 在集合s中查找等于x的元素，并返回指向该元素的迭代器。若不存在，则返回s.end()。时间复杂度为O($logn$)。</p>
<h4 id="3-5-8-lower-bound-upper-bound"><a href="#3-5-8-lower-bound-upper-bound" class="headerlink" title="3.5.8 lower_bound/upper_bound"></a>3.5.8 lower_bound/upper_bound</h4><ul>
<li>这两个函数的用法与find类似，但查找的条件略有不同，时间复杂度为 O($logn$)。</li>
<li>s.lower_bound(x) 查找大于等于x的元素中最小的一个，并返回指向该元素的迭代器。</li>
<li>s.upper_bound(x) 查找大于x的元素中最小的一个，并返回指向该元素的迭代器。</li>
</ul>
<h4 id="3-5-9-erase"><a href="#3-5-9-erase" class="headerlink" title="3.5.9 erase"></a>3.5.9 erase</h4><ul>
<li>设it是一个迭代器，s.erase(it) 从s中删除迭代器it指向的元素，时间复杂度为O$logn$)</li>
<li>设x是一个元素，s.erase(x) 从s中删除所有等于x的元素，时间复杂度为O(k+$logn$)，其中k是被删除的元素个数。 </li>
</ul>
<h4 id="3-5-10-count"><a href="#3-5-10-count" class="headerlink" title="3.5.10 count"></a>3.5.10 count</h4><p>​       s.count(x) 返回集合s中等于x的元素个数，时间复杂度为 O(k +$logn$)，其中k为元素x的个数。</p>
<h4 id="3-5-11-实例"><a href="#3-5-11-实例" class="headerlink" title="3.5.11 实例"></a>3.5.11 实例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; a;<span class="comment">// 不能包含重复元素，否则会忽略操作</span></span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; b;<span class="comment">// 可以包含重复元素</span></span><br><span class="line">    <span class="comment">// set中需要作比较，所以必须重载</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Rec</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Rec&amp; t) <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x &lt; t.x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">set</span>&lt;Rec&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = a.begin();</span><br><span class="line">    it ++, it --;</span><br><span class="line">    ++ it, -- it;</span><br><span class="line">    a.end();</span><br><span class="line"></span><br><span class="line">    a.insert(x);</span><br><span class="line">    <span class="keyword">if</span> (a.find(x) == a.end()) <span class="comment">// 判断x在a中是否存在</span></span><br><span class="line">    a.lower_bound(x);<span class="comment">// 找到大于等于x的最小元素的迭代器</span></span><br><span class="line">    a.upper_bound(x);<span class="comment">// 找到大于x的最小元素的迭代器，很容易犯错</span></span><br><span class="line">    a.count(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-include-lt-map-gt"><a href="#3-6-include-lt-map-gt" class="headerlink" title="3.6 #include &lt;map&gt;"></a>3.6 <code>#include &lt;map&gt;</code></h3><p>map容器是一个键值对key-value的映射，其内部实现是一棵以key为关键码的红黑树。Map的key和value可以是任意类型，其中key必须定义小于号运算符。</p>
<h4 id="3-6-1-声明"><a href="#3-6-1-声明" class="headerlink" title="3.6.1 声明"></a>3.6.1 声明</h4><p>​       <code>map&lt;key_type, value_type&gt; name;</code></p>
<p>​       例如：</p>
<p>​       <code>map&lt;long, long, bool&gt; vis;</code></p>
<p>​       <code>map&lt;string, int&gt; hash;</code></p>
<p>​       <code>map&lt;pair&lt;int, int&gt;, vector&lt;int&gt;&gt; test;</code></p>
<h4 id="3-6-2"><a href="#3-6-2" class="headerlink" title="3.6.2"></a>3.6.2</h4><p>​    size/empty/clear/begin/end均与set类似。 </p>
<h4 id="3-6-3-Insert-erase"><a href="#3-6-3-Insert-erase" class="headerlink" title="3.6.3 Insert/erase"></a>3.6.3 Insert/erase</h4><p>​       与set类似，但其参数均是<code>pair&lt;key_type, value_type&gt;</code>。</p>
<h4 id="3-6-4-find"><a href="#3-6-4-find" class="headerlink" title="3.6.4 find"></a>3.6.4 find</h4><p>​       h.find(x) 在变量名为h的map中查找key为x的二元组。</p>
<h4 id="3-6-5-操作符"><a href="#3-6-5-操作符" class="headerlink" title="3.6.5  []操作符"></a>3.6.5  []操作符</h4><p>​       h[key] 返回key映射的value的引用，时间复杂度为O(logn)。</p>
<p>[]操作符是map最吸引人的地方。我们可以很方便地通过h[key]来得到key对应的value，还可以对h[key]进行赋值操作，改变key对应的value。</p>
<h4 id="3-6-6-实例"><a href="#3-6-6-实例" class="headerlink" title="3.6.6 实例"></a>3.6.6 实例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; a;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">10000</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[<span class="number">10000</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; b,c;</span><br><span class="line">    b[<span class="string">&quot;yxc&quot;</span>] = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    c[<span class="string">&quot;llx&quot;</span>] = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b[<span class="string">&quot;yxc&quot;</span>].size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c[<span class="string">&quot;llx&quot;</span>][<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    b.insert(&#123;<span class="string">&quot;as&quot;</span>,&#123;&#125;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">&quot;as&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (b.find(str) == b.end()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-7-补充的几个STL"><a href="#3-7-补充的几个STL" class="headerlink" title="3.7 补充的几个STL"></a>3.7 补充的几个STL</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; S;<span class="comment">// 底层由哈希表实现，不能存储重复元素</span></span><br><span class="line">    <span class="comment">/* 与set的区别：</span></span><br><span class="line"><span class="comment">    1.比set少了lower_bound/upper_bound，因为是无序的</span></span><br><span class="line"><span class="comment">    2.主要操作复杂度是O(1)，而set是O(logn)，相对效率更高</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">unordered_multiset</span>&lt;<span class="keyword">int</span>&gt; b;<span class="comment">// 可以存储重复元素</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; c;<span class="comment">// 哈希表，与map几乎完全一样</span></span><br><span class="line">    <span class="comment">// 效率更高，都是O(1)，而map是O(logn)，但不支持二分</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bitset</span>&lt;1000&gt; a,t;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    a.<span class="built_in">set</span>(<span class="number">3</span>);<span class="comment">// 把a[3]设为1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[<span class="number">3</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    a.reset(<span class="number">3</span>);<span class="comment">// 把a[3]设为0</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[<span class="number">3</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-8-二元组-pair"><a href="#3-8-二元组-pair" class="headerlink" title="3.8 二元组(pair)"></a>3.8 二元组(pair)</h3><p>pair是将2个数据组合成一组数据，当需要这样的需求时就可以使用pair，如stl中的map就是将key和value放在一起来保存。另一个应用是，当一个函数需要返回2个数据的时候，可以选择pair。 </p>
<p>pair的实现是一个结构体，主要的两个成员变量是first second 因为是使用struct不是class，所以可以直接使用pair的成员变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt; a,b;</span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p;</span><br><span class="line">    a = &#123;<span class="number">3</span>,<span class="string">&quot;yxc&quot;</span>&#125;;<span class="comment">// C++99不支持这种赋值</span></span><br><span class="line">    a = <span class="built_in">make_pair</span>(<span class="number">4</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// pair支持a &gt;= b,a &lt;= b,a == b,a != b等比较运算</span></span><br><span class="line">    <span class="comment">// 先比较first，再比较second</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c,d;</span><br><span class="line">    <span class="comment">// if(c == d)，vector也支持按字典序进行比较，先比较数组第一个位置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-位运算与常见库函数"><a href="#4-位运算与常见库函数" class="headerlink" title="4.位运算与常见库函数"></a>4.位运算与常见库函数</h2><p>C++帮我们实现好了很多有用的函数，我们要避免重复造轮子。                                                               ——yxc</p>
<h3 id="4-1-位运算"><a href="#4-1-位运算" class="headerlink" title="4.1 位运算"></a>4.1 位运算</h3><p>其实是数学上的概念。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>运算</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>与(AND)</td>
</tr>
<tr>
<td>|</td>
<td>或(OR)</td>
</tr>
<tr>
<td><strong>~</strong></td>
<td>非(NOT)</td>
</tr>
<tr>
<td>^</td>
<td>异或(XOR)（不进位的加）</td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>右移</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>左移</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>&amp;<span class="number">0</span> = <span class="number">0</span>, <span class="number">0</span>&amp;<span class="number">1</span> = <span class="number">0</span>, <span class="number">1</span>&amp;<span class="number">0</span> = <span class="number">0</span>, <span class="number">1</span>&amp;<span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0</span>|<span class="number">0</span> = <span class="number">0</span>, <span class="number">1</span>|<span class="number">0</span> = <span class="number">1</span>, <span class="number">0</span>|<span class="number">1</span> = <span class="number">1</span>, <span class="number">1</span>|<span class="number">1</span> = <span class="number">1</span></span><br><span class="line">~<span class="number">0</span> = <span class="number">1</span>, ~<span class="number">1</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span>^<span class="number">0</span> = <span class="number">0</span>, <span class="number">1</span>^<span class="number">1</span> = <span class="number">0</span>, <span class="number">1</span>^<span class="number">0</span> = <span class="number">1</span>, <span class="number">0</span>^<span class="number">1</span> = <span class="number">1</span> </span><br></pre></td></tr></table></figure>

<p>总之,在C中,左移是逻辑/算术左移(两者完全相同),右移是算术右移,会保持符号位不变.实际应用中可以根据情况用左/右移做快速的乘/除运算,这样会比循环效率高很多.</p>
<p><strong>常用操作：</strong></p>
<p>(1)  <strong>求x的第k位数字 x &gt;&gt; k &amp; 1</strong></p>
<p>(2)  <strong>lowbit(x) = x &amp; -x=x &amp; (~x + 1)，返回x的最后一位1及以后的数</strong></p>
<p>比如12（10）二进制表示为 1100（2），<code>lowbit(12) == 100（2）== 4（10）</code>。</p>
<p>(3) 我们可以直观的发现，如果是一个偶数^1,那么答案是偶数+1.如果是一个奇数^1,那么答案是奇数-1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>,b = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (a^b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    a = <span class="number">13</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (a &gt;&gt; <span class="number">2</span> &amp; <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>;i &gt;= <span class="number">0</span>;i --) <span class="built_in">cout</span> &lt;&lt; (a &gt;&gt; i &amp; <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">2345256</span>;</span><br><span class="line">    <span class="keyword">int</span> d = -c;</span><br><span class="line">    <span class="keyword">int</span> e = ~c + <span class="number">1</span>;<span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-acwing-67-数字在排序数组中出现的次数"><a href="#5-acwing-67-数字在排序数组中出现的次数" class="headerlink" title="5.acwing.67.数字在排序数组中出现的次数"></a>5.acwing.67.数字在排序数组中出现的次数</h2><p>题目描述<br>求一个排好序的数组中k的个数。例如输入排序数组[1, 2, 3, 3, 3, 3, 4, 5]和数字3，由于3在这个数组中出现了4次，因此输出4。</p>
<p>解题思路<br>目的是练习stl和常用的库函数</p>
<h3 id="题解一："><a href="#题解一：" class="headerlink" title="题解一："></a>题解一：</h3><p>使用有序多重集合multiset</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : nums) s.insert(x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.count(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="题解二："><a href="#题解二：" class="headerlink" title="题解二："></a>题解二：</h3><p>遍历vector，计数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : nums)</span><br><span class="line">            <span class="keyword">if</span>(x == k)</span><br><span class="line">                cnt++;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="题解三："><a href="#题解三：" class="headerlink" title="题解三："></a>题解三：</h3><p>二分做法，使用lower_bound和upper_bound,指针运算得出次数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> l = lower_bound(nums.begin(), nums.end(), k);<span class="comment">//第一个大于等于x的数的地址</span></span><br><span class="line">        <span class="keyword">auto</span> r = upper_bound(nums.begin(), nums.end(), k);<span class="comment">//第一个大于x的数的地址</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> r - l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>作者：醉生梦死<br>链接：<a href="https://www.acwing.com/solution/content/16094/">https://www.acwing.com/solution/content/16094/</a><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="关于vector中的lower-bound和upper-bound"><a href="#关于vector中的lower-bound和upper-bound" class="headerlink" title="关于vector中的lower_bound和upper_bound"></a>关于vector中的lower_bound和upper_bound</h3><h4 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h4><p>比较的“首”地址+ 一个数组元素的地址（对应的这个数组里边任意一个元素的地址，表示这个二分里边的比较的”结尾’地址）+ 你要二分查找的那个数。</p>
<p>一个数组元素的地址（或者数组名来表示这个数组的首地址，用来表示这个数组的开头比较的元素的地址，不一定要是首地址，只是用于比较的“首”地址）+ 一个数组元素的地址（对应的这个数组里边任意一个元素的地址，表示这个二分里边的比较的”结尾’地址）+ 你要二分查找的那个数。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lower_bound(r[x].begin(),r[x].end(),l)</span><br><span class="line">upper_bound(r[x].begin(),r[x].end(),R)</span><br></pre></td></tr></table></figure>

<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p><strong>lower_bound</strong></p>
<p><strong>返回第一个大于等于x的数的地址</strong></p>
<p><strong>upper_bound</strong></p>
<p><strong>返回第一个大于x的数的地址</strong></p>
<h2 id="6-acwing-68-数组中唯一只出现一次的数字"><a href="#6-acwing-68-数组中唯一只出现一次的数字" class="headerlink" title="6.acwing.68.数组中唯一只出现一次的数字"></a>6.acwing.68.数组中唯一只出现一次的数字</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1，我的题解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMissingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; nums.size();i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>  (nums[i] != i) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// solution 2，y总题解，利用哈希表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMissingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i &lt;= nums.size();i ++) S.insert(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x :nums) S.erase(x);</span><br><span class="line">        <span class="keyword">return</span> *S.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="7-acwing-32-调整数组顺序使奇数位于偶数前面"><a href="#7-acwing-32-调整数组顺序使奇数位于偶数前面" class="headerlink" title="7.acwing.32. 调整数组顺序使奇数位于偶数前面"></a>7.acwing.32. 调整数组顺序使奇数位于偶数前面</h2><p>主要是不会交换vector元素的位置。思路还是知道的（双指针）。不要用迭代器做！</p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序。</p>
<p>使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分。</p>
<p>样例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p><strong>算法</strong><br><strong>(双指针扫描) O(n)</strong><br>用两个指针分别从首尾开始，往中间扫描。扫描时保证第一个指针前面的数都是奇数，第二个指针后面的数都是偶数。</p>
<p>每次迭代时需要进行的操作：</p>
<p>第一个指针一直往后走，直到遇到第一个偶数为止；<br>第二个指针一直往前走，直到遇到第一个奇数为止；<br>交换两个指针指向的位置上的数，再进入下一层迭代，直到两个指针相遇为止；<br><strong>时间复杂度</strong><br>当两个指针相遇时，走过的总路程长度是 n，所以时间复杂度是 $O(n)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="built_in">array</span>.size() - <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">             <span class="keyword">while</span> (l &lt; r &amp;&amp; <span class="built_in">array</span>[l] % <span class="number">2</span> == <span class="number">1</span>) l ++ ;</span><br><span class="line">             <span class="keyword">while</span> (l &lt; r &amp;&amp; <span class="built_in">array</span>[r] % <span class="number">2</span> == <span class="number">0</span>) r -- ;</span><br><span class="line">             <span class="keyword">if</span> (l &lt; r) swap(<span class="built_in">array</span>[l], <span class="built_in">array</span>[r]);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="8-acwing-17-从尾到头打印链表"><a href="#8-acwing-17-从尾到头打印链表" class="headerlink" title="8.acwing.17.从尾到头打印链表"></a>8.acwing.17.从尾到头打印链表</h2><p>输入一个链表的头结点，按照 <strong>从尾到头</strong> 的顺序返回节点的值。</p>
<p>返回的结果用数组存储。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1，我的题解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printListReversingly</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">        <span class="keyword">for</span> (ListNode* p = head;p != <span class="literal">NULL</span>;p = p-&gt;next) a.push_back(p-&gt;val);</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>,k = a.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; k)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(a[j],a[k]);</span><br><span class="line">            j++,k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// solution 2,递归 vector 打印</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printListReversingly</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span> vi;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            vi =printListReversingly(head-&gt;next);</span><br><span class="line">            vi.push_back(head-&gt;val);</span><br><span class="line">            <span class="keyword">return</span> vi;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">作者：雪山肥鱼</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/9900/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class="line"><span class="comment">// solution 3,y总题解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printListReversingly</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.push_back(head-&gt;val);</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(temp.begin(),temp.end());<span class="comment">// reverse vector</span></span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>竞赛语法</tag>
        <tag>位运算</tag>
        <tag>库函数</tag>
      </tags>
  </entry>
  <entry>
    <title>C++竞赛语法总结（六）</title>
    <url>/posts/9322db7e.html</url>
    <content><![CDATA[<p>类可以将变量、数组和函数完美地打包在一起。</p>
<p>​                                                            ——yxc</p>
<h2 id="1-类"><a href="#1-类" class="headerlink" title="1.类"></a>1.类</h2><p>类中的变量和函数被统一称为类的成员变量。</p>
<p>private后面的内容是私有成员变量，在类的外部不能访问；public后面的内容是公有成员变量，在类的外部可以访问。</p>
<span id="more"></span>

<h2 id="2-结构体与类的唯一区别"><a href="#2-结构体与类的唯一区别" class="headerlink" title="2.结构体与类的唯一区别"></a>2.结构体与类的唯一区别</h2><p>结构体和类的作用是一样的。不同点在于类默认是private，结构体默认是public。</p>
<p>习惯上把结构较为简单的函数较少的代码定义成<strong>结构体</strong>，较为复杂的麻烦的代码定义成<strong>类</strong>。</p>
<p>成员变量在<strong>使用初始化列表</strong>初始化时，与构造函数中初始化成员列表的<strong>顺序无关</strong>，只与定义成员变量的顺序有关。因为成员变量的初始化次序是根据变量在内存中次序有关，而内存中的排列顺序早在编译期就根据变量的定义次序决定了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> age,height;</span><br><span class="line">        <span class="keyword">double</span> money;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, &quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">get_age</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add_money</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            money += x;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">string</span> books[<span class="number">100</span>];</span><br><span class="line">&#125;d,Persons[<span class="number">100</span>]; <span class="comment">//! 一定记得加分号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person C;</span><br><span class="line">    Person Per[<span class="number">120</span>];</span><br><span class="line">    C.name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">    <span class="comment">//C.age = 18;// 私有成员不可访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age,height;<span class="comment">// 不加默认是public</span></span><br><span class="line">    <span class="keyword">double</span> money;</span><br><span class="line">    Person ()&#123;&#125;</span><br><span class="line">    Person(<span class="keyword">int</span> _age,<span class="keyword">int</span> _height):age(_age),height(_height) &#123;&#125;</span><br><span class="line">    Person(<span class="keyword">int</span> _age,<span class="keyword">int</span> _height,<span class="keyword">double</span> _money):age(_age),height(_height),money(_money) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Person b;<span class="comment">// 定义在函数体外默认初始化为0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p ;</span><br><span class="line">    Person c = &#123;<span class="number">18</span>,<span class="number">180</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p.money &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b.money &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c.money &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 一些编译器输出0，一些输出随机值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7.90505e-323 随机值</span></span><br><span class="line"><span class="comment">0 默认初始化为0</span></span><br><span class="line"><span class="comment">1.43279e-322 随机值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译器关于构造函数使用与变量初始化相同的规则来初始化数据成员。对象a在函数体外定义，其int、double类型数据成员被初始为0；对象b在函数体内定义，构造函数不会对其进行初始化（符合内置类型变量初始化规则），其中存放的都是随机值。</p>
<h2 id="3-指针与引用-回顾指针的用法"><a href="#3-指针与引用-回顾指针的用法" class="headerlink" title="3.指针与引用(回顾指针的用法)"></a>3.指针与引用(回顾指针的用法)</h2><h3 id="指针即地址"><a href="#指针即地址" class="headerlink" title="指针即地址"></a><strong>指针即地址</strong></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> a,b;<span class="comment">// 堆空间，地址从小到大</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>,d;<span class="comment">// 栈空间，地址从大到小</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0x407030</span></span><br><span class="line"><span class="comment">0x407031</span></span><br><span class="line"><span class="comment">0x61fe1f</span></span><br><span class="line"><span class="comment">0x61fe1e</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span>* p = &amp;a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;before:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    *p = <span class="number">12</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;after:&quot;</span> &lt;&lt; a &lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">before:10 10</span></span><br><span class="line"><span class="comment">after:12 12</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>指针指向存放变量的值的地址。因此我们可以通过指针来修改变量的值。</p>
<p>这类似于我们通过数组下标来修改数组中的值。</p>
<p>数组名是一种特殊的指针。指针可以做运算：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i ++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;a[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0x61fe00</span></span><br><span class="line"><span class="comment">0x61fe00</span></span><br><span class="line"><span class="comment">0x61fe04</span></span><br><span class="line"><span class="comment">0x61fe08</span></span><br><span class="line"><span class="comment">0x61fe0c</span></span><br><span class="line"><span class="comment">0x61fe10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* p = a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *(p + <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0x61fe00</span></span><br><span class="line"><span class="comment">0x61fe04</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a><strong>引用</strong></h3><p>引用和指针类似，相当于给变量起了个别名。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span>* p = &amp;a;</span><br><span class="line">    <span class="keyword">int</span>&amp; p = a;<span class="comment">// C++的简化写法，引用（别名）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-链表"><a href="#4-链表" class="headerlink" title="4.链表"></a>4.链表</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node* next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> _val) : val(_val),next(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node node = Node(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 写法一，定义Node型变量，值是1</span></span><br><span class="line">    Node* p = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 写法二，定义Node型变量，返回值是Node的地址，p是指针</span></span><br><span class="line">    <span class="comment">// new Node(1);返回的是Node*</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如图：</p>
<p><img src="/posts/9322db7e/image-20210208135341530.png" alt="image-20210208135341530"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node* next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> _val) : val(_val),next(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> q = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">auto</span> o = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    p-&gt;next = q;</span><br><span class="line">    q-&gt;next = o;<span class="comment">// 构造链表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历单链表</span></span><br><span class="line">    Node* head = p;<span class="comment">// 头结点存放第一个结点的地址，也即头结点指向第一个结点</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;before:\t&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node* i = head;i;i = i-&gt;next) <span class="comment">// 循环结束条件等价于i != NULL </span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 头插法添加结点</span></span><br><span class="line">    Node* u = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">    u-&gt;next = head;</span><br><span class="line">    head = u;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;after:\t&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node* i = head;i;i = i-&gt;next) <span class="comment">// 循环结束条件等价于i != NULL </span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//删除结点</span></span><br><span class="line">    head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment">before: </span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">after:</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>链表的头结点（head）：<strong>大部分情况下指的是第一个结点的地址。而不是它的值</strong>。记牢！</p>
<p><img src="/posts/9322db7e/image-20210208143505731.png" alt="image-20210208143505731"></p>
<h2 id="5-acwing-21-斐波那契数列"><a href="#5-acwing-21-斐波那契数列" class="headerlink" title="5.acwing.21.斐波那契数列"></a>5.acwing.21.斐波那契数列</h2><p>输入一个整数 n ，求斐波那契数列的第 n 项。</p>
<p>假定从0开始，第0项为0。(n&lt;=39)（0,1,1,2，…)</p>
<p>样例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入整数 n&#x3D;5 </span><br><span class="line"></span><br><span class="line">返回 5</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>) + Fibonacci(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="6-acwing-84-求1-2-3-…-n"><a href="#6-acwing-84-求1-2-3-…-n" class="headerlink" title="6.acwing.84.求1 + 2 + 3 + … + n"></a>6.acwing.84.求1 + 2 + 3 + … + n</h2><p>求1+2+…+n,要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1,y总题解，利用短路</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> res = n;</span><br><span class="line">            n &gt; <span class="number">0</span> &amp;&amp; (res += getSum(n<span class="number">-1</span>));<span class="comment">//利用短路运算终止递归，因为不能用if</span></span><br><span class="line">            <span class="comment">// 如果改成n &gt;= 0则到getSum(-1)才停止，比真实值少1</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// solution 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a[n][n+<span class="number">1</span>]; <span class="comment">// 变相求前n项和</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">sizeof</span>(a)&gt;&gt;<span class="number">1</span>;<span class="comment">// &gt;&gt;1 右移相当于除以2，因为不能用除法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="7-acwing-87-把字符串转换成整数"><a href="#7-acwing-87-把字符串转换成整数" class="headerlink" title="7.acwing.87.把字符串转换成整数"></a>7.acwing.87.把字符串转换成整数</h2><p>请你写一个函数StrToInt，实现把字符串转换成整数这个功能。</p>
<p>当然，不能使用atoi或者其他类似的库函数。</p>
<p>样例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;123&quot;</span><br><span class="line"></span><br><span class="line">输出：123</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>:</p>
<p>你的函数应满足下列条件：</p>
<ol>
<li>忽略所有行首空格，找到第一个非空格字符，可以是 ‘+/−’ 表示是正数或者负数，紧随其后找到最长的一串连续数字，将其解析成一个整数；</li>
<li>整数后可能有任意非数字字符，请将其忽略；</li>
<li>如果整数长度为0，则返回0；</li>
<li>如果整数大于INT_MAX(2^31 − 1)，请返回INT_MAX；如果整数小于INT_MIN(−2^31) ，请返回INT_MIN；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1,我的题解，非常复杂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">0</span>;<span class="keyword">long</span> <span class="keyword">long</span> n = <span class="number">0</span>;<span class="keyword">int</span> num[<span class="number">40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> &amp;c:str)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> ) &#123;sign = <span class="number">1</span>;<span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) &#123;sign = <span class="number">-1</span>;<span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sign != <span class="number">0</span>|| (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                    &#123;num[i] = c <span class="number">-48</span>;i ++;&#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c != <span class="string">&#x27; &#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; !sign) sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            n += (<span class="keyword">long</span> <span class="keyword">long</span>)num[j]*<span class="built_in">pow</span>(<span class="number">10</span>,i<span class="number">-1</span>-j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sign *n &gt; <span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>)<span class="number">-1</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sign *n &lt; <span class="number">-1</span>*<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>)) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> sign * n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// solution 2,y总题解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; str.size() &amp;&amp; str[k] == <span class="string">&#x27; &#x27;</span>) k ++;<span class="comment">// 过滤空格</span></span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> minus = <span class="number">1</span>;<span class="comment">// 符号位</span></span><br><span class="line">            <span class="keyword">if</span> (k &lt; str.size())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (str[k] == <span class="string">&#x27;-&#x27;</span>) &#123;minus = <span class="number">-1</span>;k ++;&#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (str[k] == <span class="string">&#x27;+&#x27;</span>) k ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; str.size() &amp;&amp; str[k] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; str[k] &gt;= <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res = res * <span class="number">10</span> + str[k] - <span class="string">&#x27;0&#x27;</span>;<span class="comment">// 这个思路特别好，可以不用数组存放</span></span><br><span class="line">                <span class="keyword">if</span> (res &gt; <span class="number">1e11</span>) <span class="keyword">break</span>;<span class="comment">// 数据太大就直接跳出来</span></span><br><span class="line">                k ++;</span><br><span class="line">            &#125;</span><br><span class="line">            res *= minus;</span><br><span class="line">            <span class="keyword">if</span> (res &gt; INT_MAX) res = INT_MAX;</span><br><span class="line">            <span class="keyword">if</span> (res &lt; INT_MIN) res = INT_MIN;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="8-acWing-28-在O-1-时间删除链表结点"><a href="#8-acWing-28-在O-1-时间删除链表结点" class="headerlink" title="8.acWing 28. 在O(1)时间删除链表结点"></a>8.acWing 28. 在O(1)时间删除链表结点</h2><p><u>tips：链表题多画图，方便思考，空想还是有难度的！</u></p>
<p>给定单向链表的一个节点指针，定义一个函数在O(1)时间删除该结点。</p>
<p>假设链表一定存在，并且该节点一定不是尾节点。</p>
<p>样例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：链表 <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">6</span>-&gt;<span class="number">8</span></span><br><span class="line">      删掉节点：第<span class="number">2</span>个节点即<span class="number">6</span>（头节点为第<span class="number">0</span>个节点）</span><br><span class="line"></span><br><span class="line">输出：新链表 <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">8</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1,y总题解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;<span class="comment">// 将待删除结点伪装成它的下一个结点</span></span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;<span class="comment">// 删除它的后一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// solution 2,y总题解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        *(node) = *(node-&gt;next);<span class="comment">// 结构体整体赋值，相当于往前推进一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="9-acwing-36-合并两个排序的链表"><a href="#9-acwing-36-合并两个排序的链表" class="headerlink" title="9.acwing.36.合并两个排序的链表"></a>9.acwing.36.合并两个排序的链表</h2><p>输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。</p>
<p>样例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;3-&gt;5 , 2-&gt;4-&gt;5</span><br><span class="line"></span><br><span class="line">输出：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;5</span><br></pre></td></tr></table></figure>

<p><strong>算法：(二路归并) O(n)</strong><br>    新建头部的保护结点dummy，设置cur指针指向dummy。<br>若当前l1指针指向的结点的值val比l2指针指向的结点的值val小，则令cur的next指针指向l1，且l1后移；否则指向l2，且l2后移。<br>    然后cur指针按照上一部设置好的位置后移。<br>    循环以上步骤直到l1或l2为空。<br>    将剩余的l1或l2接到cur指针后边。<br><strong>时间复杂度</strong><br>两个链表各遍历一次，所以时间复杂度为O(n)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1 -&gt; val &lt; l2 -&gt; val) &#123;</span><br><span class="line">                cur -&gt; next = l1;</span><br><span class="line">                l1 = l1 -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cur -&gt; next = l2;</span><br><span class="line">                l2 = l2 -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur -&gt; next = (l1 != <span class="literal">NULL</span> ? l1 : l2);</span><br><span class="line">        <span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="10-acwing-35-反转链表"><a href="#10-acwing-35-反转链表" class="headerlink" title="10.acwing.35.反转链表"></a>10.acwing.35.反转链表</h2><p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。</p>
<p><strong>思考题：</strong></p>
<ul>
<li>请同时实现迭代版本和递归版本。</li>
</ul>
<p>样例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line"></span><br><span class="line">输出:5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<p>作者：yxc<br>        链接：<a href="https://www.acwing.com/solution/content/743/">https://www.acwing.com/solution/content/743/</a><br>        来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p><strong>算法1：(链表操作，迭代) O(n)</strong></p>
<p>迭代也就是循环的意思。</p>
<p>翻转即将所有节点的next指针指向前驱节点。<br>由于是单链表，我们在迭代时不能直接找到前驱节点，所以我们需要一个额外的指针保存前驱节点。同时在改变当前节点的next指针前，不要忘记保存它的后继节点。</p>
<ul>
<li>空间复杂度分析：遍历时只有3个额外变量，所以额外的空间复杂度是 O(1)。</li>
<li>时间复杂度分析：只遍历一次链表，时间复杂度是 O(n)。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        ListNode* q = p-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (q)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* o = q-&gt;next;</span><br><span class="line">            q-&gt;next = p;</span><br><span class="line">            p = q,q = o;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;<span class="comment">// 一定注意这里不能忘</span></span><br><span class="line">        <span class="comment">// nullptr和0，NULL等价</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// solution 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">            ListNode *prev = <span class="literal">nullptr</span>;<span class="comment">// 这里不用考虑上面的初始头结点指空</span></span><br><span class="line">            ListNode *cur = head;</span><br><span class="line">            <span class="keyword">while</span> (cur)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode *next = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = prev;</span><br><span class="line">                prev = cur, cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> prev;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>算法2:(链表操作，递归) O(n)</strong><br>首先我们先考虑 reverseList 函数能做什么，它可以翻转一个链表，并返回新链表的头节点，也就是原链表的尾节点。<br>所以我们可以先递归处理 <code>reverseList(head-&gt;next)</code>，这样我们可以将以<code>head-&gt;next</code>为头节点的链表翻转，并得到原链表的尾节点tail，此时<code>head-&gt;next</code>是新链表的尾节点，我们令它的next指针指向head，并将<code>head-&gt;next</code>指向空即可将整个链表翻转，<strong>且新链表的头节点是tail</strong>。</p>
<ul>
<li>空间复杂度分析：总共递归 n 层，系统栈的空间复杂度是 O(n)，所以总共需要额外 O(n) 的空间。</li>
<li>时间复杂度分析：链表中每个节点只被遍历一次，所以时间复杂度是 O(n)。</li>
</ul>
<p><img src="/posts/9322db7e/image-20210213200327031.png" alt="来自一位xjj的javascript讲解"></p>
<p><img src="/posts/9322db7e/image-20210213201614715.png" alt="image-20210213201614715"></p>
<p>​                                                      <strong>head是每一层函数的返回值res。</strong></p>
<p>讲解链接：<a href="https://www.bilibili.com/video/av83907207?t=1">https://www.bilibili.com/video/av83907207?t=1</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;<span class="comment">// 递归最小一层返回head</span></span><br><span class="line">            ListNode *tail = reverseList(head-&gt;next);</span><br><span class="line">            head-&gt;next-&gt;next = head;</span><br><span class="line">            head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> tail;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>竞赛语法</tag>
        <tag>链表</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>CLion配置使用教程</title>
    <url>/posts/9869850b.html</url>
    <content><![CDATA[<h2 id="CLion配置使用教程"><a href="#CLion配置使用教程" class="headerlink" title="CLion配置使用教程"></a>CLion配置使用教程</h2><p>参考下载安装教程：<a href="https://www.jb51.net/article/193508.htm">https://www.jb51.net/article/193508.htm</a></p>
<p>最好不要下载最新的，破解可能失效，然后跟着教程来就行了。</p>
<span id="more"></span>

<p>下面讲一下会遇到的问题（坑）：</p>
<p>配置MinGW时可能会出现如下警告。</p>
<p><img src="/posts/9869850b/image-20210418122025803.png" alt="image-20210418122025803"></p>
<p>我们点击More，可以看到类似下图的错误：</p>
<p><img src="/posts/9869850b/image-20210418122124086.png" alt="image-20210418122124086"></p>
<p>解决方案请参照<a href="https://zhuanlan.zhihu.com/p/43680621">这里</a></p>
<p>有的人内容可能不是完全一样（没有乱码，都是英文，其他一致）：如果上面的方案不行，再接着往下看</p>
<p>参照这篇<a href="https://www.pianshen.com/article/33861131114/">文章</a>，我花了大半天时间才找到这个非常有效的解决方案，我们根据提示，在D盘下新建一个CLion文件夹（或者你找别的路径也行），对照下图修改这四个部分。</p>
<p><img src="/posts/9869850b/image-20210418122720065.png" alt="image-20210418122720065"></p>
<p>然后打开CLion，新建工程，点击 help – edit custom vm options</p>
<p>在后面加上一行 <code>-Djava.io.tmpdir=d:/CLion/Temp</code></p>
<p>这下再重新执行CMakelist就行了，运行main.cpp会顺利看到hello，world就成功了。</p>
<p>有人可能还会出现头文件下方红线提示找不到的情况，可能是因为你CMake的路径改成了下载的CMake了，</p>
<p>再按照下图改回MinGW默认的就不会报错了。</p>
<p><img src="/posts/9869850b/image-20210418123300435.png" alt="image-20210418123300435"></p>
<p>最后就可以放心的使用CLion了！</p>
<p><img src="/posts/9869850b/image-20210418123416782.png" alt="image-20210418123416782"></p>
<p><strong>补充关于CLion的多文件编译：</strong></p>
<p>CLion默认一个项目之下只能有一个带main函数的源文件。</p>
<p>我们可以通过修改CMakeList文件来分别编译一个项目下的多个带main函数的源文件。</p>
<p>参考自：<a href="https://zhuanlan.zhihu.com/p/124284203%E3%80%82">https://zhuanlan.zhihu.com/p/124284203。</a></p>
<p>这里我们采用安装插件的方式来实现，如果不能在CLion中在线下载安装插件，可以直接在官网中下载，然后通过本地安装插件。</p>
<p>官网插件下载链接：<a href="https://plugins.jetbrains.com/">https://plugins.jetbrains.com/</a></p>
<p><img src="/posts/9869850b/image-20210419133730396.png" alt="image-20210419133730396"></p>
<p>安装插件之后就可以编写代码了。</p>
<p>这里有两段测试程序，main.cpp和test.cpp。</p>
<p>分别在cpp文件下单击右键：</p>
<p><img src="/posts/9869850b/image-20210419133920525.png" alt="image-20210419133920525"></p>
<p>这时会发现CMakeList文件中多了一行代码add_executable(main main.cpp)。（其实可以不用插件手动添加）</p>
<p>要运行单个文件，只要选择对应的文件即可，然后点击’Run’按钮。</p>
<p><img src="/posts/9869850b/image-20210419134154418.png" alt="image-20210419134154418"></p>
<p>现在你已经成功掌握了CLion的基本用法了！</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>CLion</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML学习笔记（一）</title>
    <url>/posts/8b5222e1.html</url>
    <content><![CDATA[<h2 id="1-HTML简介"><a href="#1-HTML简介" class="headerlink" title="1.HTML简介"></a>1.HTML简介</h2><p><strong>超文本标记语言</strong>（Hyper Text Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。</p>
<p>2014年10月由<strong>万维网联盟</strong>（W3C）完成标准制定。</p>
<span id="more"></span>

<p>推荐实战训练巩固知识：<a href="https://www.w3cschool.cn/codecamp/list?pename=html5_and_css_camp">https://www.w3cschool.cn/codecamp/list?pename=html5_and_css_camp</a></p>
<p><img src="/posts/8b5222e1/image-20210504193312259.png" alt="image-20210504193312259"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第一个网页--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 告诉浏览器使用说明规范--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 显示内容必须包含在html标签之内--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--网页头部--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--meta描述性标签，描述网站信息--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--一般用来做SEO--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;一起学Java&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;来这里学Java&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--title网页标题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">hello,world!</span><br><span class="line"><span class="comment">&lt;!--body代表网页主题--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-网页基本标签"><a href="#2-网页基本标签" class="headerlink" title="2.网页基本标签"></a>2.网页基本标签</h2><p><img src="/posts/8b5222e1/image-20210504200453609.png" alt="image-20210504200453609"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>基本标签学习<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--标题标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>一级标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>二级标签<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>三级标签<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--段落标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是    一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这  还    是 一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--水平线标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--换行标签，间距比上面小，自闭合--&gt;</span></span><br><span class="line">这是    一个段落。<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">这  还    是 一个段落。<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--斜体与粗体--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>字体样式标签<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">粗体：<span class="tag">&lt;<span class="name">strong</span>&gt;</span>I love Java<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">斜体：<span class="tag">&lt;<span class="name">em</span>&gt;</span>I love C++<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>特殊符号<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--空    格，实际只有一个空格--&gt;</span></span><br><span class="line">空     格</span><br><span class="line">空<span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>格</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">大于号：<span class="symbol">&amp;gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">小于号：<span class="symbol">&amp;lt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">版权符号：<span class="symbol">&amp;copy;</span>版权所有</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;down&quot;</span>&gt;</span>底部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/8b5222e1/image-20210504201252485.png" alt="image-20210504201252485"></p>
<h3 id="图像标签"><a href="#图像标签" class="headerlink" title="图像标签"></a>图像标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>图像<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--img标签学习</span></span><br><span class="line"><span class="comment">src: 图片地址,相对（推荐使用）、绝对路径</span></span><br><span class="line"><span class="comment"> ../  上一级目录</span></span><br><span class="line"><span class="comment">alt: 图片名字</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">src和alt必填</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../resources/image/miku.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;初音未来&quot;</span> <span class="attr">title</span>=<span class="string">&quot;悬停文字&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;800&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="链接标签"><a href="#链接标签" class="headerlink" title="链接标签"></a>链接标签</h3><p><img src="/posts/8b5222e1/image-20210504202647535.png" alt="image-20210504202647535"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>链接<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--a标签</span></span><br><span class="line"><span class="comment">href : 必填，表示要跳转到哪个网页</span></span><br><span class="line"><span class="comment">target : 表示窗口在哪里打开</span></span><br><span class="line"><span class="comment"> _blank : 在新标签中打开链接</span></span><br><span class="line"><span class="comment"> _self : 在自己网页打开</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--使用name作为标记--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;top&quot;</span>&gt;</span>顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;图像.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>点击查看初音未来<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.w3cschool.cn/html5/html5-intro.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_self&quot;</span>&gt;</span>点击学习html<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--点击图像跳转--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.w3cschool.cn/html5/html5-intro.html&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../resources/image/miku.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;初音未来&quot;</span> <span class="attr">title</span>=<span class="string">&quot;悬停文字&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;800&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--文字填充--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">默认情况下，链接将以以下形式出现在浏览器中：</span><br><span class="line"></span><br><span class="line">一个未访问过的链接显示为蓝色字体并带有下划线。</span><br><span class="line">访问过的链接显示为紫色并带有下划线。</span><br><span class="line">点击链接时，链接显示为红色并带有下划线。</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">默认情况下，链接将以以下形式出现在浏览器中：</span><br><span class="line"></span><br><span class="line">一个未访问过的链接显示为蓝色字体并带有下划线。</span><br><span class="line">访问过的链接显示为紫色并带有下划线。</span><br><span class="line">点击链接时，链接显示为红色并带有下划线。</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">默认情况下，链接将以以下形式出现在浏览器中：</span><br><span class="line"></span><br><span class="line">一个未访问过的链接显示为蓝色字体并带有下划线。</span><br><span class="line">访问过的链接显示为紫色并带有下划线。</span><br><span class="line">点击链接时，链接显示为红色并带有下划线。</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--锚链接</span></span><br><span class="line"><span class="comment">1.需要一个锚标记</span></span><br><span class="line"><span class="comment">2.跳转到标记</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#top&quot;</span>&gt;</span>回到顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;基本标签学习.html#down&quot;</span>&gt;</span>跳转底部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--功能性链接</span></span><br><span class="line"><span class="comment">邮件链接 ： mailto:</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:2478881580@q.com&quot;</span>&gt;</span>点击联系我<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML学习笔记（三）</title>
    <url>/posts/f65a6d6b.html</url>
    <content><![CDATA[<h2 id="1-页面结构分析"><a href="#1-页面结构分析" class="headerlink" title="1.页面结构分析"></a>1.页面结构分析</h2><p><img src="/posts/f65a6d6b/image-20210504222223240.png" alt="image-20210504222223240"></p>
<span id="more"></span>

<p>头部、脚部和导航比较总要。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>页面结构分析<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>网页头部<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>网页主体<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>网页脚部<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-iframe内联框架"><a href="#2-iframe内联框架" class="headerlink" title="2.iframe内联框架"></a>2.iframe内联框架</h2><p><img src="/posts/f65a6d6b/image-20210504223521277.png" alt="image-20210504223521277"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>内联框架<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--内联框架</span></span><br><span class="line"><span class="comment">src: 地址</span></span><br><span class="line"><span class="comment">w-h：宽-高度</span></span><br><span class="line"><span class="comment">name：标识名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://www.baidu.com/&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">&quot;hello&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">width</span>=<span class="string">&quot;1200px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;800px&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;媒体元素.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;hello&quot;</span>&gt;</span>点击跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-表单语法"><a href="#3-表单语法" class="headerlink" title="3.表单语法"></a>3.表单语法</h2><p><img src="/posts/f65a6d6b/image-20210504224535465.png" alt="image-20210504224535465"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>表单学习<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--表单form</span></span><br><span class="line"><span class="comment">action: 表单提交的位置，可以是网站，也可以是一个请求处理地址</span></span><br><span class="line"><span class="comment">method：post，get 提交方式</span></span><br><span class="line"><span class="comment">get方式：可以在提交位置的url看到提交信息，不安全，高效</span></span><br><span class="line"><span class="comment">post方法：比较安全，传输大文件，可以在F12看到密码等信息</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;表格.html&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--文本输入框：input type=&quot;text&quot;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>名字：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--密码框：input type=&quot;password&quot;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--提交和重置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在填写注册信息时，打开F12，查看network–&gt;Headers.</p>
<p><img src="/posts/f65a6d6b/image-20210504230152083.png" alt="image-20210504230152083"></p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML学习笔记（二）</title>
    <url>/posts/bb44ce39.html</url>
    <content><![CDATA[<h2 id="1-行内元素和块元素"><a href="#1-行内元素和块元素" class="headerlink" title="1.行内元素和块元素"></a>1.行内元素和块元素</h2><p><img src="/posts/bb44ce39/image-20210504213328956.png" alt="image-20210504213328956"></p>
<span id="more"></span>

<h2 id="2-列表"><a href="#2-列表" class="headerlink" title="2.列表"></a>2.列表</h2><ul>
<li>有序列表</li>
<li>无序列表</li>
<li>自定义列表</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>列表学习<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--有序列表 orderlist</span></span><br><span class="line"><span class="comment">按123排序</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>C++<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>C<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>PHP<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Go<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--无序列表 unorderlist</span></span><br><span class="line"><span class="comment">按圆点分隔</span></span><br><span class="line"><span class="comment">应用：导航栏，侧边栏</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>C++<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>C<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--自定义列表</span></span><br><span class="line"><span class="comment">dl : 标签</span></span><br><span class="line"><span class="comment">dt : 列表名称</span></span><br><span class="line"><span class="comment">dd : 列表内容</span></span><br><span class="line"><span class="comment">应用：一些网站的底部</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Language<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>C++<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Cities<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>西安<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>合肥<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-表格"><a href="#3-表格" class="headerlink" title="3.表格"></a>3.表格</h2><p><img src="/posts/bb44ce39/image-20210504214925816.png" alt="image-20210504214925816"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>表格<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--表格table</span></span><br><span class="line"><span class="comment">行：tr</span></span><br><span class="line"><span class="comment">列：td</span></span><br><span class="line"><span class="comment">border:添加边框</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1px&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--跨列colspan--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span>1-1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;td&gt;1-2&lt;/td&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;td&gt;1-3&lt;/td&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--跨行rowspan--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2-1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>2-2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2-3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3-1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;td&gt;3-2&lt;/td&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3-3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-视频和音频"><a href="#4-视频和音频" class="headerlink" title="4.视频和音频"></a>4.视频和音频</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>媒体元素<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--视频</span></span><br><span class="line"><span class="comment">src：路径</span></span><br><span class="line"><span class="comment">controls：视频控制条，不加看不到视频</span></span><br><span class="line"><span class="comment">autoplay：自动播放，chrome现在好像不行，其他浏览器可以</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;video src=&quot;../resources/video/girlbythesea.mp4&quot; controls autoplay&gt;&lt;/video&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;../resources/audio/music.mp3&quot;</span> <span class="attr">controls</span> <span class="attr">autoplay</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的内存分配机制</title>
    <url>/posts/e1b970b9.html</url>
    <content><![CDATA[<h2 id="Java-中的内存区域"><a href="#Java-中的内存区域" class="headerlink" title="Java 中的内存区域"></a>Java 中的内存区域</h2><p>Java 中的内存主要分为内存堆，方法栈和方法区。当然还有一些别的内存，比如PC寄存器，和 CPU 的 PC 寄存器一样，作用是指向下一个要执行的指令，但是我们写 Java 程序的没关系，一般不需要管。下面我们就说说内存堆，方法栈和方法区。</p>
<span id="more"></span>

<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p><strong>方法区是一块连续的内存，存放的是Class文件加载到Java虚拟机内部之后的数据。</strong>表现在我们写程序的地方，方法区里的东西，也就是我们里面说的Class类的实例。方法区里的东西，包含类中的变量的定义，静态变量的值和定义，方法（所有方法，不管是静态还是非静态）的字节码等数据。我们可以通过每个类的Class实例来获取这些数据，还记得反射吗？</p>
<p>所以方法区里的数据是相对来说静止的。因为一个类一旦加载进来，就不会变了。唯一会变的可能就是静态变量的值了吧。</p>
<p>所以说，一个类无论创建多少个实例，它都不会增加方法区占用的内存。<strong>因为方法区就好想一个模版，模子，印章，不因为复制出来多少个实例而变大或者变小。</strong></p>
<h2 id="内存堆（Heap）"><a href="#内存堆（Heap）" class="headerlink" title="内存堆（Heap）"></a>内存堆（Heap）</h2><p>好，接着是内存堆。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">其实方法区也是一个堆。什么是堆呢？堆的英文名字叫做heap。是数据结构里一种标准的结构。</span><br><span class="line"></span><br><span class="line">和链表（List），Map，队列（Queue）是一样的。</span><br><span class="line"></span><br><span class="line">Java的内存堆，就是把一块连续的内存，按照堆这种数据结构组织起来。</span><br><span class="line"></span><br><span class="line">堆的结构如其名。可以简单的认为就是一堆东西，下面大上面小。就好像一堆麦子什么的。树（Tree）这个数据结构就是堆的一种。</span><br></pre></td></tr></table></figure>

<p>这里我们不去扯这些数据结构的东西。从帮助我们理解Java内存堆的作用的角度，我们可以再简化一点。可以认为Java内存堆就是一卷纸带，纸带上印着一个个大小相同的格子，比如一厘米一个格子（一个格子代表一个字节），每个格子都有一个编号（也就是内存地址）。</p>
<p>那么，我们写程序 new 一个类的对象，就是在这卷纸带上扯一段纸带，用来存放这个类的成员变量等数据。然后返回的就是这个这段纸带的开始第一个字节的地址。</p>
<p>比如说，<code>A a = new A();</code> 这段代码。new A()就是按照A占用的内存大小扯一段纸带，然后返回这段纸带的地址。紧接着把这个地址赋值给引用a。</p>
<p>这里补充一个知识点，一个对象占用的内存，是固定的。</p>
<p>先说数组，每种数据类型的数据，占用的内存大小是固定的，数组的长度也是创建的时候就确定的，所以一个数组，占用的内存就是数据类型大小 x 数组长度。当然，还有多位数组，但是我们说过，多维数组里，出了最低的一个维，其余的都是引用而已，指向低一个维度的数组对象引用。所以无论是多少维的数组，占用的内存都是一样的。</p>
<p>再说普通的类的对象。讲方法区的时候说过，方法字节码的数据，静态数据，变量定义等数据都在方法区里。那么一个对象占用的额外的数据，其实也就是成员变量。一个类里有几个成员变量是固定的。如果一个类就一个long，一个int，一个String引用，一个类A的引用，那么一个类应该占用多少内存呢？long 8 + int 4 + 引用 4 * 2 = 20个字节。当然每个对象还有一些额外的内存占用，这个所有的对象都是一样的，我们按下不表。可能还有一个问题没相同，就是那俩引用类型。这里我们要理解，String和类A的引用，其实是个引用，而不是对象本身。比如说类A的引用这个成员变量，这个引用可以指向A类的实例，A类的实例占用多少内存，这包含这个引用的对象没关系。当然A类的实例也可以是null，但是null也占内存。<strong>总言之，一个类的对象占用多少内存是固定的。</strong></p>
<p><strong>总结一下，堆就是给对象分配内存。堆里的数据可以通过内存地址访问。</strong>视频课里，我们说内存堆是挂满小本子的公告板，其实也是一个意思，小本子就是一段纸带，公告板的意思就是，这个纸带有地址，能根据地址访问。</p>
<h2 id="方法栈（Stack）"><a href="#方法栈（Stack）" class="headerlink" title="方法栈（Stack）"></a>方法栈（Stack）</h2><p>好，说完了内存堆，剩下就是执行代码了。执行方法需要的内存，都是在栈里分配的。栈，就是stack，是一种先进后出的数据结构。就好像摞盘子一样，最先摞的最后拿出来，最后摞的最先拿出来。</p>
<p>执行方法需要什么内存呢？参数和局部变量。每次执行一个方法，都要为这个方法的执行创建其中定义的参数和局部变量。</p>
<p>那么这里我们再来想通一个事情。那就是每次执行一个方法，占用的内存都是一样的。因为一个方法的参数和定义的局部变量的数量是一样的。可能有一个疑问就是，循环中定义的局部变量怎么办？其实细想，循环中定义的变量，其实是被重用的。一个for循环，里面定义了一个 int 变量。无论循环多少次，新的循环开始的时候，就可以重用之前定义的变量占用的内存，因为一个循环一旦结束，它占用的内存就没用了，可以被下次循环重新使用。</p>
<p>Stack的这个先进后出的特性，和方法调用时一样的。比如m1方法调用m2方法，m2方法调用m3方法，那么过程会是这样的。</p>
<ul>
<li>先调用m1，根据m1的代码，确定m1执行的时候需要多少内存，在栈上分配相应大小的内存供m1执行使用，同时将分配的内存进栈；</li>
<li>执行过程中调用了m2，同样的过程，在栈上分配m2需要的内存，然后内存进栈；</li>
<li>执行m2的时候，m2调用m3，还是分配m3需要的内存，然后内存进栈。</li>
<li>好了，m3执行完毕，释放m3占用的内存（内存出栈），然后是m2继续执行，执行完毕内存释放，最后是m1执行，执行完毕内存释放</li>
</ul>
<p>那么，如何访问栈上内存呢？既然每个方法执行需要的内存都是固定的，那么在分配的这一截内存上，每个变量的地址都是固定的。正所谓冥冥中自有定数，正是此意。所以这个和堆上的内存是不一样的。堆上的内存需要根据引用，找到堆上对应的对象，然后每个成员变量对应的内存地址，也都是冥冥中自有定数了。</p>
<p>参考文章：<a href="https://time.geekbang.org/course/intro/181">Java入门课程配套FAQ</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java知识详解</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的对象与对象引用</title>
    <url>/posts/c24ed739.html</url>
    <content><![CDATA[<h2 id="对象和对象引用的区别"><a href="#对象和对象引用的区别" class="headerlink" title="对象和对象引用的区别"></a>对象和对象引用的区别</h2><p>不理解的话建议参考</p>
<ol>
<li>书籍：《Java核心技术：卷I》（第11版）—&gt; 4.2.1 对象与对象变量</li>
<li> 博客：CSDN博主「技术小栈」的原创文章<a href="https://blog.csdn.net/qq_26805137/article/details/52945688">原文链接</a></li>
</ol>
<span id="more"></span>

<p>首先举个例子：<code>Demo demo=new Demo();</code></p>
<p>  这一条语句，其实包括了四个动作：<br>                1）右边的“new Demo”，是以Demo类为模板，在堆空间里创建一个Demo对象。<strong>这条语句的返回值是对Demo对象的一个引用。</strong><br>                2）末尾的()意味着，在对象创建后，立即调用Demo类的构造函数，对刚生成的对象进行初始化。<br>                3）左边的“Demo demo”创建了一个Demo类引用变量，它存放在栈空间中。也就是用来指向Demo对象的对象引用。 这里的demo，我们也可以称之为对象变量。<br>                4）“=”操作符使对象引用指向刚创建的那个Demo对象。</p>
<p>当然这条语句我们也可以写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Demo demo;<span class="comment">//创建对象引用</span></span><br><span class="line">demo=<span class="comment">/*将对象引用指向对象*/</span><span class="keyword">new</span> Demo();<span class="comment">//创建对象</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/c24ed739/image-20210403090745364.png" alt="image-20210403090745364"></p>
<h2 id="对象引用与对象之间的关系"><a href="#对象引用与对象之间的关系" class="headerlink" title="对象引用与对象之间的关系"></a>对象引用与对象之间的关系</h2><p> 1）从对象引用出发:</p>
<p> 一个对象引用可以指向一个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Demo demo；<span class="comment">//一个对象引用</span></span><br><span class="line">demo=<span class="keyword">new</span> Demo();<span class="comment">//一个对象引用指向一个对象</span></span><br></pre></td></tr></table></figure>

<p> 也可以不指向对象。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Demo demo;<span class="comment">//创建对象引用，但是没有指向对象</span></span><br></pre></td></tr></table></figure>

<p> 2）从对象出发：</p>
<p>​       一个对象可以被一个对象引用引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Demo demo;<span class="comment">//创建对象引用</span></span><br><span class="line">demo=<span class="keyword">new</span> Demo();<span class="comment">//创建对象，并被一个对象引用指向</span></span><br></pre></td></tr></table></figure>

<p>  也可以被多个对象引用同时引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Demo demo1，demo2，demo3;<span class="comment">//创建多个对象引用</span></span><br><span class="line">demo1=<span class="keyword">new</span> Demo();</span><br><span class="line">demo2=demo1;<span class="comment">// 它们地址相同，指向同一个对象</span></span><br><span class="line">demo3=demo2;<span class="comment">//创建对象，并被多个对象引用指向</span></span><br></pre></td></tr></table></figure>

<h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><p><img src="/posts/c24ed739/image-20210403091943631.png" alt="image-20210403091943631"></p>
<p><img src="/posts/c24ed739/image-20210403092008411.png" alt="image-20210403092008411"></p>
<p><img src="/posts/c24ed739/image-20210403092458600.png" alt="image-20210403092458600"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java知识详解</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中继承与组合的区别</title>
    <url>/posts/def2ac9d.html</url>
    <content><![CDATA[<p>组合和继承，是拿到一个问题，设计相应的Java类的时候，不得不面对的来自灵魂的拷问。</p>
<p>“XX到底是YY的一种，还是只是组合了YY？”，”手机到底是手电筒的一种，还是组合了一个可以当手电的闪光灯？”</p>
<span id="more"></span>

<h2 id="is-a与has-a关系"><a href="#is-a与has-a关系" class="headerlink" title="is-a与has-a关系"></a>is-a与has-a关系</h2><p>is-a( 是 “a”  小明是人类)表示的是属于得关系。比如兔子属于一种动物（继承关系）。</p>
<p>has-a( 有 “a”  汽车有轮胎) 表示组合，包含关系。比如兔子包含有腿，头等组件；就不能说兔子腿是属于一种兔子（不能说是继承关系）</p>
<h2 id="继承与组合的区别"><a href="#继承与组合的区别" class="headerlink" title="继承与组合的区别"></a>继承与组合的区别</h2><p>继承，其实表达的是一种”is-a”的关系，也就是说，在你用类构造的世界中，”子类是父类的一种特殊类别”。</p>
<p>组合，在类中创建另一个类的对象，来进行各种操作。</p>
<p>继承不是组合，继承也不只是为了能简单的拿来父类的属性和方法。如果仅仅如此，原封不动的拿来主义，组合也能做到。</p>
<p>继承也不是通过组合的方式来实现的。**和组合相比，继承更像是”融合”**。</p>
<p>所谓融合，即合二为一，可以互相影响。父类影响子类没问题，子类怎么影响父类呢？如何限制手机一次只能最多买五个？</p>
<h2 id="我们为什么需要使用继承？"><a href="#我们为什么需要使用继承？" class="headerlink" title="我们为什么需要使用继承？"></a>我们为什么需要使用继承？</h2><p>如果使用<strong>组合</strong>，对于作为属性的类对象，我们无法修改其方法。有时候是因为没有权限，有时候是因为我们的习惯：我们不该为了一个类去修改作为其属性的另一个类的方法。<strong>对于组合这种方式，我们只有使用的权限，而没有修改的权限。</strong>也就是说组合很难做到上面提到的限制手机买5个。</p>
<p>而对于<strong>继承</strong>，因为有<strong>覆写</strong>的存在，因此，虽然某个方法属于父类，但如果子类想要拥有区别于父类的属于自己的独特的方法，那么可以使用<strong>覆写机制</strong>。<strong>所以，对于继承这种方式，我们不仅可以使用，还可以修改。</strong></p>
<p>继承之于组合特殊的一点在于，它能够进行覆写，对继承自父类的方法不满足就可以修改。<strong>而在Java中，组合是没有覆盖的，覆盖只在继承中存在。</strong></p>
<p>即组合，我们从其他类简单地拿来了属性和方法；而继承，我们不仅仅从其他类拿来了属性和方法，我们还可以修改拿来的方法。</p>
<p>组合让两个类相对保持自己的独立性，而继承则让两个类相互渗透，因为继承更确切地说是子类和父类的融合。<br>类存在的目的是封装，而继承在某种程度上破坏了这种封装，让两个类紧紧耦合在了一起。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java知识详解</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（一）</title>
    <url>/posts/b67a5797.html</url>
    <content><![CDATA[<h2 id="1-java简介"><a href="#1-java简介" class="headerlink" title="1.java简介"></a>1.java简介</h2><p>本教程推荐配合大佬<a href="https://www.cnblogs.com/vccyb/tag/%E5%8C%85%E5%AD%90%E5%AD%A6%E7%B3%BB%E5%88%97/">笔记</a>食用！</p>
<p>B站视频倍速播放：F12–&gt;console–&gt;输入：document.querySelector(‘video’).playbackRate = 2.5，控制倍速。</p>
<p>随着Java的发展，SUN给Java又分出了三个不同版本：</p>
<ul>
<li>Java SE：Standard Edition</li>
<li>Java EE：Enterprise Edition</li>
<li>Java ME：Micro Edition</li>
</ul>
<span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌───────────────────────────┐</span><br><span class="line">│Java EE                    │</span><br><span class="line">│    ┌────────────────────┐ │</span><br><span class="line">│    │Java SE             │ │</span><br><span class="line">│    │    ┌─────────────┐ │ │</span><br><span class="line">│    │    │   Java ME   │ │ │</span><br><span class="line">│    │    └─────────────┘ │ │</span><br><span class="line">│    └────────────────────┘ │</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure>

<ul>
<li>JDK：Java Development Kit（java开发工具包）</li>
<li>JRE：Java Runtime Environment(Java运行环境)</li>
<li>简单而言，使用JDK的开发工具完成的java程序，交给JRE去运行。</li>
</ul>
<p>简单地说，JRE就是运行Java字节码的虚拟机。但是，如果只有Java源码，要编译成Java字节码，就需要JDK，因为JDK除了包含JRE，还提供了编译器、调试器等开发工具。</p>
<p>JDK:<strong>JRE + 开发工具集</strong>（编译器(Javac) + 其他工具）；JRE:<strong>Java虚拟机(JVM) + Java类库</strong> + 其他。</p>
<p>二者关系如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> ┌─    ┌──────────────────────────────────┐</span><br><span class="line"> │     │     Compiler, debugger, etc.     │</span><br><span class="line"> │     └──────────────────────────────────┘</span><br><span class="line">JDK ┌─ ┌──────────────────────────────────┐</span><br><span class="line"> │  │  │                                  │</span><br><span class="line"> │ JRE │      JVM + Runtime Library       │</span><br><span class="line"> │  │  │                                  │</span><br><span class="line"> └─ └─ └──────────────────────────────────┘</span><br><span class="line">       ┌───────┐┌───────┐┌───────┐┌───────┐</span><br><span class="line">       │Windows││ Linux ││ macOS ││others │</span><br><span class="line">       └───────┘└───────┘└───────┘└───────┘</span><br></pre></td></tr></table></figure>

<ul>
<li>java：这个可执行程序其实就是JVM，运行Java程序，就是启动JVM，然后让JVM执行指定的编译后的代码；</li>
<li>javac：这是Java的编译器，它用于把Java源码文件（以<code>.java</code>后缀结尾）编译为Java字节码文件（以<code>.class</code>后缀结尾）；</li>
<li>jar：用于把一组<code>.class</code>文件打包成一个<code>.jar</code>文件，便于发布；</li>
<li>javadoc：用于从Java源码中自动提取注释并生成文档；</li>
<li>jdb：Java调试器，用于开发阶段的运行调试。</li>
</ul>
<p>如果遇到编码问题，我们可以使用 <strong>-encoding</strong> 选项设置 <strong>utf-8</strong> 来编译：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javac -encoding UTF-8 HelloWorld.java </span><br><span class="line">java HelloWorld </span><br></pre></td></tr></table></figure>



<h2 id="2-Java与C-的区别"><a href="#2-Java与C-的区别" class="headerlink" title="2.Java与C++的区别"></a>2.Java与C++的区别</h2><p>我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来！</p>
<ul>
<li>都是面向对象的语言，都支持封装、继承和多态</li>
<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li>
<li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存</li>
<li><strong>在 C 语言中，字符串或字符数组最后都会有一个额外的字符<code>&#39;\0&#39;</code>来表示结束。但是，Java 语言中没有结束符这一概念。</strong> 这是一个值得深度思考的问题，具体原因推荐看这篇文章： <a href="https://blog.csdn.net/sszgg2006/article/details/49148189">https://blog.csdn.net/sszgg2006/article/details/49148189</a></li>
</ul>
<h2 id="3-java语言编译-compile-与解释并存"><a href="#3-java语言编译-compile-与解释并存" class="headerlink" title="3.java语言编译(compile)与解释并存"></a>3.java语言编译(compile)与解释并存</h2><p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 <u>Java 程序要经过先编译，后解释两个步骤</u>，由 Java 编写的程序需要先<strong>经过编译步骤，生成字节码</strong>（*.class 文件），这种字节码必须<strong>由 Java 解释器来解释执行</strong>。因此，我们可以认为 Java 语言编译与解释并存。</p>
<h2 id="4-字符型常量和字符串常量的区别"><a href="#4-字符型常量和字符串常量的区别" class="headerlink" title="4.字符型常量和字符串常量的区别"></a>4.字符型常量和字符串常量的区别</h2><ol>
<li><p>形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的 0 个或若干个字符</p>
</li>
<li><p>含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</p>
</li>
<li><p>占内存大小 字符常量只占 2 个字节; 字符串常量占若干个字节 (<strong>注意： char 在 Java 中占两个字节</strong>),</p>
<blockquote>
<p>字符封装类 <code>Character</code> 有一个成员常量 <code>Character.SIZE</code> 值为 16,单位是<code>bits</code>,该值除以 8(<code>1byte=8bits</code>)后就可以得到 2 个字节</p>
</blockquote>
</li>
</ol>
<h2 id="5-Java注释"><a href="#5-Java注释" class="headerlink" title="5.Java注释"></a>5.Java注释</h2><p>主要分为三种：单行、多行和文档注释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">   <span class="comment">/** 这是第一个Java程序</span></span><br><span class="line"><span class="comment">    * 它将输出 Hello World</span></span><br><span class="line"><span class="comment">    * 这是一个文档的示例</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       <span class="comment">// 这是单行注释的示例</span></span><br><span class="line">       <span class="comment">/* </span></span><br><span class="line"><span class="comment">       多行注释</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       System.out.println(<span class="string">&quot;Hello World&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-Java关键字"><a href="#6-Java关键字" class="headerlink" title="6.Java关键字"></a>6.Java关键字</h2><table>
<thead>
<tr>
<th>访问控制</th>
<th>private</th>
<th>protected</th>
<th>public</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>类，方法和变量修饰符</td>
<td>abstract</td>
<td>class</td>
<td>extends</td>
<td>final</td>
<td>implements</td>
<td>interface</td>
<td>native</td>
</tr>
<tr>
<td></td>
<td>new</td>
<td>static</td>
<td>strictfp</td>
<td>synchronized</td>
<td>transient</td>
<td>volatile</td>
<td></td>
</tr>
<tr>
<td>程序控制</td>
<td>break</td>
<td>continue</td>
<td>return</td>
<td>do</td>
<td>while</td>
<td>if</td>
<td>else</td>
</tr>
<tr>
<td></td>
<td>for</td>
<td>instanceof</td>
<td>switch</td>
<td>case</td>
<td>default</td>
<td></td>
<td></td>
</tr>
<tr>
<td>错误处理</td>
<td>try</td>
<td>catch</td>
<td>throw</td>
<td>throws</td>
<td>finally</td>
<td></td>
<td></td>
</tr>
<tr>
<td>包相关</td>
<td>import</td>
<td>package</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>基本类型</td>
<td>boolean</td>
<td>byte</td>
<td>char</td>
<td>double</td>
<td>float</td>
<td>int</td>
<td>long</td>
</tr>
<tr>
<td></td>
<td>short</td>
<td>null</td>
<td>true</td>
<td>false</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>变量引用</td>
<td>super</td>
<td>this</td>
<td>void</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>保留字</td>
<td>goto</td>
<td>const</td>
<td>null</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="7-java语法规范"><a href="#7-java语法规范" class="headerlink" title="7.java语法规范"></a>7.java语法规范</h2><p>编写 Java 程序时，应注意以下几点：</p>
<ul>
<li><strong>大小写敏感</strong>：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。</li>
<li><strong>类名</strong>：（class）对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 <strong>MyFirstJavaClass</strong> 。</li>
<li><strong>方法名</strong>：（method）所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。</li>
<li><strong>源文件名</strong>：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 <strong>.java</strong>。（如果文件名和类名不相同则会导致编译错误）。</li>
<li><strong>主方法入口</strong>：所有的 Java 程序由 <strong>public static void main(String[] args)</strong> 方法开始执行。</li>
</ul>
<p>像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：</p>
<ol>
<li>访问控制修饰符 : default, public , protected, private</li>
<li>非访问控制修饰符 : final, abstract, static, synchronized</li>
</ol>
<ul>
<li><p><strong>标识符命名规范</strong>：</p>
<p>所有的标识符都应该以英文字母、$、或者_开始。</p>
<p>首字符之后可以是英文字母、$_或者数字`的任意组合。</p>
<p><img src="/posts/b67a5797/image-20210210101349712.png" alt="image-20210210101349712"></p>
</li>
</ul>
<p><strong>小结</strong></p>
<p>一个Java源码只能定义一个<code>public</code>类型的class，并且class名称和文件名要完全一致；</p>
<p>但是可以定义多个class（类）;</p>
<p>使用<code>javac</code>可以将<code>.java</code>源码编译成<code>.class</code>字节码；（JVM运行字节码）</p>
<p>使用<code>java</code>可以运行一个已编译的Java程序，参数是类名。</p>
<h2 id="8-java变量与数据类型"><a href="#8-java变量与数据类型" class="headerlink" title="8.java变量与数据类型"></a>8.java变量与数据类型</h2><p>Java变量就好像一个容器，可以保存程序在运行过程中的值，它在声明的时候会定义对应的数据类型（Java分为两种数据类型：基本数据类型和引用数据类型）。变量按作用域的范围又可分为三种类型：<strong>局部变量，成员变量和静态变量</strong>。</p>
<p>Java中并没有全局变量的概念，这与C/C++不同！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Variable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> allClicks = <span class="number">0</span>;<span class="comment">// 类变量，静态变量</span></span><br><span class="line">    String s = <span class="string">&quot;helloworld&quot;</span>;<span class="comment">// 实例变量，成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">// 局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="8-1-主要分类"><a href="#8-1-主要分类" class="headerlink" title="8.1 主要分类"></a>8.1 主要分类</h5><p><img src="/posts/b67a5797/image-20210210102225703.png" alt="image-20210210102225703"></p>
<p>八大基本数据类型</p>
<ul>
<li>1字节 的是 byte 、boolean</li>
<li>2字节 的是 short 、<strong>char</strong>（Java采用<strong>Unicode编码</strong>）</li>
<li>4字节 的是 int （范围约21亿=2$^{31}$）、float</li>
<li>8字节 的是 long 、double</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> num1 = <span class="number">30L</span>;</span><br><span class="line"><span class="keyword">long</span> num1 = <span class="number">30l</span>;<span class="comment">// 两者等价</span></span><br><span class="line"><span class="keyword">float</span> num2 = <span class="number">23.1F</span>;</span><br><span class="line"><span class="keyword">float</span> num2 = <span class="number">23.1f</span>;<span class="comment">// 两者等价</span></span><br><span class="line"><span class="keyword">double</span> = <span class="number">23.23453456</span>;<span class="comment">// double不需要后缀，Java中的小数默认为double型</span></span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">Srting s = <span class="string">&quot;ABC&quot;</span>;<span class="comment">// 注意：String是一个类，不是关键字，不属于基本数据类型</span></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>

<h5 id="8-2-局部变量"><a href="#8-2-局部变量" class="headerlink" title="8.2 局部变量"></a>8.2 局部变量</h5><p>声明局部变量时的注意事项：</p>
<ul>
<li>局部变量声明在方法，构造方法或语句块中。</li>
<li>局部变量在方法，构造方法，或者语句块被执行的时候创建，当其执行完成后，将会被销毁。</li>
<li>访问修饰符不能用于局部变量。</li>
<li>局部变量只在声明它的方法，构造方法或语句块中可见。</li>
<li>局部变量是在栈上分配的。</li>
<li>局部变量没有默认值，所以局部变量被声明后，<strong>必须经过初始化，才可以使用</strong>。</li>
</ul>
<h5 id="8-3-成员变量"><a href="#8-3-成员变量" class="headerlink" title="8.3 成员变量"></a>8.3 成员变量</h5><p>在类内部但在方法体外声明的变量称为成员变量，或者实例变量。之所以称为实例变量，是因为该变量只能通过类的实例（对象）来访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 文档注释：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 微信搜「沉默王二」，回复关键字 PDF</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceVariable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">88</span>;<span class="comment">// data是成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InstanceVariable iv = <span class="keyword">new</span> InstanceVariable();</span><br><span class="line">        System.out.println(iv.data); <span class="comment">// 88</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以是一个变量，它是一个引用类型的变量。<code>new</code>关键字可以创建一个类的实例（也称为对象），通过“ =”操作符赋值给iv这个变量，iv就成了这个对象的引用，通过<code>iv.data</code>就可以访问成员变量了。</p>
<p>声明成员变量时的注意事项：</p>
<ul>
<li>成员变量声明在一个类中，但在方法，构造方法和语句块之外。</li>
<li>当一个对象被实例化之后，每个成员变量的值就跟着确定。</li>
<li>成员变量在对象创造的时候创造，在对象被销毁的时候销毁。</li>
<li>成员变量的值应该至少被一个方法，构造方法或语句块引用，以便外部能够通过这些方式获取实例变量信息。</li>
<li>成员变量可以声明在使用前或使用后。</li>
<li>访问修饰符可以修饰成员变量。</li>
<li>一般情况下应该把成员变量设为所有权。通过使用访问修饰符可以使成员变量对子类可见；成员变量具有唯一值。数值型成员变量对于类中的方法，构造方法或语句块是可见的。变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定。</li>
</ul>
<h2 id="9-位运算"><a href="#9-位运算" class="headerlink" title="9.位运算"></a>9.位运算</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;&gt;：符号位不动，其余位右移，符号位后边正数补<span class="number">0</span>，负数补<span class="number">1</span>。又称带符号右移</span><br><span class="line">&gt;&gt;&gt;：符号位一起右移，左边补<span class="number">0</span>，又称无符号右移</span><br><span class="line">&lt;&lt;：左移，右边补<span class="number">0</span>。左移没有带符号位一说，因为符号位在最左侧</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（七）</title>
    <url>/posts/a4cff879.html</url>
    <content><![CDATA[<h2 id="1-方法和属性的可见性修饰符"><a href="#1-方法和属性的可见性修饰符" class="headerlink" title="1.方法和属性的可见性修饰符"></a>1.方法和属性的可见性修饰符</h2><span id="more"></span>

<p><img src="/posts/a4cff879/image-20210403114450929.png" alt="image-20210403114450929"></p>
<ul>
<li><p>非公共的类，不能在包外被使用。</p>
</li>
<li><p>public的方法类似一种约定，既然外面的代码可以使用，就意味着不能乱改。比如签名不能改之类的。</p>
</li>
<li><p>对于private的方法，因为类外面调不到，所以无论怎么改，也不会影响（直接影响）类外面的代码。</p>
</li>
<li><p>有些时候，会把所有的构造方法都定义成private的，然后使用静态方法调用构造方法，这样的好处是可以通过代码，检查每个属性值是否合法。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MerchandiseV2 <span class="title">createMerchandise</span><span class="params">(String name, String id, <span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">double</span> soldPrice, <span class="keyword">double</span> purchasePrice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (soldPrice &lt; <span class="number">0</span> || purchasePrice &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MerchandiseV2(name, id, count, soldPrice, purchasePrice);<span class="comment">// 合法则调用构造器</span></span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>访问控制修饰符</th>
<th>本类内部</th>
<th>同包</th>
<th>不同包子类</th>
<th>同一工程</th>
</tr>
</thead>
<tbody><tr>
<td>Public</td>
<td>可以</td>
<td>可以</td>
<td>可以</td>
<td>可以</td>
</tr>
<tr>
<td>Protected</td>
<td>可以</td>
<td>可以</td>
<td>可以</td>
<td></td>
</tr>
<tr>
<td>默认（default）</td>
<td>可以</td>
<td>可以</td>
<td></td>
<td></td>
</tr>
<tr>
<td>private</td>
<td>可以</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="2-Math类"><a href="#2-Math类" class="headerlink" title="2.Math类"></a>2.Math类</h2><p>Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。</p>
<p>Math类中的方法都是静态的，所以不需要实例化对象。</p>
<p>它没有成员变量，是一个工具类，只提供一些方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.abs(-<span class="number">10</span>) <span class="comment">// 绝对值</span></span><br><span class="line">Math.sqrt(X)<span class="comment">//计算平方根</span></span><br><span class="line">Math.cbrt(X)<span class="comment">//计算立方根</span></span><br><span class="line">Math.pow(a, b)<span class="comment">//计算a的b次方</span></span><br><span class="line">Math.max( <span class="number">1</span>,<span class="number">2</span> );<span class="comment">//计算最大值</span></span><br><span class="line">Math.min( <span class="number">3</span>,<span class="number">4</span> );<span class="comment">//计算最小值</span></span><br><span class="line">Math.ceil(X) <span class="comment">//接近此数的大的整数的值 3.1-&gt;4</span></span><br><span class="line">Math.floor(X) <span class="comment">//接近此数的小的整数的值 3.1-&gt;3</span></span><br><span class="line">Math.random() <span class="comment">//[0,1)</span></span><br><span class="line">Math.round(X) <span class="comment">//round 四舍五入，float时返回int值，double时返回long值</span></span><br><span class="line">   </span><br><span class="line">Math.random(); <span class="comment">// 0.53907... 每次都不一样，返回值是double</span></span><br><span class="line"><span class="comment">//前面我们使用的Math.random()实际上内部调用了Random类</span></span><br><span class="line"><span class="comment">//random在java.util包里</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Math.random());</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//nextInt的返回值竟然有正数有负数哦！随机生成一个int值</span></span><br><span class="line">            System.out.println(Math.abs(random.nextInt()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Math.round(-<span class="number">9.2</span>));</span><br><span class="line">        System.out.println(Math.round(-<span class="number">9.5</span>));</span><br><span class="line">        System.out.println(Math.round(-<span class="number">9.8</span>));</span><br><span class="line">        System.out.println(Math.round(<span class="number">9.2</span>));</span><br><span class="line">        System.out.println(Math.round(<span class="number">9.5</span>));</span><br><span class="line">        System.out.println(Math.round(<span class="number">9.8</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*0.8715393731162016</span></span><br><span class="line"><span class="comment">1876651818</span></span><br><span class="line"><span class="comment">1246645657</span></span><br><span class="line"><span class="comment">1659850256</span></span><br><span class="line"><span class="comment">1890712276</span></span><br><span class="line"><span class="comment">1135262753</span></span><br><span class="line"><span class="comment">-9</span></span><br><span class="line"><span class="comment">-9</span></span><br><span class="line"><span class="comment">-10</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">10*/</span></span><br></pre></td></tr></table></figure>

<h2 id="3-重新认识String类"><a href="#3-重新认识String类" class="headerlink" title="3.重新认识String类"></a>3.重新认识String类</h2><p>String 对象最重要的特点：<strong>不可变（immutable）</strong>不可变不可变，重要的事情说三遍。String 用来存储字符的数据是private 的，而且不提供任何修改内容的方法，<strong>所以String 对象一旦生成，其内容就是完全不可能被修改的。</strong></p>
<p>String是一个final类，不可变。</p>
<p>String 对象的字符内容是存储在一个字符数组 value[] 中 的。</p>
<p><img src="/posts/a4cff879/image-20210502134230914.png" alt="image-20210502134230914"></p>
<p><img src="/posts/a4cff879/image-20210502134630605.png" alt="image-20210502134630605"></p>
<p><img src="/posts/a4cff879/image-20210502134822887.png" alt="image-20210502134822887"></p>
<p><code>String s = new String(&quot;abc&quot;);</code>方式创建对象，在内存中创建了几个对象？<br><strong>两个</strong>:一个是堆空间中new结构，另一个是char[]对应的常量池中的数据：”abc”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LearnString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String content = <span class="string">&quot;01234567ABCDefgh&quot;</span>;<span class="comment">// java为String开后门，不用new String创建</span></span><br><span class="line">        <span class="comment">// String的length()是个方法不是属性哦，数组的length是属性</span></span><br><span class="line">        System.out.println(content.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其实是生成了一个新的String对象</span></span><br><span class="line">        System.out.println(content.toUpperCase());<span class="comment">//全部大写，生成副本</span></span><br><span class="line">        System.out.println(content.toLowerCase());<span class="comment">//全部小写，生成副本</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// content指向对象的内容并没有变化</span></span><br><span class="line">        System.out.println(content);</span><br><span class="line">        <span class="comment">//返回指定索引处的字符。索引范围为从 0 到 length() - 1</span></span><br><span class="line">        System.out.println(content.charAt(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// System.out.println(content.charAt(99));</span></span><br><span class="line">        System.out.println(content.substring(<span class="number">5</span>));</span><br><span class="line">        System.out.println(content.substring(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*16</span></span><br><span class="line"><span class="comment">01234567ABCDEFGH</span></span><br><span class="line"><span class="comment">01234567abcdefgh</span></span><br><span class="line"><span class="comment">01234567ABCDefgh</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">567ABCDefgh</span></span><br><span class="line"><span class="comment">1234*/</span></span><br></pre></td></tr></table></figure>

<p><code>substring(int beginIndex，int endIndex)</code> 形式：左闭右开</p>
<p>此方法中的 <code>beginIndex</code> 表示截取的起始索引，截取的字符串中包括起始索引对应的字符；endIndex 表示结束索引，截取的字符串中不包括结束索引对应的字符，如果不指定 <code>endIndex</code>，则表示截取到目标字符串末尾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LearnString2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String content = <span class="string">&quot;Orange_Apple_Banana&quot;</span>;</span><br><span class="line">	<span class="comment">//toCharArray() 方法将字符串转换为字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = content.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            System.out.println(chars[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String sp = <span class="string">&quot;_&quot;</span>;</span><br><span class="line">        String[] s = content.split(sp);<span class="comment">// 分割String，用char数组保存</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">            System.out.println(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String s1 = <span class="string">&quot;  ad &quot;</span>;</span><br><span class="line">        String s2 = s1.trim();<span class="comment">//去除左右两边的空格</span></span><br><span class="line">        String s3 =<span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        System.out.println(s1.compareTo(s2));<span class="comment">//比较String大小</span></span><br><span class="line">        System.out.println(s1.compareTo(s3));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> indexOf = content.indexOf(<span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">        System.out.println(indexOf);</span><br><span class="line">        System.out.println(content.substring(indexOf + <span class="number">1</span>, content.length()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lastIndexOf = content.lastIndexOf(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">        System.out.println(lastIndexOf);</span><br><span class="line">        System.out.println(content.substring(<span class="number">0</span>, lastIndexOf));</span><br><span class="line"></span><br><span class="line">        System.out.println(content.contains(<span class="string">&quot;apple&quot;</span>));</span><br><span class="line">        System.out.println(content.contains(<span class="string">&quot;Apple&quot;</span>));</span><br><span class="line">        System.out.println(content.startsWith(<span class="string">&quot;Orange&quot;</span>));</span><br><span class="line">        System.out.println(content.endsWith(<span class="string">&quot;Banana&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        String content2 = <span class="string">&quot;Orange_Apple_Banana&quot;</span>;</span><br><span class="line">        String content3 = <span class="string">&quot;   orange_Apple_banana   &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 两个String对象比较是否相等，一定要用equals方法</span></span><br><span class="line">        System.out.println(content.equals(content2));</span><br><span class="line">        System.out.println(content.equals(content3));</span><br><span class="line">        System.out.println(content.equalsIgnoreCase(content3.trim()));<span class="comment">//忽略大小写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>indexOf()</code> 方法有以下四种形式：</p>
<ul>
<li><strong>int indexOf(int ch)/int indexOf(String str):</strong> 返回指定字符（索引）或字符串在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</li>
<li><strong>int indexOf(int ch, int fromIndex)/int indexOf(String str, int fromIndex):</strong> 返回从 <code>fromIndex</code> 位置开始查找指定字符（索引）或字符串在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</li>
</ul>
<p><code>lastIndexOf()</code> 方法也有四种形式：</p>
<ul>
<li>前两种把第一次改成最后一次就行；</li>
<li>后两种改为从 <code>fromIndex</code> 位置反向查找即可。</li>
</ul>
<p><code>startsWith()</code>和<code>endsWith()</code> 方法用于测试字符串是否以指定的字符串前/后缀结束。</p>
<p><code>contains()</code> 方法用于判断字符串中是否包含指定的字符或字符串。</p>
<p><strong>equals方法：</strong></p>
<p>equals() 方法用于将字符串与指定的对象比较。</p>
<p>String 类中重写了 equals() 方法用于比较两个字符串的内容是否相等。</p>
<p>如果给定对象与字符串相等，则返回 true；否则返回 false。</p>
<p>注意：String 中 <strong>==</strong> 比较引用地址是否相同，<strong>equals()</strong> 比较字符串的内容是否相同。</p>
<p>用==进行比较时，符号两边的数据类型必须兼容，可自动转换的基本数据类型除外，否则编译 出错。</p>
<p>equalsIgnoreCase() 方法用于将字符串与指定的对象比较，不考虑大小写。</p>
<p>contains() 方法用于判断字符串中是否包含指定的字符或字符串。</p>
<p>trim() 方法用于删除字符串的头尾空白符。</p>
<h2 id="4-String类与char-、byte-之间的转换"><a href="#4-String类与char-、byte-之间的转换" class="headerlink" title="4.String类与char[]、byte[]之间的转换"></a>4.String类与char[]、byte[]之间的转换</h2><p><img src="/posts/a4cff879/image-20210502142039420.png" alt="image-20210502142039420"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;abc1234&quot;</span>;</span><br><span class="line">        <span class="keyword">char</span>[] c1 = s1.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; c1.length;i++)&#123;</span><br><span class="line">            System.out.println(c1[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] c2 = &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">        String s2 = <span class="keyword">new</span> String(c2);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/a4cff879/image-20210502142755814.png" alt="image-20210502142755814"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;abc1234&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] b1 = s1.getBytes();<span class="comment">// 可以在getBytes中指定编码集</span></span><br><span class="line">        System.out.println(Arrays.toString(b1));<span class="comment">// 输出UTF-8编码，默认编码集</span></span><br><span class="line"></span><br><span class="line">        String s2 = <span class="keyword">new</span> String(b1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（三）</title>
    <url>/posts/cb72181d.html</url>
    <content><![CDATA[<h2 id="1-Scanner（扫描器）对象"><a href="#1-Scanner（扫描器）对象" class="headerlink" title="1.Scanner（扫描器）对象"></a>1.Scanner（扫描器）对象</h2><p>java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。</p>
<p>下面是创建 Scanner 对象的基本语法：</p>
<p><code>import java.util.Scanner;</code></p>
<p><code>Scanner s = new Scanner(System.in);</code></p>
<span id="more"></span>

<p><img src="/posts/cb72181d/image-20210226155906265.png" alt="image-20210226155906265"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Scanner s = <span class="keyword">new</span> Scanner(System.in);<span class="comment">// 创建Scanner对象s</span></span><br><span class="line">	    System.out.println(<span class="string">&quot;使用next方式接受：&quot;</span>);</span><br><span class="line">	    <span class="comment">//判断用户有没有输入字符串</span></span><br><span class="line">	    <span class="keyword">if</span> (s.hasNext())&#123;</span><br><span class="line">	    	String str = s.next();</span><br><span class="line">	    	System.out.println(<span class="string">&quot;输入的内容是：&quot;</span>+str);</span><br><span class="line">	    &#125;</span><br><span class="line">	    s.close();<span class="comment">// 凡是属于IO流的类如果不关闭会一直占用资源</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* input:  hello world</span></span><br><span class="line"><span class="comment">output:hello*/</span> hello之前的空格会过滤</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Scanner s = <span class="keyword">new</span> Scanner(System.in);<span class="comment">// 创建Scanner对象s</span></span><br><span class="line">	    System.out.println(<span class="string">&quot;使用nextLine方式接受：&quot;</span>);</span><br><span class="line">	    <span class="comment">//判断用户有没有输入字符串</span></span><br><span class="line">	    <span class="keyword">if</span> (s.hasNextLine())&#123;</span><br><span class="line">	    	String str = s.nextLine();</span><br><span class="line">	    	System.out.println(<span class="string">&quot;输入的内容是：&quot;</span>+str);</span><br><span class="line">	    &#125;</span><br><span class="line">	    s.close();<span class="comment">// 凡是属于IO流的类如果不关闭会一直占用资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* input:  hello world</span></span><br><span class="line"><span class="comment">output:  hello world*/</span> hello之前的空格会接收</span><br></pre></td></tr></table></figure>

<p><img src="/posts/cb72181d/image-20210226173438395.png" alt="image-20210226173438395"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> sign = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (s.hasNextDouble())&#123;</span><br><span class="line">			sum += s.nextDouble();</span><br><span class="line">			sign ++;</span><br><span class="line">			System.out.println(<span class="string">&quot;你输入了第&quot;</span>+sign+<span class="string">&quot;个数据，结果是&quot;</span>+sum);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(sign+<span class="string">&quot;个数的总和是&quot;</span>+sum+<span class="string">&quot;，平均值是&quot;</span>+sum/sign);</span><br><span class="line">	    s.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-选择分支"><a href="#2-选择分支" class="headerlink" title="2.选择分支"></a>2.选择分支</h2><h3 id="if选择分支"><a href="#if选择分支" class="headerlink" title="if选择分支"></a>if选择分支</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入内容：&quot;</span>);</span><br><span class="line">		String str = s.nextLine();</span><br><span class="line">		<span class="comment">// equals:用于判断字符串是否相等，与==不一样，少用==判断</span></span><br><span class="line">		<span class="keyword">if</span>(s.equals(<span class="string">&quot;hello&quot;</span>))&#123;</span><br><span class="line">			System.out.println(str);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;End!&quot;</span>);</span><br><span class="line">	    s.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/cb72181d/image-20210226180441511.png" alt="image-20210226180441511"></p>
<h3 id="switch选择分支"><a href="#switch选择分支" class="headerlink" title="switch选择分支"></a>switch选择分支</h3><p><img src="/posts/cb72181d/image-20210226180716484.png" alt="image-20210226180716484"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">char</span> grade = <span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (grade)&#123;<span class="comment">// 大致同C++</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:<span class="comment">// case语句有穿透效果，用break跳出</span></span><br><span class="line">                System.out.println(<span class="string">&quot;优秀&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">            	System.out.println(<span class="string">&quot;良好&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            	System.out.println(<span class="string">&quot;挂科&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            	System.out.println(<span class="string">&quot;未知&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;<span class="comment">// JDK7的新特性，switch支持string字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-循环结构"><a href="#3-循环结构" class="headerlink" title="3.循环结构"></a>3.循环结构</h2><p>包括while，do-while和for循环，break和continue跳出循环。大致语法结构与C++相同。</p>
<p>在JDK5中引入了一种主要用于数组的增强型for循环。</p>
<p>关于goto，它是java的保留字，但是并没有得到正式使用。</p>
<p><img src="/posts/cb72181d/image-20210226184655016.png" alt="image-20210226184655016"></p>
<p><img src="/posts/cb72181d/image-20210226185120597.png" alt="image-20210226185120597"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x:nums)&#123;<span class="comment">// 增强for循环，遍历数组中的元素</span></span><br><span class="line">			System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4 5 6</span></span><br></pre></td></tr></table></figure>

<h2 id="4-Java中的方法"><a href="#4-Java中的方法" class="headerlink" title="4.Java中的方法"></a>4.Java中的方法</h2><p><img src="/posts/cb72181d/image-20210226190359631.png" alt="image-20210226190359631"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">		System.out.println(sum);<span class="comment">// 3</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="comment">// static修饰，可以直接在main方法中使用</span></span><br><span class="line">		<span class="keyword">return</span> a+b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/cb72181d/image-20210226191028284.png" alt="image-20210226191028284"></p>
<p><img src="/posts/cb72181d/image-20210226191746005.png" alt="image-20210226191746005"></p>
<p>记住：<strong>Java中的方法都是值传递</strong>。<strong>其实 Java 只存在一种传参的方式，就是用实参给形参赋值。</strong></p>
<h2 id="5-方法的重载（非常重要）"><a href="#5-方法的重载（非常重要）" class="headerlink" title="5.方法的重载（非常重要）"></a>5.方法的重载（非常重要）</h2><p><img src="/posts/cb72181d/image-20210226195152023.png" alt="image-20210226195152023"></p>
<p>方法重载基本类似C++中的函数重载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum1 = add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">double</span> sum2 = add(<span class="number">1.0</span>,<span class="number">2.0</span>);</span><br><span class="line">		<span class="keyword">double</span> sum3 = add(<span class="number">1</span>,<span class="number">2.0</span>);</span><br><span class="line">		System.out.println(sum1);</span><br><span class="line">		System.out.println(sum2);</span><br><span class="line">		System.out.println(sum3);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a+b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a+b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">// 注意：仅仅返回类型不同不足以成为方法的重载，要求参数列表必须不同</span></span><br><span class="line"><span class="comment">//必须参数类型不同，名字相同也不行</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/cb72181d/image-20210403104515242.png" alt="image-20210403104515242"></p>
<p>重载的特殊之处在于：如果参数满足自动类型转换的方法有好几个，重载规则是选择最近的调用。</p>
<p>比如：int add(int a)和int add(double b)，如果传入byte,short,int类型的参数a，会调用第一个，传入float,double类型的参数a会调用第二个。自己写的话最好避免这样的情况。</p>
<h2 id="6-给main函数传参"><a href="#6-给main函数传参" class="headerlink" title="6.给main函数传参"></a>6.给main函数传参</h2><h3 id="6-1通过命令行传参"><a href="#6-1通过命令行传参" class="headerlink" title="6.1通过命令行传参"></a>6.1通过命令行传参</h3><p><img src="/posts/cb72181d/image-20210226195848316.png" alt="image-20210226195848316"></p>
<p>上图中<code>String args[]</code>意思同<code>String[] args</code>，前者是类C的写法，后者是Java写法。</p>
<p><img src="/posts/cb72181d/image-20210226200420492.png" alt="image-20210226200420492"></p>
<p>注意：要通过java命令运行放在package中的class文件，必须回退到包的路径（此处是src目录）。</p>
<p>通过java命令给main方法传递参数”this is…”，并打印参数。</p>
<h3 id="6-2通过IDEA传参"><a href="#6-2通过IDEA传参" class="headerlink" title="6.2通过IDEA传参"></a>6.2通过IDEA传参</h3><p><img src="/posts/cb72181d/image-20210403162513517.png" alt="image-20210403162513517"></p>
<p><img src="/posts/cb72181d/image-20210403162656746.png" alt="image-20210403162656746"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输出：</span><br><span class="line"><span class="number">4</span></span><br><span class="line">anb</span><br><span class="line"><span class="number">123</span></span><br><span class="line">qw sd df</span><br><span class="line">王小明</span><br></pre></td></tr></table></figure>

<h2 id="7-可变参数（不定项参数）"><a href="#7-可变参数（不定项参数）" class="headerlink" title="7.可变参数（不定项参数）"></a>7.可变参数（不定项参数）</h2><p><img src="/posts/cb72181d/image-20210226200859067.png" alt="image-20210226200859067"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">		demo.test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);<span class="comment">// 2</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>... i)</span></span>&#123;</span><br><span class="line">		System.out.println(i[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-数组"><a href="#8-数组" class="headerlink" title="8.数组"></a>8.数组</h2><p>数组是引用数据类型。数组的长度是固定的，一旦创建就不能修改。</p>
<p><img src="/posts/cb72181d/image-20210226202658385.png" alt="image-20210226202658385"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] num1;<span class="comment">// 1.首选声明方法</span></span><br><span class="line">		num1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];<span class="comment">// 定义，存放10个int型数字		</span></span><br><span class="line">		<span class="keyword">int</span> num2[];<span class="comment">// 2.</span></span><br><span class="line">		<span class="keyword">int</span>[] num3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">12</span>];<span class="comment">// 3.</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; num1.length;i ++)&#123;</span><br><span class="line">			num1[i] = i+<span class="number">1</span>;<span class="comment">// 赋值</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x: num1)&#123;</span><br><span class="line">			System.out.println(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/cb72181d/image-20210226204957419.png" alt="image-20210226204957419"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">// 静态初始化:创建 +赋值</span></span><br><span class="line">		<span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line">		<span class="comment">// 动态初始化：包含默认初始化</span></span><br><span class="line">		<span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">		b[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/cb72181d/image-20210226205614686.png" alt="image-20210226205614686"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arrays = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span>[] result = reverse(arrays);</span><br><span class="line">		printArray(result);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 打印数组</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arrays)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> array:arrays)&#123;</span><br><span class="line">			System.out.println(array);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 翻转数组</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] reverse(<span class="keyword">int</span>[] arrays)&#123;</span><br><span class="line">		<span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[arrays.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,j = result.length-<span class="number">1</span>;i &lt; arrays.length;i++,j--)&#123;</span><br><span class="line">			result[j] = arrays[i];</span><br><span class="line">		&#125;</span><br><span class="line"> 		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>多维数组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[][] array = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line">		System.out.println(array[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-内存分析"><a href="#9-内存分析" class="headerlink" title="9.内存分析"></a>9.内存分析</h2><p><img src="/posts/cb72181d/image-20210226204256773.png" alt="image-20210226204256773"></p>
<p>数组的内存机制：</p>
<p>1.声明数组array，存放于栈中；</p>
<p>2.创建数组array，在堆中开辟空间。(<strong>数组对象本身是在堆中的</strong>)</p>
<p><img src="/posts/cb72181d/image-20210226204804592.png" alt="image-20210226204804592"></p>
<h2 id="10-Arrays类"><a href="#10-Arrays类" class="headerlink" title="10.Arrays类"></a>10.Arrays类</h2><p><img src="/posts/cb72181d/image-20210227113849263.png" alt="image-20210227113849263"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">// Arrays类中的方法都是通过类名调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">67</span>,<span class="number">345</span>,<span class="number">2</span>,<span class="number">456</span>,<span class="number">67</span>,<span class="number">45</span>&#125;;</span><br><span class="line">		<span class="comment">// 打印数组元素：Arrays.toString</span></span><br><span class="line">		System.out.println(Arrays.toString(a));</span><br><span class="line">		</span><br><span class="line">		Arrays.sort(a);<span class="comment">// 对数组排序，从小到大</span></span><br><span class="line">		System.out.println(Arrays.toString(a));</span><br><span class="line">		</span><br><span class="line">		Arrays.fill(a, <span class="number">0</span>);<span class="comment">// 将数组全部用0填充</span></span><br><span class="line">		System.out.println(Arrays.toString(a));</span><br><span class="line">		Arrays.fill(a, <span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>);<span class="comment">// 将数组（左闭右开）下标2~4全部用1填充</span></span><br><span class="line">		System.out.println(Arrays.toString(a));</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（九）</title>
    <url>/posts/2969f165.html</url>
    <content><![CDATA[<h2 id="1-万类之祖：Object类"><a href="#1-万类之祖：Object类" class="headerlink" title="1.万类之祖：Object类"></a>1.万类之祖：Object类</h2><p><strong>所有的类，都间接或者直接的继承自Object 类。</strong></p>
<p><strong>数组属于引用类型，也是继承自Object 类。</strong></p>
<p>Object 类没有成员变量，只有一些成员方法。</p>
<p>注意：hashCode和equals方法基本面试必考！！！</p>
<span id="more"></span>

<p>Object getClass() 方法用于获取对象的运行时对象的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunoobTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 创建 RunoobTest 类的对象</span></span><br><span class="line">        RunoobTest obj = <span class="keyword">new</span> RunoobTest();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// RunoobTest 继承 Object 类，Object 是所有类的超类</span></span><br><span class="line">        <span class="comment">// 调用 getClass() 方法</span></span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//class RunoobTest</span></span><br></pre></td></tr></table></figure>

<p><strong>Object toString() 方法</strong>用于返回对象的字符串表示形式。对于有数据的类，常用 toString() 方法展示数据内容。</p>
<p>当输出对象s时，会调用toString() 方法。唯一的一点区别就是：若对象是null时，打印s显示null（保护机制，避免异常），而打印s.toString()会出现NullPointerException。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子演示</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Circle&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;radius=&quot;</span> + radius +</span><br><span class="line">                <span class="string">&quot;, color=&#x27;&quot;</span> + color + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>默认返回格式：<strong>对象的 class 名称 + @ + hashCode 的十六进制字符串</strong>。</p>
<p>Object hashCode() 方法用于获取对象的 hash 值。</p>
<p>返回对象哈希值，是一个整数，表示在哈希表中的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunoobTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// toString() with Object</span></span><br><span class="line">        Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line">        System.out.println(obj1.toString());</span><br><span class="line">        Object obj2 = <span class="keyword">new</span> Object();</span><br><span class="line">        System.out.println(obj2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.lang.Object@d716361</span></span><br><span class="line"><span class="comment">//1878246837</span></span><br></pre></td></tr></table></figure>

<p>Object equals() 方法用于比较两个对象是否相等。</p>
<p>equals() 方法比较两个对象，是判断两个对象引用指向的是同一个对象，即比较 2 个对象的内存地址是否相等。</p>
<p><strong>注意：</strong>如果子类重写了 equals() 方法，就需要重写hashCode()方法，比如 String 类就重写了 equals() 方法，同时也重写了 hashCode() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunoobTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Object 类使用 equals() 方法</span></span><br><span class="line">        <span class="comment">// 创建两个对象</span></span><br><span class="line">        Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line">        Object obj2 = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 判断 obj1 与 obj2 是否相等</span></span><br><span class="line">        <span class="comment">// 不同对象，内存地址不同，不相等，返回 false</span></span><br><span class="line">        System.out.println(obj1.equals(obj2)); <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// obj1 赋值给 obj3</span></span><br><span class="line">        <span class="comment">// String 重写了 equals() 方法</span></span><br><span class="line">        <span class="comment">// 对象引用，内存地址相同，相等，返回 true</span></span><br><span class="line">        Object obj3 = obj1;</span><br><span class="line">        System.out.println(obj1.equals(obj3)); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p><strong>hashCode和equals是我们最常覆盖的两个方法。</strong></p>
<p>覆盖的原则：equals是true，hashCode就应该相等，这是一种约定俗成的规范。</p>
<p>即equals为true是hashCode相等的充分非必要条件，hashCode相等是equals为true的必要不充分条件。</p>
<p>在IDEA中，右键–&gt;Generate，可以选择生成hashCode和equals方法。</p>
<p><strong>自动生成</strong>的equals方法比自己手动写要更准确，手动可能存在漏洞。</p>
<p><strong>以后直接自动生成就行。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> MerchandiseV2)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        MerchandiseV2 that = (MerchandiseV2) o;</span><br><span class="line">        <span class="comment">// 判断成员变量等是否相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getCount() == that.getCount() &amp;&amp;</span><br><span class="line">                Double.compare(that.getSoldPrice(), getSoldPrice()) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                Double.compare(that.getPurchasePrice(), getPurchasePrice()) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getName().equals(that.getName()) &amp;&amp;</span><br><span class="line">                getId().equals(that.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(getName(), getId(), getCount(), getSoldPrice(), getPurchasePrice());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>用“==”不能判断两个对象是否相等，只能判断两个引用是否指向同一个对象。</p>
<p><img src="/posts/2969f165/image-20210404113052887.png" alt="image-20210404113052887"></p>
<h2 id="2-判断String类是否相等"><a href="#2-判断String类是否相等" class="headerlink" title="2.判断String类是否相等"></a>2.判断String类是否相等</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;aaabbb&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String s2 = <span class="string">&quot;aaa&quot;</span> + <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt; TODO 说好的每次创建一个新的String对象呢？</span></span><br><span class="line">        System.out.println(<span class="string">&quot;s1和s2用==判断结果：&quot;</span>+(s1 == s2));</span><br><span class="line">		<span class="comment">// 是因为Java对String的优化，发现有一样的String，就直接返回</span></span><br><span class="line">        System.out.println(<span class="string">&quot;s1和s2用 equals 判断结果：&quot;</span>+(s1.equals(s2)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt; TODO 打乱Java对String的的优化，再试试看</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入s1&quot;</span>);</span><br><span class="line">        s1 = scanner.nextLine();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入s2&quot;</span>);</span><br><span class="line">        s2 = scanner.nextLine();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;s1和s2用==判断结果：&quot;</span>+(s1 == s2));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;s1和s2用 equals 判断结果：&quot;</span>+(s1.equals(s2)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*s1和s2用==判断结果：true</span></span><br><span class="line"><span class="comment">s1和s2用 equals 判断结果：true</span></span><br><span class="line"><span class="comment">请输入s1</span></span><br><span class="line"><span class="comment">acsde</span></span><br><span class="line"><span class="comment">请输入s2</span></span><br><span class="line"><span class="comment">acsde</span></span><br><span class="line"><span class="comment">s1和s2用==判断结果：false</span></span><br><span class="line"><span class="comment">s1和s2用 equals 判断结果：true*/</span></span><br></pre></td></tr></table></figure>

<h2 id="3-Class类"><a href="#3-Class类" class="headerlink" title="3.Class类"></a>3.Class类</h2><p>Class类是代表类的类。</p>
<p>每个Class类的实例，都代表了一个类。</p>
<p><code>getName()</code> 来产生完整（带包名）的类名，使用 <code>getSimpleName()</code> 产生不带包名的类名。</p>
<h2 id="4-JUnit单元测试"><a href="#4-JUnit单元测试" class="headerlink" title="4.JUnit单元测试"></a>4.JUnit单元测试</h2><p>先讲讲什么是单元测试？</p>
<p>IDEA为Java类创建JUnit单元测试。</p>
<p><img src="/posts/2969f165/image-20210404125900225.png" alt="image-20210404125900225"></p>
<p><img src="/posts/2969f165/image-20210404131222019.png" alt="image-20210404131222019"></p>
<p>此时的Java类要求：① 此类是public的  ②此类提供公共的无参的构造器</p>
<ul>
<li><p>此类中声明单元测试方法。</p>
<p>此时的单元测试方法：方法的权限是public,没有返回值，没有形参</p>
</li>
<li><p>此单元测试方法上需要<strong>声明注解：@Test</strong>,并在单元测试类中导入：import org.junit.Test;（不同版本junit可能导入不一样）</p>
</li>
<li><p>声明好单元测试方法以后，就可以在方法体内测试相关的代码。</p>
</li>
<li><p>写完代码以后，左键双击单元测试方法名，右键：run as - JUnit Test</p>
</li>
<li><p>说明：</p>
</li>
<li><p>1.如果执行结果没有任何异常：绿条</p>
</li>
<li><p>2.如果执行结果出现异常：红条</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（二）</title>
    <url>/posts/866cbb4f.html</url>
    <content><![CDATA[<h2 id="1-IDEA快捷键"><a href="#1-IDEA快捷键" class="headerlink" title="1.IDEA快捷键"></a>1.IDEA快捷键</h2><p>psvm：<code>public static void main(String[] args)</code></p>
<p>sout：<code>System.out.println(&quot;&quot;)</code></p>
<p>ctrl + D：复制当前行到下一行</p>
<p>Alt + Insert：生成构造器，get/set方法</p>
<span id="more"></span>

<h2 id="2-HelloWorld"><a href="#2-HelloWorld" class="headerlink" title="2.HelloWorld"></a>2.HelloWorld</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;hello world!&quot;</span>);<span class="comment">// print line</span></span><br><span class="line">		System.out.print(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-数据类型扩展"><a href="#3-数据类型扩展" class="headerlink" title="3.数据类型扩展"></a>3.数据类型扩展</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.整数扩展</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">010</span>,i2 = <span class="number">10</span>,i3 = <span class="number">0x10</span>;</span><br><span class="line">		System.out.println(i);<span class="comment">// 八进制0，以0开头的就是八进制</span></span><br><span class="line">		System.out.println(i2);<span class="comment">// 十进制，默认</span></span><br><span class="line">		System.out.println(i3);<span class="comment">// 十六进制0x</span></span><br><span class="line">        <span class="comment">// 二进制0b</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 8 10 16 */</span></span><br><span class="line"><span class="comment">// 2.浮点数扩展</span></span><br><span class="line"><span class="comment">// 最好完全避免使用浮点数进行比较，因为存在精度丢失！！！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.字符扩展</span></span><br><span class="line"><span class="comment">// 所有字符本质还是数字</span></span><br><span class="line"><span class="comment">// java中采用Unicode编码字符char，2字节，0~65536(2^16)，对应16进制Unicode字符U0000~UFFFF</span></span><br><span class="line"><span class="comment">//Java 中的 char 类型之所以占 2 个字节，是因为 Java 使用的是 Unicode 字符集而不是 ASCII 字符集</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">char</span> c1 = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">		<span class="keyword">char</span> c2 = <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">        <span class="keyword">char</span> c3 = <span class="string">&#x27;\u0061&#x27;</span>;<span class="comment">// 采用十六进制，对应十进制下的97，即a</span></span><br><span class="line">		System.out.println(c1);</span><br><span class="line">		System.out.println((<span class="keyword">int</span>)c1);</span><br><span class="line">		System.out.println(c2);</span><br><span class="line">		System.out.println((<span class="keyword">int</span>)c2);</span><br><span class="line">        System.out.println(c3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*A</span></span><br><span class="line"><span class="comment">65</span></span><br><span class="line"><span class="comment">中</span></span><br><span class="line"><span class="comment">20013</span></span><br><span class="line"><span class="comment">a*/</span></span><br></pre></td></tr></table></figure>

<h2 id="4-类型转换"><a href="#4-类型转换" class="headerlink" title="4.类型转换"></a>4.类型转换</h2><p>整型、实型（常量）、字符型数据可以混合运算。运算中，<strong>不同类型的数据先转化为同一类型，然后进行运算</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">低  ------------------------------------&gt;  高</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>,<span class="keyword">short</span>,<span class="keyword">char</span>—&gt; <span class="keyword">int</span> —&gt; <span class="keyword">long</span>—&gt; <span class="keyword">float</span> —&gt; <span class="keyword">double</span> </span><br></pre></td></tr></table></figure>

<p>数据类型转换必须满足如下规则：</p>
<ul>
<li><p>不能对boolean类型进行类型转换。</p>
</li>
<li><p>不能把对象类型转换成不相关类的对象。</p>
</li>
<li><p> 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</p>
</li>
</ul>
<h3 id="4-1-强制类型转换：从高级到低级"><a href="#4-1-强制类型转换：从高级到低级" class="headerlink" title="4.1 强制类型转换：从高级到低级"></a>4.1 强制类型转换：从高级到低级</h3><ul>
<li>条件是转换的数据类型必须是兼容的。</li>
<li>格式：<code>(type)value</code>是要强制类型转换后的数据类型</li>
</ul>
<p>隐含的强制类型转换：</p>
<ul>
<li>整数的默认类型是 int。</li>
<li>浮点型不存在这种情况，因为在定义 float 类型时必须在数字后面跟上 F 或者 f，浮点数的默认类型是double。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = <span class="number">10_0000_0000</span>;</span><br><span class="line"><span class="keyword">int</span> years = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">long</span> total1 = m*years;<span class="comment">// 右边是int型，溢出</span></span><br><span class="line"><span class="keyword">long</span> total2 = m*(<span class="keyword">long</span>)years;<span class="comment">// 右边是long型，溢出</span></span><br><span class="line">System.out.println(total1);</span><br><span class="line">System.out.println(total2);</span><br><span class="line"><span class="comment">/*-1474836480  溢出</span></span><br><span class="line"><span class="comment">20000000000*/</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：强制类型转换过程中可能导致溢出或损失精度</strong>，例如：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i =<span class="number">128</span>;   </span><br><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)i;<span class="comment">// b = -128,内存溢出</span></span><br></pre></td></tr></table></figure>

<p>  因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。</p>
<ul>
<li><p>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">int</span>)<span class="number">23.7</span> == <span class="number">23</span>;        </span><br><span class="line">(<span class="keyword">int</span>)-<span class="number">45.89f</span> == -<span class="number">45</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-2自动类型转换：从低级到高级"><a href="#4-2自动类型转换：从低级到高级" class="headerlink" title="4.2自动类型转换：从低级到高级"></a>4.2自动类型转换：从低级到高级</h3><p>必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。</p>
<p>char不能自动转换为short，因为它们都是2字节，但是char是无符号数，在正数范围超过了short。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 补充</span></span><br><span class="line"><span class="comment">// JDK7新特性，数字之间可以用下划线分隔</span></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">10_0000_0000</span>;</span><br><span class="line">System.out.println(m);</span><br></pre></td></tr></table></figure>

<h2 id="5-class的属性"><a href="#5-class的属性" class="headerlink" title="5.class的属性"></a>5.class的属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="comment">// 属性：先简单理解为变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//类变量，静态变量 static</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> salary = <span class="number">2500</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实例变量，成员变量，在类的里面，方法体之外，从属于对象</span></span><br><span class="line">    String name;<span class="comment">//如果不自行初始化，默认为</span></span><br><span class="line">    <span class="keyword">int</span> age;<span class="comment">//如果不自行初始化，默认为0 0.0</span></span><br><span class="line">    <span class="comment">// boolean默认为false，除了基本类型，其余默认值都是null</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//main方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//局部变量:必须声明和初始化值</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        </span><br><span class="line">        Demo demo = <span class="keyword">new</span> Demo();<span class="comment">// 创建对象demo</span></span><br><span class="line">        System.out.println(demo.age);<span class="comment">// 0</span></span><br><span class="line">        System.out.println(demo.name);<span class="comment">// null</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(salary);<span class="comment">// 类变量可以直接打印</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-常量"><a href="#6-常量" class="headerlink" title="6.常量"></a>6.常量</h2><p>常量确定后在程序运行过程中不允许修改。</p>
<p>语法格式：<code>final 常量名 = 值</code></p>
<p><code>final double PI = 3.14159</code> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类变量</span></span><br><span class="line"><span class="comment">// static,final都是修饰符，不区分先后顺序</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>

<h2 id="7-变量命名规范（再次强调）"><a href="#7-变量命名规范（再次强调）" class="headerlink" title="7.变量命名规范（再次强调）"></a>7.变量命名规范（再次强调）</h2><p>1.变量，方法名：monthSalary，Run()，首字母小写和驼峰命名原则，除第一个单词以外后面单词首字母大写。</p>
<p>2.常量：MAX_VALUE，大写字母和下划线。</p>
<p>3.类名：GoodMan，首字母大写和驼峰命名原则。</p>
<h2 id="8-Java运算符"><a href="#8-Java运算符" class="headerlink" title="8.Java运算符"></a>8.Java运算符</h2><p>大部分同C++。</p>
<p><img src="/posts/866cbb4f/image-20210226144639115.png" alt="image-20210226144639115"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> a = <span class="number">121415531646L</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">234</span>;</span><br><span class="line"><span class="keyword">short</span> c = <span class="number">23</span>;</span><br><span class="line"><span class="keyword">byte</span> d = <span class="number">4</span>;</span><br><span class="line">System.out.println(a+b+c+d);<span class="comment">// long,运算中有long结果就是long</span></span><br><span class="line">System.out.println(b+c+d);<span class="comment">// int,运算中无long结果就是int</span></span><br><span class="line">System.out.println(c+d);<span class="comment">// int,运算中无long结果就是int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 幂运算，Math是自带的工具类</span></span><br><span class="line"><span class="keyword">double</span> pow = Math.pow(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">// Math.pow()返回double型</span></span><br><span class="line">System.out.println(pow);</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串连接符 + ,String，只要+两边有至少一个String就能运算</span></span><br><span class="line"><span class="keyword">int</span> a =<span class="number">10</span>;<span class="comment">// Srting必须用双引号</span></span><br><span class="line"><span class="keyword">int</span> b =<span class="number">20</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>+a+b);<span class="comment">// 1020</span></span><br><span class="line">System.out.println(a+b+<span class="string">&quot;&quot;</span>);<span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三元运算符,同C++</span></span><br><span class="line"><span class="number">2</span> &lt; <span class="number">3</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>

<h2 id="9-Package包机制"><a href="#9-Package包机制" class="headerlink" title="9.Package包机制"></a>9.Package包机制</h2><p><u>为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间，防止命名空间重复。</u></p>
<p>右键新建Package，将class文件拖入Package，方便程序管理，相当于文件夹的作用。</p>
<p><img src="/posts/866cbb4f/image-20210226145141548.png" alt="image-20210226145141548"></p>
<p><img src="/posts/866cbb4f/image-20210226152120269.png" alt="image-20210226152120269"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demo</span></span><br><span class="line"><span class="keyword">package</span> com.cnblogs.www.conyoo;<span class="comment">// 注意包语句必须放在class文件最上面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blog</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">import</span> com.kunag.base.*; <span class="comment">// 导入该包中的所有类</span></span><br></pre></td></tr></table></figure>

<h2 id="10-JavaDoc生成文档"><a href="#10-JavaDoc生成文档" class="headerlink" title="10.JavaDoc生成文档"></a>10.JavaDoc生成文档</h2><p><img src="/posts/866cbb4f/image-20210226153609818.png" alt="image-20210226153609818"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Java_01;</span><br><span class="line"><span class="comment">/** 类的注释</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> grant drew</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 方法的注释</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> grant drew</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception</span>&#123;<span class="comment">// 只是演示，不需要深入理解</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>javadoc命令：生成API文档。</p>
<p><code>jvadoc -sncoding UTF-8 -charset UTF-8 Doc.java</code></p>
<p>index.html即生成的帮助文档首页。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（五）</title>
    <url>/posts/13c1c43f.html</url>
    <content><![CDATA[<h2 id="1-方法重写（覆盖）（非常重要）"><a href="#1-方法重写（覆盖）（非常重要）" class="headerlink" title="1.方法重写（覆盖）（非常重要）"></a>1.方法重写（覆盖）（非常重要）</h2><p>又被称为方法覆盖，override</p>
<p><strong>覆盖才是继承的精髓和终极奥义</strong></p>
<p>记住：重写是方法的重写，和属性无关</p>
<p>覆盖：通过使用和父类方法签名一样，而且返回值也必须一样的方法，可以让子类覆盖掉父类的方法</p>
<p>如果方法签名一样，但返回值不同，会报错</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B=&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A=&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.test();<span class="comment">//A</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态方法的调用只与左边定义的数据类型有关</span></span><br><span class="line">        <span class="comment">// 父类的引用指向了子类</span></span><br><span class="line">        B b = <span class="keyword">new</span> A();</span><br><span class="line">        b.test();<span class="comment">//B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*A=&gt;test()</span></span><br><span class="line"><span class="comment">B=&gt;test()*/</span></span><br></pre></td></tr></table></figure>

<p>test方法去掉static修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B=&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Override 重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A=&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态方法与非静态方法区别很大！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.test();</span><br><span class="line"></span><br><span class="line">        B b = <span class="keyword">new</span> A();<span class="comment">// 子类重写了父类的方法</span></span><br><span class="line">        <span class="comment">// 重写只与非静态方法有关</span></span><br><span class="line">        b.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*A=&gt;test()</span></span><br><span class="line"><span class="comment">A=&gt;test()*/</span></span><br></pre></td></tr></table></figure>

<p>静态方法是类的方法，而非静态方法是对象的方法。</p>
<p>在demo1中，b是A new出来的对象，所以调用A的方法test。</p>
<blockquote>
<p><strong>重写的关键字只能是public，不能是static或者private，子类继承父类才有重写</strong></p>
</blockquote>
<p>重写：（IDEA快捷键：Alt + Insert：override）</p>
<ul>
<li>需要有继承关系，子类重写父类的方法！</li>
<li>方法名必须相同</li>
<li>参数列表必须相同</li>
<li>修饰符：范围可以扩大但不能缩小，<code>public &gt; porotected &gt; default &gt; private</code></li>
<li>抛出的异常：范围可以缩小但不能扩大，例：<code>ClassNotFoundException(小)--&gt;Exception(大)</code></li>
</ul>
<p>-为什么需要重写？</p>
<p>-父类的功能，子类不一定需要或不一定满足！</p>
<p>-什么方法不能重写？</p>
<ol>
<li>static方法：它属于类，不属于实例（对象）</li>
<li>final 常量</li>
<li>private方法</li>
</ol>
<h2 id="2-多态（重要）"><a href="#2-多态（重要）" class="headerlink" title="2.多态（重要）"></a>2.多态（重要）</h2><p><img src="/posts/13c1c43f/image-20210305195037264.png" alt="image-20210305195037264"></p>
<p>多态注意事项：</p>
<ol>
<li>多态是方法的多态，属性没有多态</li>
<li>必须是父类与子类间的继承关系</li>
<li>存在条件：继承关系，方法需要重写，<strong>父类引用指向子类对象！</strong></li>
<li>一个Person类既可以引用Person类型的对象，也可以引用Person类的任何一个子类的对象</li>
<li>可以调用哪些方法，取决于引用类型是什么，具体调用哪个方法，取决于对象所属的类是什么</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于同一方法run有不同的行为</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;<span class="comment">// 方法覆盖，体现了多态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;son&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一个对象的实现类型是确定的</span></span><br><span class="line">        <span class="comment">// 如new Student();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 但是可以指向的引用类型就不确定了</span></span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="comment">// Student能调用的方法都是自己的或者继承父类的！</span></span><br><span class="line">        <span class="comment">//父类的引用指向子类的对象</span></span><br><span class="line">        Person s2 = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="comment">//Person可以指向子类，但是不能调用子类独有的方法，只能重写</span></span><br><span class="line">        Object s3 = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象能执行哪些方法，主要看左边的类型，与右边关系不大</span></span><br><span class="line">        s2.run();<span class="comment">//子类重写父类的方法，执行子类的方法</span></span><br><span class="line">        <span class="comment">//s2.eat(); 无法重写，报错</span></span><br><span class="line">        s1.run();</span><br><span class="line">        s1.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当父类的引用指向子类的实例，只能通过父类的引用，像父类一样操作子类的对象</strong>，也就是说左边“名”的类型，决定了能执行哪些操作（调用哪些方法…）。</p>
<p>总结：无论一个方法是使用哪个引用被调用的，”它都是在实际的对象上执行的”。执行的任何一个方法，都是这个对象所属的类的方法。如果没有，就去父类找，再没有，就去父类的父类找，依次寻找，直到找到。那么自然的，即使是在继承自父类的代码里，去调用一个方法，也是先从子类开始，一层层继承关系的找。这也是Java选择单继承的重要原因之一。在多继承的情况下，如果使用不当，多态可能会非常复杂，以至于使用的代价超过其带来的好处。</p>
<p>在这里我再总结一下这三个模式。</p>
<p>1）父类引用指向子类对象，<strong>可以调用只在父类中的方法</strong>（继承） 2）父类引用指向子类对象，<strong>可以调用子类覆盖了父类的方法</strong>（覆盖，多态） 3）父类引用指向子类对象，在1）和2）这两种情况下。如果这个方法的代码中又调用了别的方法，那么还是会遵循这个规则。举个例子，如果父类中有m1，m2两个方法。子类覆盖了m2方法。那么如果调用m1，则m1中调用的m2会是子类中定义的m2。</p>
<h2 id="3-instanceof和类型转换"><a href="#3-instanceof和类型转换" class="headerlink" title="3.instanceof和类型转换"></a>3.instanceof和类型转换</h2><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>instanceof 是 Java 的一个二元操作符，类似于 ==，&gt;，&lt; 等操作符。</p>
<p>它的作用是测试它左边的对象是否是它右边的类（或子类）的实例，返回 boolean 的数据类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Object &gt; Person &gt; Student</span></span><br><span class="line">        <span class="comment">// Object &gt; Person &gt; Teacher</span></span><br><span class="line">        <span class="comment">// Object &gt; String</span></span><br><span class="line">        Object object = <span class="keyword">new</span> Student();<span class="comment">//注意object是Student类的对象</span></span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Student);<span class="comment">//true</span></span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Person);<span class="comment">//true</span></span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Object);<span class="comment">//true</span></span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Teacher);<span class="comment">//false</span></span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> String);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>System.out.println(x instanceof Y);</code>能不能编译（无关对错）通过取决于x指向的类型是不是与Y有继承·关系。</p>
<p>如果引用时null，肯定返回false。</p>
<p><strong>“is-a”规则</strong></p>
<p>用来判断是否应该将数据设计为继承关系，它指出子类的每个对象也是父类的对象。</p>
<p>例如：将Student类设计为Person类的子类，因为“Student is a Person”。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ol>
<li><strong>父类引用指向子类的对象，不能反过来</strong></li>
<li>把子类转换为父类，向上转型</li>
<li>把父类转换为子类，向下转型，强制转换，<strong>只能在继承关系下进行强制转换</strong></li>
<li>方便方法的调用，减少重复代码</li>
<li>在将父类强制类型转换成子类之前，应该使用instanceof进行检查</li>
<li>一般情况下，最好尽量少使用强制转换和instanceof</li>
<li>父类若转换为子类，父类引用必须指向的是一个子类对象。实质上是将一个指向子类对象的父类引用改为了子类引用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注:Person是Student的父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 类型之间的转换（高到低）：父  子</span></span><br><span class="line">        Person s = <span class="keyword">new</span> Student();<span class="comment">//低 --&gt; 高，自动转换</span></span><br><span class="line">        <span class="comment">//将s这个对象转换为Student类型，就可以使用Student类方法</span></span><br><span class="line">        Student obj = (Student)s;<span class="comment">//高 --&gt; 低，强制类型转换</span></span><br><span class="line">        obj.go();</span><br><span class="line">        <span class="comment">//上面两行等价于((Student)s).go();</span></span><br><span class="line"></span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        Person person = student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所谓强制转型（转自CSDN）</strong></p>
<ul>
<li><p>你没有改变对象，只是改变了引用而已</p>
</li>
<li><p>父类引用不能访问子类方法</p>
<p>所以当你用父类引用指向子类对象时，不能访问子类的方法</p>
<p>而当你转回子类引用指向子类对象时，又可以访问子类方法了</p>
</li>
<li><p>记住，这个过程中对象一直没变过，一直都是那个子类对象，变的只是引用</p>
</li>
</ul>
<h2 id="4-static关键字"><a href="#4-static关键字" class="headerlink" title="4.static关键字"></a>4.static关键字</h2><p>静态方法里面只能调用静态的东西，而main函数也是静态的。</p>
<p><img src="/posts/13c1c43f/image-20210502090403539.png" alt="image-20210502090403539"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2.</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;匿名代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.只执行一次</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 3.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*静态代码块</span></span><br><span class="line"><span class="comment">匿名代码块</span></span><br><span class="line"><span class="comment">构造方法*/</span></span><br></pre></td></tr></table></figure>

<p>小例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态导入包</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		System.out.println(random());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-抽象类（不是重点"><a href="#5-抽象类（不是重点" class="headerlink" title="5.抽象类（不是重点)"></a>5.抽象类（不是重点)</h2><p><img src="/posts/13c1c43f/image-20210305220537625.png" alt="image-20210305220537625"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// abstract 抽象类</span></span><br><span class="line"><span class="comment">// Java类是单继承的，但是接口可以多继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="comment">//抽象方法，只有方法名字，没有方法的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//1.不能new这个抽象类，只能靠子类去实现它</span></span><br><span class="line">    <span class="comment">//2.抽象类中可以写普通方法</span></span><br><span class="line">    <span class="comment">//3.抽象方法必须在抽象类中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类的所有方法，继承它的子类都必须要实现它的方法，除非它也是抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 注解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.不能new这个抽象类，只能靠子类去实现它</p>
<p>2.抽象类中可以写普通方法</p>
<p>3.抽象方法必须在抽象类中</p>
<h2 id="6-接口（重要）"><a href="#6-接口（重要）" class="headerlink" title="6.接口（重要）"></a>6.接口（重要）</h2><p>Java通过接口来实现C++中多继承的效果。</p>
<p>接口和类是两个并列的结构。</p>
<p><img src="/posts/13c1c43f/image-20210305222342257.png" alt="image-20210305222342257"></p>
<p><img src="/posts/13c1c43f/image-20210502111638626.png" alt="image-20210502111638626"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//interface修饰接口，接口都需要实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//接口中的所有定义其实都是抽象的，默认为public abstract</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(String name)</span></span>;<span class="comment">// public abstract void run(String name);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TimeService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">timer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类可以通过implements实现接口</span></span><br><span class="line"><span class="comment">// 实现接口的类，需要重写接口中的所有方法</span></span><br><span class="line"><span class="comment">// 利用接口实现多继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span>,<span class="title">TimeService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接口作用</strong></p>
<ol>
<li>约束</li>
<li>定义一些方法，让不同的人实现</li>
<li>接口中方法默认用<code>public abstract</code>修饰</li>
<li>接口中属性默认用<code>public static final</code>修饰，也即静态常量</li>
<li>接口不能被实例化，接口中没有构造方法</li>
<li>接口中定义的静态方法只能通过接口来调用</li>
<li>通过实现类的对象，可以调用接口的default方法</li>
<li>通过implements可以实现多个接口</li>
<li>必须要重写接口中的方法</li>
</ol>
<h2 id="7-N种内部类"><a href="#7-N种内部类" class="headerlink" title="7.N种内部类"></a>7.N种内部类</h2><p><img src="/posts/13c1c43f/image-20210306112110052.png" alt="image-20210306112110052"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是外部类的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是内部类的方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//内部类可以获得外部类的私有属性</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getID</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        <span class="comment">// 通过外部类来实例化内部类</span></span><br><span class="line">        Outer.Inner inner = outer.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">        inner.in();<span class="comment">//这是内部类的方法</span></span><br><span class="line">        inner.getID();<span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个java类中可以有多个class类，但是只能有一个public class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下小例子只作为扩展眼界，不必深究。</p>
<p>小例子1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//局部内部类</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小例子2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//没有名字初始化类，不用将实例保存到变量中</span></span><br><span class="line">        <span class="keyword">new</span> Apple().eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 成员内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">D</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-属性访问修饰符"><a href="#8-属性访问修饰符" class="headerlink" title="8.属性访问修饰符"></a>8.属性访问修饰符</h2><p><img src="/posts/13c1c43f/image-20210403100049939.png" alt="image-20210403100049939"></p>
<p><img src="/posts/13c1c43f/image-20210403100119985.png" alt="image-20210403100119985"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（八）</title>
    <url>/posts/53a4d03a.html</url>
    <content><![CDATA[<h2 id="1-System类不简单"><a href="#1-System类不简单" class="headerlink" title="1.System类不简单"></a>1.System类不简单</h2><span id="more"></span>

<p><img src="/posts/53a4d03a/image-20210403163004447.png" alt="image-20210403163004447"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LearnSystem</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startMS = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> endMS = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;程序执行使用了几个毫秒？&quot;</span> + (endMS - startMS));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startNS = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        counter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> endNS = System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;程序执行使用了几个纳秒？&quot;</span> + (endNS - startNS));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一般常用毫米</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">程序执行使用了几个毫秒？0</span></span><br><span class="line"><span class="comment">程序执行使用了几个纳秒？7600*/</span></span><br></pre></td></tr></table></figure>

<p><code>System.currentTimeMillis()</code> 返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">currentTimeMillis</span><span class="params">()</span> <span class="comment">// 返回long</span></span></span><br></pre></td></tr></table></figure>

<h2 id="2-String类的好兄弟：StringBuilder"><a href="#2-String类的好兄弟：StringBuilder" class="headerlink" title="2.String类的好兄弟：StringBuilder"></a>2.String类的好兄弟：StringBuilder</h2><p>它是一个非常方便用于拼接和处理字符串的类，它和String不同在于<strong>它是可变的</strong>。</p>
<p>这对“好兄弟”的关系有点像C++中的string类和vector。</p>
<p><strong>StringBuffer</strong> 与<strong>StringBuilder</strong>类似。 </p>
<p><strong>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</strong></p>
<p><strong>String、StringBuffer、StringBuilder三者的对比</strong></p>
<ul>
<li><code>String</code>:不可变的字符序列；底层使用char[]存储</li>
<li><code>StringBuffer</code>:可变的字符序列；线程安全的，效率低；底层使用char[]存储</li>
<li><code>StringBuilder</code>:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；底层使用char[]存储</li>
</ul>
<p>虽然可以直接拼接String字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率。</p>
<p>为了能高效拼接字符串，Java标准库提供了<code>StringBuilder</code>，它是一个可变对象，可以预分配缓冲区，这样，往<code>StringBuilder</code>中新增字符时，不会创建新的临时对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//StringBuilder首先是可变的</span></span><br><span class="line">        <span class="comment">//而且对它进行操作的方法，都会返回this自引用。这样我们就可以一直点下去，对String进行构造。</span></span><br><span class="line">        StringBuilder strBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">long</span> longVal = <span class="number">123456789</span>;</span><br><span class="line">	<span class="comment">//StringBuilder sb = new StringBuilder(&quot;Run&quot;);// 可以传入参数</span></span><br><span class="line">        <span class="comment">//StringBuilder sb = new StringBuilder(10);// 初始长度为10，可以一直append</span></span><br><span class="line">    </span><br><span class="line">        strBuilder.append(<span class="keyword">true</span>).append(<span class="string">&quot;abc&quot;</span>).append(longVal);</span><br><span class="line"></span><br><span class="line">        System.out.println(strBuilder.toString());<span class="comment">// 转换为String对象</span></span><br><span class="line">        System.out.println(strBuilder.reverse().toString());<span class="comment">//反转</span></span><br><span class="line">        System.out.println(strBuilder.reverse().toString());</span><br><span class="line">        System.out.println(strBuilder.toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(strBuilder.delete(<span class="number">0</span>, <span class="number">4</span>).toString());<span class="comment">// 左闭右开</span></span><br><span class="line"></span><br><span class="line">        System.out.println(strBuilder.insert(<span class="number">3</span>,<span class="string">&quot;LLLLL&quot;</span>).toString());<span class="comment">// 放在索引为3的位置</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/53a4d03a/image-20210502145658876.png" alt="image-20210502145658876"></p>
<p><img src="/posts/53a4d03a/image-20210502145722353.png" alt="image-20210502145722353"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常用方法</span></span><br><span class="line">增：append(xxx)</span><br><span class="line">删：delete(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span><br><span class="line">改：setCharAt(<span class="keyword">int</span> n ,<span class="keyword">char</span> ch) / replace(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span><br><span class="line">查：charAt(<span class="keyword">int</span> n )</span><br><span class="line">插：insert(<span class="keyword">int</span> offset, xxx)</span><br><span class="line">长度：length();</span><br><span class="line">*遍历：<span class="keyword">for</span>() + charAt() / toString()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>append、reverse、delete和insert均不会创建新对象，直接在原对象上修改。</p>
</blockquote>
<h2 id="3-多态里更多的语法"><a href="#3-多态里更多的语法" class="headerlink" title="3.多态里更多的语法"></a>3.多态里更多的语法</h2><p>静态多态：重载（Overload）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重载调用哪个方法，和参数的引用类型相关，和引用实际指向的类型无关</span></span><br><span class="line">merchandiseTest.testMerchandiseOverload(m);</span><br><span class="line">merchandiseTest.testMerchandiseOverload((Phone) m);</span><br><span class="line">merchandiseTest.testMerchandiseOverload((ShellColorChangePhone) m);</span><br><span class="line"><span class="comment">//甚至是个null也可以，但是要用强制类型转换，告诉Java这个类型是什么，否则找不到一个唯一的方法去调用</span></span><br><span class="line"><span class="comment">// 重载的参数类型，相同位置，不一定要有继承或者兼容的关系，完全free style</span></span><br><span class="line"><span class="comment">//如果引用类型没有完全匹配的，则会根据继承关系，沿着参数当前类型，向下撸       </span></span><br><span class="line">merchandiseTest.testMerchandiseOverloadNotExactlyMatchType((ShellColorChangePhone) <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>重载总结：静态多态，调用的方法和参数实际指向的对象无关，只和引用本身的类型相关。</p>
<p>因为调用时参数类型是确定的，所以，在编译期间就可以明确的知道哪个方法会被调用。如果有多种可能，则会有编译错误</p>
<p>如果没有类型完全匹配的候选，则根据类型的继承关系向下撸着找。找到最贴近参数类型的那个方法</p>
<p>无论是静态方法，还是成员方法，重载寻找方法的顺序是一样的，在这里就不赘述了</p>
<p>动态多态：覆盖（Override）</p>
<h2 id="4-继承专属的访问控制符"><a href="#4-继承专属的访问控制符" class="headerlink" title="4.继承专属的访问控制符"></a>4.继承专属的访问控制符</h2><p>protected 可见性= default + 对子类可见</p>
<p>子类覆盖父类的方法，不可以使用可见性更低的修饰符，但可以使用可见性更高的修饰符。</p>
<h2 id="5-final修饰符"><a href="#5-final修饰符" class="headerlink" title="5.final修饰符"></a>5.final修饰符</h2><p>final意为最终的。不可变！！不需要再扩充功能了，已经够用了。</p>
<p><img src="/posts/53a4d03a/image-20210404091023201.png" alt="image-20210404091023201"></p>
<p>我们常用的String类就是用final修饰的，不能被随意修改。</p>
<p>final修饰变量，也就成了常量，必须在定义时初始化，或在构造器里初始化，且不能修改。</p>
<p>final修饰static变量，必须在定义时初始化，或在<code>static&#123;&#125;</code>代码块里赋值。</p>
<p>final修饰父类的方法，确保不会被子类覆盖。</p>
<p><strong>final不能修饰构造方法！</strong></p>
<p>final修饰的类不可被继承：比如：String类、System类、StringBuffer类。</p>
<p><strong>final修饰引用</strong>：不能修改令引用指向别的对象，但是可以修改引用指向的对象。</p>
<p>这就有C语言的常量指针内味了，不可修改指针的指向，但能修改指针指向的值。</p>
<p>注：常量指针与指向常量的指针不一样！</p>
<h2 id="6-继承里的静态方法"><a href="#6-继承里的静态方法" class="headerlink" title="6.继承里的静态方法"></a>6.继承里的静态方法</h2><p>静态方法可以被继承，方法签名和返回值必须一样。</p>
<p>用引用调用（即用对象）静态方法不会被覆盖，不推荐这样调用，应该用类名调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">m.staticMethod();</span><br><span class="line">((Phone) m).staticMethod(); <span class="comment">// 会调用对应对象的方法</span></span><br><span class="line">((ShellColorChangePhone) m).staticMethod();</span><br><span class="line"><span class="comment">// TODO 有些东西，学会就应该马上忘掉，比如上面使用引用调用静态方法的内容</span></span><br><span class="line">((MerchandiseV2) <span class="keyword">null</span>).staticMethod();</span><br><span class="line">((Phone) <span class="keyword">null</span>).staticMethod(); <span class="comment">// 会调用对应对象的方法</span></span><br><span class="line">((ShellColorChangePhone) <span class="keyword">null</span>).staticMethod();</span><br><span class="line"><span class="comment">// TODO 有些东西，学会就应该马上忘掉，比如上面使用有类型的null引用调用静态方法的内容</span></span><br></pre></td></tr></table></figure>

<h2 id="7-for-each循环"><a href="#7-for-each循环" class="headerlink" title="7.for-each循环"></a>7.for-each循环</h2><p>语法基本同C++/Python中的类似写法，循环对象必须是一个数组或者一个实现了Iterable接口的类对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="comment">//forEach写法（效果跟下面同等）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i:arr)</span><br><span class="line">	System.out.println(<span class="string">&quot;数组元素:&quot;</span>+i);</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（十一）</title>
    <url>/posts/a2f332aa.html</url>
    <content><![CDATA[<h2 id="1-类的结构：代码块（初始化块）"><a href="#1-类的结构：代码块（初始化块）" class="headerlink" title="1.类的结构：代码块（初始化块）"></a>1.类的结构：代码块（初始化块）</h2><ol>
<li>代码块的作用：用来初始化类、对象的信息</li>
<li>分类：静态代码块 VS 非静态代码块</li>
<li>代码块要是使用修饰符，只能使用static</li>
</ol>
<span id="more"></span>

<p>静态代码块：</p>
<ul>
<li><p>内部可以输出语句</p>
</li>
<li><p>随着<strong>类的加载而执行</strong>,而且只执行一次</p>
</li>
<li><p>作用：初始化类的信息</p>
</li>
<li><p>静态方法也随着类的加载而加载，但是不执行</p>
</li>
<li><p>如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行</p>
</li>
<li><p>静态代码块的执行要优先于非静态代码块的执行</p>
</li>
<li><p>静态代码块内只能调用静态的属性、静态的方法，<strong>不能</strong>调用<strong>非静态</strong>的结构</p>
</li>
</ul>
<p>非静态代码块：</p>
<ul>
<li>内部可以输出语句</li>
<li>随着<strong>对象的创建</strong>而执行</li>
<li>每创建一个对象，就执行一次非静态代码块</li>
<li>作用：可以在创建对象时，对对象的属性等进行初始化</li>
<li>如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行</li>
<li>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</li>
</ul>
<p><img src="/posts/a2f332aa/image-20210502102003114.png" alt="image-20210502102003114"></p>
<p><img src="/posts/a2f332aa/image-20210502102122061.png" alt="image-20210502102122061"></p>
<p><strong>总结：由父及子，静态先行。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">成员变量赋值顺序</span><br><span class="line"> * ①默认初始化</span><br><span class="line"> * ②显式初始化/⑤在代码块中赋值，看先后顺序</span><br><span class="line"> * ③构造器中初始化</span><br><span class="line"> * ④有了对象以后，可以通过<span class="string">&quot;对象.属性&quot;</span>或<span class="string">&quot;对象.方法&quot;</span>的方式，进行赋值</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * 执行的先后顺序：① - ② / ⑤ - ③ - ④</span><br></pre></td></tr></table></figure>

<h2 id="2-抽象类的应用：模板方法设计模式"><a href="#2-抽象类的应用：模板方法设计模式" class="headerlink" title="2.抽象类的应用：模板方法设计模式"></a>2.抽象类的应用：模板方法设计模式</h2><p><img src="/posts/a2f332aa/image-20210502105438764.png" alt="image-20210502105438764"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SubTemplate t = <span class="keyword">new</span> SubTemplate();</span><br><span class="line">        t.spendTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板方法设计模式的一个应用案例</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span></span>&#123;</span><br><span class="line">    <span class="comment">// 计算某段代码执行时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spendTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        code(); <span class="comment">// 不确定部分</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间是：&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubTemplate</span> <span class="keyword">extends</span> <span class="title">Template</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">1000</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> isFlag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>;j &lt;= Math.sqrt(i);j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i % j == <span class="number">0</span>)&#123;</span><br><span class="line">                    isFlag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isFlag)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-时间日期API"><a href="#3-时间日期API" class="headerlink" title="3.时间日期API"></a>3.时间日期API</h2><p><img src="/posts/a2f332aa/image-20210502150445942.png" alt="image-20210502150445942"></p>
<p><img src="/posts/a2f332aa/image-20210502151051302.png" alt="image-20210502151051302"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JunitTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// JDK8之前的日期和时间API</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//返回1970年XXX到现在的时间差，时间戳形式</span></span><br><span class="line">        System.out.println(start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//构造器1：Date()，对应当前时间的Date对象</span></span><br><span class="line">        Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(date1.toString());</span><br><span class="line">        System.out.println(date1.getTime());<span class="comment">// 返回毫秒数,时间戳</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造器2：Date(long Date)</span></span><br><span class="line">        Date date2 = <span class="keyword">new</span> Date(<span class="number">1619941526721L</span>);<span class="comment">//记得加L</span></span><br><span class="line">        System.out.println(date2.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建java.sql.Date对象，它是java.util.Date的子类</span></span><br><span class="line">        java.sql.Date date3 = <span class="keyword">new</span> java.sql.Date(<span class="number">1619941526721L</span>);</span><br><span class="line">        System.out.println(date3.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将java.util.Date对象转换为java.sql.Date对象</span></span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        Date date4 = <span class="keyword">new</span> java.sql.Date(<span class="number">1619941526721L</span>);</span><br><span class="line">        java.sql.Date date5 = (java.sql.Date) date4;</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        Date date6 = <span class="keyword">new</span> Date();</span><br><span class="line">        java.sql.Date date7 = <span class="keyword">new</span> java.sql.Date(date6.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-java-text-SimpleDataFormat类"><a href="#4-java-text-SimpleDataFormat类" class="headerlink" title="4.java.text.SimpleDataFormat类"></a>4.java.text.SimpleDataFormat类</h2><p>SimpleDateFormat对日期Date类的格式化和解析</p>
<ul>
<li>两个操作<ul>
<li>格式化：日期 —&gt;字符串</li>
<li>解析：格式化的逆过程，字符串 —&gt; 日期</li>
</ul>
</li>
<li>SimpleDateFormat的实例化:new + 构造器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat sdf1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">//格式化</span></span><br><span class="line">String format1 = sdf1.format(date);</span><br><span class="line">System.out.println(format1);<span class="comment">//2019-02-18 11:48:27</span></span><br><span class="line"><span class="comment">//解析:要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现),</span></span><br><span class="line"><span class="comment">//否则，抛异常</span></span><br><span class="line">Date date2 = sdf1.parse(<span class="string">&quot;2020-02-18 11:48:27&quot;</span>);</span><br><span class="line">System.out.println(date2);</span><br></pre></td></tr></table></figure>

<h2 id="5-Calendar类：日历类、抽象类"><a href="#5-Calendar类：日历类、抽象类" class="headerlink" title="5.Calendar类：日历类、抽象类"></a>5.Calendar类：日历类、抽象类</h2><p>它是抽象类，所以不能实例化。</p>
<p><img src="/posts/a2f332aa/image-20210502160622844.png" alt="image-20210502160622844"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCalendar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//实例化</span></span><br><span class="line">        <span class="comment">//1.创建子类GregorianCalendar的对象</span></span><br><span class="line">        <span class="comment">//2.调用其静态方法getInstance()，方便记忆</span></span><br><span class="line">        Calendar calendar = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//常用方法</span></span><br><span class="line">        <span class="comment">//get方法获取常用的属性信息</span></span><br><span class="line">        <span class="keyword">int</span> days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(days);</span><br><span class="line">        System.out.println(calendar.get(Calendar.DAY_OF_WEEK));</span><br><span class="line">        <span class="comment">//set修改信息</span></span><br><span class="line">        calendar.set(Calendar.DAY_OF_MONTH,<span class="number">19</span>);</span><br><span class="line">        <span class="keyword">int</span> day = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(day);</span><br><span class="line">        <span class="comment">//add追加信息</span></span><br><span class="line">        calendar.add(Calendar.DAY_OF_MONTH,<span class="number">2</span>);</span><br><span class="line">        day = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(day);</span><br><span class="line">        <span class="comment">//getTime():日历类---&gt;Date</span></span><br><span class="line">        Date date = calendar.getTime();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">        <span class="comment">//setTime():Date---&gt;日历类</span></span><br><span class="line">        Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">        calendar.setTime(date1);</span><br><span class="line">        System.out.println(calendar.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（六）</title>
    <url>/posts/76cf8fe6.html</url>
    <content><![CDATA[<h2 id="Java异常机制（Exception）"><a href="#Java异常机制（Exception）" class="headerlink" title="Java异常机制（Exception）"></a>Java异常机制（Exception）</h2><span id="more"></span>

<p><img src="/posts/76cf8fe6/image-20210306125425820.png" alt="image-20210306125425820"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//小例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> A().a();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        b();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Exception in thread &quot;main&quot; java.lang.StackOverflowError 栈溢出</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/76cf8fe6/image-20210306130118928.png" alt="image-20210306130118928"></p>
<p><img src="/posts/76cf8fe6/image-20210306130155892.png" alt="image-20210306130155892"></p>
<h3 id="错误（Error）与异常（Exception）"><a href="#错误（Error）与异常（Exception）" class="headerlink" title="错误（Error）与异常（Exception）"></a>错误（Error）与异常（Exception）</h3><p><img src="/posts/76cf8fe6/image-20210306130317211.png" alt="image-20210306130317211"></p>
<p><img src="/posts/76cf8fe6/image-20210306130400193.png" alt="image-20210306130400193"></p>
<p>Exception可以分成运行时异常和非运行时异常。</p>
<p>以上理论只作为了解内容，重点是如何处理异常。</p>
<h3 id="异常处理（抛出与捕获）"><a href="#异常处理（抛出与捕获）" class="headerlink" title="异常处理（抛出与捕获）"></a>异常处理（抛出与捕获）</h3><p><img src="/posts/76cf8fe6/image-20210306130827800.png" alt="image-20210306130827800"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//try监控区域</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(a/b);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ArithmeticException e)&#123;</span><br><span class="line">            <span class="comment">//catch用于捕获异常</span></span><br><span class="line">            System.out.println(<span class="string">&quot;程序异常，变量b不能为0&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//处理善后工作，无论是否异常都会执行</span></span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//try-catch代码块是必要的</span></span><br><span class="line">        <span class="comment">//finally不是必须的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">new</span> Test().a();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            <span class="comment">//catch(想要捕获的异常类型)</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        b();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try-catch…-catch结构：一般把较大的异常放在后面。</p>
<p>假设要捕获多个异常，必须从小到大，否则会报错！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(a/b);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Error e)&#123;</span><br><span class="line">            <span class="comment">//catch用于捕获异常</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Throwable&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//处理善后工作，无论是否异常都会执行</span></span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//try-catch代码块是必要的</span></span><br><span class="line">        <span class="comment">//finally不是必须的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IDEA异常处理快捷键：</p>
<p><img src="/posts/76cf8fe6/image-20210306132935760.png" alt="image-20210306132935760"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> Test().test(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//假设这个方法处理不了这个异常，就从方法上抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> ArithmeticException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException();<span class="comment">//主动抛出异常，一般在方法中使用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/76cf8fe6/image-20210306135620960.png" alt="image-20210306135620960"></p>
<p><strong>异常处理的一般经验</strong>：捕获那些你知道如何处理的异常，继续传播（抛出）那些不知道如何处理的异常。</p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>大部分情况下，我们不需要自定义异常。</p>
<p><img src="/posts/76cf8fe6/image-20210306135807062.png" alt="image-20210306135807062"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义的异常类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="comment">//传递数字&gt;10抛出异常</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> detail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.detail = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//toString:异常的打印信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyException&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;detail=&quot;</span> + detail +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可能会存在异常的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">throws</span> MyException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;传递的参数为：&quot;</span>+a);</span><br><span class="line">        <span class="keyword">if</span> (a&gt;<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyException(a);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//传递的参数为：1 OK</span></span><br><span class="line">            test(<span class="number">11</span>);</span><br><span class="line">            <span class="comment">//传递的参数为：11 MyException=&gt;MyException&#123;detail=11&#125;</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyException=&gt;&quot;</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/76cf8fe6/image-20210306143205863.png" alt="image-20210306143205863"></p>
<p>IDEA代码出现波浪线（一些异常等），按住Alt + Enter进行处理。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>异常</tag>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（十三）</title>
    <url>/posts/dffb7d20.html</url>
    <content><![CDATA[<h2 id="1-BigInteger类和BigDecimal类"><a href="#1-BigInteger类和BigDecimal类" class="headerlink" title="1.BigInteger类和BigDecimal类"></a>1.BigInteger类和BigDecimal类</h2><p><img src="/posts/dffb7d20/image-20210502211408301.png" alt="image-20210502211408301"></p>
<span id="more"></span>

<p><img src="/posts/dffb7d20/image-20210502211423255.png" alt="image-20210502211423255"></p>
<p><img src="/posts/dffb7d20/image-20210502211432078.png" alt="image-20210502211432078"></p>
<h2 id="2-枚举类的使用"><a href="#2-枚举类的使用" class="headerlink" title="2.枚举类的使用"></a>2.枚举类的使用</h2><p>JDK1.5之前自定义枚举类了解就行。</p>
<ul>
<li><p>重点掌握JDK1.5的新特性，enum关键字定义枚举类。</p>
</li>
<li><p>类的对象只有有限个，确定的。</p>
</li>
<li><p>当需要定义一组常量时，强烈建议使用枚举类。</p>
</li>
<li><p>若枚举只有一个对象 , 则可以作为一种<strong>单例模式</strong>的实现方式。</p>
</li>
</ul>
<p><img src="/posts/dffb7d20/image-20210503090139873.png" alt="image-20210503090139873"></p>
<p>看看就行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//enum关键字定义枚举类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeasonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Season summer = Season.SUMMER;</span><br><span class="line">        System.out.println(summer);<span class="comment">//SUMMER，无需重写toString</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义的枚举类默认继承于java.lang.Enum类</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season</span></span>&#123;</span><br><span class="line">    <span class="comment">//提供当前枚举类的对象，之间用&quot;,&quot;隔开，&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>),<span class="comment">//默认为private final</span></span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>);</span><br><span class="line">    <span class="comment">//声明Season对象的四有属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="comment">//私有化类的构造器，并给属性赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他诉求，获取对象属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/dffb7d20/image-20210503091556341.png" alt="image-20210503091556341"></p>
<p><img src="/posts/dffb7d20/image-20210503091617899.png" alt="image-20210503091617899"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Season[] values = Season.values();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; values.length;i++)&#123;</span><br><span class="line">        System.out.println(values[i].toString());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;____________________________&quot;</span>);</span><br><span class="line">    <span class="comment">//valueOf(String objname)，返回枚举类中对象名是objname的对象</span></span><br><span class="line">    Season winter = Season.valueOf(<span class="string">&quot;WINTER&quot;</span>);</span><br><span class="line">    System.out.println(winter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*SPRING</span></span><br><span class="line"><span class="comment">SUMMER</span></span><br><span class="line"><span class="comment">AUTUMN</span></span><br><span class="line"><span class="comment">WINTER</span></span><br><span class="line"><span class="comment">____________________________</span></span><br><span class="line"><span class="comment">WINTER*/</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/dffb7d20/image-20210503092548552.png" alt="image-20210503092548552"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个枚举值分别实现同一个接口方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeasonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Season season1 = Season.SUMMER;</span><br><span class="line">        Season season2 = Season.SPRING;</span><br><span class="line">        Season season3 = Season.AUTUMN;</span><br><span class="line">        season1.show();</span><br><span class="line">        season2.show();</span><br><span class="line">        season3.show();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*summer</span></span><br><span class="line"><span class="comment">spring</span></span><br><span class="line"><span class="comment">autumn*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义的枚举类默认继承于java.lang.Enum类</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season</span> <span class="keyword">implements</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="comment">//提供当前枚举类的对象，之间用&quot;,&quot;隔开，&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;spring&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;summer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;autumn&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;winter&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//声明Season对象的四有属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="comment">//私有化类的构造器，并给属性赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他诉求，获取对象属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-注解-Annotation）"><a href="#3-注解-Annotation）" class="headerlink" title="3.注解 (Annotation）"></a>3.注解 (Annotation）</h2><p><img src="/posts/dffb7d20/image-20210503093537140.png" alt="image-20210503093537140"></p>
<p>一定程度上可以说： <strong>框架 = 注解 + 反射 + 设计模式</strong>。</p>
<p><img src="/posts/dffb7d20/image-20210503093702587.png" alt="image-20210503093702587"></p>
<p><strong>自定义Annotation</strong>：</p>
<p><img src="/posts/dffb7d20/image-20210503094509895.png" alt="image-20210503094509895"></p>
<p><img src="/posts/dffb7d20/image-20210503094431440.png" alt="image-20210503094431440"></p>
<p>没有成员定义的 Annotation 称为 <strong>标记</strong> ，包含成员变量的 Annotation 称为<strong>元数据</strong> Annotation</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注解声明为@interface</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">//内部定义成员，通常使用value表示</span></span><br><span class="line">    <span class="comment">//可以指定成员的默认值，使用default定义</span></span><br><span class="line">    <span class="comment">//自定义注解必须使用反射才有意义</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;string&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>元注解：注解其他注解的注解</p>
<p><img src="/posts/dffb7d20/image-20210503095742361.png" alt="image-20210503095742361"></p>
<p><img src="/posts/dffb7d20/image-20210503095819473.png" alt="image-20210503095819473"></p>
<p>默认为CLASS。<img src="/posts/dffb7d20/image-20210503095906860.png" alt="image-20210503095906860"></p>
<p><img src="/posts/dffb7d20/image-20210503095953225.png" alt="image-20210503095953225"></p>
<p><strong>自定义注解一般会指明以上两个元注解：Retention、Target。</strong></p>
<p>下面两个用到频率较低。</p>
<p><img src="/posts/dffb7d20/image-20210503100238905.png" alt="image-20210503100238905"></p>
<p>Java 8对注解处理提供了两点改进： <strong>可重复的注解</strong> 及 <strong>可用于类型的注解</strong> 。此外，反射也得到了加强，在 </p>
<p>Java8 中能够得到方法参数的名称。这会简化标注在方法参数上的注解。</p>
<p><img src="/posts/dffb7d20/image-20210503101428719.png" alt="image-20210503101428719"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（十二）</title>
    <url>/posts/92e5de72.html</url>
    <content><![CDATA[<h2 id="1-JDK8中新日期时间API"><a href="#1-JDK8中新日期时间API" class="headerlink" title="1.JDK8中新日期时间API"></a>1.JDK8中新日期时间API</h2><p>日期时间API的迭代</p>
<p>第一代：jdk 1.0 Date类</p>
<p>第二代：jdk 1.1 Calendar类，一定程度上替换Date类</p>
<p>第三代：jdk 1.8 提出了新的一套API</p>
<p>前两代存在的问题举例</p>
<p>可变性：像日期和时间这样的类应该是不可变的。</p>
<p>偏移性：Date中的年份是从1900开始的，而月份都从0开始。</p>
<p>格式化：格式化只对Date用，Calendar则不行。</p>
<p>此外，它们也不是线程安全的；不能处理闰秒等。</p>
<span id="more"></span>

<p><img src="/posts/92e5de72/image-20210502163607157.png" alt="image-20210502163607157"></p>
<p><img src="/posts/92e5de72/image-20210502164631141.png" alt="image-20210502164631141"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">APITest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// LocalDate、LocalTime、LocalDateTime的使用</span></span><br><span class="line">        LocalDate localdate = LocalDate.now();<span class="comment">//根基当前时间创建对象</span></span><br><span class="line">        LocalTime localtime = LocalTime.now();</span><br><span class="line">        <span class="comment">//LocalDateTime用的较多</span></span><br><span class="line">        LocalDateTime localdatetime = LocalDateTime.now();</span><br><span class="line">        System.out.println(localdate);</span><br><span class="line">        System.out.println(localtime);</span><br><span class="line">        System.out.println(localdatetime);</span><br><span class="line">        <span class="comment">//根据指定时间创建对象</span></span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.of(<span class="number">2021</span>,<span class="number">3</span>,<span class="number">31</span>,<span class="number">15</span>,<span class="number">25</span>,<span class="number">45</span>);</span><br><span class="line">        System.out.println(localDateTime);</span><br><span class="line">        <span class="comment">//getXxx()获取对象信息</span></span><br><span class="line">        System.out.println(localDateTime.getDayOfMonth());</span><br><span class="line">        System.out.println(localDateTime.getDayOfWeek());</span><br><span class="line">        System.out.println(localDateTime.getMonth());</span><br><span class="line">        System.out.println(localDateTime.getMonthValue());</span><br><span class="line">        <span class="comment">//withXxx()修改信息并返回新的对象，体现不可变性</span></span><br><span class="line">        LocalDate localDate = localdate.withDayOfMonth(<span class="number">4</span>);</span><br><span class="line">        System.out.println(localDate);</span><br><span class="line">        System.out.println(localdate);</span><br><span class="line">        <span class="comment">//plusXxx(),minusXxx()对当前对象加减相应时间，体现不可变性</span></span><br><span class="line">        LocalDateTime localDateTime1 = localDateTime.plusDays(<span class="number">12</span>);</span><br><span class="line">        System.out.println(localDateTime);</span><br><span class="line">        System.out.println(localDateTime1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/92e5de72/image-20210502193652086.png" alt="image-20210502193652086"></p>
<p>Instant类，时间戳。</p>
<p><img src="/posts/92e5de72/image-20210502193732034.png" alt="image-20210502193732034"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">APITest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//now()获取本初子午线对应的标准时间</span></span><br><span class="line">        Instant instant = Instant.now();</span><br><span class="line">        System.out.println(instant);</span><br><span class="line">        <span class="comment">//2021-05-02T11:41:52.974Z</span></span><br><span class="line">        <span class="comment">//添加时间偏移量</span></span><br><span class="line">        OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(<span class="number">5</span>));</span><br><span class="line">        System.out.println(offsetDateTime);</span><br><span class="line">        <span class="comment">//2021-05-02T16:41:52.974+05:00</span></span><br><span class="line">        <span class="comment">//获取自1970年对应的毫秒数</span></span><br><span class="line">        <span class="keyword">long</span> milli = instant.toEpochMilli();</span><br><span class="line">        System.out.println(milli);</span><br><span class="line">        <span class="comment">//返回毫秒数对应的Instant对象</span></span><br><span class="line">        Instant instant1 = Instant.ofEpochMilli(<span class="number">1619956303369L</span>);</span><br><span class="line">        System.out.println(instant1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/92e5de72/image-20210502195424494.png" alt="image-20210502195424494"></p>
<h2 id="2-Java比较器（重要）"><a href="#2-Java比较器（重要）" class="headerlink" title="2.Java比较器（重要）"></a>2.Java比较器（重要）</h2><p>利用比较器对多个对象进行排序。</p>
<p>Java 实现对象排序的方式有两种：</p>
<ul>
<li><p>自然排序： java.lang.Comparable</p>
</li>
<li><p>定制排序： java.util.Comparator</p>
</li>
</ul>
<p><img src="/posts/92e5de72/image-20210502201039171.png" alt="image-20210502201039171"></p>
<p>重写compareTo()方法的<strong>一般规则</strong>如上图蓝色字体。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String name, <span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Goods&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//指明排序方,价格从低到高排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">            Goods goods = (Goods)o;</span><br><span class="line">            <span class="comment">//方法1</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.price &gt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.price &lt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//涉及到String类和包装类的比较建议就直接用实现好的方法</span></span><br><span class="line">            <span class="comment">//方法2，包装类中的compare</span></span><br><span class="line">            <span class="comment">//return Integer.compare(this.price,goods.price);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;传入的数据类型不一致！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompareTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Comparable接口的使用举例</span></span><br><span class="line">        <span class="comment">//像String、包装类等实现了Comparable接口，重写了compareTo()方法</span></span><br><span class="line">        <span class="comment">//给出了比较两个对象大小的方式</span></span><br><span class="line">        String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;As&quot;</span>,<span class="string">&quot;cd&quot;</span>,<span class="string">&quot;sd1&quot;</span>,<span class="string">&quot;12&quot;</span>&#125;;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        <span class="comment">//自定义类实现Comparable接口</span></span><br><span class="line">        <span class="comment">//在compareTo(obj)指明如何排序</span></span><br><span class="line">        Goods[] goods = <span class="keyword">new</span> Goods[<span class="number">4</span>];</span><br><span class="line">        goods[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;xiaomi&quot;</span>,<span class="number">19</span>);</span><br><span class="line">        goods[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;lenovo&quot;</span>,<span class="number">25</span>);</span><br><span class="line">        goods[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;apple&quot;</span>,<span class="number">199</span>);</span><br><span class="line">        goods[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;dell&quot;</span>,<span class="number">35</span>);</span><br><span class="line">        Arrays.sort(goods);</span><br><span class="line">        System.out.println(Arrays.toString(goods));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*[12, As, cd, sd1]</span></span><br><span class="line"><span class="comment">[Goods&#123;name=&#x27;xiaomi&#x27;, price=19&#125;, Goods&#123;name=&#x27;lenovo&#x27;, price=25&#125;, Goods&#123;name=&#x27;dell&#x27;, price=35&#125;, Goods&#123;name=&#x27;apple&#x27;, price=199&#125;]*/</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/92e5de72/image-20210502204316839.png" alt="image-20210502204316839"></p>
<p>接上面例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompareTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;As&quot;</span>,<span class="string">&quot;cd&quot;</span>,<span class="string">&quot;sd1&quot;</span>,<span class="string">&quot;12&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//从大到小排序</span></span><br><span class="line">        Arrays.sort(arr,<span class="keyword">new</span> Comparator()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1,Object o2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> String &amp;&amp; o2 <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">                    String s1 = (String)o1;</span><br><span class="line">                    String s2 = (String)o2;</span><br><span class="line">                    <span class="keyword">return</span> -s1.compareTo(s2);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;传入的数据类型不一致！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        Goods[] goods = <span class="keyword">new</span> Goods[<span class="number">4</span>];</span><br><span class="line">        goods[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;xiaomi&quot;</span>,<span class="number">19</span>);</span><br><span class="line">        goods[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;lenovo&quot;</span>,<span class="number">25</span>);</span><br><span class="line">        goods[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;xiaomi&quot;</span>,<span class="number">199</span>);</span><br><span class="line">        goods[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;dell&quot;</span>,<span class="number">35</span>);</span><br><span class="line">        <span class="comment">//先按名称从低到高，再按价格从高到低排序</span></span><br><span class="line">        Arrays.sort(goods,<span class="keyword">new</span> Comparator()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1,Object o2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Goods &amp;&amp; o2 <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">                    Goods g1 = (Goods)o1;</span><br><span class="line">                    Goods g2 = (Goods)o2;</span><br><span class="line">                    <span class="keyword">if</span> (g1.getName().equals(g2.getName()))&#123;</span><br><span class="line">                        <span class="keyword">return</span> -Integer.compare(g1.getPrice(),g2.getPrice());</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> g1.getName().compareTo(g2.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;传入的数据类型不一致！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(goods));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*[sd1, cd, As, 12]</span></span><br><span class="line"><span class="comment">[Goods&#123;name=&#x27;dell&#x27;, price=35&#125;, Goods&#123;name=&#x27;lenovo&#x27;, price=25&#125;, Goods&#123;name=&#x27;xiaomi&#x27;, price=199&#125;, Goods&#123;name=&#x27;xiaomi&#x27;, price=19&#125;]*/</span></span><br></pre></td></tr></table></figure>

<p>比较</p>
<ul>
<li>Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小。</li>
<li>Comparator接口属于临时性的比较。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（十）</title>
    <url>/posts/ac5bd4a1.html</url>
    <content><![CDATA[<h2 id="1-包装类-Wrapper-的使用"><a href="#1-包装类-Wrapper-的使用" class="headerlink" title="1.包装类 (Wrapper) 的使用"></a>1.包装类 (Wrapper) 的使用</h2><span id="more"></span>

<p><img src="/posts/ac5bd4a1/image-20210404124237876.png" alt="image-20210404124237876"></p>
<p><img src="/posts/ac5bd4a1/image-20210404132608185.png" alt="image-20210404132608185"></p>
<p>包装类的重点就在于基本数据类型、包装类和String类之间的转换。</p>
<p><strong>重点记住：自动装/拆箱，parseXXX()/valueOf()。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本数据类型--&gt;包装类：调用包装类的构造器</span></span><br><span class="line"><span class="meta">@org</span>.junit.jupiter.api.Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    Integer in1 = <span class="keyword">new</span> Integer(num1);</span><br><span class="line">    System.out.println(in1.toString());</span><br><span class="line"></span><br><span class="line">    Integer in2 = <span class="keyword">new</span> Integer(<span class="string">&quot;1234&quot;</span>);</span><br><span class="line">    System.out.println(in2);<span class="comment">// 输出对象默认调用toString</span></span><br><span class="line"></span><br><span class="line">    Float f1 = <span class="keyword">new</span> Float(<span class="string">&quot;123.34F&quot;</span>);</span><br><span class="line">    System.out.println(f1);</span><br><span class="line">    Float f2 = <span class="keyword">new</span> Float(<span class="string">&quot;234&quot;</span>);</span><br><span class="line">    System.out.println(f2);</span><br><span class="line"></span><br><span class="line">    Boolean b1 = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);<span class="comment">//true</span></span><br><span class="line">    System.out.println(b1);</span><br><span class="line">    Boolean b2 = <span class="keyword">new</span> Boolean(<span class="string">&quot;TRue12&quot;</span>);<span class="comment">//false，不会报错</span></span><br><span class="line">    System.out.println(b2);</span><br><span class="line">    Boolean b3 = <span class="keyword">new</span> Boolean(<span class="string">&quot;TRue&quot;</span>);<span class="comment">//true，忽略大小写</span></span><br><span class="line">    System.out.println(b3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包装类--&gt;基本数据类型：调用包装类的xxxValue()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Integer in1 = <span class="keyword">new</span> Integer(<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">int</span> i1 = in1.intValue();</span><br><span class="line">    System.out.println(i1%<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK5.0新特性，自动装箱与自动拆箱</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 基本数据类型--&gt;包装类的对象</span></span><br><span class="line">        method(num1);</span><br><span class="line">        <span class="comment">// 自动装箱：基本数据类型--&gt;包装类</span></span><br><span class="line">        <span class="comment">//不需要调用包装类的构造器</span></span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">18</span>;</span><br><span class="line">        Integer in1 = num2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自动拆箱：包装类--&gt;基本数据类型</span></span><br><span class="line">        <span class="keyword">int</span> num3 = in1;</span><br><span class="line">        System.out.println(num3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本数据类型、包装类--&gt;String类型：调用String重载的valueOf()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 方式1：连接运算</span></span><br><span class="line">    String s1 = num1+<span class="string">&quot;&quot;</span>;</span><br><span class="line">    System.out.println(s1);</span><br><span class="line">    <span class="comment">// 方式2</span></span><br><span class="line">    <span class="keyword">float</span> f1 = <span class="number">12.3F</span>;</span><br><span class="line">    String s2 = String.valueOf(f1);<span class="comment">//基本数据类型</span></span><br><span class="line">    System.out.println(s2);</span><br><span class="line"></span><br><span class="line">    Double d1 = <span class="keyword">new</span> Double(<span class="number">12.4</span>);<span class="comment">//包装类</span></span><br><span class="line">    String s3 = String.valueOf(d1);</span><br><span class="line">    System.out.println(s3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String类型--&gt;基本数据类型、包装类：调用包装类的parseXXX()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> num1 = Integer.parseInt(s1);</span><br><span class="line">    System.out.println(num1+<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    String s2 = <span class="string">&quot;true&quot;</span>;</span><br><span class="line">    <span class="keyword">boolean</span> num2 = Boolean.parseBoolean(s2);</span><br><span class="line">    System.out.println(num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关于包装类使用的面试题</span></span><br><span class="line"><span class="comment">// 问test1和test2输出是否相等</span></span><br><span class="line"><span class="comment">// 问test3的输出内容</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterviewTest</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 三元运算符要求后面两个返回值类型一致，否则自动类型转换</span></span><br><span class="line">		Object o1 = <span class="keyword">true</span> ? <span class="keyword">new</span> Integer(<span class="number">1</span>) : <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">		System.out.println(o1);<span class="comment">// 1.0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Object o2;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">true</span>)</span><br><span class="line">			o2 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			o2 = <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">		System.out.println(o2);<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">		Integer j = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">		System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line"><span class="comment">/*解释：</span></span><br><span class="line"><span class="comment">三目运算符比较基本数据类型，所以在编译阶段自动拆箱为 int 和 double 类型，由于三目运算符要求 表达式2 和 表达式3 类型一致，所以在编译阶段自动类型提升（即 int 自动类型转换为 double 类型），再自动装箱为Object，输出时使用多态调用重写的toString();即Double包装类的toString();*/</span></span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[],</span></span><br><span class="line"><span class="comment">//保存了从-128~127范围的整数。如果我们使用自动装箱的方式，给Integer赋值的范围在</span></span><br><span class="line"><span class="comment">//-128~127范围内时，可以直接使用数组中的元素，不用再去new了。目的：提高效率		</span></span><br><span class="line">		Integer m = <span class="number">1</span>;</span><br><span class="line">		Integer n = <span class="number">1</span>;</span><br><span class="line">		System.out.println(m == n);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">		Integer x = <span class="number">128</span>;<span class="comment">//相当于new了一个Integer对象</span></span><br><span class="line">		Integer y = <span class="number">128</span>;<span class="comment">//相当于new了一个Integer对象</span></span><br><span class="line">		System.out.println(x == y);<span class="comment">//false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充知识：搞懂Java集合类，参照文章<a href="https://mp.weixin.qq.com/s/8EeWLdK7UZt81sGpQZvh9A%EF%BC%8C%E6%9B%B4%E5%A4%9A%E5%86%85%E5%AE%B9%E7%9C%8B%E5%85%AC%E4%BC%97%E5%8F%B7%E3%80%82">https://mp.weixin.qq.com/s/8EeWLdK7UZt81sGpQZvh9A，更多内容看公众号。</a></p>
<h2 id="2-单例（Singleton）设计模式"><a href="#2-单例（Singleton）设计模式" class="headerlink" title="2.单例（Singleton）设计模式"></a>2.单例（Singleton）设计模式</h2><p>什么是设计模式？</p>
<p>设计 模式 是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式 。 设</p>
<p>计模免去我们自己再思考和摸索 。就 像是经典的棋谱，不同的棋局，我们用不同 的 棋谱。</p>
<p>简而言之，就两字，<strong>“套路”</strong>。</p>
<p>设计模式和算法一样，也是语言无关的。用Java较多。</p>
<p>入门可以参考大话设计模式。</p>
<p>所谓 类的<strong>单例设计模式</strong>，就是采取一定的方法保证在整个的软件系统中，对某个类 只能存在<strong>一个对象实例</strong> ，</p>
<p>并且该类只提供<strong>一个</strong>取得其对象实例的方法。</p>
<p>如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的<strong>构造器的访问权限设置为 private</strong> ，这样，就不能用 new 操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能调用<strong>该类的某个静态方法</strong>以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的 <strong>该类对象的变量也必须定义成静态的</strong> 。</p>
<p><strong>单例模式分为两种：饿汉式和懒汉式。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bank bank1 = Bank.getInstance();</span><br><span class="line">        Bank bank2 = Bank.getInstance();</span><br><span class="line">        System.out.println(bank1 == bank2);</span><br><span class="line"></span><br><span class="line">        Order order1 = Order.getInstance();</span><br><span class="line">        Order order2 = Order.getInstance();</span><br><span class="line">        System.out.println(order1 == order2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 饿汉式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.私有化构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Bank</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.内部创建类的对象，必须是静态的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bank instance = <span class="keyword">new</span> Bank();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.提供公有静态方法，返回类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒汉式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.私有化构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Order</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.声明当前类对象，没有初始化，必须是静态的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Order instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.提供公有静态方法，返回类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Order();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对比</strong></p>
<ol>
<li>饿汉式：</li>
</ol>
<p>坏处：对象加载时间过长。</p>
<p>好处：饿汉式是线程安全的。</p>
<ol start="2">
<li>懒汉式：</li>
</ol>
<p>好处：延迟对象的创建。</p>
<p>目前的懒汉式写法坏处：线程不安全。—&gt;到多线程内容时，再修改</p>
<p><img src="/posts/ac5bd4a1/image-20210502094523609.png" alt="image-20210502094523609"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（十四）</title>
    <url>/posts/68d66445.html</url>
    <content><![CDATA[<h2 id="1-集合框架概述"><a href="#1-集合框架概述" class="headerlink" title="1.集合框架概述"></a>1.集合框架概述</h2><p>参考博客：<a href="https://www.acwing.com/blog/content/4414/">https://www.acwing.com/blog/content/4414/</a></p>
<p>集合、数组都是对多个数据进行存储操作的结构，简称Java容器。</p>
<span id="more"></span>

<p><strong>Java集合类库将接口与实现分离。</strong></p>
<p><img src="/posts/68d66445/image-20210503103116117.png" alt="image-20210503103116117"></p>
<p>这两个都是接口，不是类。</p>
<p><img src="/posts/68d66445/image-20210503103324545.png" alt="image-20210503103324545"></p>
<p><img src="/posts/68d66445/image-20210503103348318.png" alt="image-20210503103348318"></p>
<p><img src="/posts/68d66445/image-20210503103440883.png" alt="image-20210503103440883"></p>
<p>List接口：动态数组，Set接口：集合，Queue接口：队列。</p>
<p>Map接口：函数，一个key不能对应多个value。</p>
<h2 id="3-Collection接口"><a href="#3-Collection接口" class="headerlink" title="3.Collection接口"></a>3.Collection接口</h2><p>推荐一个Java全面教程：<a href="https://blog.csdn.net/qq_38490457/article/details/108281646">https://blog.csdn.net/qq_38490457/article/details/108281646</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（四）</title>
    <url>/posts/7c5f0178.html</url>
    <content><![CDATA[<h2 id="1-数组的拓展"><a href="#1-数组的拓展" class="headerlink" title="1.数组的拓展"></a>1.数组的拓展</h2><h3 id="1-1冒泡排序"><a href="#1-1冒泡排序" class="headerlink" title="1.1冒泡排序"></a>1.1冒泡排序</h3><p>时间复杂度：o(n$^2$)</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">34</span>,<span class="number">5673</span>,<span class="number">3</span>,<span class="number">456</span>,<span class="number">124</span>,<span class="number">4562</span>,<span class="number">23</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span>[] sort = sorted(a);</span><br><span class="line">		System.out.println(Arrays.toString(sort));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 冒泡排序</span></span><br><span class="line">	<span class="comment">// 核心思路：1.比较相邻的两个元素，如果左边大于右边就交换顺序</span></span><br><span class="line">	<span class="comment">// 2.每一次比较都会产生一个最大或最小的数</span></span><br><span class="line">	<span class="comment">// 3.下一轮可以减少一次排序</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sorted(<span class="keyword">int</span>[] a)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; a.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; a.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span> (a[j+<span class="number">1</span>] &lt; a[j])&#123;</span><br><span class="line">					<span class="keyword">int</span> temp = a[j];</span><br><span class="line">					a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">					a[j+<span class="number">1</span>] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2稀疏数组"><a href="#1-2稀疏数组" class="headerlink" title="1.2稀疏数组"></a>1.2稀疏数组</h3><p><img src="/posts/7c5f0178/image-20210227121053148.png" alt="image-20210227121053148"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[][] array1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">		array1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">		array1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;输出原始数组：&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span>[] x:array1)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> y:x)&#123;</span><br><span class="line">				System.out.print(y + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 转换为稀疏数组保存</span></span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">11</span>;i ++)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">11</span>;j ++)&#123;</span><br><span class="line">				<span class="keyword">if</span> (array1[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">					sum ++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;有效数字的个数是：&quot;</span>+sum);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span>[][] array2 = <span class="keyword">new</span> <span class="keyword">int</span>[sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">		array2[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">		array2[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">		array2[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 对于多维数组a，a.length返回a的第一维长度</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array1.length;i ++)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; array1[i].length;j ++)&#123;</span><br><span class="line">				<span class="keyword">if</span> (array1[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">					array2[count][<span class="number">0</span>] = i;</span><br><span class="line">					array2[count][<span class="number">1</span>] = j;</span><br><span class="line">					array2[count][<span class="number">2</span>] = array1[i][j];</span><br><span class="line">					count ++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 输出稀疏数组</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span>[] x:array2)&#123;<span class="comment">// 注意&quot;\t&quot;不要写成单引号，否则会相加</span></span><br><span class="line">			System.out.println(x[<span class="number">0</span>]+<span class="string">&quot;\t&quot;</span>+x[<span class="number">1</span>]+<span class="string">&quot;\t&quot;</span>+x[<span class="number">2</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 读取稀疏数组</span></span><br><span class="line">		<span class="keyword">int</span>[][] array3 = <span class="keyword">new</span> <span class="keyword">int</span>[array2[<span class="number">0</span>][<span class="number">0</span>]][array2[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; array2.length;i++)&#123;</span><br><span class="line">			array3[array2[i][<span class="number">0</span>]][array2[i][<span class="number">1</span>]] = array2[i][<span class="number">2</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span>[] x:array3)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> y:x)&#123;</span><br><span class="line">				System.out.print(y+<span class="string">&quot; &quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-面向对象编程（OOP）"><a href="#2-面向对象编程（OOP）" class="headerlink" title="2.面向对象编程（OOP）"></a>2.面向对象编程（OOP）</h2><p><strong>Java的核心思想就是OOP。</strong></p>
<img src="/posts/7c5f0178/image-20210227142737516.png" alt="image-20210227142737516" style="zoom:67%;">

<img src="/posts/7c5f0178/image-20210227142935926.png" alt="image-20210227142935926" style="zoom:67%;">

<h2 id="3-静态方法与非静态方法"><a href="#3-静态方法与非静态方法" class="headerlink" title="3.静态方法与非静态方法"></a>3.静态方法与非静态方法</h2><p>静态方法（类方法）的特点：只能使用参数和静态变量（包括自己类的和别的类的允许访问的），没有this自引用，但是可以通过new的对象或传入的参数对象来引用。</p>
<p>Demo1：new一个对象来调用非静态方法（随对象创建进行加载）。</p>
<p><img src="/posts/7c5f0178/image-20210227144507848.png" alt="image-20210227144507848"></p>
<p>Demo2：用类名来调用静态方法（随类进行加载）。</p>
<p><img src="/posts/7c5f0178/image-20210227150226347.png" alt="image-20210227150226347"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;&#125;		</span><br><span class="line">	<span class="comment">// 两个非静态方法之间可以直接调用</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">		b();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 静态方法a不能直接调用非静态方法b</span></span><br><span class="line">    <span class="comment">// 因为静态方法a随class一起加载，而非静态方法b在对象创建(类实例化)时才存在</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">		b();<span class="comment">// 非法的调用</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 非静态方法a可以直接调用静态方法b</span></span><br><span class="line">    <span class="comment">// 因为静态方法a随class一起加载，而非静态方法b在对象创建(类实例化)时才存在</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">		b();<span class="comment">// 合法的调用</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：非静态方法可以调用非静态方法以及静态方法；静态方法不能调用非静态方法。</p>
<h2 id="4-java中的方法都是值传递"><a href="#4-java中的方法都是值传递" class="headerlink" title="4.java中的方法都是值传递"></a>4.java中的方法都是值传递</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span></span>&#123;</span><br><span class="line">    <span class="comment">// 值传递</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">		Demo.change(a);</span><br><span class="line">		System.out.println(a);<span class="comment">// a的值还是1</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">		a = <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span></span>&#123;</span><br><span class="line">	<span class="comment">// 引用传递：对象，本质还是值传递</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Person person = <span class="keyword">new</span> Person();</span><br><span class="line">		System.out.println(person.name);<span class="comment">// null</span></span><br><span class="line">		Demo.change(person);</span><br><span class="line">		System.out.println(person.name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">        <span class="comment">//person是一个对象</span></span><br><span class="line">        <span class="comment">// 指向--&gt; Person person = new Person();它是一个具体的人，可以改变属性</span></span><br><span class="line">		person.name = <span class="string">&quot;java&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义Person类，有一个属性：name</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-类与对象的创建"><a href="#5-类与对象的创建" class="headerlink" title="5.类与对象的创建"></a>5.类与对象的创建</h2><p><img src="/posts/7c5f0178/image-20210227152818697.png" alt="image-20210227152818697"></p>
<p>养成习惯，专门在一个主程序中写main方法，用于测试。在别的类中不要加上main方法。</p>
<p><img src="/posts/7c5f0178/image-20210227153327859.png" alt="image-20210227153327859"></p>
<p><img src="/posts/7c5f0178/image-20210227155204438.png" alt="image-20210227155204438"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Student.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 属性：字段</span></span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;在学习&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Demo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">// 类实例化后会返回一个自己的对象！</span></span><br><span class="line">		<span class="comment">// 类是抽象的，对象是类的具体实例</span></span><br><span class="line">		Student xiaoming = <span class="keyword">new</span> Student();</span><br><span class="line">		Student xiaohong = <span class="keyword">new</span> Student();</span><br><span class="line">		</span><br><span class="line">		xiaoming.name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">		xiaoming.age = <span class="number">18</span>;</span><br><span class="line">		System.out.println(xiaoming.name);</span><br><span class="line">		System.out.println(xiaoming.age);</span><br><span class="line">		xiaoming.study();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*小明</span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment">小明在学习*/</span></span><br></pre></td></tr></table></figure>

<h2 id="6-类的构造器（构造方法）"><a href="#6-类的构造器（构造方法）" class="headerlink" title="6.类的构造器（构造方法）"></a>6.类的构造器（构造方法）</h2><p>类中的构造方法是在进行创建对象时必须调用的。它只能在创建对象时被间接调用。</p>
<p>它有以下两个特点：</p>
<ul>
<li>必须和类的名字相同</li>
<li>必须没有返回类型，也不能写void</li>
</ul>
<p>如果类中什么都不写，它会存在默认构造方法。</p>
<p>1.使用new关键字本质上是在调用构造器</p>
<p>2.用来初始化值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 构造器实例化初始值</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = <span class="string">&quot;wang&quot;</span>;</span><br><span class="line">	&#125;  </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="comment">// 构造器实例化初始值</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 有参构造</span></span><br><span class="line">	<span class="comment">//一旦定义有参构造，无参构造必须显式定义，否则报错</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Person person = new Person(&quot;wang&quot;,23);</span></span><br><span class="line"><span class="comment">// 根据方法重载进行有参构造</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 构造器实例化初始值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造器的重载与相互调用</span></span><br><span class="line">    <span class="comment">//在构造器里调用重载的构造器时，必须是方法的第一行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">&quot;xiaoming&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-创建对象内存分析"><a href="#7-创建对象内存分析" class="headerlink" title="7.创建对象内存分析"></a>7.创建对象内存分析</h2><p><img src="/posts/7c5f0178/image-20210305150045041.png" alt="image-20210305150045041"></p>
<h2 id="8-小结类与对象"><a href="#8-小结类与对象" class="headerlink" title="8.小结类与对象"></a>8.小结类与对象</h2><p><strong>对象的引用</strong></p>
<p>引用类型：除8种基本类型之外的都是引用类型。</p>
<p>对象是通过引用来操作的（如上图）：栈 —&gt; 堆（地址）。</p>
<p><strong>属性</strong></p>
<p>也即字段Field，成员变量</p>
<p>会进行默认初始化（缺省值）：</p>
<ul>
<li>数字：0  0.0</li>
<li>char：<code>\u0000</code></li>
<li>boolean：false</li>
<li>引用类型：null</li>
</ul>
<p><strong>类</strong></p>
<p>1.属性：静态的属性</p>
<p>2.方法：动态的行为</p>
<h2 id="9-OOP三大特性之封装"><a href="#9-OOP三大特性之封装" class="headerlink" title="9.OOP三大特性之封装"></a>9.OOP三大特性之封装</h2><p><img src="/posts/7c5f0178/image-20210305151408746.png" alt="image-20210305151408746"></p>
<p>1.提高程序的安全性，保护数据</p>
<p>2.隐藏代码的实现细节</p>
<p>3.统一接口get/set</p>
<p>4.系统可维护性增加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="comment">// private:属性私有</span></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">char</span> gender;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="comment">// 提供一些可以操作这些属性的方法</span></span><br><span class="line">	<span class="comment">// 提供一些public的get、set方法，自己实现</span></span><br><span class="line">	<span class="comment">// get获得这个数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// set给数据设置值</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		<span class="comment">// 合法性验证</span></span><br><span class="line">		<span class="keyword">if</span> (age &gt;= <span class="number">130</span> || age &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">this</span>.age = <span class="number">3</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.age = age;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">		s1.setName(<span class="string">&quot;student1&quot;</span>);</span><br><span class="line">		System.out.println(s1.getName());</span><br><span class="line">		s1.setAge(<span class="number">999</span>);<span class="comment">// 不合法的</span></span><br><span class="line">		System.out.println(s1.getAge());</span><br><span class="line">		s1.setAge(<span class="number">75</span>);</span><br><span class="line">		System.out.println(s1.getAge());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*student1</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">75*/</span></span><br></pre></td></tr></table></figure>

<h2 id="10-OOP三大特性之继承"><a href="#10-OOP三大特性之继承" class="headerlink" title="10.OOP三大特性之继承"></a>10.OOP三大特性之继承</h2><p><img src="/posts/7c5f0178/image-20210305160318864.png" alt="image-20210305160318864"></p>
<ul>
<li>在Java中，所有的类都默认直接或者间接继承Object类</li>
<li>Java中类只有单继承，没有多继承！一个儿子只能有一个爸爸，而一个爸爸可以有多个儿子</li>
<li>私有的东西无法被继承</li>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong></li>
<li>被final修饰的class不能被继承</li>
<li>子类可以通过this访问公共继承自父类的属性，相当于子类对象里藏着一个父类对象</li>
<li>就好像子类的引用可以一物二用，既可以当作父类的引用使用，又可以当作子类的引用<br>使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 如果是private就不能继承到子类</span></span><br><span class="line">	<span class="comment">// 使用public子类就能继承父类的属性，方法</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> money = <span class="number">10_000</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.money;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(<span class="keyword">int</span> money)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.money = money;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Student继承Person，派生类，子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Teacher继承Person，派生类，子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Student student = <span class="keyword">new</span> Student();</span><br><span class="line">		student.say();</span><br><span class="line">		System.out.println(student.getMoney());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*hello</span></span><br><span class="line"><span class="comment">10000*/</span></span><br></pre></td></tr></table></figure>

<p><strong>super演示（重要）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> String name = <span class="string">&quot;kuangshen&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Student继承Person，派生类，子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name = <span class="string">&quot;qingjiang&quot;</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		System.out.println(name);</span><br><span class="line">		System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">		System.out.println(<span class="keyword">super</span>.name);<span class="comment">//kuangshen</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Student&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		print();<span class="comment">// Student</span></span><br><span class="line">		<span class="keyword">this</span>.print();<span class="comment">// Student</span></span><br><span class="line">		<span class="keyword">super</span>.print();<span class="comment">// Person</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Student student = <span class="keyword">new</span> Student();</span><br><span class="line">		student.test(<span class="string">&quot;请将&quot;</span>);</span><br><span class="line">        student.test1();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*请将</span></span><br><span class="line"><span class="comment">qingjiang</span></span><br><span class="line"><span class="comment">kuangshen*/</span></span><br></pre></td></tr></table></figure>

<p>子类与父类的构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> String name = <span class="string">&quot;kuangshen&quot;</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Person无参执行了&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Teacher继承Person，派生类，子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 隐藏代码：调用了父类的无参构造</span></span><br><span class="line">        <span class="keyword">super</span>();<span class="comment">// 默认的，调用父类的构造器必须在子类的第一行</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Teacher无参执行了&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Teacher teacher = <span class="keyword">new</span> Teacher();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Person无参执行了</span></span><br><span class="line"><span class="comment">Teacher无参执行了*/</span></span><br></pre></td></tr></table></figure>

<p>super的注意点</p>
<ul>
<li><p>子类对象里可以认为有一个特殊的父类的对象，这个父类对象和子类对象之<br>间通过super 关键字来沟通，super是沟通的桥梁</p>
</li>
<li><p>super();调用父类的构造器，<strong>必须在当前类（子类）的第一行</strong></p>
</li>
<li><p>super必须只能出现在子类的方法或者构造器中</p>
</li>
<li><p>super和this不能同时调用构造方法（因为都必须放第一行）</p>
</li>
<li><p>super并不是父类的引用，和this自引用不一样，如果一样那不就成组合了嘛</p>
</li>
</ul>
<p>super与this的不同点</p>
<ul>
<li>代表的对象不同</li>
<li>this没继承也能使用，super只能在继承时使用</li>
<li>this();调用本类的构造，super();调用父类的构造</li>
<li>this可以作为返回值，但super不可以</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter notebook快速入门笔记</title>
    <url>/posts/c4bef09b.html</url>
    <content><![CDATA[<p>Jupyter notebook是用python进行数据科学、机器学习的必备工具。</p>
<p>吴恩达的《深度学习》慕课的课后编程作业、大数据竞赛网站Kaggle上的代码文档、美国大学的数据科学课程的课后资料及编程作业，都是以jupyter notebook文件的形式给出的，也就是<code>.ipynb</code>文件。</p>
<p><a href="https://github.com/TommyZihao/zihaopython/blob/master/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%AD%A6%E4%B9%A0%E6%97%B6%E9%97%B4%E4%B8%8E%E6%88%90%E7%BB%A9%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%88%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%EF%BC%89/Jupyter%20notebook%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B.md">文章参考自TommyZihao</a></p>
<p>推荐教程：<a href="https://www.freeaihub.com/jupyter/setup.html">https://www.freeaihub.com/jupyter/setup.html</a></p>
<p>五大插件推荐：<a href="https://mp.weixin.qq.com/s/nOMQNUd8fqLXvMrRRE7q6A">https://mp.weixin.qq.com/s/nOMQNUd8fqLXvMrRRE7q6A</a></p>
<span id="more"></span>

<p>Jupyter notebook是基于Ipython内核的，在浏览器中以网页形式运行Python代码的工具，十分方便。</p>
<blockquote>
<p>Ipython是啥？</p>
<p>Ipython可以理解成更高级的python解释器，相比原生的python交互式命令行，Ipython有更强大的命令计数、自动补全等交互功能。</p>
<p>Spyder和Jupyter notebook都是以Ipython为内核的。</p>
</blockquote>
<h2 id="安装Jupyter-notebook"><a href="#安装Jupyter-notebook" class="headerlink" title="安装Jupyter notebook"></a>安装Jupyter notebook</h2><p>如果你安装了python数据科学全家桶Anaconda，那么其中自带了Jupyter notebook。</p>
<p>如果你没安装Anaconda，可以直接在命令行里运行这行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install jupyter -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br></pre></td></tr></table></figure>

<h2 id="运行Jupyter-notebook"><a href="#运行Jupyter-notebook" class="headerlink" title="运行Jupyter notebook"></a>运行Jupyter notebook</h2><p>打开命令行，通过cd命令切换到指定文件路径下，输入<code>jupter notebook</code>，回车。稍等片刻即可跳出浏览器网页。如果没有跳转浏览器，也可以手动复制链接到浏览器打开。</p>
<p><img src="/posts/c4bef09b/image-20210306224106698.png" alt="image-20210306224106698"></p>
<h2 id="主要操作界面"><a href="#主要操作界面" class="headerlink" title="主要操作界面"></a>主要操作界面</h2><p><img src="/posts/c4bef09b/image-20210307180617165.png" alt="image-20210307180617165"></p>
<p><img src="/posts/c4bef09b/image-20210307181033194.png" alt="image-20210307181033194"></p>
<p><img src="/posts/c4bef09b/image-20210307180926021.png" alt="image-20210307180926021"></p>
<p>点击右边的New-Python3即可创建python文档。</p>
<p>点击New-Folder可以创建新文件夹。</p>
<p>点击New-Text File可以创建空的<code>.txt</code>文件。</p>
<p>点击New-Terminal可以打开操作系统命令行，你可以使用操作系统对应的命令行进行目录切换、解压文件等操作。</p>
<p>勾选文件夹，点击rename即可重命名。</p>
<h2 id="蓝绿两模式：命令模式、编辑模式"><a href="#蓝绿两模式：命令模式、编辑模式" class="headerlink" title="蓝绿两模式：命令模式、编辑模式"></a>蓝绿两模式：命令模式、编辑模式</h2><p>Jupyter notebook中，代码和文档都存在于一个个单元格中，每个单元格都有蓝色和绿色两种状态。</p>
<ul>
<li>命令模式（蓝色）：用于执行键盘输入的快捷命令（新增单元格、剪切、复制等等）。通过 <code>Esc</code> 键从绿色的编辑模式切换到蓝色的命令模式，此时单元左侧显示蓝色竖线。</li>
<li>编辑模式（绿色）：编辑文本和代码。选中单元并按 <code>Enter</code> 键进入编辑模式，此时单元左侧显示绿色竖线。</li>
</ul>
<blockquote>
<p>命令模式和编辑模式，其实是源自于著名的vim编辑器，vim编辑器以特别难学和学成之后可以超神而闻名于世。</p>
</blockquote>
<h2 id="两种单元格：代码单元格和Markdown单元格"><a href="#两种单元格：代码单元格和Markdown单元格" class="headerlink" title="两种单元格：代码单元格和Markdown单元格"></a>两种单元格：代码单元格和Markdown单元格</h2><p>Jupyter notebook中，有两种单元格：代码单元格和Markdown单元格。</p>
<ul>
<li>代码单元格：这里是你编写代码的地方，通过按 <code>Shift + Enter</code> 运行代码，其结果显示在本单元下方。代码单元左边有 <code>In [1]:</code> 这样的序列标记，方便人们查看代码的执行次序。在<strong>蓝色命令模式下，按<code>y</code>键</strong>可以将Markdown单元格转换为代码单元格。</li>
<li>Markdown 单元格：在这里对文本进行编辑，采用 markdown 的语法规范，可以设置文本格式、插入链接、图片甚至数学公式。同样使用 <code>Shift + Enter</code> 运行 markdown 单元来显示渲染后的文本。在<strong>蓝色命令模式下按<code>m</code>键</strong>可以将代码单元格转换为Markdown单元格。</li>
</ul>
<blockquote>
<p>Markdown是程序员通用的撰写文档的语法，可以轻松实现标题、引用、链接、图片等，非常简洁易学，Github代码托管网站、有道云笔记、简书、知乎、CSDN论坛、电子邮件等都支持Markdown语法。</p>
<p>学习Markdown，推荐我制作的博客和视频教程：</p>
<p><a href="https://www.jianshu.com/p/4475b9d8810f">二十分钟精通排版神器Markdown，从此word和秀米是路人</a></p>
<p><a href="https://www.bilibili.com/video/av35579542">Bilibili视频：二十分钟精通排版神器Markdown</a></p>
</blockquote>
<h2 id="抛弃鼠标，只用键盘"><a href="#抛弃鼠标，只用键盘" class="headerlink" title="抛弃鼠标，只用键盘"></a>抛弃鼠标，只用键盘</h2><p>下面介绍Jupyter notebook快捷键，掌握这些快捷键之后，你将彻底解放你拿鼠标的那只手，更专注、高效地敲代码了。在文件操作界面按<code>h</code>键可以查看全部快捷键。</p>
<h2 id="最常用快捷键（必会）"><a href="#最常用快捷键（必会）" class="headerlink" title="最常用快捷键（必会）"></a>最常用快捷键（必会）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">h 查看所有快捷键</span><br><span class="line"></span><br><span class="line">Enter 从命令模式进入编辑模式</span><br><span class="line"></span><br><span class="line">Esc 从编辑模式退回到命令模式</span><br><span class="line"></span><br><span class="line">m 将代码单元格转换为Markdown单元格</span><br><span class="line"></span><br><span class="line">y 将Markdown单元格转换为代码单元格</span><br><span class="line"></span><br><span class="line">shift+Enter 运行本单元格，选择下面的代码块</span><br><span class="line"></span><br><span class="line">ctrl+Enter 运行本单元格</span><br><span class="line"></span><br><span class="line">alt+Enter 运行本单元格，在下方新建一个单元格</span><br><span class="line"></span><br><span class="line">a 在上方新建一个单元格（above）</span><br><span class="line"></span><br><span class="line">b 在下方新建一个单元格（below）</span><br><span class="line"></span><br><span class="line">d 删除选中的单元格（delete）</span><br><span class="line"></span><br><span class="line">x 剪切本单元格</span><br><span class="line"></span><br><span class="line">c 复制本单元格</span><br><span class="line"></span><br><span class="line">shift v 粘贴到上面</span><br><span class="line"></span><br><span class="line">v 粘贴到下面</span><br><span class="line"></span><br><span class="line">l 显示代码行号</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Jupyter notebook</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab快速入门笔记</title>
    <url>/posts/284e5fc1.html</url>
    <content><![CDATA[<h2 id="1-初始Matlab"><a href="#1-初始Matlab" class="headerlink" title="1.初始Matlab"></a>1.初始Matlab</h2><p><img src="/posts/284e5fc1/image-20210307201346455.png" alt="image-20210307201346455"></p>
<p>点击新建脚本即创建<code>.m</code>文件。</p>
<span id="more"></span>

<p><strong>命令行窗口</strong></p>
<p><img src="/posts/284e5fc1/image-20210307202741592.png" alt="按向上箭头弹出历史命令"></p>
<p><code>clear</code>：清空工作区</p>
<p><code>clc</code>：清空命令行</p>
<h2 id="2-Matlab帮助系统"><a href="#2-Matlab帮助系统" class="headerlink" title="2.Matlab帮助系统"></a>2.Matlab帮助系统</h2><p><img src="/posts/284e5fc1/image-20210307203526202.png" alt="image-20210307203526202"></p>
<h3 id="查询函数："><a href="#查询函数：" class="headerlink" title="查询函数："></a>查询函数：</h3><p><img src="/posts/284e5fc1/image-20210307203605322.png" alt="image-20210307203605322"></p>
<h3 id="在线查询："><a href="#在线查询：" class="headerlink" title="在线查询："></a>在线查询：</h3><p><img src="/posts/284e5fc1/image-20210307205132363.png" alt="image-20210307205132363"></p>
<h3 id="模糊搜索："><a href="#模糊搜索：" class="headerlink" title="模糊搜索："></a>模糊搜索：</h3><p><img src="/posts/284e5fc1/image-20210307205443076.png" alt="image-20210307205443076"></p>
<h3 id="内存变量列表（who）："><a href="#内存变量列表（who）：" class="headerlink" title="内存变量列表（who）："></a>内存变量列表（who）：</h3><h3 id="内存变量信息（whos）："><a href="#内存变量信息（whos）：" class="headerlink" title="内存变量信息（whos）："></a>内存变量信息（whos）：</h3><p><img src="/posts/284e5fc1/image-20210307210116394.png" alt="image-20210307210116394"></p>
<p>Matlab的最小数据单元就是矩阵，所以size为1*1.</p>
<h3 id="变量检测函数（exist）："><a href="#变量检测函数（exist）：" class="headerlink" title="变量检测函数（exist）："></a>变量检测函数（exist）：</h3><p><img src="/posts/284e5fc1/image-20210307210444329.png" alt="image-20210307210444329"></p>
<h3 id="文件操作："><a href="#文件操作：" class="headerlink" title="文件操作："></a>文件操作：</h3><p><img src="/posts/284e5fc1/image-20210307211255022.png" alt="image-20210307211255022"></p>
<h2 id="3-基础知识"><a href="#3-基础知识" class="headerlink" title="3.基础知识"></a>3.基础知识</h2><p>MATLAB的代码执行如果返回结果但是没有写变量来保存 默认保存在 ans 变量中 。</p>
<p>注意：自己定义变量最好不要命名为ans。</p>
<h3 id="3-1命令"><a href="#3-1命令" class="headerlink" title="3.1命令"></a>3.1命令</h3><p><img src="/posts/284e5fc1/image-20210307212506649.png" alt="image-20210307212506649"></p>
<p><img src="/posts/284e5fc1/image-20210307213023170.png" alt="image-20210307213023170"></p>
<p><img src="/posts/284e5fc1/image-20210307213045734.png" alt="image-20210307213045734"></p>
<p><img src="/posts/284e5fc1/image-20210307213914912.png" alt="image-20210307213914912"></p>
<h3 id="3-2数据类型"><a href="#3-2数据类型" class="headerlink" title="3.2数据类型"></a>3.2数据类型</h3><p><img src="/posts/284e5fc1/image-20210307214128238.png" alt="image-20210307214128238"></p>
<p><img src="/posts/284e5fc1/image-20210307214034914.png" alt="image-20210307214034914"></p>
<p>常量：</p>
<p><img src="/posts/284e5fc1/image-20210307214359948.png" alt="image-20210307214359948"></p>
<p>注意：Matlab可以改变常量的值</p>
<p><img src="/posts/284e5fc1/image-20210307214721096.png" alt="image-20210307214721096"></p>
<p>数值类型包括整型、 浮点型 、 符号型 、 复数类型等 。</p>
<p><img src="/posts/284e5fc1/image-20210307215356971.png" alt="image-20210307215356971"></p>
<p><img src="/posts/284e5fc1/image-20210307215409394.png" alt="image-20210307215409394"></p>
<p>复数：与实数类似，虚数单位用 i 表示即可 。</p>
]]></content>
      <categories>
        <category>Matlab</category>
      </categories>
      <tags>
        <tag>Matlab入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Latex常用语法总结</title>
    <url>/posts/fcaedc74.html</url>
    <content><![CDATA[<p>文章开头加上一句：<code>mathjax: true</code>，即可启动Latex渲染。</p>
<span id="more"></span>

<p>1.打出斜体：$O(n)$,<code>$O(n)$</code></p>
<p>2.打出根号：$\sqrt n$ ,<code>$\sqrt n$</code></p>
<p>3.打出上标（单字符）：A$^2$,<code>A$^2$</code></p>
<p>4.打出上标（多字符）：A$^{mod}$,<code>A$^&#123;mod&#125;$</code></p>
<p>5.打出下标（单字符）：A$_2$,<code>A$_2$</code></p>
<p>6.打出下标（多字符）：A$_{mod}$,<code>A$_&#123;mod&#125;$</code></p>
<p>7.打出log对数：$\log_ax$，<code>$\log_ax$</code>;    $\ln x$，<code>\ln x$</code>;    $\lg x$,<code>$\lg x$</code></p>
<p>8.打出正上方的上标：$\bar a$,<code>$\bar a$</code></p>
<p>9.小写希腊字母：</p>
<p><img src="/posts/fcaedc74/image-20210310195229711.png" alt="image-20210310195229711"></p>
<p>10.大写希腊字母：</p>
<p><img src="/posts/fcaedc74/image-20210310195310812.png" alt="image-20210310195310812"></p>
<p>11.打出关于x的偏微分：$\partial/\partial x$,<code>$\partial/\partial x$</code>，补充一点：\partial可以简写为\part</p>
<p>12.打出除法：$\frac a b$,<code>$\frac a b$</code></p>
<p>13.求和和连乘</p>
<ul>
<li>对于连加的情况，我们通常使用$\Sigma$来表示。它的使用用法也很简单，但是通常都要添加上下标，像<code>$\sum_&#123;&#125;^&#123;&#125;$</code>形式。除了连加，我们有时也使用连乘，虽然没有连加使用得多（连乘都能通过对数写成连加），它只要以<code>$\prod_&#123;&#125;^&#123;&#125;$</code>的形式表示。</li>
</ul>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">&lt;!--连加--&gt;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span><span class="keyword">\sum</span><span class="built_in">_</span>&#123;i = 1&#125;<span class="built_in">^</span>&#123;n&#125;x<span class="built_in">_</span>i<span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"></span><br><span class="line">&lt;!--连乘--&gt;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span><span class="keyword">\prod</span><span class="built_in">_</span>&#123;i = 1&#125;<span class="built_in">^</span>&#123;n&#125;x<span class="built_in">_</span>i<span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在latex中，默认情况下行内公式都是显示像$\sum_{i = 1}^{n}x_i$的效果，如果想要这样$\displaystyle\sum_{i = 1}^{n}x_i$的效果，就需要在前面加上<code>\displaystyle</code>，来重新看一下下面的例子：</li>
</ul>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">&lt;!--连加--&gt;</span><br><span class="line"><span class="built_in">$</span><span class="keyword">\sum</span><span class="built_in">_</span>&#123;i = 1&#125;<span class="built_in">^</span>&#123;n&#125;x<span class="built_in">_</span>i<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\displaystyle</span><span class="keyword">\sum</span><span class="built_in">_</span>&#123;i = 1&#125;<span class="built_in">^</span>&#123;n&#125;x<span class="built_in">_</span>i<span class="built_in">$</span></span><br><span class="line"></span><br><span class="line">&lt;!--连乘--&gt;</span><br><span class="line"><span class="built_in">$</span><span class="keyword">\prod</span><span class="built_in">_</span>&#123;i = 1&#125;<span class="built_in">^</span>&#123;n&#125;x<span class="built_in">_</span>i<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\displaystyle</span><span class="keyword">\prod</span><span class="built_in">_</span>&#123;i = 1&#125;<span class="built_in">^</span>&#123;n&#125;x<span class="built_in">_</span>i<span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>补充：关于上下标的位置有以下三种情况</p>
<p><code>\sum\nolimits_&#123;j=1&#125;^&#123;M&#125;</code> 上下标位于求和符号的水平右端，</p>
<p><code>\sum\limits_&#123;j=1&#125;^&#123;M&#125;</code> 上下标位于求和符号的上下处，</p>
<p><code>\sum_&#123;j=1&#125;^&#123;M&#125;</code> 对上下标位置没有设定，会随公式所处环境自动调整。</p>
<p>14.无穷大：$\infty$,<code>$\infty$</code></p>
<p>正无穷大： +\infty</p>
<p>负无穷大： -\infty</p>
<p>15.极限：</p>
<p>还记得高数里极限的符号吗<img src="/posts/fcaedc74/1684731-20191002102657884-1615601426.png" alt="皱眉">。在latex中的极限表示，也直接使用<code>\lim</code>这个我们时常看到的符号。当然极限通常都是带下标的，所以更多的是使用<code>lim_&#123;&#125;</code>的形式。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">&lt;!--来看看两个重要极限--&gt;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span><span class="keyword">\displaystyle</span><span class="keyword">\lim</span><span class="built_in">_</span>&#123;x <span class="keyword">\rightarrow</span> 0&#125;<span class="keyword">\frac</span>&#123;<span class="keyword">\sin</span> x&#125;&#123;x&#125; = 1<span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span><span class="keyword">\displaystyle</span><span class="keyword">\lim</span><span class="built_in">_</span>&#123;x <span class="keyword">\rightarrow</span> + <span class="keyword">\infty</span>&#125;(1 + <span class="keyword">\frac</span>&#123;1&#125;&#123;x&#125;)<span class="built_in">^</span>x = e<span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p>$\displaystyle\lim_{x \rightarrow 0}\frac{\sin x}{x} = 1$</p>
<p>$\displaystyle\lim_{x \rightarrow + \infty}(1 + \frac{1}{x})^x = e$</p>
<ul>
<li><strong>tip1：</strong>右箭头$\rightarrow$的表示方式为<code>$\rightarrow$</code>，左箭头$\leftarrow$的表示方式是<code>$\leftarrow$</code></li>
<li><strong>tip2：</strong>正无穷$+ \infty$的表示方式为<code>$+ \infty$</code>，负无穷$- \infty$的表示方式是<code>$- \infty$</code></li>
</ul>
<p>16.积分：</p>
<p>如果想要输入积分，则需要使用<code>\int_&#123;&#125;^&#123;&#125;</code>来表示</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span><span class="keyword">\int</span><span class="built_in">_</span>0<span class="built_in">^</span>1 x<span class="built_in">^</span>2 dx<span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line">&lt;!--来看一个更加复杂的例子--&gt;</span><br><span class="line">&lt;!--正态分布的分布函数--&gt;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span>F(x) = <span class="keyword">\int</span><span class="built_in">_</span>&#123;- <span class="keyword">\infty</span>&#125;<span class="built_in">^</span>&#123;+ <span class="keyword">\infty</span>&#125; <span class="keyword">\frac</span>&#123;1&#125;&#123;<span class="keyword">\sqrt</span>&#123;2<span class="keyword">\pi</span>&#125;<span class="keyword">\sigma</span>&#125;e<span class="built_in">^</span>&#123;-(<span class="keyword">\frac</span>&#123;x-<span class="keyword">\mu</span>&#125;&#123;<span class="keyword">\sigma</span>&#125;)<span class="built_in">^</span>2&#125; dx<span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p>$\int_0^1 x^2 dx$</p>
<p>$F(x) = \int_{- \infty}^{+ \infty} \frac{1}{\sqrt{2\pi}\sigma}e^{-(\frac{x-\mu}{\sigma})^2} dx$</p>
<p>17.求导：</p>
<p>使用<code>$\mathrm&#123;d&#125;$</code>来表示求导符号，<code>$\partial$</code>来表示求偏导</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\frac</span> &#123;<span class="keyword">\mathrm</span>&#123;d&#125;L(<span class="keyword">\beta</span>)&#125;&#123;<span class="keyword">\beta</span>&#125;<span class="built_in">$</span></span><br><span class="line"></span><br><span class="line">&lt;!--直接用d来表示求导符的效果--&gt;</span><br><span class="line"><span class="built_in">$</span><span class="keyword">\frac</span> &#123;dL(<span class="keyword">\beta</span>)&#125;&#123;<span class="keyword">\beta</span>&#125;<span class="built_in">$</span></span><br><span class="line"></span><br><span class="line">&lt;!--偏导--&gt;</span><br><span class="line"><span class="built_in">$</span><span class="keyword">\frac</span> &#123;<span class="keyword">\partial</span> L(<span class="keyword">\beta</span><span class="built_in">_</span>0, <span class="keyword">\beta</span><span class="built_in">_</span>1)&#125;&#123;<span class="keyword">\partial</span> <span class="keyword">\beta</span><span class="built_in">_</span>0&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p>$\frac {\mathrm{d}L(\beta)}{\beta}$</p>
<p>$\frac {dL(\beta)}{\beta}$</p>
<p>$\frac {\partial L(\beta_0, \beta_1)}{\partial \beta_0}$</p>
<p>18.打出空格：$a \ b$,<code>$a \ b$</code></p>
<p>19.打出向上向下取整符号：</p>
<p>上取整$\lceil x \rceil$(表示不小于x的最小整数),<code>$\lceil x \rceil$</code></p>
<p>下取整$\lfloor x \rfloor$(表示不大于x的最大整数),<code>$\lfloor x \rfloor$</code></p>
<p>20.打出实数集符号：$\mathbb{R}$，<code>$\mathbb&#123;R&#125;$</code>;$\mathbb{R}^{n}$,<code>$\mathbb&#123;R&#125;^&#123;3&#125;$</code></p>
]]></content>
      <categories>
        <category>Latex</category>
      </categories>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab快速入门笔记（二）</title>
    <url>/posts/ebd04ff8.html</url>
    <content><![CDATA[<h2 id="1-迭代法求解线性方程组"><a href="#1-迭代法求解线性方程组" class="headerlink" title="1.迭代法求解线性方程组"></a>1.迭代法求解线性方程组</h2><h3 id="1-1雅可比（Jacobi）迭代法"><a href="#1-1雅可比（Jacobi）迭代法" class="headerlink" title="1.1雅可比（Jacobi）迭代法"></a>1.1雅可比（Jacobi）迭代法</h3><span id="more"></span>

<p><img src="/posts/ebd04ff8/image-20210410224045532.png" alt="image-20210410224045532"></p>
<p><img src="/posts/ebd04ff8/image-20210410224307814.png" alt="image-20210410224307814"></p>
<p>triu用于生成矩阵A的上三角部分的矩阵（其余部分为0），用法基本同tril。</p>
<p><img src="/posts/ebd04ff8/image-20210410225034024.png" alt="image-20210410225034024"></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">X</span> = <span class="title">Jacobi</span><span class="params">(A,b,k)</span></span></span><br><span class="line">D = <span class="built_in">diag</span>(<span class="built_in">diag</span>(A));  <span class="comment">%对角矩阵</span></span><br><span class="line">L = -( <span class="built_in">tril</span>(A) - <span class="built_in">diag</span>(<span class="built_in">diag</span>(A)) ); <span class="comment">%下三角矩阵</span></span><br><span class="line">U = -( <span class="built_in">triu</span>(A) - <span class="built_in">diag</span>(<span class="built_in">diag</span>(A)) ); <span class="comment">%上三角矩阵</span></span><br><span class="line">X = <span class="built_in">zeros</span>(<span class="built_in">length</span>(A),<span class="number">1</span>);</span><br><span class="line">X_New = <span class="built_in">zeros</span>(<span class="built_in">length</span>(A),<span class="number">1</span>);</span><br><span class="line"><span class="built_in">i</span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">i</span>&lt;k</span><br><span class="line">    X_New = D\((L+U)*X) + D\b;</span><br><span class="line">    X = X_New;</span><br><span class="line">    <span class="built_in">i</span> = <span class="built_in">i</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/ebd04ff8/image-20210410231824380.png" alt="image-20210410231824380"></p>
<p>注意：</p>
<ul>
<li>源文件中命令不以分号结尾会显示结果在命令行中，加上就不显示。</li>
<li>函数名与文件名必须相同。</li>
</ul>
<h3 id="1-2高斯-塞德尔-Gauss-Seidel-迭代法"><a href="#1-2高斯-塞德尔-Gauss-Seidel-迭代法" class="headerlink" title="1.2高斯-塞德尔(Gauss-Seidel)迭代法"></a>1.2高斯-塞德尔(Gauss-Seidel)迭代法</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">X</span> = <span class="title">Gauss_Seidel</span><span class="params">(A,b,k)</span></span></span><br><span class="line">D = <span class="built_in">diag</span>(<span class="built_in">diag</span>(A));  <span class="comment">%对角矩阵</span></span><br><span class="line">L = -( <span class="built_in">tril</span>(A) - <span class="built_in">diag</span>(<span class="built_in">diag</span>(A)) ); <span class="comment">%下三角矩阵</span></span><br><span class="line">U = -( <span class="built_in">triu</span>(A) - <span class="built_in">diag</span>(<span class="built_in">diag</span>(A)) ); <span class="comment">%上三角矩阵</span></span><br><span class="line">X = <span class="built_in">zeros</span>(<span class="built_in">length</span>(A),<span class="number">1</span>);</span><br><span class="line">X_New = <span class="built_in">zeros</span>(<span class="built_in">length</span>(A),<span class="number">1</span>);</span><br><span class="line"><span class="built_in">i</span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">i</span>&lt;k</span><br><span class="line">    X_New = (D-L)\(U*X) + (D-L)\b;</span><br><span class="line">    X = X_New;</span><br><span class="line">    <span class="built_in">i</span> = <span class="built_in">i</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Matlab</category>
      </categories>
      <tags>
        <tag>Matlab入门</tag>
        <tag>迭代法</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习笔记（一）</title>
    <url>/posts/ec3642b8.html</url>
    <content><![CDATA[<h2 id="1-什么是数据库？"><a href="#1-什么是数据库？" class="headerlink" title="1.什么是数据库？"></a>1.什么是数据库？</h2><p>DataBase，数据仓库，用于存储有组织的数据。</p>
<p>数据库分类：</p>
<ol>
<li><p>关系型数据库：MySQL，Oracle，…</p>
<ul>
<li><p>SQL</p>
</li>
<li><p>RDBMS，即关系数据库管理系统(Relational Database Management System)</p>
</li>
<li><p>通过表和表之间，行和列之间的关系进行数据的存储，如学员信息表</p>
</li>
</ul>
</li>
<li><p>非关系型数据库：Redis，MongDB，…</p>
<ul>
<li><p>NoSQL，Not Only SQL</p>
</li>
<li><p>通过对象存储，由对象自身属性来决定。</p>
</li>
</ul>
</li>
</ol>
<span id="more"></span>

<p>DBMS：数据库管理系统</p>
<p>它是数据库的管理软件，通过DBMS来操作管理数据库</p>
<p>软件安装建议：</p>
<p>尽量不要安装exe，卸载时会有注册表残留，尽可能使用压缩包安装，卸载方便</p>
<h2 id="2-MySQL入门使用"><a href="#2-MySQL入门使用" class="headerlink" title="2.MySQL入门使用"></a>2.MySQL入门使用</h2><p>安装MySQL直接百度教程就行。</p>
<p>打开cmd命令行，输入<code>mysql -u root -p</code>，然后输入密码，进入mysql。</p>
<p><img src="/posts/ec3642b8/image-20210503122112663.png" alt="image-20210503122112663"></p>
<p>然后是安装SQLyog，建议看我的另一篇<a href="https://grant1499.github.io/2021/04/27/%E4%BD%BF%E7%94%A8SQL%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%B7%A5%E5%85%B7/">文章</a>。</p>
<p>新建一个数据库school，名称随意。</p>
<p>在<code>root@localhost</code>处右键创建数据库，然后填入名称，选择字符集、排序规则，<strong>注意不要选错</strong>。</p>
<p><img src="/posts/ec3642b8/image-20210503123218934.png" alt="image-20210503123218934"></p>
<p>右键–&gt;创建表。</p>
<p><img src="/posts/ec3642b8/image-20210503123942013.png" alt="image-20210503123942013"></p>
<p>填入信息。</p>
<p><img src="/posts/ec3642b8/image-20210503124527839.png" alt="image-20210503124527839"></p>
<p>查看表：</p>
<p>选中左侧表下属的student，打开表。</p>
<p>尝试添加删除数据：</p>
<p><img src="/posts/ec3642b8/image-20210503125105714.png" alt="image-20210503125105714"></p>
<h2 id="3-连接数据库"><a href="#3-连接数据库" class="headerlink" title="3.连接数据库"></a>3.连接数据库</h2><p>在cmd中输入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span>mysql <span class="operator">-</span>uroot <span class="operator">-</span>p你的密码 <span class="comment">--连接数据库</span></span><br><span class="line"><span class="comment">-------------------------------</span></span><br><span class="line"><span class="comment">--注意：所有的语句都用;结尾</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> databases;<span class="comment">--查看所有的数据库</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> Database           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> information_schema <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> bipowernode        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> performance_schema <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> school             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sys                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> use school<span class="comment">--使用切换数据库，use 数据库名</span></span><br><span class="line">Database changed</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;<span class="comment">--查看当前数据库所有的表</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_school <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span> student          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">describe</span> student;<span class="comment">--查看查看当前数据库所有表的信息</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type         <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> <span class="type">int</span>(<span class="number">10</span>)      <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">100</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> age   <span class="operator">|</span> <span class="type">int</span>(<span class="number">3</span>)       <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> database school;<span class="comment">--创建一个数据库</span></span><br><span class="line"><span class="comment">-----------------------------------</span></span><br><span class="line">mysql<span class="operator">&gt;</span> exit;<span class="comment">--退出连接</span></span><br><span class="line"><span class="comment">--单行注释（SQL本来的注释）</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">SQL的多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>对于SQLyog的操作：选中语句执行</p>
<p><img src="/posts/ec3642b8/image-20210503134031081.png" alt="image-20210503134031081"></p>
<h2 id="4-数据库的四种语言"><a href="#4-数据库的四种语言" class="headerlink" title="4.数据库的四种语言"></a>4.数据库的四种语言</h2><p>CRUD：增删改查</p>
<ol>
<li>DDL： 数据库定义语言</li>
<li>DML：数据库操作语言</li>
<li>DQL： 数据库查询语言</li>
<li>DCL：  数据库控制语言</li>
</ol>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习笔记（三）</title>
    <url>/posts/913e0d32.html</url>
    <content><![CDATA[<h2 id="1-创建数据库表"><a href="#1-创建数据库表" class="headerlink" title="1.创建数据库表"></a>1.创建数据库表</h2><span id="more"></span>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 注意：表的名称和字段尽量用``包起来</span></span><br><span class="line"><span class="comment">-- 字符串使用单引号括起来！（双引号也行）</span></span><br><span class="line"><span class="comment">-- 所有语句后面加,最后一个不用</span></span><br><span class="line"><span class="comment">-- primary key，主键一般一张表一个</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `student` (</span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;学号&#x27;</span>,</span><br><span class="line">`name` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;匿名&#x27;</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">`pwd` <span class="type">VARCHAR</span>(<span class="number">15</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;12345&#x27;</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">`gender` <span class="type">VARCHAR</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;女&#x27;</span> COMMENT <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">`birthday` DATETIME <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;出生日期&#x27;</span>,</span><br><span class="line">`address` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;家庭住址&#x27;</span>,</span><br><span class="line">`email` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(`id`)</span><br><span class="line">)ENGINE <span class="operator">=</span> INNODB <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8</span><br></pre></td></tr></table></figure>

<h2 id="2-三个常用命令"><a href="#2-三个常用命令" class="headerlink" title="2.三个常用命令"></a>2.三个常用命令</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看数据库和表的创建语句</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE school</span><br><span class="line"><span class="comment">-- CREATE DATABASE `school` /*!40100 DEFAULT CHARACTER SET utf8 */</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student`</span><br><span class="line"><span class="comment">-- CREATE TABLE IF NOT EXISTS `student`(XXX)XXX</span></span><br><span class="line"><span class="keyword">DESC</span> student</span><br><span class="line"><span class="comment">-- 查看表的结构</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/913e0d32/image-20210504173551477.png" alt="image-20210504173551477"></p>
<h2 id="3-数据表的类型"><a href="#3-数据表的类型" class="headerlink" title="3.数据表的类型"></a>3.数据表的类型</h2><p>关于数据库引擎：（了解）</p>
<p>默认使用INNODB，</p>
<p>早些年使用MYISAM。</p>
<p>两者的区别：</p>
<p><img src="/posts/913e0d32/image-20210504173012750.png" alt="image-20210504173012750"></p>
<p>所有数据库文件都存在data目录下，一个文件夹对应一个数据库。</p>
<p>数据库本质还是用文件存储。</p>
<p><img src="/posts/913e0d32/image-20210504173513323.png" alt="image-20210504173513323"></p>
<p>了解。</p>
<p>charset设置数据库表的字符集编码。</p>
<p>不设置的话，默认的不支持中文</p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习笔记（二）</title>
    <url>/posts/dc20ae60.html</url>
    <content><![CDATA[<h2 id="1-操作数据库（了解）"><a href="#1-操作数据库（了解）" class="headerlink" title="1.操作数据库（了解）"></a>1.操作数据库（了解）</h2><p>操作数据库–&gt;操作数据库中的表–&gt;操作数据库中表的数据。</p>
<p>创建、使用和删除数据库。</p>
<p><strong>MySQL关键字不区分大小写。</strong></p>
<span id="more"></span>

<p>1.创建数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE (IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>) xxx; <span class="comment">--注意()表示选用，不是命令的一部分，如果不存在就创建</span></span><br></pre></td></tr></table></figure>

<p>2.删除数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE (IF <span class="keyword">EXISTS</span>) hello</span><br></pre></td></tr></table></figure>

<p>3.使用数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE `school` <span class="comment">--如果你的表名或字段名是一个特殊词语，加上``修饰</span></span><br><span class="line"><span class="comment">--它是为了区分MYSQL的保留字与普通字符而引入的符号，比如使用user容易与sql关键字混淆</span></span><br></pre></td></tr></table></figure>

<p>4.查看所有数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES; <span class="comment">--记得加S</span></span><br></pre></td></tr></table></figure>

<p>以上四条命令对照SQLyog的可视化操作学习。</p>
<p>不会某个命令时，在SQLyog执行可视化操作，然后在历史记录中查看对应的语句。</p>
<h2 id="2-数据库的列类型"><a href="#2-数据库的列类型" class="headerlink" title="2.数据库的列类型"></a>2.数据库的列类型</h2><p>参考教程：<a href="https://www.w3cschool.cn/mysql/mysql-data-types.html">https://www.w3cschool.cn/mysql/mysql-data-types.html</a></p>
<p>MySQL 支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。</p>
<h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><table>
<thead>
<tr>
<th align="left"><strong>类型</strong></th>
<th align="left"><strong>大小</strong></th>
<th align="left"><strong>范围（有符号）</strong></th>
<th align="left"><strong>范围（无符号）</strong></th>
<th align="left"><strong>用途</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">TINYINT</td>
<td align="left">1 字节</td>
<td align="left">(-128，127)</td>
<td align="left">(0，255)</td>
<td align="left">小整数值</td>
</tr>
<tr>
<td align="left">SMALLINT</td>
<td align="left">2 字节，较小</td>
<td align="left">(-32 768，32 767)</td>
<td align="left">(0，65 535)</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="left">MEDIUMINT</td>
<td align="left">3 字节</td>
<td align="left">(-8 388 608，8 388 607)</td>
<td align="left">(0，16 777 215)</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="left"><strong>INT</strong>或INTEGER</td>
<td align="left">4 字节，常用</td>
<td align="left">(-2 147 483 648，2 147 483 647)</td>
<td align="left">(0，4 294 967 295)</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="left">BIGINT</td>
<td align="left">8 字节，类似long</td>
<td align="left">(-9 233 372 036 854 775 808，9 223 372 036 854 775 807)</td>
<td align="left">(0，18 446 744 073 709 551 615)</td>
<td align="left"><strong>极大整数值</strong></td>
</tr>
<tr>
<td align="left"><strong>FLOAT</strong></td>
<td align="left">4 字节</td>
<td align="left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td>
<td align="left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td>
<td align="left"><strong>单精度 浮点数值</strong></td>
</tr>
<tr>
<td align="left"><strong>DOUBLE</strong></td>
<td align="left">8 字节</td>
<td align="left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td align="left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td align="left">双精度 浮点数值</td>
</tr>
<tr>
<td align="left"><strong>DECIMAL</strong></td>
<td align="left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td>
<td align="left">依赖于M和D的值，字符串形式浮点数，金融计算常用</td>
<td align="left">依赖于M和D的值</td>
<td align="left">小数值</td>
</tr>
</tbody></table>
<h3 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h3><blockquote>
<p>java.util.Date</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小 (字节)</th>
<th align="left">范围</th>
<th align="left">格式</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>DATE</strong></td>
<td align="left">3</td>
<td align="left">1000-01-01/9999-12-31</td>
<td align="left"><strong>YYYY-MM-DD</strong></td>
<td align="left">日期值</td>
</tr>
<tr>
<td align="left"><strong>TIME</strong></td>
<td align="left">3</td>
<td align="left">‘-838:59:59’/‘838:59:59’</td>
<td align="left"><strong>HH:MM:SS</strong></td>
<td align="left">时间值或持续时间</td>
</tr>
<tr>
<td align="left">YEAR</td>
<td align="left">1</td>
<td align="left">1901/2155</td>
<td align="left">YYYY</td>
<td align="left">年份值</td>
</tr>
<tr>
<td align="left"><strong>DATETIME</strong>，最常用</td>
<td align="left">8</td>
<td align="left">1000-01-01 00:00:00/9999-12-31 23:59:59</td>
<td align="left"><strong>YYYY-MM-DD HH:MM:SS</strong></td>
<td align="left">混合日期和时间值</td>
</tr>
<tr>
<td align="left"><strong>TIMESTAMP</strong>，时间戳</td>
<td align="left">4</td>
<td align="left">1970-01-01 00:00:00/2038 结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038-1-19 03:14:07</td>
<td align="left">YYYYMMDD HHMMSS</td>
<td align="left">混合日期和时间值，时间戳</td>
</tr>
</tbody></table>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CHAR</td>
<td align="left">0-255字节</td>
<td align="left">定长字符串</td>
</tr>
<tr>
<td align="left"><strong>VARCHAR</strong></td>
<td align="left">0-65535 字节</td>
<td align="left"><strong>变长字符串</strong>，<strong>常用</strong></td>
</tr>
<tr>
<td align="left">TINYBLOB</td>
<td align="left">0-255字节</td>
<td align="left">不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td align="left">TINYTEXT</td>
<td align="left">0-255字节</td>
<td align="left">短文本字符串，用于博客等</td>
</tr>
<tr>
<td align="left">BLOB</td>
<td align="left">0-65 535字节</td>
<td align="left">二进制形式的长文本数据</td>
</tr>
<tr>
<td align="left"><strong>TEXT</strong></td>
<td align="left">0-65 535字节</td>
<td align="left">长文本数据，<strong>存放大文本</strong></td>
</tr>
<tr>
<td align="left">MEDIUMBLOB</td>
<td align="left">0-16 777 215字节</td>
<td align="left">二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td align="left">MEDIUMTEXT</td>
<td align="left">0-16 777 215字节</td>
<td align="left">中等长度文本数据</td>
</tr>
<tr>
<td align="left">LONGBLOB</td>
<td align="left">0-4 294 967 295字节</td>
<td align="left">二进制形式的极大文本数据</td>
</tr>
<tr>
<td align="left">LONGTEXT</td>
<td align="left">0-4 294 967 295字节</td>
<td align="left">极大文本数据</td>
</tr>
</tbody></table>
<h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><p>没有值，未知，<strong>注意不要使用它运算</strong>。</p>
<h2 id="3-数据库的字段属性（重点）"><a href="#3-数据库的字段属性（重点）" class="headerlink" title="3.数据库的字段属性（重点）"></a>3.数据库的字段属性（重点）</h2><p>Unsigned：</p>
<ul>
<li>无符号整数</li>
<li>声明该列不能为负数</li>
</ul>
<p>Zerofill：</p>
<ul>
<li>零填充</li>
<li>不足的位数用0填充，int(3)，5–&gt;005</li>
</ul>
<p>自增：</p>
<ul>
<li><p>通常理解为自增，自动在上一条记录的基础上+1（默认）</p>
</li>
<li><p>通常用来设计唯一的主键，必须是整数类型</p>
</li>
<li><p>可以自定义主键自增的起始值和步长</p>
</li>
</ul>
<p>非空 not null：</p>
<ul>
<li>设置为not null时，不赋值就会报错！</li>
<li>不填写时默认为NULL</li>
</ul>
<p>默认：</p>
<ul>
<li>设置默认值，如果不指定该列的值，设定为默认值</li>
</ul>
<p>拓展：听听就好</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 每个表都必须存在以下五个字段！</span></span><br><span class="line"><span class="comment">id 主键</span></span><br><span class="line"><span class="comment">`version` 乐观锁</span></span><br><span class="line"><span class="comment">is_delete 伪删除</span></span><br><span class="line"><span class="comment">gmt_create 创建时间</span></span><br><span class="line"><span class="comment">gmt_update 修改时间</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>现在只作为了解，以后做项目会用到！</p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Python入门笔记（一）</title>
    <url>/posts/5092f4ee.html</url>
    <content><![CDATA[<h5 id="1-多行语句"><a href="#1-多行语句" class="headerlink" title="1.多行语句"></a>1.多行语句</h5><p>使用 \ 来实现多行语句：（尽量不用续行符）</p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br><span class="line">s = <span class="string">&#x27;string,\</span></span><br><span class="line"><span class="string">abc,\</span></span><br><span class="line"><span class="string">de&#x27;</span>  <span class="comment"># 注意这里续行符后不能存在空格，续行符之后直接换行</span></span><br></pre></td></tr></table></figure>

<p>在  [], {}, 或 () 中的多行语句，不需要使用反斜杠()，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total = [<span class="string">&#x27;item_one&#x27;</span>, <span class="string">&#x27;item_two&#x27;</span>, <span class="string">&#x27;item_three&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;item_four&#x27;</span>, <span class="string">&#x27;item_five&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h5 id="2-print函数的格式化输出"><a href="#2-print函数的格式化输出" class="headerlink" title="2.print函数的格式化输出"></a>2.print函数的格式化输出</h5><p>示例：</p>
<p>练习1：华氏温度转换为摄氏温度。</p>
<blockquote>
<p>提示：华氏温度到摄氏温度的转换公式为：$C=(F−32)÷1.8$</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入华氏温度: &#x27;</span>))</span><br><span class="line">c = (f - <span class="number">32</span>) / <span class="number">1.8</span></span><br><span class="line">print(<span class="string">&#x27;%.1f华氏度 = %.1f摄氏度&#x27;</span> % (f, c)) <span class="comment"># solution1</span></span><br><span class="line">print(<span class="string">&#x27;&#123;:.1f&#125;华氏度 = &#123;:.1f&#125;摄氏度&#x27;</span>.<span class="built_in">format</span>(f,c))<span class="comment"># solution2,不带编号输出</span></span><br><span class="line">print(<span class="string">&#x27;&#123;0:.1f&#125;华氏度 = &#123;1:.1f&#125;摄氏度&#x27;</span>.<span class="built_in">format</span>(f,c))<span class="comment"># solution3,带编号输出</span></span><br><span class="line">print(<span class="string">f&#x27;<span class="subst">&#123;f:<span class="number">.1</span>f&#125;</span>华氏度 = <span class="subst">&#123;c:<span class="number">.1</span>f&#125;</span>摄氏度&#x27;</span>)<span class="comment"># solution4,带关键字输出1</span></span><br><span class="line">print(<span class="string">&#x27;&#123;0:.1f&#125;华氏度 = &#123;1:.1f&#125;摄氏度&#x27;</span>.<span class="built_in">format</span>(f,c))<span class="comment"># solution5,带关键字输出2</span></span><br></pre></td></tr></table></figure>

<h6 id="2-1-操作符的使用："><a href="#2-1-操作符的使用：" class="headerlink" title="2.1 %操作符的使用："></a>2.1 %操作符的使用：</h6><p>%o：oct，八进制</p>
<p>%c:  返回整数对应的Unicode字符</p>
<p>%d：dec，十进制；%2d ：占位符2位，空格填充；%02d：占位符2位，0填充</p>
<p>%x：hex，十六进制</p>
<p>%f：保留小数点后6位有效数字。如果是%.3f则保留3位小数</p>
<p>%e：保留小数点后6位有效数字，按指数形式输出，如果是%.3e则保留3位小数位，使用科学记数法</p>
<p>%s：字符串</p>
<p>%10s：右对齐，占位符10位</p>
<p>%-10s：左对齐，占位符10位</p>
<p>%.2s：截取两位字符串</p>
<p>%10.2s：10位占位符，截取两位字符串</p>
<h6 id="2-2-str-format-格式化："><a href="#2-2-str-format-格式化：" class="headerlink" title="2.2 str.format() 格式化："></a>2.2 str.format() 格式化：</h6><p>{:.2f}: 保留2位小数</p>
<p>{:+.2f}: 带正负号，保留2位小数</p>
<p><strong>{:.0f}: 不带小数</strong></p>
<p>{:0&gt;2d}: 数字补零 (填充左边, 宽度为2)，即右对齐</p>
<p>{:x&lt;4d} : 数字补x (填充右边, 宽度为4) ，即左对齐</p>
<p>{:,} : 以逗号分隔的数字，每三位分隔</p>
<p>{:.2e} : 指数计数法，例1.00e+09 </p>
<p>{:&gt;10d} ,{:&lt;10d} ,{:^10d} : 右，左，居中对齐，宽度为10</p>
<p>{:b},{:d},{:o},{:x},{:#x},{:c}: 输出二，十，八，十六进制数，整数对应的Unicode字符</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>‘&#123;:b&#125;’.format(11)  ‘&#123;:d&#125;’.format(11)  ‘&#123;:o&#125;’.format(11)  ‘&#123;:x&#125;’.format(11)  ‘&#123;:#x&#125;’.format(11)  ‘&#123;:#X&#125;’.format(11)</code></td>
<td>1011  11  13  b  0xb  0XB</td>
</tr>
</tbody></table>
<p>^, &lt;, &gt; 分别是居中、左对齐、右对齐，后面带宽度， : 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。</p>
<p>+ 表示在正数前显示 +，负数前显示 -；<code> </code>（空格）表示在正数前加空格</p>
<p>b、d、o、x 分别是二进制、十进制、八进制、十六进制。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#此外我们可以使用大括号 &#123;&#125; 来转义大括号</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> (<span class="string">&quot;&#123;&#125; 对应的位置是 &#123;&#123;0&#125;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;runoob&quot;</span>))</span><br><span class="line">runoob 对应的位置是 &#123;<span class="number">0</span>&#125;</span><br><span class="line"><span class="comment"># 字符串拼接</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">&#x27;dDASD&#x27;</span>,<span class="string">&#x27;fdsd&#x27;</span>,<span class="string">&#x27;dsf&#x27;</span>)</span><br><span class="line"><span class="comment">#print()会依次打印每个字符串，遇到逗号“,”会输出一个空格</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/5092f4ee/image-20210117141051561.png" alt="image-20210117141051561"></p>
<p>注意引导符号的优先顺序！！！以上表格建议背下来！！！</p>
<h5 id="3-python的主要数据类型"><a href="#3-python的主要数据类型" class="headerlink" title="3.python的主要数据类型"></a>3.python的主要数据类型</h5><ul>
<li> number：int, bool, float, complex 其中bool包括True和False</li>
<li> str：加了引号的字符都被认为是字符串</li>
<li> tuple：元组和列表一样，也是一种序列，与列表不同的是，元组是不可修改的</li>
<li> dict：字典是一种键值对的集合，列表是有序的对象集合，字典是无序的对象集合</li>
<li> set：集合是一个无序的、不重复的数据组合，主要作用有两个，分别是去重和关系测试</li>
<li> list：列表是由一系列特定元素顺序排列的元素组成的</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># list</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="string">&#x27;two&#x27;</span>,<span class="number">3.0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># tuple</span></span><br><span class="line">b = (<span class="number">1</span>,<span class="string">&#x27;throw&#x27;</span>,<span class="number">4.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dict</span></span><br><span class="line">c = &#123;<span class="number">1</span>:<span class="string">&#x27;one&#x27;</span>,<span class="number">2</span>:<span class="string">&#x27;two&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># set</span></span><br><span class="line">d = <span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>])</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">set</span></span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; <span class="comment"># set只保留不重复的数据</span></span><br></pre></td></tr></table></figure>

<h5 id="4-变量类型转换"><a href="#4-变量类型转换" class="headerlink" title="4.变量类型转换"></a>4.变量类型转换</h5><p>可以使用Python中内置的函数对变量类型进行转换。</p>
<ul>
<li><code>int()</code>：将一个数值或字符串转换成整数，可以指定进制。</li>
<li><code>float()</code>：将一个字符串转换成浮点数。</li>
<li><code>str()</code>：将指定的对象转换成字符串形式，可以指定编码。</li>
<li><code>chr()</code>：将整数转换成该编码对应的字符串（一个字符）。</li>
<li><code>ord()</code>：将字符串（一个字符）转换成对应的编码（整数）。</li>
</ul>
<h5 id="5-常用运算符"><a href="#5-常用运算符" class="headerlink" title="5.常用运算符"></a>5.常用运算符</h5><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>[]</code> <code>[:]</code></td>
<td>下标，切片</td>
</tr>
<tr>
<td>**</td>
<td>指数</td>
</tr>
<tr>
<td><code>~ + -</code></td>
<td>按位取反，正负号</td>
</tr>
<tr>
<td><code>* / % //</code></td>
<td>乘，除，模，整除</td>
</tr>
<tr>
<td><code>is</code> <code>is not</code></td>
<td>身份运算符</td>
</tr>
<tr>
<td><code>in</code>  <code>not in</code></td>
<td>成员运算符</td>
</tr>
<tr>
<td><code>not</code> <code>or</code> <code>and</code></td>
<td>逻辑运算符，与C的&amp;&amp;，！，||注意区别</td>
</tr>
</tbody></table>
<p><strong>优先级：not &gt; and &gt;or</strong>　</p>
<p><strong>说明：</strong>   大家可以自己感受一下这两种写法到底是哪一种更好。在之前我们提到的Python之禅中有这么一句话“Flat is better than   nested.”，之所以提倡代码“扁平化”是因为嵌套结构的嵌套层次多了之后会严重的影响代码的可读性，所以能使用扁平化的结构时就不要使用嵌套。</p>
<h5 id="6-循环结构"><a href="#6-循环结构" class="headerlink" title="6.循环结构"></a>6.循环结构</h5><p>在Python中构造循环结构有两种做法，一种是<code>for-in</code>循环，一种是<code>while</code>循环。</p>
<h6 id="6-1-for-in-循环"><a href="#6-1-for-in-循环" class="headerlink" title="6.1 for-in 循环"></a>6.1 for-in 循环</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">用for循环实现1~100求和</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">101</span>): <span class="comment"># 不写的话默认从0开始</span></span><br><span class="line">    <span class="built_in">sum</span> += x</span><br><span class="line">print(<span class="built_in">sum</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">打印乘法口诀表</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">        print(<span class="string">&#x27;%d*%d=%d&#x27;</span> % (i, j, i * j), end=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure>

<p>需要说明的是上面代码中的<code>range(1, 101)</code>可以用来构造一个从1到100的范围，当我们把这样一个范围放到<code>for-in</code>循环中，就可以通过前面的循环变量<code>x</code>依次取出从1到100的整数。当然，<code>range</code>的用法非常灵活，下面给出了一个例子：</p>
<ul>
<li><code>range(101)</code>：可以用来产生0到100范围的整数，需要注意的是取不到101。</li>
<li><code>range(1, 101)</code>：(左闭右开)可以用来产生1到100范围的整数，相当于前面是闭区间后面是开区间。</li>
<li><code>range(1, 101, 2)</code>：可以用来产生1到100的奇数，其中2是步长，即每次数值递增的值。</li>
<li><code>range(100, 0, -2)</code>：可以用来产生100到1的偶数，其中-2是步长，即每次数字递减的值。</li>
</ul>
<h6 id="6-2-while-循环"><a href="#6-2-while-循环" class="headerlink" title="6.2 while 循环"></a>6.2 while 循环</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    counter += <span class="number">1</span></span><br><span class="line">    number = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入: &#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>注意break和continue关键字，作用基本同C/C++.</p>
<h5 id="7-练习：输入两个正整数，计算它们的最大公约数和最小公倍数。"><a href="#7-练习：输入两个正整数，计算它们的最大公约数和最小公倍数。" class="headerlink" title="7.练习：输入两个正整数，计算它们的最大公约数和最小公倍数。"></a>7.练习：输入两个正整数，计算它们的最大公约数和最小公倍数。</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;x = &#x27;</span>))</span><br><span class="line">y = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;y = &#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x &gt; y: <span class="comment"># 这里可以直接简化为 x,y = y,x</span></span><br><span class="line">    t = x</span><br><span class="line">    x = y</span><br><span class="line">    y = t</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(x,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> x%n <span class="keyword">and</span> <span class="keyword">not</span> y%n:</span><br><span class="line">        print(<span class="string">&#x27;&#123;&#125;是最大公约数，&#123;&#125;是最小公倍数&#x27;</span>.<span class="built_in">format</span>(n,x*y//n)) <span class="comment"># &quot;//&quot; 对应C的&quot;/&quot;</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h5 id="8-整数与浮点数"><a href="#8-整数与浮点数" class="headerlink" title="8.整数与浮点数"></a>8.整数与浮点数</h5><p>二进制（Bin）：0b或0B，例0b1010</p>
<p>八进制（Oct）：0o或0O，例0o1010</p>
<p>十进制（Dec）：无，默认十进制</p>
<p>十六进制（Hex）：0x或0X，例0x1010</p>
<p>浮点数科学计数法：<code>1e-6 == 1*10^-6</code></p>
<p>注意浮点数的计算不是完全精确的！！！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># solution 1,使用round函数四舍五入保留一定位数再判断</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(<span class="number">0.1</span>+<span class="number">0.2</span>,<span class="number">5</span>) == <span class="built_in">round</span>(<span class="number">0.3</span>,<span class="number">5</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(<span class="number">0.1</span>+<span class="number">0.2</span>,<span class="number">20</span>) == <span class="built_in">round</span>(<span class="number">0.3</span>,<span class="number">20</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#solution 2,两数作差，当差值足够小时认为近似相等</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>((<span class="number">0.1</span>+<span class="number">0.2</span>)-<span class="number">0.3</span>) &lt; <span class="number">1e-10</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h5 id="9-一些内置数值运算函数"><a href="#9-一些内置数值运算函数" class="headerlink" title="9.一些内置数值运算函数"></a>9.一些内置数值运算函数</h5><table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>abs(x)</td>
<td>x的绝对值  ，计算整数、浮点数结果为非负值，也可用于复数</td>
</tr>
<tr>
<td>divmod(x,y)</td>
<td>(x//y,x%y)，输出为二元组形式</td>
</tr>
<tr>
<td>pow(x,y)或pow(x,y,z)</td>
<td><code>x**y或(x**y)%z</code>，幂运算</td>
</tr>
<tr>
<td>round(x)或round(x,d)</td>
<td>对x四舍五入，保留d位小数，无参则返回x的整数</td>
</tr>
<tr>
<td>max(x1,x2,…,xn)</td>
<td>任意数量的最大值</td>
</tr>
<tr>
<td>min(x1,x2, …,xn)</td>
<td>任意数量的最小值</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">divmod</span>(<span class="number">10</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">pow</span>(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>) == <span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">5</span>)%<span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(<span class="number">1</span>,<span class="number">3</span>),<span class="built_in">round</span>(<span class="number">0.5</span>),<span class="built_in">round</span>(<span class="number">1.5</span>) <span class="comment"># 奇进偶不进只针对round(x)</span></span><br><span class="line"><span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span> <span class="comment"># 奇进偶不进取决于小数点前一位</span></span><br><span class="line"><span class="comment"># 如果保留小数位数是0位或1位，奇进偶不进</span></span><br><span class="line"><span class="comment"># 如果保留位数的后一位数字是5且后面还有数字，则进</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(<span class="number">2.30000045</span>,<span class="number">5</span>) <span class="comment"># 多余的0省略s</span></span><br><span class="line"><span class="number">2.3</span></span><br><span class="line"><span class="comment"># round()函数掌握一进整，二进一即可，可能存在一些精度问题，避免使用太多</span></span><br></pre></td></tr></table></figure>

<h5 id="10-字符串"><a href="#10-字符串" class="headerlink" title="10.字符串"></a>10.字符串</h5><p>两种索引方式：（1）从左到右，从0开始到长度-1,；（2）从右到左，从-1开始到开头</p>
<p>截取方式：</p>
<p><img src="/posts/5092f4ee/image-20210113132138310.png" alt="image-20210113132138310"></p>
<p><strong>牢牢记住</strong>：不管索引还是截断，都是<strong>左闭右开</strong>的！！！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span> = <span class="string">&#x27;IlovePython&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>[<span class="number">3</span>] <span class="comment"># 第4个字符</span></span><br><span class="line"><span class="string">&#x27;v&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>[-<span class="number">3</span>] <span class="comment"># 倒数第3个字符</span></span><br><span class="line"><span class="string">&#x27;h&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>[:] <span class="comment"># 整个字符串</span></span><br><span class="line"><span class="string">&#x27;IlovePython&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>[<span class="number">1</span>:] <span class="comment"># 第2个字符 -&gt; 最后面</span></span><br><span class="line"><span class="string">&#x27;lovePython&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>[<span class="number">2</span>:<span class="number">6</span>] <span class="comment"># 第3个字符 -&gt; 第6个</span></span><br><span class="line"><span class="string">&#x27;oveP&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>[:-<span class="number">1</span>] <span class="comment"># 最前面 -&gt; 倒数第2个(左闭右开，不包括最后一个)</span></span><br><span class="line"><span class="string">&#x27;IlovePytho&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>[-<span class="number">5</span>:-<span class="number">1</span>] <span class="comment"># 倒数第5个 -&gt; 倒数第2个(左闭右开，不包括最后一个)</span></span><br><span class="line"><span class="string">&#x27;ytho&#x27;</span></span><br></pre></td></tr></table></figure>

<p>创建字符串：单、双、三引号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;asdsd&#x27;</span> <span class="keyword">or</span> s = <span class="string">&quot;sadaf&quot;</span></span><br><span class="line">s = <span class="string">&#x27;&#x27;&#x27;asdfdf!</span></span><br><span class="line"><span class="string">afdgg&#x27;&#x27;&#x27;</span> <span class="comment"># 相当于加一个\n</span></span><br></pre></td></tr></table></figure>

<p>len()函数：返回字符串长度或者字符数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#ininstance()和type()判断类型：</span></span><br><span class="line">s = <span class="string">&#x27;adsaf&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(s)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">str</span>&#x27;&gt;</span></span><br><span class="line">&gt;&gt;&gt; type(s) == str</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(s,<span class="built_in">str</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>字符串的相关操作：</p>
<p><code>x + y</code>: 连接两个字符串x，y，不加空格，如果用逗号会自动加空格</p>
<p><code>x * n</code>: 复制n次字符(串)x</p>
<p><code>x in s</code>: x 在s中，返回True</p>
<p><code>x not in s</code>:与上面相反</p>
<p>r/R:原始字符串（raw），所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。在字符串的第一个引号前加上字母 r/R。<code>print( r&#39;\badc\t\n&#39; )</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">&#x27;a&#x27;</span> * <span class="number">8</span>)</span><br><span class="line">aaaaaaaa</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">&#x27;a,b&#x27;</span> * <span class="number">4</span>)</span><br><span class="line">a,ba,ba,ba,b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;fggfsgradgf&#x27;</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>字符串处理函数：</p>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>len(x)</td>
<td>返回字符串x的长度或者是其他组合类型的元素个数</td>
</tr>
<tr>
<td>str(x)</td>
<td>把任意类型转换为字符串形式</td>
</tr>
<tr>
<td>chr(x)</td>
<td>返回Unicode编码对应的单字符，<strong>注意是Unicode不是ASCII</strong></td>
</tr>
<tr>
<td>ord(x)</td>
<td>返回单个字符对应的Unicode编码</td>
</tr>
<tr>
<td>hex(x)</td>
<td>返回整数x对应的十六进制的小写形式，返回字符串</td>
</tr>
<tr>
<td>oct(x)</td>
<td>返回整数x对应的八进制的小写形式返回字符串</td>
</tr>
</tbody></table>
<p>字符串处理方法：（str用于替换字符串变量名）</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>str.lower()</td>
<td>以小写的方式全部返回str的副本</td>
</tr>
<tr>
<td>str.upper()</td>
<td>以大写的方式全部返回str的副本</td>
</tr>
<tr>
<td>str.split(sep=None)</td>
<td>返回一个列表，以sep作为分隔点，sep默认为空格或\n</td>
</tr>
<tr>
<td>str.count(sub)</td>
<td>返回sub子串出现的次数</td>
</tr>
<tr>
<td>str.replace(old,new)</td>
<td>返回字符串str的副本，所有old子串被替换为new</td>
</tr>
<tr>
<td>str.center(width,fillchar)</td>
<td>字符串居中函数，fillchar参数可选，用于填充</td>
</tr>
<tr>
<td>str.format()</td>
<td>格式化字符串</td>
</tr>
<tr>
<td>str.strip(chars)</td>
<td>从字符串str中去掉在其左侧和右侧chars中列出的字符</td>
</tr>
<tr>
<td>str.join(iter)</td>
<td>将iter变量的每一个元素后面增加一个str</td>
</tr>
<tr>
<td>str.isdigit()</td>
<td>如果 str只包含数字则返回 True 否则返回 False.</td>
</tr>
</tbody></table>
<p>str.join(iter)：注意，str是一个字符串，里面包含着你将要将可迭代变量中元素分隔的符号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;abc&quot;</span></span><br><span class="line">print(<span class="string">&quot;,&quot;</span>.join(s))</span><br><span class="line"><span class="comment"># a,b,c</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意str.replace()返回str的副本，并不会修改str</span></span><br><span class="line">s = <span class="string">&quot;bilaoshi&quot;</span></span><br><span class="line">print(s.replace(<span class="string">&quot;bi&quot;</span>,<span class="string">&quot;xu&quot;</span>))</span><br><span class="line">print(s)</span><br><span class="line"><span class="comment"># xulaoshi</span></span><br><span class="line"><span class="comment"># bilaoshi</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;1234&quot;</span>.isdigit()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;213.254&quot;</span>.isdigit()</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Python入门笔记（三）</title>
    <url>/posts/2d9abb64.html</url>
    <content><![CDATA[<h2 id="1-函数"><a href="#1-函数" class="headerlink" title="1.函数"></a>1.函数</h2><p>四种传递参数的方式！！！</p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    print(a+b)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">sum</span>(<span class="number">2</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><strong>位置参数</strong>是比较常用的形式，调用函数时实参和形参的顺序必须一致，并且数量相同。</p>
<p>​    <strong>默认值参数</strong>：函数的参数在定义时也可以指定默认值，函数调用时若该位置没有给定实际参数，则使用默认值代替。但需要注意可选参数应当放在非可选参数后面。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">x,y=<span class="number">10</span></span>):</span></span><br><span class="line">    print(x*y)</span><br><span class="line"></span><br><span class="line">mul(<span class="number">2</span>,<span class="number">5</span>)<span class="comment"># 2 * 5 = 10</span></span><br><span class="line">mul(<span class="number">2</span>)<span class="comment"># 2 * 10 = 20</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">y=<span class="number">10</span>,x</span>):</span> <span class="comment">#ERROR:默认参数不能放在位置参数前面</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">x,z,y=<span class="number">10</span></span>):</span></span><br><span class="line">    print(x*y)</span><br><span class="line">mul(<span class="number">2</span>,<span class="number">3</span>) <span class="comment"># 20</span></span><br></pre></td></tr></table></figure>

<p><strong>关键字参数</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    print(x,y)</span><br><span class="line">    </span><br><span class="line">mul(y = <span class="number">2</span>,x = <span class="number">99</span>)</span><br></pre></td></tr></table></figure>

<p><strong>可变长度参数</strong>：</p>
<p>除了以上传参方式以外，当我们不确定会接受多少个参数的时候可以利用可变长度参数解决。</p>
<p>​    *param接收任意多个参数放在一个元组中</p>
<p>​    **param接收任意多个关键字参数放入字典中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  *param返回元组</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">*x</span>):</span></span><br><span class="line">    print(x)</span><br><span class="line">    </span><br><span class="line">mul(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)<span class="comment"># (2, 3, 4, 5, 6, 7)</span></span><br><span class="line"><span class="comment"># **param返回字典</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span>(<span class="params">**p</span>):</span></span><br><span class="line">    print(p)</span><br><span class="line">demo(a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>)<span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span></span><br><span class="line">demo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)<span class="comment"># ERROR:只能以关键字方式接受参数</span></span><br></pre></td></tr></table></figure>

<h2 id="2-变量的作用域"><a href="#2-变量的作用域" class="headerlink" title="2.变量的作用域"></a>2.变量的作用域</h2><p>局部变量仅在函数内部，且作用域也在函数内部，全局变量的作用域跨越多个函数。</p>
<p>当局部变量与全局变量同名时，函数内部会优先使用局部变量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span> <span class="comment"># 全局变量</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    s = x + y</span><br><span class="line">    print(s)<span class="comment"># 3，局部变量</span></span><br><span class="line">    print(a)<span class="comment"># 1</span></span><br><span class="line"><span class="built_in">sum</span>(a,b)</span><br></pre></td></tr></table></figure>

<p>全局变量指在函数之外定义的变量，在程序执行全过程有效。全部变量在函数内部使用（修改）时，需要提前使用保留字global声明，语法形式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    s = x + y</span><br><span class="line">    a = <span class="number">4</span> <span class="comment"># 未使用global，在函数内部不能修改全局变量</span></span><br><span class="line">    <span class="comment"># 此处的a是一个同名的局部变量</span></span><br><span class="line">    <span class="comment"># 建议尽量不适用global，以免与外面代码形成耦合容易出错</span></span><br><span class="line"><span class="built_in">sum</span>(a,b)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    print(x+y)</span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a = <span class="number">4</span></span><br><span class="line"><span class="built_in">sum</span>(a,b)</span><br><span class="line">print(a)<span class="comment"># a == 4</span></span><br></pre></td></tr></table></figure>

<h2 id="3-函数的返回值"><a href="#3-函数的返回值" class="headerlink" title="3.函数的返回值"></a>3.函数的返回值</h2><ul>
<li>用return返回函数值，作用同C/C++。</li>
<li>return语句可以出现在函数中的任何部分。</li>
<li>return可以同时返回0个或多个函数运算的结果给函数被调用处的变量。</li>
<li>当return返回多个值时，返回的值形成元组数据类型。</li>
<li>函数也可以没有return代表无返回值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    s = x+y</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">print(<span class="built_in">sum</span>(a,b))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    s = x + y</span><br><span class="line">    v = x * y</span><br><span class="line">    <span class="keyword">return</span> s,v</span><br><span class="line">print(mul(a,b)) <span class="comment">#以元组形式返回值</span></span><br><span class="line">m = mul(a,b)</span><br><span class="line">print(m[<span class="number">1</span>])  </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">(3, 2)</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>代码复用（选择题常考）</strong></p>
<p>模块化设计指通过函数的封装功能将程序划分为主程序、子程序和子程序间关系的表达。模块化设计是使用函数设计程度的思考方法，以功能为基本单位，一般由两个基本要求：    </p>
<p>•紧耦合：尽可能合理划分功能模块，功能块内部耦合紧密。</p>
<p>•松耦合：模块间关系尽可能简单，功能块之间耦合度低。</p>
<p>耦合性指程序中各模块之间想相互关联的程度。</p>
<p><strong>匿名函数</strong></p>
<p>匿名函数适合处理临时需要一个类似于函数的功能但又不想定义函数的场合，可以省去函数的定义过程和考虑函数的命名，让代码更加简洁，可读性更好。</p>
<p>适合处理一些简单的函数</p>
<p>使用语法：<code>&lt;函数对象名&gt;=lambda &lt;形式参数列表&gt;:&lt;表达式&gt;</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">x:y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">fun = <span class="keyword">lambda</span> x,y:x+y</span><br><span class="line"><span class="comment"># 1和2是等价的</span></span><br><span class="line">print(fun(<span class="number">2</span>,<span class="number">3</span>))<span class="comment"># 5</span></span><br></pre></td></tr></table></figure>

<h2 id="4-组合数据类型"><a href="#4-组合数据类型" class="headerlink" title="4.组合数据类型"></a>4.组合数据类型</h2><p>注意：对于基本的数据类型，如整数或字符串，可以通过等号实现元素赋值。但对于列表类型，使用等号无法实现真正的赋值。其中，ls = lt语句并不是拷贝lt中 元素给变量ls，而是新关联了一个引用，即ls和lt所指向 的是同一套内容。</p>
<h2 id="5-做题总结"><a href="#5-做题总结" class="headerlink" title="5.做题总结"></a>5.做题总结</h2><p><img src="/posts/2d9abb64/image-20210119221538951.png" alt="image-20210119221538951"></p>
<p>如何读取类似用空格分隔的两个字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>()</span><br><span class="line">s = <span class="built_in">str</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">s1 = s[<span class="number">0</span>]</span><br><span class="line">s2 = s[<span class="number">1</span>]</span><br><span class="line">print(s1,s2)</span><br><span class="line"><span class="comment"># str == &quot;abc defg&quot;</span></span><br><span class="line"><span class="comment"># &quot;abc&quot; &amp; &quot;defg&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-文件"><a href="#6-文件" class="headerlink" title="6.文件"></a>6.文件</h2><p>（记住）<strong>文件主要分为：文本文件和二进制文件</strong>。</p>
<p>1、 文本文件一般由单一特定编码的字符组成，如 UTF-8编码，内容容易统一展示和阅读。 </p>
<p>2、 二进制文件直接由比特0和比特1组成，文件内部数据的组织格式与文件用途有关。二进制是信息按照非字符但特定格式形成的文件，例如，png 格式的图片文件、avi格式的视频文件。</p>
<p>3、二进制文件和文本文件最主要的区别在于是否有统一的字符编码。 </p>
<p> 4、无论文件创建为文本文件或者二进制文件，都可以用“文本文件方式”和“二进制文件方式”打开，但打开后的操作不同。</p>
<p><strong>（记住）</strong>采用文本方式读入文件，文件经过编码形成<strong>字符串</strong>，打印出有含义的字符；采用二进制方式打开文件，文件被解析为<strong>字节流</strong></p>
<p>Python对文本文件和二进制文件采用统一的操作步骤， 即“打开-操作-关闭”</p>
<p>open函数语法：<code>&lt;变量名&gt; = open(&lt;文件路径及文件名&gt;, &lt;打开模式&gt;)</code></p>
<table>
<thead>
<tr>
<th><strong>打开模式</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>‘r’</td>
<td>只读模式，如果文件不存在，返回异常FileNotFoundError，默认值</td>
</tr>
<tr>
<td>‘w’</td>
<td>覆盖写模式，文件不存在则创建，存在则完全覆盖源文件</td>
</tr>
<tr>
<td>‘x’</td>
<td>创建写模式，文件不存在则创建，存在则返回异常FileExistsError</td>
</tr>
<tr>
<td>‘a’</td>
<td>追加写模式，文件不存在则创建，存在则在原文件最后追加内容</td>
</tr>
<tr>
<td>‘b’</td>
<td>二进制文件模式</td>
</tr>
<tr>
<td>‘t’</td>
<td>文本文件模式，默认值</td>
</tr>
<tr>
<td>‘+’</td>
<td>与r/w/x/a一同使用，在原功能基础上增加同时读写功能</td>
</tr>
</tbody></table>
<p><img src="/posts/2d9abb64/image-20210222182101934.png" alt="image-20210222182101934"></p>
<p><img src="/posts/2d9abb64/image-20210222183442871.png" alt="image-20210222183442871"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;abc.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)<span class="comment"># 这里的txt是相对路径（与py文件同一级）</span></span><br><span class="line"><span class="comment"># 如果中文乱码</span></span><br><span class="line"><span class="comment"># 改成open(&quot;abc.txt&quot;,&quot;r&quot;,encoding = &quot;utf-8&quot;)</span></span><br><span class="line">s = f.read()</span><br><span class="line">print(s)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;F:\\Python二级\\abc.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="comment"># 采用绝对路径，用\\表示转义</span></span><br><span class="line"><span class="comment"># 写法2：f = open(&quot;F:/Python二级/abc.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;)</span></span><br><span class="line"><span class="comment"># 写法3：f = open(r&quot;F:\Python二级\abc.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;)</span></span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;b.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)<span class="comment">#  覆盖写模式</span></span><br><span class="line">f.write(<span class="string">&quot;今天天气正好&quot;</span>)</span><br><span class="line">f.close()</span><br><span class="line"><span class="comment"># &quot;rb&quot;, &quot;wb&quot;, &quot;ab&quot; 以二进制形式对文件操作</span></span><br><span class="line"><span class="comment"># 二进制操作千万不要加encoding=&quot;utf-8&quot;</span></span><br><span class="line"><span class="comment"># &quot;rt&quot;与&quot;r&quot;没有区别</span></span><br><span class="line"><span class="comment"># &quot;r+&quot;在原有功能上增加同时读写功能</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;hello.txt&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f: <span class="comment"># 老师推荐，不用close文件</span></span><br><span class="line">    t = f.read()</span><br><span class="line">    print(t)</span><br></pre></td></tr></table></figure>

<p>文件的读取</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>f.read(size=-1)</td>
<td>从文件中读入整个文件内容。参数可选，如果给出，读入  前size长度的字符串或字节流</td>
</tr>
<tr>
<td>f.readline(size  = -1)</td>
<td>从文件中读入一行内容。参数可选，如果给出，读入该行  前size长度的字符串或字节流</td>
</tr>
<tr>
<td>f.readlines(hint=-1)</td>
<td>从文件中读入所有行，以每行为元素形成一个<strong>列表</strong>。参数  可选，如果给出，读入hint行</td>
</tr>
<tr>
<td>f.seek(offset,whence)</td>
<td>改变当前文件操作指针的位置，whence的值：  0：文件开头；1:当前位置 2: 文件结尾</td>
</tr>
</tbody></table>
<p>如果文件不大，可以一次性将文件内容读入，保存到程序内部变量中。f.read()是最常用的一次性读入文件的函数，其结果是一个字符串。 </p>
<p>f.seek(offset,whence)方法能够移动读取指针的位置。</p>
<p>offset ： 开始的偏移量，也就是代表需要移动偏移的字节数，如果是负数表示从倒数第几位开始。 </p>
<p>whence：可选，默认值为 0。给 offset 定义一个参数，表示要从哪个位置开始偏移；0 代表从文件开头开始算起，1 代表从当前位置开始算起，2 代表从文件末尾算起。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;abc.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">s = f.read(<span class="number">5</span>)<span class="comment"># 读取前5个字符</span></span><br><span class="line">print(s)</span><br><span class="line">print(<span class="built_in">type</span>(s))  <span class="comment"># &quot;str&quot;</span></span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;abc.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">s = f.readline()<span class="comment"># 读取一行内容，继续读的话就从下一行开始，会读到行未的换行符</span></span><br><span class="line">print(<span class="built_in">type</span>(s))  <span class="comment"># &quot;str&quot;</span></span><br><span class="line">print(s)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">s = f.readlines()</span><br><span class="line">print(<span class="built_in">type</span>(s))  <span class="comment"># &quot;list&quot;这里是列表类型，不是字符串</span></span><br><span class="line"><span class="comment"># 每一行（包括\n）作为列表中的一个元素</span></span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;abc.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">s = f.read()</span><br><span class="line">print(s)</span><br><span class="line">f.seek(<span class="number">0</span>, <span class="number">0</span>)  <span class="comment"># 文件指针的位置可以理解为光标位置</span></span><br><span class="line">string = f.read()</span><br><span class="line">print(string)</span><br><span class="line">print(<span class="built_in">type</span>(s))  <span class="comment"># &quot;str&quot;</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p>文件的写入</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>f.write(s)</td>
<td>向文件写入一个字符串或字节流</td>
</tr>
<tr>
<td>f.writelines(lines)</td>
<td>将一个<strong>元素为字符串的列表</strong>写入文件</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;abcd.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">f.write(<span class="string">&quot;学习使我快乐&quot;</span>)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;abcd.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">ls = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]</span><br><span class="line">f.writelines(ls)</span><br><span class="line">f.close()<span class="comment"># 文件里是abc连在一起</span></span><br></pre></td></tr></table></figure>

<p><strong>补充知识</strong></p>
<p>w+：在写的基础上增加读的功能（打开文件清空内容）；</p>
<p>r+：在读的基础上增加写的功能（打开文件不清空内容），两者不一样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;abc.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line">s = <span class="string">&quot;塔防&quot;</span></span><br><span class="line">f.write(s)</span><br><span class="line">f.close()<span class="comment"># abc文件中写入“塔防”</span></span><br><span class="line">---------------------Demo1</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;abc.txt&quot;</span>,<span class="string">&quot;w+&quot;</span>)</span><br><span class="line">f.write(<span class="string">&quot;塔防&quot;</span>)</span><br><span class="line">s = f.read()</span><br><span class="line">print(s)<span class="comment"># 空</span></span><br><span class="line"><span class="comment"># abc内容：塔防</span></span><br><span class="line"><span class="comment"># 先写后读，写完后指针走到末尾，读不到内容</span></span><br><span class="line">f.close()</span><br><span class="line">---------------------Demo2</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;abc.txt&quot;</span>,<span class="string">&quot;r+&quot;</span>)</span><br><span class="line">s = f.read()</span><br><span class="line">print(s)<span class="comment"># 塔防</span></span><br><span class="line"><span class="comment"># abc内容：塔防塔防</span></span><br><span class="line">f.write(<span class="string">&quot;塔防&quot;</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h2 id="7-数据的组织维度"><a href="#7-数据的组织维度" class="headerlink" title="7.数据的组织维度"></a>7.数据的组织维度</h2><h3 id="7-1-一维数据"><a href="#7-1-一维数据" class="headerlink" title="7.1 一维数据"></a>7.1 一维数据</h3><p>一维数据是最简单的数据组织类型，由于是线性结构，在Python语言中主要采用列表形式表示。</p>
<p>一维数据的文件存储有多种方式，总体思路是采用特殊字符分隔各数据。常用存储方法包括4种。</p>
<p> （1）采用空格分隔元素，例如： 北京  上海  天津  重庆</p>
<p> （2）采用逗号分隔元素，（重点）例如： 北京,上海,天津,重庆</p>
<p> （3）采用换行分隔包括，例如：</p>
<p>​      北京</p>
<p>​      上海</p>
<p>​      天津</p>
<p>​      重庆 </p>
<p> （4）其他特殊符号分隔，以分号分隔为例，例 如： </p>
<p>​      北京;上海;天津;重庆 </p>
<p><img src="/posts/2d9abb64/image-20210120134702444.png" alt="image-20210120134702444"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##s = &quot;北京,重庆,武汉,广东&quot;  # 注意用英文逗号！！！</span></span><br><span class="line"><span class="comment">##f = open(&quot;demo.csv&quot;, &quot;w&quot;)</span></span><br><span class="line"><span class="comment">##f.write(s)</span></span><br><span class="line"><span class="comment">##f.close()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ls = [<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;西藏&quot;</span>,<span class="string">&quot;武汉&quot;</span>,<span class="string">&quot;广州&quot;</span>] <span class="comment"># 把列表变成字符串</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;test.csv&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">f.write(<span class="string">&quot;,&quot;</span>.join(ls))</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;demo.csv&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">s = f.read()</span><br><span class="line">print(s.strip(<span class="string">&quot;\n&quot;</span>).split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">f.close()</span><br><span class="line"><span class="comment"># [&#x27;北京&#x27;, &#x27;重庆&#x27;, &#x27;武汉&#x27;, &#x27;广东&#x27;]得到列表</span></span><br></pre></td></tr></table></figure>

<h3 id="7-2-二维数据"><a href="#7-2-二维数据" class="headerlink" title="7.2 二维数据"></a>7.2 二维数据</h3><p>1、二维数据由一维数据组成，用CSV格式文件存储。 CSV文件的每一行是一维数据，整个CSV文件是 一个二维数据。</p>
<p>2、二维列表对象输出为CSV格式文件方法如下，采用遍历循环和字符串的join()方法相结合。</p>
<p>二维数据处理等同于二维列表的操作，与一维列表不同，二维列表一般需要借助循环遍历实现对每个数据的处理，基本代码格式如下：</p>
<p><code>for row in ls:</code></p>
<p> <code>for item in row:</code>   </p>
<p> <code>&lt;对第row行第item列元素进行处理&gt;</code> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ls = [[<span class="string">&quot;学校&quot;</span>, <span class="string">&quot;报考人数&quot;</span>, <span class="string">&quot;往年录取人数&quot;</span>, <span class="string">&quot;理科人数&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;xx实验中学&quot;</span>,<span class="string">&quot;100&quot;</span>, <span class="string">&quot;100&quot;</span>, <span class="string">&quot;60&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;xx中学&quot;</span>,<span class="string">&quot;150&quot;</span>,<span class="string">&quot;30&quot;</span>,<span class="string">&quot;80&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;xx高级中学&quot;</span>,<span class="string">&quot;200&quot;</span>,<span class="string">&quot;140&quot;</span>,<span class="string">&quot;160&quot;</span>]]</span><br><span class="line"><span class="comment"># 写入</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;demo1.csv&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> ls:</span><br><span class="line">    f.write(<span class="string">&quot;,&quot;</span>.join(row)+<span class="string">&quot;\n&quot;</span>)<span class="comment"># 在每行后面加换行，以便从下一行继续写入</span></span><br><span class="line"><span class="comment"># 读取</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;demo1.csv&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">ls = f.readlines()</span><br><span class="line">L = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> ls:</span><br><span class="line">    L.append(line.strip(<span class="string">&quot;\n&quot;</span>).split(<span class="string">&quot;,&quot;</span>))<span class="comment"># 将小列表ls放入大列表L</span></span><br><span class="line">print(L)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Python入门笔记（二）</title>
    <url>/posts/60841836.html</url>
    <content><![CDATA[<h2 id="1-进阶赋值方法"><a href="#1-进阶赋值方法" class="headerlink" title="1.进阶赋值方法"></a>1.进阶赋值方法</h2><ul>
<li>同时给多个变量赋同一个值：</li>
</ul>
<p><code>a = b = c = 100</code></p>
<ul>
<li>同时给多个变量赋不同的值：</li>
</ul>
<p><code>a , b , c  = 1, 2 , 3</code></p>
<span id="more"></span>

<h2 id="2-逻辑推理练习"><a href="#2-逻辑推理练习" class="headerlink" title="2.逻辑推理练习"></a>2.逻辑推理练习</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">4.0</span> == <span class="number">4</span> <span class="comment"># True</span></span><br><span class="line"><span class="built_in">bool</span>(<span class="string">&quot;1&quot;</span>),<span class="built_in">bool</span>(<span class="string">&quot;0&quot;</span>) <span class="comment"># True,True</span></span><br><span class="line"><span class="comment">#这里是两个字符串，注意是&quot;0&quot;，不是数字0</span></span><br><span class="line"><span class="built_in">str</span>(<span class="number">32</span>) <span class="comment"># &#x27;32&#x27; ,这里直接变成字符串，不作其他改动，和ASCII码无关</span></span><br><span class="line"><span class="built_in">int</span>(<span class="string">&quot;3.42&quot;</span>) <span class="comment"># 报错</span></span><br><span class="line"><span class="built_in">bool</span>(-<span class="number">1</span>)，<span class="built_in">bool</span>(<span class="string">&quot;&quot;</span>),<span class="built_in">bool</span>(<span class="number">0</span>) <span class="comment"># True,False,False</span></span><br><span class="line"><span class="string">&quot;wrqq&quot;</span> &gt; <span class="string">&quot;acd&quot;</span> <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<ul>
<li>bool函数进行转换时，其结果取决于传入参数与True和 False的等价关系。</li>
</ul>
<p>只需记住一点即可：<strong>数字0，空字符串，None在条件判断语句中等价于 False</strong>，其他数值都等价于True。bool函数在做数据类型转换时遵循该原则。</p>
<ul>
<li><p>用加号连接字符串：不会自动加空格；用逗号连接字符串：自动加空格。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">&#x27;a&#x27;</span>+<span class="string">&#x27;b&#x27;</span>+<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">abc</span><br><span class="line">print(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">a b c</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串大小比较规则</p>
</li>
</ul>
<p>两个字符串在比较大小时，比的不是长度，而是内容，逐个字符按<u>Unicode码</u>比较</p>
<p>字符串左对齐后，逐个字符依次比较，直到可以分出胜负</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算16开根</span></span><br><span class="line"><span class="comment"># solution 1，只适用于正数</span></span><br><span class="line"><span class="number">16</span> ** <span class="number">0.5</span></span><br><span class="line"><span class="number">4.0</span></span><br><span class="line"><span class="comment"># solution 2，可以用于正数，负数和复数</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">math.sqrt(<span class="number">16</span>)</span><br><span class="line"><span class="number">4.0</span></span><br></pre></td></tr></table></figure>

<h2 id="3-列表（List）"><a href="#3-列表（List）" class="headerlink" title="3.列表（List）"></a>3.列表（List）</h2><p>列表的正向和逆向索引与字符串基本相同。</p>
<p>可以直接对列表的数据进行修改和更新。用del语句删除列表元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;第三个元素为 : &quot;</span>, <span class="built_in">list</span>[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">list</span>[<span class="number">2</span>] = <span class="number">2001</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;更新后的第三个元素为 : &quot;</span>, <span class="built_in">list</span>[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">del</span> <span class="built_in">list</span>[<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;删除第三个元素 : &quot;</span>, <span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-1-列表的操作函数"><a href="#3-1-列表的操作函数" class="headerlink" title="3.1 列表的操作函数"></a>3.1 列表的操作函数</h3><p>列表类型继承序列类型特点，有一些通用的操作函数</p>
<table>
<thead>
<tr>
<th><strong>操作函数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>len(ls)</td>
<td>列表ls的元素个数（长度)</td>
</tr>
<tr>
<td>min(ls)</td>
<td>列表ls中的最小元素(内部数据可比较)</td>
</tr>
<tr>
<td>max(ls)</td>
<td>列表ls中的最大元素  (内部数据可比较)</td>
</tr>
<tr>
<td>list(x)</td>
<td>将x转变成列表类型</td>
</tr>
</tbody></table>
<h3 id="3-2-列表的操作方法"><a href="#3-2-列表的操作方法" class="headerlink" title="3.2 列表的操作方法"></a>3.2 列表的操作方法</h3><p>基本语法：&lt;列表变量&gt;.&lt;方法名称&gt;(&lt;方法参数&gt;)</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>ls.append(x)</td>
<td>在列表ls最后增加一个元素x</td>
</tr>
<tr>
<td>ls.insert(index, x)</td>
<td>在列表ls第index位置增加元素x，无返回值</td>
</tr>
<tr>
<td>ls.clear()</td>
<td>删除ls中所有元素</td>
</tr>
<tr>
<td>ls.pop(index)</td>
<td>将列表ls中第index项元素取出并删除该元素，默认最后一个元素，并且返回该元素的值</td>
</tr>
<tr>
<td>ls.remove(x)</td>
<td>将列表中出现的第一个元素x删除，无返回值</td>
</tr>
<tr>
<td>ls.reverse()</td>
<td>列表ls中元素反转</td>
</tr>
<tr>
<td>ls.copy()</td>
<td>生成一个新列表，复制ls中所有元素</td>
</tr>
<tr>
<td>ls.index(obj)</td>
<td>从列表中找出某个值第一个匹配项的索引位置</td>
</tr>
<tr>
<td>ls.count(obj)</td>
<td>统计某个元素在列表中出现的次数</td>
</tr>
<tr>
<td>list.sort( key=None, reverse=False)</td>
<td>reverse – 排序规则，reverse = True 降序， reverse = False 升序（默认）。</td>
</tr>
</tbody></table>
<h3 id="3-3-列表的脚本操作符"><a href="#3-3-列表的脚本操作符" class="headerlink" title="3.3 列表的脚本操作符"></a>3.3 列表的脚本操作符</h3><table>
<thead>
<tr>
<th>Python 表达式</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>len([1, 2, 3])</td>
<td>3</td>
<td>长度</td>
</tr>
<tr>
<td>[1, 2, 3] + [4, 5, 6]</td>
<td>[1, 2, 3, 4, 5, 6]</td>
<td>组合</td>
</tr>
<tr>
<td>[‘Hi!’] * 4</td>
<td>[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td>
<td>重复</td>
</tr>
<tr>
<td>3 in [1, 2, 3]</td>
<td>True</td>
<td>元素是否存在于列表中</td>
</tr>
<tr>
<td>for x in [1, 2, 3]: print(x, end=” “)</td>
<td>1 2 3</td>
<td>迭代</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;L=[<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">2</span>]</span><br><span class="line"><span class="string">&#x27;Taobao&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[-<span class="number">2</span>]</span><br><span class="line"><span class="string">&#x27;Runoob&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">1</span>:]</span><br><span class="line">[<span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt;squares = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares += [<span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br><span class="line"><span class="comment"># list嵌套</span></span><br><span class="line">&gt;&gt;&gt;a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [a, n]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">0</span>]</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="comment"># 列表</span></span><br><span class="line">vowels = [<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;i&#x27;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 降序</span></span><br><span class="line">vowels.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span> ( <span class="string">&#x27;降序输出:&#x27;</span>, vowels )</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">list</span>(<span class="string">&quot;python&quot;</span>)</span><br><span class="line">print(name)</span><br><span class="line">name[<span class="number">2</span>:] = <span class="built_in">list</span>(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">print(name)</span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">5</span>]</span><br><span class="line">numbers[<span class="number">1</span>:<span class="number">1</span>] = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]  <span class="comment"># [1:1]表示1与5之间的位置</span></span><br><span class="line">print(numbers)</span><br><span class="line"></span><br><span class="line">numbers[<span class="number">1</span>:<span class="number">4</span>] = []</span><br><span class="line">print(numbers)</span><br><span class="line"></span><br><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">l.insert(<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment"># 在索引下标2之前插入&#x27;a&#x27;</span></span><br><span class="line">print(l)</span><br><span class="line"><span class="comment"># 注意区别remove和pop</span></span><br><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">l.remove(<span class="number">1</span>) <span class="comment"># 无返回值，删除第一个元素1</span></span><br><span class="line">print(l)</span><br><span class="line">l.pop(<span class="number">2</span>)<span class="comment"># 返回索引下标为2的元素值并删除它</span></span><br><span class="line">print(l)</span><br><span class="line"><span class="comment"># [&#x27;p&#x27;, &#x27;y&#x27;, &#x27;t&#x27;, &#x27;h&#x27;, &#x27;o&#x27;, &#x27;n&#x27;]</span></span><br><span class="line"><span class="comment"># [&#x27;p&#x27;, &#x27;y&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment"># [1, 5]</span></span><br><span class="line"><span class="comment"># [1,2,&#x27;a&#x27;,3,4]</span></span><br><span class="line"><span class="comment"># [2, 3, 4, 5]</span></span><br><span class="line"><span class="comment"># [2, 3, 5]</span></span><br></pre></td></tr></table></figure>

<p>Question: 已知列表ls = [1,3,5,7,9,5]，去掉列表中的重复值。</p>
<p>Answer: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ls = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">5</span>]</span><br><span class="line">s = <span class="built_in">set</span>(ls) <span class="comment"># 利用集合的无重复性</span></span><br><span class="line">ls = <span class="built_in">list</span>(s)</span><br><span class="line">print(ls)</span><br></pre></td></tr></table></figure>

<h2 id="4-字典（Dict）"><a href="#4-字典（Dict）" class="headerlink" title="4.字典（Dict）"></a>4.字典（Dict）</h2><p>字典是另一种可变容器模型，且可存储任意类型对象。</p>
<p>字典的每个键值 key=&gt;value  对用冒号 :  分割，每个对之间用逗号(<strong>,</strong>)分割，整个字典包括在花括号 {} 中 .</p>
<p>键必须是唯一的，但值则不必。</p>
<p>值可以取任何数据类型，但键必须是不可变的，如字符串，数字。key可以使用元组，而不能使用列表、字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;likes&#x27;</span>: <span class="number">123</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;www.runoob.com&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;dict[&#x27;Name&#x27;]: &quot;</span>, <span class="built_in">dict</span>[<span class="string">&#x27;Name&#x27;</span>])<span class="comment"># dict[&#x27;Name&#x27;]:  Runoob</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;dict[&#x27;Age&#x27;]: &quot;</span>, <span class="built_in">dict</span>[<span class="string">&#x27;Age&#x27;</span>]) <span class="comment"># dict[&#x27;Age&#x27;]:  7</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;Age&#x27;</span>] = <span class="number">8</span>               <span class="comment"># 更新 Age</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;School&#x27;</span>] = <span class="string">&quot;菜鸟教程&quot;</span>  <span class="comment"># 添加信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> <span class="built_in">dict</span>[<span class="string">&#x27;Name&#x27;</span>] <span class="comment"># 删除键 &#x27;Name&#x27;</span></span><br><span class="line"><span class="built_in">dict</span>.clear()     <span class="comment"># 清空字典</span></span><br><span class="line"><span class="keyword">del</span> <span class="built_in">dict</span>         <span class="comment"># 删除字典</span></span><br><span class="line"><span class="comment"># 不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住</span></span><br><span class="line"><span class="comment"># 键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行</span></span><br></pre></td></tr></table></figure>

<h3 id="4-1-字典的操作函数"><a href="#4-1-字典的操作函数" class="headerlink" title="4.1 字典的操作函数"></a>4.1 字典的操作函数</h3><table>
<thead>
<tr>
<th><strong>操作函数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>len(d)</td>
<td>字典d的元素个数（长度）</td>
</tr>
<tr>
<td>min(d)</td>
<td>字典d中键的最小值</td>
</tr>
<tr>
<td>max(d)</td>
<td>字典d中键的最大值</td>
</tr>
<tr>
<td>dict()</td>
<td>生成一个空字典</td>
</tr>
</tbody></table>
<h3 id="4-2-字典的操作方法"><a href="#4-2-字典的操作方法" class="headerlink" title="4.2 字典的操作方法"></a>4.2 字典的操作方法</h3><p>基本语法：<code>&lt;字典变量&gt;.&lt;方法名称&gt;(&lt;方法参数&gt;)</code></p>
<table>
<thead>
<tr>
<th><strong>操作方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>d.keys()</td>
<td>返回所有的键信息</td>
</tr>
<tr>
<td>d.values()</td>
<td>返回所有的值信息</td>
</tr>
<tr>
<td>d.items()</td>
<td>返回所有的键值对</td>
</tr>
<tr>
<td>d.get(key, default)</td>
<td>键存在则返回相应值，否则返回默认值</td>
</tr>
<tr>
<td>d.pop(key, default)</td>
<td>键存在则返回相应值，同时删除键值对，否则返回默认值</td>
</tr>
<tr>
<td>d.popitem()</td>
<td>随机从字典中取出一个键值对，以元组(key, value)形式返回</td>
</tr>
<tr>
<td>d.clear()</td>
<td>删除所有的键值对</td>
</tr>
</tbody></table>
<h3 id="创建字典"><a href="#创建字典" class="headerlink" title="创建字典"></a>创建字典</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>,<span class="string">&quot;b&quot;</span>:<span class="number">2</span>&#125; <span class="comment"># 一般的方式创建字典</span></span><br><span class="line">print(d)</span><br><span class="line">data = [(<span class="string">&quot;a&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>)] <span class="comment"># 根据其他序列新建字典</span></span><br><span class="line">print(data)</span><br><span class="line">d = <span class="built_in">dict</span>(data)</span><br><span class="line">print(d)</span><br><span class="line">d = <span class="built_in">dict</span>(lilei = <span class="number">98</span>,hanmeimei = <span class="number">99</span>) <span class="comment"># 根据关键字参数新建字典</span></span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># d.items()以列表返回可遍历的(键, 值) 元组数组</span></span><br><span class="line">d = &#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>,<span class="string">&quot;b&quot;</span>:<span class="number">2</span>,<span class="string">&quot;c&quot;</span>:<span class="number">4</span>&#125;</span><br><span class="line">print(d.keys())<span class="comment"># dict_keys([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]) 返回列表</span></span><br><span class="line">print(d.values())<span class="comment"># dict_values([1, 2, 4]) 返回列表</span></span><br><span class="line">print(d.items())<span class="comment"># 返回的是一个列表，其中包括多个元组</span></span><br><span class="line"><span class="comment"># dict_items([(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 4)])</span></span><br><span class="line">print(<span class="built_in">list</span>(d.items()))<span class="comment"># 用list()转化为列表</span></span><br><span class="line"><span class="comment"># [(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 4)]</span></span><br><span class="line"><span class="keyword">for</span> key, val <span class="keyword">in</span> d.items():</span><br><span class="line">    print(<span class="string">&quot;编号：&#123;&#125;，名称：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(key, val))</span><br><span class="line"><span class="comment"># 编号：a，名称：1</span></span><br><span class="line"><span class="comment"># 编号：b，名称：2</span></span><br><span class="line"><span class="comment"># 编号：c，名称：4</span></span><br></pre></td></tr></table></figure>

<h3 id="字典与列表的互相嵌套"><a href="#字典与列表的互相嵌套" class="headerlink" title="字典与列表的互相嵌套"></a>字典与列表的互相嵌套</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在列表中存储字典</span></span><br><span class="line">student1 = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;lilei&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>,<span class="string">&quot;grade&quot;</span>:<span class="number">98</span>&#125;</span><br><span class="line">student2 = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;hanmeimei&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">19</span>,<span class="string">&quot;grade&quot;</span>:<span class="number">99</span>&#125;</span><br><span class="line">student3 = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;madongmei&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>,<span class="string">&quot;grade&quot;</span>:<span class="number">95</span>&#125;</span><br><span class="line"></span><br><span class="line">student = [student1,student2,student3]</span><br><span class="line"></span><br><span class="line">print(student)</span><br><span class="line"><span class="comment"># 在字典中存储列表</span></span><br><span class="line">favorite_class = &#123;</span><br><span class="line">    <span class="string">&quot;lilei&quot;</span>:[<span class="string">&quot;math&quot;</span>,<span class="string">&quot;English&quot;</span>],</span><br><span class="line">    <span class="string">&quot;hanmeimei&quot;</span>:[<span class="string">&quot;yuwen&quot;</span>],</span><br><span class="line">    <span class="string">&quot;madongmei&quot;</span>:[<span class="string">&quot;computer&quot;</span>,<span class="string">&quot;magic&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">print(favorite_class[<span class="string">&quot;lilei&quot;</span>])</span><br><span class="line">print(favorite_class[<span class="string">&quot;madongmei&quot;</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<h3 id="列表和字典的引用"><a href="#列表和字典的引用" class="headerlink" title="列表和字典的引用"></a>列表和字典的引用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python中的赋值准确理解为贴标签，创建数据是相当于把数据放在盒子里，赋值时就是在盒子上贴标签</span></span><br><span class="line">l1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">l2 = l1</span><br><span class="line">l2[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line">print(<span class="string">f&#x27;l2:<span class="subst">&#123;l2&#125;</span>&#x27;</span>)</span><br><span class="line">print(<span class="string">f&#x27;l1:<span class="subst">&#123;l1&#125;</span>&#x27;</span>)<span class="comment"># 修改l1时l2也发生了变化</span></span><br><span class="line"><span class="comment">#l2:[5, 2, 3, 4]</span></span><br><span class="line"><span class="comment">#l1:[5, 2, 3, 4]</span></span><br><span class="line"><span class="comment"># 用.copy()方法克隆一个数据</span></span><br><span class="line">l1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">l2 = l1.copy()</span><br><span class="line">l2[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line">print(<span class="string">f&#x27;l1:<span class="subst">&#123;l1&#125;</span>&#x27;</span>)</span><br><span class="line">print(<span class="string">f&#x27;l2:<span class="subst">&#123;l2&#125;</span>&#x27;</span>)<span class="comment"># 修改l2时l1不发生变化</span></span><br><span class="line"><span class="comment">#l1:[1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">#l2:[5, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<h2 id="5-复数（complex）"><a href="#5-复数（complex）" class="headerlink" title="5.复数（complex）"></a>5.复数（complex）</h2><p><code>z = 1 + 2j</code></p>
<p>print(z.real,z.imag) # 实部和虚部，都是浮点型</p>
<h2 id="6-元组"><a href="#6-元组" class="headerlink" title="6.元组"></a>6.元组</h2><p>列表和元组的区别：</p>
<ul>
<li>列表元素用方括号包括，元组元素用圆括号包括；</li>
<li>列表中的元素可以修改、添加、删除，是可变的，而元组是不可变的。</li>
</ul>
<p>元组创建后并非是不可改变的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">t = (<span class="number">1</span>,<span class="number">2</span>,l)</span><br><span class="line">l[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line">print(t)</span><br><span class="line"><span class="comment"># (1, 2, [5, 2, 3])</span></span><br><span class="line"><span class="comment"># 元组中的可变元素是可以进行修改的</span></span><br></pre></td></tr></table></figure>

<h2 id="7-集合"><a href="#7-集合" class="headerlink" title="7.集合"></a>7.集合</h2><p>集合中的元素是惟一的，不能重复的。</p>
<p>创建集合:</p>
<p>注意：创建一个空集合必须用 set() 而不是 { }，<strong>因为 { } 是用来创建一个空字典</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>&#125;<span class="comment"># 直接创建</span></span><br><span class="line"></span><br><span class="line">set2 = <span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">4</span>])<span class="comment"># 用set()方法创建</span></span><br><span class="line">print(set1,set2)</span><br><span class="line"><span class="comment"># &#123;1, 2, 3, 4, 5, 7, 8&#125; &#123;1, 2, 3, 4, 6&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.集合的交集&amp;</span></span><br><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>&#125;</span><br><span class="line">print(set1 &amp; set2)</span><br><span class="line"><span class="comment"># &#123;1, 2, 3, 5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.集合的并集|</span></span><br><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>&#125;</span><br><span class="line">print(set1 | set2)</span><br><span class="line"><span class="comment"># &#123;1, 2, 3, 4, 5, 8, 9&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.集合的差集，在set1中但是不在set2</span></span><br><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>&#125;</span><br><span class="line">print(set1 - set2)</span><br><span class="line"><span class="comment"># &#123;8, 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.集合的对称差集，在set1或set2中，不同时在两个集合中</span></span><br><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>&#125;</span><br><span class="line">print(set1 ^ set2)</span><br><span class="line"><span class="comment">#  &#123;3, 4, 8, 9&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="8-程序的控制结构"><a href="#8-程序的控制结构" class="headerlink" title="8.程序的控制结构"></a>8.程序的控制结构</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.if——else语句</span></span><br><span class="line"><span class="keyword">if</span> XXX:</span><br><span class="line">    XXX</span><br><span class="line"><span class="keyword">elif</span> XXX:</span><br><span class="line">    XXX</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    XXX</span><br><span class="line"><span class="comment"># 簡化： eg, 1 if 1 &gt; 2 else 2</span></span><br><span class="line"><span class="comment"># 2.一般的while循环</span></span><br><span class="line"><span class="keyword">while</span> XXX:</span><br><span class="line">    XXX</span><br><span class="line"><span class="comment"># 3.while——else循环</span></span><br><span class="line"><span class="comment"># 当while循环正常执行之后，继续执行else语句并结束</span></span><br><span class="line"><span class="comment"># 只有使用break跳出循环是才不会执行else语句</span></span><br><span class="line"><span class="keyword">while</span> XXX:</span><br><span class="line">    XXX</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    XXX    </span><br><span class="line"><span class="comment"># example</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">5</span>:</span><br><span class="line">    print(i)</span><br><span class="line">    i += <span class="number">1</span>    </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;循环正常结束&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; 输出如下：</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">循环正常结束</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 4.break与continue</span></span><br><span class="line"><span class="comment"># 作用同C/C++中的break和continue，跳出循环，跳出本次循环</span></span><br><span class="line"><span class="comment"># 5.for循环</span></span><br><span class="line"><span class="comment"># for-in循环及range()的使用参见学习笔记一</span></span><br><span class="line"><span class="comment"># 6.for——else循环</span></span><br><span class="line"><span class="comment"># 只有使用break跳出循环是才不会执行else语句</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    print(i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;循环正常结束&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; 输出如下：</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">循环正常结束</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>    </span><br></pre></td></tr></table></figure>

<h2 id="9-异常处理"><a href="#9-异常处理" class="headerlink" title="9.异常处理"></a>9.异常处理</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># try-except结构</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    age = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入年龄数字：&quot;</span>))</span><br><span class="line">    print(age)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">&quot;输入有误！&quot;</span>)</span><br><span class="line"><span class="comment"># try-except-else结构</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    age = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入年龄数字：&quot;</span>))</span><br><span class="line">    print(age)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">&quot;输入有误！&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;输入正确！&quot;</span>)<span class="comment"># 当程序未出现异常（except）时，执行else语句</span></span><br><span class="line"><span class="comment"># try-except-else-finally结构</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    age = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入年龄数字：&quot;</span>))</span><br><span class="line">    print(age)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">&quot;输入有误！&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;输入正确！&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">&quot;运行结束&quot;</span>)<span class="comment"># 不管程序是否出现异常都会执行finally语句</span></span><br><span class="line"><span class="comment"># 捕捉多种异常</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    age = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入年龄数字：&quot;</span>))</span><br><span class="line">    print(age)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    print(<span class="string">&quot;输入内容非数字！&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">&quot;其他错误！&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Python入门笔记（五）</title>
    <url>/posts/f5296746.html</url>
    <content><![CDATA[<h2 id="1-文件读取指针函数seek-用法详解"><a href="#1-文件读取指针函数seek-用法详解" class="headerlink" title="1.文件读取指针函数seek()用法详解"></a>1.文件读取指针函数seek()用法详解</h2><p>seek()方法的语法如下：<code>fileObject.seek(offset, from)</code></p>
<p>offset ： 开始的偏移量，也就是代表需要移动偏移的字节数，如果是负数表示从倒数第几位开始。 </p>
<p>from：可选，默认值为 0。给 offset 定义一个参数，表示要从哪个位置开始偏移；0 代表从文件开头开始算起，1 代表从当前位置开始算起，2 代表从文件末尾算起。</p>
<span id="more"></span>

<p><strong>实例1</strong></p>
<p>下面将用实例演示一下seek()方法的用法<br>下面是‘test.txt’文件内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">0123456789</span><br><span class="line">0123456789</span><br><span class="line">0123456789</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="comment">#只读方式，文件读取指针指向开头</span></span><br><span class="line">print(file.tell())           <span class="comment">#file.tell()返回当前读取指针</span></span><br><span class="line">file_data = file.readline()  <span class="comment">#读取一行数据</span></span><br><span class="line">print(file_data)</span><br><span class="line"></span><br><span class="line">file.seek(<span class="number">3</span>,<span class="number">0</span>)               <span class="comment">#从0开始偏移3个字节</span></span><br><span class="line">print(file.tell())</span><br><span class="line">file_data = file.readline()  <span class="comment">#读取一行数据</span></span><br><span class="line">print(file_data)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line">0123456789</span><br><span class="line"></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3456789</span></span><br><span class="line"></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>上述结果之间空一行是因为读取了末尾的换行符</p>
<p><strong>实例2</strong></p>
<p>下面我再说一个例子，关于文件打开模式为‘a+’情况下的例子<br>文件跟上一个例子一样，先看代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;a+&#x27;</span>)  <span class="comment">#可读写方式，文件读取指针指向末尾，数据追加在末尾</span></span><br><span class="line">print(file.tell())             <span class="comment">#file.tell()返回当前读取指针</span></span><br><span class="line">file.write(<span class="string">&#x27;9876543210\n&#x27;</span>)     <span class="comment">#末尾写入数据</span></span><br><span class="line">print(file.tell())             <span class="comment">#文件写入后返回当前读取指针</span></span><br><span class="line">file_data = file.readline()    <span class="comment">#读取一行数据</span></span><br><span class="line">print(<span class="string">&#x27;one&#x27;</span> + file_data)       <span class="comment">#文件读取指针在末尾，读取数据为空</span></span><br><span class="line">file.seek(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">print(<span class="string">&#x27;two&#x27;</span> + file.readline()) <span class="comment">#文件读取指针在开头，读取第一行数据</span></span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">36</span></span><br><span class="line"><span class="number">48</span></span><br><span class="line">one</span><br><span class="line">two0123456789</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>没有读取到数据是因为文件读取指针指向了末尾，所以在使用‘a+’模式时，如果要读取数据要利用seek(0,0)设置文件读取指针<br>‘test.txt’的变化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">0123456789</span><br><span class="line">0123456789</span><br><span class="line">0123456789</span><br><span class="line"><span class="number">9876543210</span></span><br><span class="line"></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>上述这个例子是我学习Python文件操作时遇到的坑，在利用‘a+’模式打开文件并写入数据后，用readline()怎么都无法读取数据，后来了解到是因为文件读取指针在末尾，所以无法读取数据，要用seek(0，0)方法将文件读取指针重置，才可以读取数据。</p>
<h2 id="2-小练习"><a href="#2-小练习" class="headerlink" title="2.小练习"></a>2.小练习</h2><h3 id="2-1-题目简化："><a href="#2-1-题目简化：" class="headerlink" title="2.1 题目简化："></a>2.1 题目简化：</h3><p>将浮点数num保留整数部分输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># solution 1</span></span><br><span class="line">print(<span class="string">&quot;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">int</span>(num)))</span><br><span class="line"><span class="comment"># solution 2</span></span><br><span class="line">print(<span class="string">&quot;&#123;:.0f&#125;&quot;</span>.<span class="built_in">format</span>(num)) <span class="comment"># 掌握这种做法</span></span><br><span class="line"><span class="comment"># print(&quot;&#123;:d&#125;&quot;.format(num))这样不行，无法直接将浮点型转换为int</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-python的连续不等式写法："><a href="#2-2-python的连续不等式写法：" class="headerlink" title="2.2 python的连续不等式写法："></a>2.2 python的连续不等式写法：</h3><p><code>1 &lt;= n &lt;=  2</code></p>
<p>这种写法在python中是合理的，在其他大多数语言可能不成立。</p>
<h3 id="2-3-小例题1"><a href="#2-3-小例题1" class="headerlink" title="2.3 小例题1"></a>2.3 小例题1</h3><p>让用户输入一个数字，判断它是否等于553，如果不等于则让用户再次输入，否则退出程序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">not</span> n.isdigit()) <span class="keyword">or</span> n != <span class="number">553</span>:<span class="comment">#  错误示范！！！教训！！！</span></span><br><span class="line">	n = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">    </span><br><span class="line">n = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">not</span> n.isdigit()) <span class="keyword">or</span> <span class="built_in">int</span>(n) != <span class="number">553</span>: <span class="comment"># n是字符串，需要先转换！！</span></span><br><span class="line">	n = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br></pre></td></tr></table></figure>

<h3 id="2-4-小例题2"><a href="#2-4-小例题2" class="headerlink" title="2.4 小例题2"></a>2.4 小例题2</h3><p><img src="/posts/f5296746/image-20210204162557662.png" alt="image-20210204162557662"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># solution 1</span></span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">sa = s.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">a = <span class="built_in">int</span>(sa[<span class="number">0</span>])</span><br><span class="line">b = <span class="built_in">int</span>(sa[<span class="number">1</span>])</span><br><span class="line">c = <span class="built_in">int</span>(sa[<span class="number">2</span>])</span><br><span class="line">ls = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(c):</span><br><span class="line">	ls.append(a + b * i)</span><br><span class="line">print(ls)</span><br><span class="line"><span class="comment"># solution 2</span></span><br><span class="line">a,b,c = <span class="built_in">input</span>().split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">a,b,c = <span class="built_in">int</span>(a),<span class="built_in">int</span>(b),<span class="built_in">int</span>(c)</span><br><span class="line">ls = [a + b * i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(c)] <span class="comment"># 生成列表一步到位</span></span><br><span class="line">print(ls)</span><br></pre></td></tr></table></figure>

<h3 id="2-5-小例题3"><a href="#2-5-小例题3" class="headerlink" title="2.5 小例题3"></a>2.5 小例题3</h3><p>判断用户输入的一个数是不是回文数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># solution 1</span></span><br><span class="line">n = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">t = n</span><br><span class="line">m = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> t:</span><br><span class="line">	m = m*<span class="number">10</span> + t%<span class="number">10</span></span><br><span class="line">	t //= <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n == m:</span><br><span class="line">	print(<span class="string">&quot;是&quot;</span>) </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(<span class="string">&quot;否&quot;</span>)</span><br><span class="line"><span class="comment"># solution 2</span></span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">if</span> s == s[::-<span class="number">1</span>]:</span><br><span class="line">    print(<span class="string">&quot;是&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(<span class="string">&quot;否&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3-pass语句"><a href="#3-pass语句" class="headerlink" title="3.pass语句"></a>3.pass语句</h2><p>Python pass 是空语句，是为了保持程序结构的完整性。</p>
<p><strong>pass</strong> 不做任何事情，一般用做占位语句。</p>
<p>在 Python 中有时候会看到一个 def 函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample</span>(<span class="params">n_samples</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>该处的 pass 便是占据一个位置，因为如果定义一个空函数程序会报错，当你没有想好函数的内容是可以用 pass 填充，使程序可以正常运行。（python3中好像可以定义空函数）</p>
<h2 id="4-for循环补充小知识"><a href="#4-for循环补充小知识" class="headerlink" title="4.for循环补充小知识"></a>4.for循环补充小知识</h2><p>在for-in循环中，不能对<code>虚拟变量i</code>进行修改，但是可以对<code>可迭代对象s</code>进行修改。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;abcdefghijklmn&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="string">&quot;a&quot;</span>:</span><br><span class="line">        i = <span class="string">&quot;s&quot;</span></span><br><span class="line">print(s)</span><br><span class="line"><span class="comment"># abcdefghijklmn</span></span><br><span class="line">s = <span class="string">&quot;abcdefghijklmn&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    s = <span class="string">&quot;vn&quot;</span></span><br><span class="line">print(s)</span><br><span class="line"><span class="comment"># vn</span></span><br></pre></td></tr></table></figure>

<h2 id="5-错题1"><a href="#5-错题1" class="headerlink" title="5.错题1"></a>5.错题1</h2><p>以下说法中错误的是（）<br>A、对已经关闭的文件进行读写操作会默认再次打开文件<br>B、对文件操作完成后即使不关闭文件也不会报错，所以可以不关闭文件<br>C、对于非空文本文件，read()返回字符串，readlines()返回列表<br>D、file = open(filename,’rb’)表示只读、二进制方式打开名为filename的文件</p>
<p>答案选A.    B选项是正确的。</p>
<h2 id="6-错题2"><a href="#6-错题2" class="headerlink" title="6.错题2"></a>6.错题2</h2><p>1、编写代码将列表ls  = [‘新年都未有芳华，\n’,’ 二月初惊见草芽。\n’,’白雪却嫌春色晚，\n’,’故穿庭树作飞花。’]、<br>写入a.txt文件内容如下：<br>新年都未有芳华，<br>二月初惊见草芽。<br>白雪却嫌春色晚，<br>故穿庭树作飞花。</p>
<p>2、读取a.txt中的内容，并输出。输出格式如下(输出为一行)：<br>     新年都未有芳华，二月初惊见草芽。白雪却嫌春色晚， 故穿庭树作飞花。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># solution for 1</span></span><br><span class="line">ls  = [<span class="string">&#x27;新年都未有芳华，\n&#x27;</span>,<span class="string">&#x27;二月初惊见草芽。\n&#x27;</span>,<span class="string">&#x27;白雪却嫌春色晚，\n&#x27;</span>,<span class="string">&#x27;故穿庭树作飞花。&#x27;</span>]</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;a.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line">f.writelines(ls)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;a.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> ls:</span><br><span class="line">	f.write(s)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># solution for 2，不会啊</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;a.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">t = f.readlines()</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> t:</span><br><span class="line">	print(line.strip(<span class="string">&quot;\n&quot;</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h2 id="7-练习1"><a href="#7-练习1" class="headerlink" title="7.练习1"></a>7.练习1</h2><p>二千多年前希腊的天文学家希巴克斯命名十二星座，它们是水瓶座、双鱼座、白羊座、金牛座、<br>双子座、巨蟹座、狮子座、处女座、天秤座、天蝎座、射手座、摩羯座。给出一个CSV文件（SunSign.csv），<br>内容示例如下：<br>序号,星座,开始月日,结束月日,Unicode<br>1,水瓶座,120,218,9810<br>2,双色座,219,320,9811<br>3,白羊座,321,419,9800<br>4,金牛座,420,520,9801<br>5,双子座,521,621,9802<br>…（略）<br>以第1行为例,120表示1月20日,218表示2月18日,9810是Unicode码。<br>问题：读入CSV文件中数据，获得用户输入。根据用户输入的星座名称，输出此星座的出生日期范围。<br>参考输入和输出示例格式如下：<br>请输入星座中文名称（例如，双子座）：双子座<br>双子座的生日位于521-621之间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># solution 1</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;SunSign.csv&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">ls = f.readlines()</span><br><span class="line">L = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> ls:</span><br><span class="line">	L.append(line.strip(<span class="string">&quot;\n&quot;</span>).split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">n = <span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> L:</span><br><span class="line">	<span class="keyword">if</span>(l[<span class="number">1</span>] == n):</span><br><span class="line">		print(<span class="string">&quot;&#123;&#125;的生日位于&#123;&#125;-&#123;&#125;之间&quot;</span>.<span class="built_in">format</span>(n,l[<span class="number">2</span>],l[<span class="number">3</span>]))</span><br><span class="line">f.close()</span><br><span class="line"><span class="comment"># solution 2，巧妙的解法</span></span><br><span class="line">n = <span class="built_in">input</span>()</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;SunSign.csv&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">ls = f.readlines()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; ls : </span></span><br><span class="line"><span class="string">[&#x27;序号,星座,开始月日,结束月日,Unicode\n&#x27;,</span></span><br><span class="line"><span class="string">     ...,</span></span><br><span class="line"><span class="string">&#x27;12,魔蝎座,1222,119,9809\n&#x27;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> ls:</span><br><span class="line">    lt = line.split(<span class="string">&quot;,&quot;</span>)<span class="comment"># 用&#x27;,&#x27;分隔产生列表lt</span></span><br><span class="line">    <span class="keyword">if</span> s == lt[<span class="number">1</span>]:</span><br><span class="line">        print(<span class="string">&quot;&#123;&#125;的生日位于&#123;&#125;-&#123;&#125;之间&quot;</span>.<span class="built_in">format</span>(n,lt[<span class="number">2</span>],lt[<span class="number">3</span>]))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h2 id="8-错题3"><a href="#8-错题3" class="headerlink" title="8.错题3"></a>8.错题3</h2><p><img src="/posts/f5296746/image-20210222184011849.png" alt="image-20210222184011849"></p>
<p>当<code>fo.write()</code>完成后，指针指向文件末尾，此时<code>fo.read()</code>无法读取到内容。</p>
<h2 id="9-练习2"><a href="#9-练习2" class="headerlink" title="9.练习2"></a>9.练习2</h2><p><img src="/posts/f5296746/image-20210306230603132.png" alt="image-20210306230603132"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;vacations.csv&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">ls = f.readlines()</span><br><span class="line">s = <span class="built_in">input</span>(<span class="string">&quot;请输入节假日名称(例如,春节):&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> ls:</span><br><span class="line">    lt = line.strip(<span class="string">&quot;\n&quot;</span>).split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> s == lt[<span class="number">1</span>]:</span><br><span class="line">        print(<span class="string">&quot;&#123;&#125;的假期位于&#123;&#125;-&#123;&#125;之间&quot;</span>.<span class="built_in">format</span>(lt[<span class="number">1</span>],lt[<span class="number">2</span>],lt[<span class="number">3</span>]))</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简化版本</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;vacations.csv&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">s = <span class="built_in">input</span>(<span class="string">&quot;请输入节假日名称(例如,春节):&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:<span class="comment"># 直接遍历文件，也是一行一行读取</span></span><br><span class="line">    lt = line.strip(<span class="string">&quot;\n&quot;</span>).split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> s == lt[<span class="number">1</span>]:</span><br><span class="line">        print(<span class="string">&quot;&#123;&#125;的假期位于&#123;&#125;-&#123;&#125;之间&quot;</span>.<span class="built_in">format</span>(lt[<span class="number">1</span>],lt[<span class="number">2</span>],lt[<span class="number">3</span>]))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h5 id="10-练习3"><a href="#10-练习3" class="headerlink" title="10.练习3"></a>10.练习3</h5><p>使用字典和列表型变量完成某课程的考勤记录统计，某班有 74 名同学，名单由考生目录下文件 name.txt 给出，</p>
<p>某课程第一次考勤数据由考生目录下文件 card.csv 给出。请求出第一次缺勤同学的名单。‪</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># solution 1，自己写的，比较复杂</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;name.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">d = <span class="built_in">dict</span>()</span><br><span class="line">lt = f.readlines()</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lt:</span><br><span class="line">    d[line.strip(<span class="string">&quot;\n&quot;</span>)] = <span class="number">0</span></span><br><span class="line">print(d)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">ft = <span class="built_in">open</span>(<span class="string">&quot;card.csv&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">ls = ft.readlines()</span><br><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> ls:</span><br><span class="line">    <span class="keyword">if</span> d.get(l.strip(<span class="string">&quot;\n&quot;</span>).split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>],<span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">        d[l.strip(<span class="string">&quot;\n&quot;</span>).split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>]] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> key,val <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="keyword">if</span> val == <span class="number">0</span>:</span><br><span class="line">        print(key)</span><br><span class="line">ft.close()</span><br><span class="line"><span class="comment"># solution 2，比较简单</span></span><br><span class="line">f_name = <span class="built_in">open</span>(<span class="string">&quot;name.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">f_card = <span class="built_in">open</span>(<span class="string">&quot;card.csv&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">ls = f_name.readlines()</span><br><span class="line">lt = f_card.readlines()</span><br><span class="line">L = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lt:</span><br><span class="line">    L.append(line.split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ls:</span><br><span class="line">    name = i.strip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> L:</span><br><span class="line">        print(name)</span><br><span class="line">f_name.close()</span><br><span class="line">f_card.close()</span><br></pre></td></tr></table></figure>



<p>==100-days04.循环结构，开始看130道字符串内置方法==</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Python入门笔记（四）</title>
    <url>/posts/9ab7a201.html</url>
    <content><![CDATA[<h2 id="1-小练习"><a href="#1-小练习" class="headerlink" title="1.小练习"></a>1.小练习</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># s = &quot;* ** ** hel  l* o*  ** * *  &quot;</span></span><br><span class="line"><span class="comment"># 去除两边的&#x27; &#x27;和&#x27;*&#x27;</span></span><br><span class="line"><span class="keyword">while</span> s[<span class="number">0</span>] == <span class="string">&quot;*&quot;</span> <span class="keyword">or</span> s[<span class="number">0</span>] == <span class="string">&quot; &quot;</span>:</span><br><span class="line">    s.strip()</span><br><span class="line">    s.strip(<span class="string">&quot;*&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> s[-<span class="number">1</span>] == <span class="string">&quot;*&quot;</span> <span class="keyword">or</span> s[-<span class="number">1</span>] == <span class="string">&quot; &quot;</span>:</span><br><span class="line">    s.strip()</span><br><span class="line">    s.strip(<span class="string">&quot;*&quot;</span>)  </span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="2-计算思维"><a href="#2-计算思维" class="headerlink" title="2.计算思维"></a>2.计算思维</h2><p>考点：计算思维的本质是抽象和自动化。</p>
<p>自顶向下设计，自底向上执行。</p>
<h2 id="3-常用内置函数"><a href="#3-常用内置函数" class="headerlink" title="3.常用内置函数"></a>3.常用内置函数</h2><p><img src="/posts/9ab7a201/image-20210121155428455.png" alt="image-20210121155428455"></p>
<h2 id="4-turtle库"><a href="#4-turtle库" class="headerlink" title="4.turtle库"></a>4.turtle库</h2><h3 id="turtle库的引用方式"><a href="#turtle库的引用方式" class="headerlink" title="turtle库的引用方式"></a>turtle库的引用方式</h3><p>第一种，import turtle，则对turtle库中函数调 用采用turtle.&lt;函数名&gt;()形式。</p>
<p>第二种，from turtle import *，则对turtle库中 函数调用直接采用&lt;函数名&gt;()形式，不在使用 turtle.作为前导。</p>
<p>第三种，import turtle as t，则对turtle库中函数 调用采用更简洁的t.&lt;函数名&gt;()形式，保留字as 的作用是将turtle库给予别名t。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line">turtle.fd(<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="keyword">from</span> turtle <span class="keyword">import</span> *</span><br><span class="line">fd(<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="keyword">import</span> turtle <span class="keyword">as</span> t <span class="comment"># 类似取别名</span></span><br><span class="line">t.fd(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<h3 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h3><p><code>turtle.setup(width, height, startx, starty)</code> 窗体函数</p>
<p>作用：设置主窗体的大小和位置 参数： </p>
<p>width ：窗口宽度，如果值是整数，表示的像素值；如果值 是小数，表示窗口宽度与屏幕的比例； </p>
<p>height: 窗口高度，如果值是整数，表示的像素值；如果 值是小数，表示窗口高度与屏幕的比例； </p>
<p>startx：窗口左侧与屏幕左侧的像素距离，如果值是None ，窗口位于屏幕水平中央； </p>
<p>starty：窗口顶部与屏幕顶部的像素距离，如果值是None ，窗口位于屏幕垂直中央。</p>
<h3 id="常用状态函数"><a href="#常用状态函数" class="headerlink" title="常用状态函数"></a>常用状态函数</h3><table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>pendown()</td>
<td>放下画笔</td>
</tr>
<tr>
<td>penup()</td>
<td>拿起画笔</td>
</tr>
<tr>
<td>pensize()</td>
<td>设置画笔线条的粗细</td>
</tr>
<tr>
<td>pencolor()</td>
<td>设置画笔颜色</td>
</tr>
<tr>
<td>color()</td>
<td>设置画笔和填充颜色</td>
</tr>
<tr>
<td>begin_fill()</td>
<td>填充图形前，调用该方法</td>
</tr>
<tr>
<td>end_fill()</td>
<td>填充图形结束</td>
</tr>
<tr>
<td>filling()</td>
<td>返回填充状态，True为填充，较少用到</td>
</tr>
<tr>
<td>clear()</td>
<td>清空当前窗口</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>reset()</td>
<td>清空当前窗口，并重置位置</td>
</tr>
<tr>
<td>write(str,font=None)</td>
<td>输出font字体的字符串</td>
</tr>
<tr>
<td>screensize()</td>
<td>设置画布的长和宽</td>
</tr>
<tr>
<td>hideturtle()</td>
<td>隐藏画笔的turtle形状，比较重要</td>
</tr>
<tr>
<td>showturtle</td>
<td>显示画笔形状</td>
</tr>
<tr>
<td>Isvisible()</td>
<td>如果画笔可见则显示true</td>
</tr>
</tbody></table>
<h3 id="常用运动函数"><a href="#常用运动函数" class="headerlink" title="常用运动函数"></a>常用运动函数</h3><table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>forward()</td>
<td>沿着当前指定方向前进距离</td>
</tr>
<tr>
<td>backward()</td>
<td>沿着当前相反方向后退指定距离</td>
</tr>
<tr>
<td>setheading(angle)</td>
<td>设置当前朝向为angle角度</td>
</tr>
<tr>
<td>circle(r,e)</td>
<td>绘制一个半径r和角度e的圆或弧形</td>
</tr>
<tr>
<td>undo()</td>
<td>撤销画笔最后一步动作</td>
</tr>
<tr>
<td>right(angle)</td>
<td>向右旋转angle角度</td>
</tr>
<tr>
<td>left(angle)</td>
<td>向左旋转angle角度</td>
</tr>
<tr>
<td>goto(x,y)</td>
<td>移动到绝对坐标（x,y）处</td>
</tr>
<tr>
<td>speed()</td>
<td>设置画笔得绘制速度，参数为0-10</td>
</tr>
<tr>
<td>dot(d,color)</td>
<td>绘制一个直径d和颜色color的圆点</td>
</tr>
<tr>
<td>home()</td>
<td>设置当前画笔位置为原点，朝向东</td>
</tr>
</tbody></table>
<p>实例1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># import turtle</span></span><br><span class="line"><span class="comment"># turtle.fd(100)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># from turtle import *</span></span><br><span class="line"><span class="comment"># fd(100)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># import turtle as t</span></span><br><span class="line"><span class="comment"># t.fd(100)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> turtle <span class="keyword">import</span> *</span><br><span class="line">penup() <span class="comment"># 抬起画笔</span></span><br><span class="line">pendown() <span class="comment"># 放下画笔，有点多余</span></span><br><span class="line">fd(<span class="number">100</span>)</span><br><span class="line">done()  <span class="comment"># 避免一闪而过，对于第一种导入方式改成turtle.done()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> turtle <span class="keyword">as</span> t</span><br><span class="line">t.pensize(<span class="number">5</span>) <span class="comment"># 粗细为5pix</span></span><br><span class="line">t.pencolor(<span class="string">&quot;blue&quot;</span>)</span><br><span class="line">t.fd(<span class="number">110</span>)</span><br><span class="line">t.done()</span><br><span class="line"></span><br><span class="line"><span class="comment"># color(),begin_fill()和end_fill()是搭配使用的</span></span><br><span class="line"><span class="keyword">import</span> turtle <span class="keyword">as</span> t</span><br><span class="line">t.color(<span class="string">&quot;green&quot;</span>, <span class="string">&quot;red&quot;</span>)</span><br><span class="line">t.begin_fill()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    t.fd(<span class="number">120</span>)</span><br><span class="line">    t.left(<span class="number">120</span>)</span><br><span class="line">t.end_fill()</span><br><span class="line">t.done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line">turtle.fd(<span class="number">200</span>)</span><br><span class="line"><span class="comment"># turtle.clear()  # 注意！清空窗口(只擦掉痕迹)但画笔停留在200处</span></span><br><span class="line"><span class="comment"># turtle.reset()  # 清空窗口并重置画笔位置</span></span><br><span class="line">turtle.write(<span class="string">&quot;你好&quot;</span>)</span><br><span class="line">turtle.hideturtle()</span><br><span class="line">turtle.done()</span><br><span class="line"></span><br><span class="line"><span class="comment"># hideturtle()和showturtle()是搭配使用的</span></span><br></pre></td></tr></table></figure>

<p>实例2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle <span class="keyword">as</span> t</span><br><span class="line">t.forward(<span class="number">100</span>),简写成fd(<span class="number">100</span>)</span><br><span class="line">t.fd(-<span class="number">100</span>) <span class="comment"># == t.backward(100)</span></span><br><span class="line">t.done()</span><br><span class="line"></span><br><span class="line">t.setheading(<span class="number">60</span>),简写成seth(<span class="number">60</span>)</span><br><span class="line">t.fd(<span class="number">100</span>)</span><br><span class="line">t.circle(<span class="number">100</span>)</span><br><span class="line">t.circle(<span class="number">100</span>, <span class="number">180</span>)</span><br><span class="line">t.circle(<span class="number">100</span>, <span class="number">180</span>, <span class="number">5</span>)</span><br><span class="line">t.undo()  <span class="comment"># 撤销最后一步动作</span></span><br><span class="line">t.done()</span><br><span class="line"></span><br><span class="line"><span class="comment"># right()和left()比较重要</span></span><br><span class="line"><span class="comment"># seth()是朝着某角度方向，left()是旋转某角度</span></span><br><span class="line">t.speed(<span class="number">1</span>)</span><br><span class="line">t.left(<span class="number">60</span>)</span><br><span class="line">t.left(<span class="number">60</span>)  <span class="comment"># 旋转是有记忆的</span></span><br><span class="line">t.fd(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">t.goto(<span class="number">100</span>, <span class="number">200</span>)  <span class="comment"># 向绝对坐标移动，不改变方向</span></span><br><span class="line">t.dot(<span class="number">100</span>, <span class="string">&quot;pink&quot;</span>)</span><br><span class="line">t.home()  <span class="comment"># 画笔回到原点，方向朝东</span></span><br><span class="line">t.done()</span><br></pre></td></tr></table></figure>

<h2 id="5-random库"><a href="#5-random库" class="headerlink" title="5.random库"></a>5.random库</h2><p>使用random库主要目的是生成随机数 </p>
<p>​    这个库提供了不同类型的随机数函数，其中最基本的函数是<code>random.random()</code>，它生成 一个[0.0, 1.0)之间的随机小数，所有其他随机函数都是基于这个函数扩展而来。</p>
<p>random库常用函数： </p>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>seed(a=None)</td>
<td>初始化随机数种子，默认值为当前系统时间</td>
</tr>
<tr>
<td>random()</td>
<td>生成一个[0.0,  1.0)之间的随机小数</td>
</tr>
<tr>
<td>randint(a,  b)</td>
<td>生成一个[a,b]之间的整数</td>
</tr>
<tr>
<td>getrandbits(k)</td>
<td>生成一个k比特长度的随机整数</td>
</tr>
<tr>
<td>randrange(start,  stop[, step])</td>
<td>生成一个[start,  stop)之间以step为步数的随机整数</td>
</tr>
<tr>
<td>uniform(a,  b)</td>
<td>生成一个[a,  b]之间的随机小数</td>
</tr>
<tr>
<td>choice(seq)</td>
<td>从序列类型(例如：列表)中随机返回一个元素，考试常考</td>
</tr>
<tr>
<td>shuffle(seq)</td>
<td>将序列类型中元素随机排列，返回打乱后的序列</td>
</tr>
<tr>
<td>sample(pop,  k)</td>
<td>从pop类型中随机选取k个元素，以列表类型返回</td>
</tr>
</tbody></table>
<p>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">n = random.random()</span><br><span class="line"><span class="comment"># 注意生成随机数的右边区间开闭情况</span></span><br><span class="line">print(n)</span><br><span class="line"><span class="comment"># 学到了，文件名不要设置成random库名，否则会报错循环导入，憨憨</span></span><br><span class="line"><span class="comment"># random.seed()  # seed参数限定了后面生成随机数的值</span></span><br><span class="line">m = random.randint(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">print(m)</span><br><span class="line">t = random.getrandbits(<span class="number">6</span>)</span><br><span class="line">print(<span class="built_in">bin</span>(t))</span><br><span class="line">print(random.randrange(<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>))</span><br><span class="line">print(random.uniform(<span class="number">1</span>,<span class="number">11</span>))</span><br><span class="line">ls = [<span class="number">12</span>,<span class="number">34.56</span>,<span class="number">4</span>,<span class="string">&quot;你&quot;</span>,<span class="string">&quot;我&quot;</span>,<span class="number">1434</span>,<span class="number">34</span>,[<span class="number">2</span>,<span class="number">3</span>,<span class="number">232.4</span>]]</span><br><span class="line">print(random.choice(ls)) <span class="comment"># 有返回值</span></span><br><span class="line">random.shuffle(ls)  <span class="comment"># 无返回值</span></span><br><span class="line">print(ls)</span><br><span class="line">lt = random.sample(ls,<span class="number">3</span>)</span><br><span class="line">print(lt)</span><br></pre></td></tr></table></figure>

<h2 id="6-time库"><a href="#6-time库" class="headerlink" title="6.time库"></a>6.time库</h2><p>处理时间是程序最常用的功能之一，time库是Python提供的处理时间标准库。time库提供系统级精确计时器的计时功能，可以用来分析程序性能，也可让程序暂停运行时间。</p>
<p>time库的功能主要分为3个方面：时间处理、 时间格式化和计时。 </p>
<p>• 时间处理主要包括4个函数：time.time()、 time.gmtime()、time.localtime() 、time.ctime()。 </p>
<p>• 时间格式化主要包括3个函数：time.mktime()、 time.strftime()、time.strptime()。 </p>
<p>• 计 时 主 要 包用到 1 个 函 数 ： time.sleep( )。</p>
<p>使用time.gmtime(secs)获取当前时间戳对应的struct_time对象。</p>
<p>使用time.localtime(secs)获取当前时间戳对应的本地时间的struct_time对象。</p>
<p>time库使用time.mktime()、time.strftime()、 time.strptime()进行时间格式化。 </p>
<p>使用time.mktime(t) 将struct_time对象t转换 为时间戳，注意t代表当地时间。</p>
<p>time.strftime()函数是时间格式化最有效的方法，几 乎可以以任何通用格式输出时间。该方法利用一个 格式字符串，对时间格式进行表达。</p>
<p><strong>strftime()方法的格式化控制符</strong> </p>
<p><img src="/posts/9ab7a201/image-20210125095305368.png" alt="image-20210125095305368"></p>
<p><img src="/posts/9ab7a201/image-20210125101522267.png" alt="image-20210125101522267"></p>
<p>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">print(time.time())  <span class="comment"># 获取当前时间戳</span></span><br><span class="line">print(time.gmtime())  <span class="comment"># 很少考到，返回UTC时间</span></span><br><span class="line">print(time.localtime())  <span class="comment"># 经常考到，一定要记住，返回本地北京时间</span></span><br><span class="line">print(time.ctime())  <span class="comment"># 返回当地时间对应的字符串</span></span><br><span class="line">t = time.localtime()</span><br><span class="line">print(time.mktime(t))</span><br><span class="line">print(time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, t))  <span class="comment"># 记住这些常用的，这是考的最多的</span></span><br><span class="line">timestring = <span class="string">&quot;2020-04-17 10:17:44&quot;</span>  <span class="comment"># 反格式化</span></span><br><span class="line">print(time.strptime(timestring, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>))  <span class="comment"># 和上面相反，用到较少</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># time.sleep()较常用到，记住</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    print(i)</span><br><span class="line">    time.sleep(<span class="number">3</span>)  <span class="comment"># 每次循环睡眠3秒</span></span><br></pre></td></tr></table></figure>

<h2 id="7-PyInstaller库"><a href="#7-PyInstaller库" class="headerlink" title="7.PyInstaller库"></a>7.PyInstaller库</h2><p>PyInstaller是一个十分有用的Python第三方库，它能够在Windows、Linux、Mac OS  X等操作系统下将Python源文件打包，变成直接可运行的可执行文件。通过对源文件打包，Python程序可以在没有安装Python的环境中运行，也可以作为一个独立文件方便传递和管理。</p>
<p><img src="/posts/9ab7a201/image-20210125102142517.png" alt="image-20210125102142517"></p>
<p>第2种方式在dist文件夹中只有一个exe文件。（记住常用参数指令）</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-h,  –help</td>
<td>查看帮助</td>
</tr>
<tr>
<td>–clean</td>
<td>清理打包过程中的临时文件</td>
</tr>
<tr>
<td>-D,  –onedir</td>
<td>默认值，生成dist目录</td>
</tr>
<tr>
<td>-F,  –onefile</td>
<td>在dist文件夹中只生成独立的打包文件</td>
</tr>
<tr>
<td>-i  &lt;图标文件名.ico  &gt;</td>
<td>指定打包程序使用的图标（icon）文件</td>
</tr>
</tbody></table>
<p>eg : <code>pyinstaller -F -i 1.cio yinyang.py</code></p>
<p>eg : <code>pyinstaller -F -w yinyang.py  # -w去掉运行exe时的黑窗口</code></p>
<h2 id="8-jieba库"><a href="#8-jieba库" class="headerlink" title="8.jieba库"></a>8.jieba库</h2><p>1、由于中文文本中的单词不是通过空格或者标点符号分割，中文及类似语言存在一个重要的“分词”问题。</p>
<p>2、jieba（“结巴”）是Python中一个重要的第三方中文分词函数库。</p>
<p>3、jieba库的分词原理是利用一个中文词库，将待分词的内容与分词词库进行比对，通过图结构和动态规划方法找到最大概率的词组。除了分词jieba还提供增加自定义中文单词的功能。</p>
<p>4、jieba库支持三种分词模式：精确模式，将句子最精确地切开，适合文本分析；全模式，把句子中所有可以成词的词语都扫描出来，速度非常快，但是不能解决歧义；搜索引擎模式，在精确模式基础上，对长词再次切分，提高召回率，适合用于搜索引擎分词。</p>
<p>1、<code>jieba.lcut(s)</code>是最常用的中文分词函数，用于精准模式，即将字符串分割成等量的中文词组，返回结果是列表类型。</p>
<p>2、<code>jieba.lcut(s, cut_all = True)</code>用于全模式，即将字符串的所有分词可能均列出来，返回结果是列表类型，冗余性最大。</p>
<p>3、<code>jieba.lcut_for_search(s)</code>返回搜索引擎模式，该模式首先执行精确模式，然后再对其中长词进一步切分获得最终结果。搜索引擎模式更倾向于寻找短词语，这种方式具有一定冗余度，但冗余度相比全模式较少。</p>
<p>4、<code>jieba.add_word()</code>函数，顾名思义，用来向jieba词库增加新的单词。</p>
<p>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line">ls = jieba.lcut(<span class="string">&quot;全国计算机等级考试python科目&quot;</span>)</span><br><span class="line">print(ls)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> jieba <span class="keyword">import</span> *</span><br><span class="line">ls = lcut(<span class="string">&quot;全国计算机等级考试python科目&quot;</span>,cut_all = <span class="literal">True</span>)</span><br><span class="line">print(ls)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line">ls = jieba.lcut_for_search(<span class="string">&quot;全国计算机等级考试python科目&quot;</span>)</span><br><span class="line">print(ls)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line">jieba.add_word(<span class="string">&quot;奥利给&quot;</span>)</span><br><span class="line">ls = jieba.lcut(<span class="string">&quot;作为一个年轻人，我们要努力加油，奥利给！！&quot;</span>)</span><br><span class="line">print(ls)</span><br></pre></td></tr></table></figure>

<h2 id="9-wordcloud库"><a href="#9-wordcloud库" class="headerlink" title="9.wordcloud库"></a>9.wordcloud库</h2><p>1、wordcloud库是专门用于根据文本生成词云的Python第三方库，十分常用且有趣。</p>
<p>2、装wordcloud库在Windows的cmd命令行使用</p>
<p><img src="/posts/9ab7a201/image-20210125111300257.png" alt="image-20210125111300257"></p>
<p><img src="/posts/9ab7a201/image-20210125111332948.png" alt="image-20210125111332948"></p>
<p><strong>WordCloud对象创建的常用参数</strong></p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td>font_path</td>
<td>指定字体文件的完整路径，默认None</td>
</tr>
<tr>
<td>width</td>
<td>生成图片宽度，默认400像素</td>
</tr>
<tr>
<td>height</td>
<td>生成图片高度，默认200像素</td>
</tr>
<tr>
<td>mask</td>
<td>词云形状，默认None，即，方形图</td>
</tr>
<tr>
<td>min_font_size</td>
<td>词云中最小的字体字号，默认4号</td>
</tr>
<tr>
<td>font_step</td>
<td>字号步进间隔，默认1</td>
</tr>
<tr>
<td>min_font_size</td>
<td>词云中最大的字体字号，默认None，根据高度自动调节</td>
</tr>
<tr>
<td>max_words</td>
<td>词云图中最大词数，默认200</td>
</tr>
<tr>
<td>stopwords</td>
<td>被排除词列表，排除词不在词云中显示</td>
</tr>
<tr>
<td>background_color</td>
<td>图片背景颜色，默认黑色</td>
</tr>
</tbody></table>
<p>WordCloud不显示中文问题解决：</p>
<p>在下面的代码中添加<code>font_path=&quot;./kai.ttf&quot;</code>（自己替换），选择一个支持中文的字体。无法确定是否支持中文的话，双击字体打开查看，有中文显示就是支持中文的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wc=WordCloud(font_path=<span class="string">&quot;./kai.ttf&quot;</span>,background_color=<span class="string">&quot;white&quot;</span>,width=<span class="number">800</span>,height=<span class="number">600</span>,max_font_size=<span class="number">50</span>,max_words=<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td>generate(text)</td>
<td>由text文本生成词云</td>
</tr>
<tr>
<td>to_file(filename)</td>
<td>将词云图保存为名为filename的文件</td>
</tr>
</tbody></table>
<p>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> wordcloud</span><br><span class="line">txt = <span class="string">&quot;i like python and i am learning python&quot;</span></span><br><span class="line">wd = wordcloud.WordCloud().generate(txt)</span><br><span class="line">wd.to_file(<span class="string">&quot;test.png&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">txt = <span class="string">&#x27;&#x27;&#x27;程序设计语言是计算机能够识别和理解用户</span></span><br><span class="line"><span class="string">操作意图的一种交互体系，它能够按照特定的规则</span></span><br><span class="line"><span class="string">组织计算机指令，使得计算机能够自动进行各种运算处理</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> wordcloud</span><br><span class="line">ls = jieba.lcut(txt)</span><br><span class="line">txtwords = <span class="string">&#x27; &#x27;</span>.join(ls)</span><br><span class="line">print(txtwords)</span><br><span class="line">wd = wordcloud.WordCloud(font_path=<span class="string">r&quot;F:\下载\方正楷体_GBK.TTF&quot;</span>,width=<span class="number">800</span>,height=<span class="number">600</span>).generate(txtwords) </span><br><span class="line"><span class="comment"># wordcloud默认不支持中文，得设置font_path添加中文字体</span></span><br><span class="line">wd.to_file(<span class="string">&quot;word.png&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="10-python第三方库纵览"><a href="#10-python第三方库纵览" class="headerlink" title="10.python第三方库纵览"></a>10.python第三方库纵览</h2><p>考选择题，以记忆库的名称、作用为主。</p>
<p><img src="/posts/9ab7a201/image-20210125115734415.png" alt="image-20210125115734415"></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python入门</tag>
        <tag>Python库</tag>
      </tags>
  </entry>
  <entry>
    <title>Python入门笔记（六）</title>
    <url>/posts/90272c9f.html</url>
    <content><![CDATA[<h2 id="1-列表作为函数参数的例子"><a href="#1-列表作为函数参数的例子" class="headerlink" title="1.列表作为函数参数的例子"></a>1.列表作为函数参数的例子</h2><span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x=[],y=[<span class="number">6</span>,<span class="number">7</span>]</span>):</span></span><br><span class="line">    x.append(<span class="number">8</span>)</span><br><span class="line">    y.append(<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line">a,b = [<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">t = func(x=a)</span><br><span class="line">t = func(y=b)</span><br><span class="line">print(func(),end=<span class="string">&quot;;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>执行完第7行：</p>
<p>a = [1,2,8] <strong>注意</strong>：a被func函数修改了</p>
<p>b = [3,4] # 不变</p>
<p>x = [1,2,8]</p>
<p>y = [6,7,8]</p>
<p>t = [1,2,8,6,7,8]</p>
<p>执行完第8行：</p>
<p>a = [1,2,8] # 不变</p>
<p>b = [3,4,8]</p>
<p>x = [8] </p>
<p>y = [3,4,8]</p>
<p>执行完第9行：</p>
<p>func()中传入上一步得到的默认参数x和y</p>
<p>输出[8,8,3,4,8,8];</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x=[],y=[<span class="number">6</span>,<span class="number">7</span>]</span>):</span></span><br><span class="line">    x.append(<span class="number">8</span>)</span><br><span class="line">    print(<span class="string">&quot;x:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(x))</span><br><span class="line">    y.append(<span class="number">8</span>)</span><br><span class="line">    print(<span class="string">&quot;y:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(y))</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line">a,b = [<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">t = func(x=a)</span><br><span class="line">t = func(y=b)</span><br><span class="line">print(func(),end=<span class="string">&quot;;&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;x:[1, 2, 8]</span></span><br><span class="line"><span class="string">y:[6, 7, 8]</span></span><br><span class="line"><span class="string">x:[8]</span></span><br><span class="line"><span class="string">y:[3, 4, 8]</span></span><br><span class="line"><span class="string">x:[8, 8]</span></span><br><span class="line"><span class="string">y:[6, 7, 8, 8]</span></span><br><span class="line"><span class="string">[8, 8, 6, 7, 8, 8];&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-python处理空行输入"><a href="#2-python处理空行输入" class="headerlink" title="2.python处理空行输入"></a>2.python处理空行输入</h2><p>input()遇到空行、回车即停止，即使没接收到有效输入。</p>
<p><img src="/posts/90272c9f/image-20210317205917723.png" alt="image-20210317205917723"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = <span class="built_in">input</span>()  <span class="comment"># 课程名 考分</span></span><br><span class="line"><span class="meta">... </span> </span><br><span class="line"><span class="keyword">while</span> data:</span><br><span class="line">    ...</span><br><span class="line">    data = <span class="built_in">input</span>()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Python进阶笔记（一）</title>
    <url>/posts/f4f081c5.html</url>
    <content><![CDATA[<h1 id="一-面向对象概述"><a href="#一-面向对象概述" class="headerlink" title="一.面向对象概述"></a>一.面向对象概述</h1><h2 id="1-面向过程与面向对象"><a href="#1-面向过程与面向对象" class="headerlink" title="1.面向过程与面向对象"></a>1.面向过程与面向对象</h2><ol>
<li><p><strong>面向过程</strong> —— <strong>怎么做</strong>？</p>
</li>
<li><p>把完成某一个需求的 <code>所有步骤</code> <code>从头到尾</code> 逐步实现</p>
</li>
<li><p>根据开发需求，将某些 <strong>功能独立</strong> 的代码 <strong>封装</strong> 成一个又一个 <strong>函数</strong></p>
</li>
<li><p>最后完成的代码，就是顺序地调用 <strong>不同的函数</strong></p>
<span id="more"></span>

</li>
</ol>
<p><strong>特点</strong></p>
<ol>
<li><p>注重 <strong>步骤与过程</strong>，不注重职责分工</p>
</li>
<li><p>如果需求复杂，代码会变得很复杂</p>
</li>
<li><p><strong>开发复杂项目，没有固定的套路，开发难度很大！</strong></p>
</li>
<li><p><strong>面向对象</strong> —— <strong>谁来做</strong>？</p>
</li>
</ol>
<blockquote>
<p>相比较函数，<strong>面向对象</strong> 是 <strong>更大</strong> 的 <strong>封装</strong>，根据 <strong>职责</strong> 在 <strong>一个对象中 封装 多个方法</strong></p>
</blockquote>
<ol>
<li>在完成某一个需求前，首先确定 <strong>职责</strong> —— <strong>要做的事情（方法）</strong></li>
<li>根据 <strong>职责</strong> 确定不同的 <strong>对象</strong>，在 <strong>对象</strong> 内部封装不同的 <strong>方法</strong>（多个）</li>
<li>最后完成的代码，就是顺序地让 <strong>不同的对象</strong> 调用 <strong>不同的方法</strong></li>
</ol>
<p><strong>特点</strong></p>
<ol>
<li>注重 <strong>对象和职责</strong>，不同的对象承担不同的职责</li>
<li>更加适合应对复杂的需求变化，<strong>是专门应对复杂项目开发，提供的固定套路</strong></li>
<li><strong>需要在面向过程基础上，再学习一些面向对象的语法</strong></li>
</ol>
<h2 id="2-重要概念：类和对象"><a href="#2-重要概念：类和对象" class="headerlink" title="2.重要概念：类和对象"></a>2.重要概念：类和对象</h2><h3 id="2-1-概念引入"><a href="#2-1-概念引入" class="headerlink" title="2.1 概念引入"></a>2.1 概念引入</h3><p>在洗衣机洗衣服的过程中，洗衣机就是我们所说的对象，整个过程描述如下：图纸—&gt;洗衣机—&gt;洗衣服。在这个过程中，图纸就是类，而洗衣机就是对象。有了类，我们就能根据它来创建对象。</p>
<p><strong>简单的说，类是对象的蓝图和模板，而对象是类的实例。</strong>这个解释虽然有点像用概念在解释概念，但是从这句话我们至少可以看出，类是抽象的概念，而对象是具体的东西。在面向对象编程的世界中，一切皆为对象，对象都有属性和行为，每个对象都是独一无二的，而且对象一定属于某个类（型）。当我们把一大堆拥有共同特征的对象的静态特征（属性）和动态特征（行为）都抽取出来后，就可以定义出一个叫做“类”的东西。</p>
<p><strong>类和对象的关系</strong></p>
<ul>
<li><strong>类是模板</strong>，<strong>对象</strong> 是根据 <strong>类</strong> 这个模板创建出来的，应该 <strong>先有类，再有对象</strong></li>
<li>类只有一个，而对象可以有很多个<ul>
<li><strong>不同的对象</strong> 之间 <strong>属性</strong> 可能会各不相同</li>
</ul>
</li>
<li><strong>类</strong> 中定义了什么 <strong>属性和方法</strong>，<strong>对象</strong> 中就有什么属性和方法，<strong>不可能多，也不可能少</strong></li>
</ul>
<p><strong>总结：类和对象的关系，就是用类去创建一个对象，或者用类去实例化一个对象。</strong></p>
<h3 id="2-2-类"><a href="#2-2-类" class="headerlink" title="2.2 类"></a>2.2 类</h3><p>类是对一系列列具有相同特征和行为的事物的统称，<strong>是一个抽象的概念，不是真实存在的事物</strong>。</p>
<ul>
<li>特征即是属性</li>
<li>行为即是方法</li>
</ul>
<p>在程序开发中，要设计一个类，通常需要满足一下三个要素：</p>
<ol>
<li><strong>类名</strong> 这类事物的名字，<strong>满足大驼峰命名法</strong></li>
<li><strong>属性</strong> 这类事物具有什么样的特征</li>
<li><strong>方法</strong> 这类事物具有什么样的行为</li>
</ol>
<p><strong>大驼峰命名法</strong></p>
<p><code>CapWords</code></p>
<ol>
<li>每一个单词的首字母大写</li>
<li>单词与单词之间没有下划线</li>
</ol>
<p><strong>类名的确定</strong></p>
<p><strong>名词提炼法</strong> 分析 <strong>整个业务流程</strong>，出现的 <strong>名词</strong>，通常就是找到的类</p>
<p><strong>属性和方法的确定</strong></p>
<ul>
<li>对 <strong>对象的特征描述</strong>，通常可以定义成 <strong>属性</strong></li>
<li><strong>对象具有的行为</strong>（动词），通常可以定义成 <strong>方法</strong></li>
</ul>
<blockquote>
<p>提示：需求中没有涉及的属性或者方法在设计类时，不需要考虑</p>
</blockquote>
<h3 id="2-3-对象"><a href="#2-3-对象" class="headerlink" title="2.3 对象"></a>2.3 对象</h3><p>对象是<strong>类创建出来的真实存在的事物</strong>，例如：洗衣机。</p>
<blockquote>
<p>注意：开发中，先有类，再有对象。</p>
</blockquote>
<h3 id="2-4-定义类"><a href="#2-4-定义类" class="headerlink" title="2.4 定义类"></a>2.4 定义类</h3><p>在Python中可以使用<code>class</code>关键字定义类，然后在类中通过之前学习过的函数来定义方法，这样就可以将对象的动态特征描述出来，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名():</span></span><br><span class="line">    代码</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Washer</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wash</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;我会洗衣服&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># __init__是一个特殊方法用于在创建对象时进行初始化操作</span></span><br><span class="line">    <span class="comment"># 通过这个方法我们可以为学生对象绑定name和age两个属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">study</span>(<span class="params">self, course_name</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;%s正在学习%s.&#x27;</span> % (self.name, course_name))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># PEP 8要求标识符的名字用全小写多个单词用下划线连接</span></span><br><span class="line">    <span class="comment"># 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">watch_movie</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.age &lt; <span class="number">18</span>:</span><br><span class="line">            print(<span class="string">&#x27;%s只能观看《熊出没》.&#x27;</span> % self.name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&#x27;%s正在观看爱情大电影.&#x27;</span> % self.name)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明：</strong> 写在类中的函数，我们通常称之为（对象的）方法，这些方法就是对象可以接收的消息。</p>
</blockquote>
<h3 id="2-5-创建和使用对象"><a href="#2-5-创建和使用对象" class="headerlink" title="2.5 创建和使用对象"></a>2.5 创建和使用对象</h3><p>对象又名实例。创建对象也叫做实例化对象。</p>
<p>语法：<code>对象名 = 类名()</code></p>
<p>当我们定义好一个类之后，可以通过下面的方式来创建对象并给对象发消息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 创建学生对象并指定姓名和年龄</span></span><br><span class="line">    stu1 = Student(<span class="string">&#x27;骆昊&#x27;</span>, <span class="number">38</span>)</span><br><span class="line">    <span class="comment"># 给对象发study消息</span></span><br><span class="line">    stu1.study(<span class="string">&#x27;Python程序设计&#x27;</span>)</span><br><span class="line">    <span class="comment"># 给对象发watch_av消息</span></span><br><span class="line">    stu1.watch_movie()</span><br><span class="line">    stu2 = Student(<span class="string">&#x27;王大锤&#x27;</span>, <span class="number">15</span>)</span><br><span class="line">    stu2.study(<span class="string">&#x27;思想品德&#x27;</span>)</span><br><span class="line">    stu2.watch_movie()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="3-面向对象基础语法"><a href="#3-面向对象基础语法" class="headerlink" title="3.面向对象基础语法"></a>3.面向对象基础语法</h2><h3 id="3-1-dir内置函数（知道）"><a href="#3-1-dir内置函数（知道）" class="headerlink" title="3.1 dir内置函数（知道）"></a>3.1 dir内置函数（知道）</h3><ul>
<li>在 <code>Python</code> 中 <strong>对象几乎是无所不在的</strong>，我们之前学习的 <strong>变量</strong>、<strong>数据</strong>、<strong>函数</strong> 都是对象</li>
</ul>
<p>在 <code>Python</code> 中可以使用以下两个方法验证：</p>
<ol>
<li>在 <strong>标识符</strong> / <strong>数据</strong> 后输入一个 <code>.</code>，然后按下 <code>TAB</code> 键，<code>iPython</code> 会提示该对象能够调用的 <strong>方法列表</strong></li>
<li>使用内置函数 <code>dir</code> 传入 <strong>标识符</strong> / <strong>数据</strong>，可以查看对象内的<strong>所有属性及方法</strong></li>
</ol>
<p><strong>提示</strong> <code>__方法名__</code> 格式的方法是 <code>Python</code> 提供的 <strong>内置方法 / 属性</strong>，稍后会给大家介绍一些常用的内置方法 / 属性</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法名</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>01</td>
<td><code>__new__</code></td>
<td>方法</td>
<td><strong>创建对象</strong>时，会被 <strong>自动</strong> 调用</td>
</tr>
<tr>
<td>02</td>
<td><code>__init__</code></td>
<td>方法</td>
<td><strong>对象被初始化</strong>时，会被 <strong>自动</strong> 调用</td>
</tr>
<tr>
<td>03</td>
<td><code>__del__</code></td>
<td>方法</td>
<td><strong>对象被从内存中销毁</strong>前，会被 <strong>自动</strong> 调用</td>
</tr>
<tr>
<td>04</td>
<td><code>__str__</code></td>
<td>方法</td>
<td>返回<strong>对象的描述信息</strong>，<code>print</code> 函数输出使用</td>
</tr>
</tbody></table>
<p><strong>提示</strong> 利用好 <code>dir()</code> 函数，在学习时很多内容就不需要死记硬背了</p>
<h3 id="3-2-定义简单的类（仅包含方法）"><a href="#3-2-定义简单的类（仅包含方法）" class="headerlink" title="3.2 定义简单的类（仅包含方法）"></a>3.2 定义简单的类（仅包含方法）</h3><h4 id="3-2-1-定义只包含方法的类"><a href="#3-2-1-定义只包含方法的类" class="headerlink" title="3.2.1 定义只包含方法的类"></a>3.2.1 定义只包含方法的类</h4><ul>
<li>在 <code>Python</code> 中要定义一个只包含方法的类，语法格式如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> 方法1(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> 方法2(<span class="params">self, 参数列表</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>方法</strong> 的定义格式和之前学习过的<strong>函数</strong> 几乎一样</li>
<li>区别在于第一个参数必须是 <code>self</code>，大家暂时先记住，稍后介绍 <code>self</code></li>
</ul>
<blockquote>
<p>注意：<strong>类名</strong> 的 命名规则 要符合 <strong>大驼峰命名法</strong></p>
</blockquote>
<h4 id="3-2-2-创建对象"><a href="#3-2-2-创建对象" class="headerlink" title="3.2.2 创建对象"></a>3.2.2 创建对象</h4><p>对象又名实例。创建对象也叫做实例化对象。</p>
<p>语法：<code>对象名 = 类名()</code></p>
<h4 id="3-2-3-第一个面向对象程序"><a href="#3-2-3-第一个面向对象程序" class="headerlink" title="3.2.3 第一个面向对象程序"></a>3.2.3 第一个面向对象程序</h4><p><strong>需求</strong></p>
<ul>
<li><strong>小猫</strong> 爱 <strong>吃</strong> 鱼，<strong>小猫</strong> 要 <strong>喝</strong> 水</li>
</ul>
<p><strong>分析</strong></p>
<ol>
<li>定义一个猫类 <code>Cat</code></li>
<li>定义两个方法 <code>eat</code> 和 <code>drink</code></li>
<li>按照需求 —— 不需要定义属性</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span> <span class="comment"># 对类进行封装</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;这是一个猫类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;小猫爱吃鱼&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drink</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;小猫在喝水&quot;</span>)</span><br><span class="line"></span><br><span class="line">tom = Cat() <span class="comment"># 创建一个叫tom的对象</span></span><br><span class="line">tom.drink() <span class="comment"># 调用tom中的方法</span></span><br><span class="line">tom.eat()</span><br><span class="line">print(tom) <span class="comment"># 打印tom对象在内存中的地址</span></span><br><span class="line">addr = <span class="built_in">id</span>(tom)</span><br><span class="line">print(<span class="string">&quot;%x&quot;</span> % addr)</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># 小猫在喝水</span></span><br><span class="line"><span class="comment"># 小猫爱吃鱼</span></span><br><span class="line"><span class="comment"># &lt;__main__.Cat object at 0x7f76373fa670&gt;</span></span><br><span class="line"><span class="comment"># 7f780b7c1670</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-4-引用概念的强调"><a href="#3-2-4-引用概念的强调" class="headerlink" title="3.2.4 引用概念的强调"></a>3.2.4 引用概念的强调</h4><blockquote>
<p>在面向对象开发中，<strong>引用</strong>的概念是同样适用的！</p>
</blockquote>
<ul>
<li>在 <code>Python</code> 中使用类 <strong>创建对象之后</strong>，<code>tom</code> 变量中 仍然记录的是 <strong>对象在内存中的地址</strong></li>
<li>也就是 <code>tom</code> 变量 <strong>引用</strong> 了 <strong>新建的猫对象</strong></li>
<li>使用 <code>print</code> 输出 <strong>对象变量</strong>，默认情况下，是能够输出这个变量 <strong>引用的对象</strong> 是 <strong>由哪一个类创建的对象</strong>，以及 <strong>在内存中的地址</strong>（<strong>十六进制表示</strong>）</li>
</ul>
<blockquote>
<p>提示：在计算机中，通常使用 <strong>十六进制</strong> 表示 <strong>内存地址</strong></p>
<ul>
<li><strong>十进制</strong> 和 <strong>十六进制</strong> 都是用来表达数字的，只是表示的方式不一样</li>
<li><strong>十进制</strong> 和 <strong>十六进制</strong> 的数字之间可以来回转换</li>
</ul>
</blockquote>
<ul>
<li><code>%d</code> 可以以 <strong>10 进制</strong> 输出数字</li>
<li><code>%x</code> 可以以 <strong>16 进制</strong> 输出数字</li>
</ul>
<p>补充知识：引用与赋值</p>
<p>在Python中，令values=[0,1,2];values[1]=values,为何结果是[0,[…],2]?]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>values[<span class="number">1</span>] = values</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>values[<span class="number">0</span>, [...], <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>我预想应当是 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>但结果却为何要赋值无限次？</p>
<p><strong>可以说 Python 没有赋值，只有引用</strong>。你这样相当于创建了一个引用自身的结构，所以导致了无限循环。为了理解这个问题，有个基本概念需要搞清楚。</p>
<p>Python 没有「变量」，我们平时所说的变量其实只是「标签」，是引用。这里的引用类似C语言中的指针。</p>
<h4 id="3-2-5-使用Cat类再创建一个对象"><a href="#3-2-5-使用Cat类再创建一个对象" class="headerlink" title="3.2.5 使用Cat类再创建一个对象"></a>3.2.5 使用Cat类再创建一个对象</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;这是一个猫类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;小猫爱吃鱼&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drink</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;小猫在喝水&quot;</span>)</span><br><span class="line"></span><br><span class="line">tom = Cat()</span><br><span class="line">tom.drink()</span><br><span class="line">tom.eat()</span><br><span class="line">print(tom)</span><br><span class="line"></span><br><span class="line">lazy_cat = Cat()</span><br><span class="line">lazy_cat.eat()</span><br><span class="line">lazy_cat.drink()</span><br><span class="line">print(lazy_cat) <span class="comment"># lazy_cat 和 tom 是两个不同的对象</span></span><br><span class="line">lazy_cat2 = lazy_cat <span class="comment"># 这里涉及到引用</span></span><br><span class="line">print(lazy_cat2) <span class="comment"># lazy_cat2和lazy_cat2表示同一个对象</span></span><br><span class="line"><span class="comment"># 小猫在喝水</span></span><br><span class="line"><span class="comment"># 小猫爱吃鱼</span></span><br><span class="line"><span class="comment"># &lt;__main__.Cat object at 0x7fbcf2de2670&gt;</span></span><br><span class="line"><span class="comment"># 小猫爱吃鱼</span></span><br><span class="line"><span class="comment"># 小猫在喝水</span></span><br><span class="line"><span class="comment"># &lt;__main__.Cat object at 0x7fbcf2de7fd0&gt;</span></span><br><span class="line"><span class="comment"># &lt;__main__.Cat object at 0x7f0869e2afd0&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-案例改造-——-给对象增加属性"><a href="#3-3-案例改造-——-给对象增加属性" class="headerlink" title="3.3 案例改造 —— 给对象增加属性"></a>3.3 案例改造 —— 给对象增加属性</h3><ul>
<li><p>在Python中，要给对象设置属性，非常的容易，但是不推荐使用</p>
<p>因为：对象属性的封装应该封装在类的内部</p>
</li>
<li><p>只需要在 <strong>类的外部的代码</strong> 中直接通过 <code>.</code> 设置一个属性即可</p>
</li>
</ul>
<blockquote>
<p>注意：这种方式虽然简单，但是不推荐使用！</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tom.name = <span class="string">&quot;Tom&quot;</span> <span class="comment"># 这种属性只针对tom</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">lazy_cat.name = <span class="string">&quot;大懒猫&quot;</span> <span class="comment"># 这种属性只针对lazy_cat</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-方法中的self参数"><a href="#3-4-方法中的self参数" class="headerlink" title="3.4 方法中的self参数"></a>3.4 方法中的self参数</h3><blockquote>
<p>由 <strong>哪一个对象</strong> 调用的方法，方法内的 <code>self</code> 就是 <strong>哪一个对象的引用</strong></p>
</blockquote>
<ul>
<li>在类封装的方法内部，<code>self</code> 就表示 <strong>当前调用方法的对象自己</strong></li>
<li><strong>调用方法时</strong>，程序员不需要传递 <code>self</code> 参数</li>
<li>在方法内部<ul>
<li>可以通过 <code>self.</code> <strong>访问对象的属性</strong></li>
<li>也可以通过 <code>self.</code> <strong>调用其他的对象方法</strong></li>
</ul>
</li>
<li>改造代码如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;%s 爱吃鱼&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">tom = Cat()</span><br><span class="line">tom.name = <span class="string">&quot;Tom&quot;</span> <span class="comment"># 访问对象的属性</span></span><br><span class="line">tom.eat() <span class="comment"># 访问对象的方法</span></span><br><span class="line"></span><br><span class="line">lazy_cat = Cat()</span><br><span class="line">lazy_cat.name = <span class="string">&quot;大懒猫&quot;</span></span><br><span class="line">lazy_cat.eat()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">output:</span></span><br><span class="line"><span class="string">Tom 爱吃鱼</span></span><br><span class="line"><span class="string">大懒猫 爱吃鱼</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/f4f081c5/005_%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84self.png" alt="005_方法中的self"></p>
<ul>
<li>在 <strong>类的外部</strong>，通过 <code>变量名.</code> 访问对象的 <strong>属性和方法</strong></li>
<li>在 <strong>类封装的方法中</strong>，通过 <code>self.</code> 访问对象的 <strong>属性和方法</strong></li>
</ul>
<h3 id="3-5-注意避免在类的外部给对象增加属性"><a href="#3-5-注意避免在类的外部给对象增加属性" class="headerlink" title="3.5 注意避免在类的外部给对象增加属性"></a>3.5 注意避免在类的外部给对象增加属性</h3><ul>
<li>将案例代码进行调整，<strong>先调用方法 再设置属性</strong>，观察一下执行效果</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tom = Cat()</span><br><span class="line">tom.drink()</span><br><span class="line">tom.eat()</span><br><span class="line">tom.name = <span class="string">&quot;Tom&quot;</span></span><br><span class="line">print(tom)</span><br></pre></td></tr></table></figure>

<ul>
<li>程序执行报错如下：</li>
<li>原因：python自顶向下执行，执行<code>tom.drink()</code>时不能通过self.name访问name，因为name还未定义。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">AttributeError: <span class="string">&#x27;Cat&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;name&#x27;</span></span><br><span class="line">属性错误：<span class="string">&#x27;Cat&#x27;</span> 对象没有 <span class="string">&#x27;name&#x27;</span> 属性</span><br></pre></td></tr></table></figure>

<p><strong>提示</strong></p>
<ul>
<li>在日常开发中，不推荐在类的外部给对象增加属性<ul>
<li>如果<strong>在运行时，没有找到属性，程序会报错</strong></li>
</ul>
</li>
<li>对象应该包含有哪些属性，应该 <strong>封装在类的内部</strong></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag>Python进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Python进阶笔记（二）</title>
    <url>/posts/c4e66d1d.html</url>
    <content><![CDATA[<blockquote>
<p><strong>续…python进阶学习笔记（一）</strong></p>
</blockquote>
<span id="more"></span>

<h1 id="一-面向对象概述"><a href="#一-面向对象概述" class="headerlink" title="一.面向对象概述"></a>一.面向对象概述</h1><h2 id="3-面向对象基础语法"><a href="#3-面向对象基础语法" class="headerlink" title="3.面向对象基础语法"></a>3.面向对象基础语法</h2><h3 id="3-6-初始化方法"><a href="#3-6-初始化方法" class="headerlink" title="3.6 初始化方法"></a>3.6 初始化方法</h3>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag>Python进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Sort函数的应用</title>
    <url>/posts/e6c1070a.html</url>
    <content><![CDATA[<h2 id="PAT-甲级-1025"><a href="#PAT-甲级-1025" class="headerlink" title="PAT 甲级 1025"></a>PAT 甲级 1025</h2><span id="more"></span>

<p>Programming Ability Test (PAT) is organized by the College of Computer Science and Technology of Zhejiang University. Each test is supposed to run simultaneously in several places, and the ranklists will be merged immediately after the test. Now it is your job to write a program to correctly merge all the ranklists and generate the final rank.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive number <em>N</em> (≤100), the number of test locations. Then <em>N</em> ranklists follow, each starts with a line containing a positive integer <em>K</em> (≤300), the number of testees, and then <em>K</em> lines containing the registration number (a 13-digit number) and the total score of each testee. All the numbers in a line are separated by a space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, first print in one line the total number of testees. Then print the final ranklist in the following format:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registration_number final_rank location_number local_rank</span><br></pre></td></tr></table></figure>

<p>The locations are numbered from 1 to <em>N</em>. The output must be sorted in nondecreasing order of the final ranks. The testees with the same score must have the same rank, and the output must be sorted in nondecreasing order of their registration numbers.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">5</span><br><span class="line">1234567890001 95</span><br><span class="line">1234567890005 100</span><br><span class="line">1234567890003 95</span><br><span class="line">1234567890002 77</span><br><span class="line">1234567890004 85</span><br><span class="line">4</span><br><span class="line">1234567890013 65</span><br><span class="line">1234567890011 25</span><br><span class="line">1234567890014 100</span><br><span class="line">1234567890012 85</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">1234567890005 1 1 1</span><br><span class="line">1234567890014 1 2 1</span><br><span class="line">1234567890001 3 1 2</span><br><span class="line">1234567890003 3 1 2</span><br><span class="line">1234567890004 5 1 4</span><br><span class="line">1234567890012 5 2 2</span><br><span class="line">1234567890002 7 1 5</span><br><span class="line">1234567890013 8 2 3</span><br><span class="line">1234567890011 9 2 4</span><br></pre></td></tr></table></figure>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>  给所有地区的考生排名。题目首先给出N，表示有N个地区，之后每个地区给出K，及K个考生的考号，分数，最后要求你不仅要输出每个考生的总排名，还要输出每个考生的地区排名</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>  首先建立一个结构体，存储考生的考号，分数，地区序号及地区排名，然后建立一个充分大(&gt;=30000)的结构体数组，然后依次每输入一个地区的考生信息，就对该地区的考试进行排序，同时计算其地区排名。输入完毕后，对该结构体数组进行总排序，最终计算总排名并输出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">30010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">char</span> id[<span class="number">14</span>];</span><br><span class="line">    <span class="keyword">int</span> location_num;</span><br><span class="line">    <span class="keyword">int</span> local_rank;</span><br><span class="line">&#125;stu[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Student a,Student b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.score != b.score) <span class="keyword">return</span> a.score &gt; b.score;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(a.id,b.id) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s %d&quot;</span>,stu[num].id,&amp;stu[num].score);</span><br><span class="line">            stu[num].location_num = i+<span class="number">1</span>;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sort(stu+num-m,stu+num,cmp);</span><br><span class="line">        stu[num-m].local_rank = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num-m+<span class="number">1</span>;i &lt; num;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (stu[i].score == stu[i<span class="number">-1</span>].score) stu[i].local_rank = stu[i<span class="number">-1</span>].local_rank;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                stu[i].local_rank = i+<span class="number">1</span>-(num-m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num);</span><br><span class="line">    sort(stu,stu+num,cmp);</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; num;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; stu[i].score != stu[i<span class="number">-1</span>].score) r = i +<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d %d %d\n&quot;</span>,stu[i].id,r,stu[i].location_num,stu[i].local_rank);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL语句大全</title>
    <url>/posts/68d55db1.html</url>
    <content><![CDATA[<p>转载：<a href="https://mp.weixin.qq.com/s/EbdgRbGBgzzRa2pET-6qRA">https://mp.weixin.qq.com/s/EbdgRbGBgzzRa2pET-6qRA</a></p>
<h2 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h2><h3 id="1、说明：创建数据库"><a href="#1、说明：创建数据库" class="headerlink" title="1、说明：创建数据库"></a>1、说明：创建数据库</h3><p>CREATE DATABASE database-name</p>
<h3 id="2、说明：删除数据库"><a href="#2、说明：删除数据库" class="headerlink" title="2、说明：删除数据库"></a>2、说明：删除数据库</h3><p>drop database dbname</p>
<span id="more"></span>

<h3 id="3、说明：备份sql-server"><a href="#3、说明：备份sql-server" class="headerlink" title="3、说明：备份sql server"></a>3、说明：备份sql server</h3><p>— 创建 备份数据的 device<br>USE master<br>EXEC sp_addumpdevice ‘disk’, ‘testBack’, ‘c:mssql7backupMyNwind_1.dat’<br>— 开始 备份<br>BACKUP DATABASE pubs TO testBack </p>
<h3 id="4、说明：创建新表"><a href="#4、说明：创建新表" class="headerlink" title="4、说明：创建新表"></a>4、说明：创建新表</h3><p>create table tabname(col1 type1 [not null] [primary key],col2 type2 [not null],..)</p>
<p>根据已有的表创建新表：<br>A：create table tab_new like tab_old (使用旧表创建新表)<br>B：create table tab_new as select col1,col2… from tab_old definition only</p>
<h3 id="5、说明：删除新表"><a href="#5、说明：删除新表" class="headerlink" title="5、说明：删除新表"></a>5、说明：删除新表</h3><p>drop table tabname </p>
<h3 id="6、说明：增加一个列"><a href="#6、说明：增加一个列" class="headerlink" title="6、说明：增加一个列"></a>6、说明：增加一个列</h3><p>Alter table tabname add column col type注：列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加varchar类型的长度。</p>
<h3 id="7、说明：添加主键：-Alter-table-tabname-add-primary-key-col"><a href="#7、说明：添加主键：-Alter-table-tabname-add-primary-key-col" class="headerlink" title="7、说明：添加主键： Alter table tabname add primary key(col)"></a>7、说明：添加主键： Alter table tabname add primary key(col)</h3><p>说明：删除主键： Alter table tabname drop primary key(col) </p>
<h3 id="8、说明：创建索引：create-unique-index-idxname-on-tabname-col…"><a href="#8、说明：创建索引：create-unique-index-idxname-on-tabname-col…" class="headerlink" title="8、说明：创建索引：create [unique] index idxname on tabname(col….)"></a>8、说明：创建索引：create [unique] index idxname on tabname(col….)</h3><p>删除索引：drop index idxname<br>注：索引是不可更改的，想更改必须删除重新建。</p>
<h3 id="9、说明：创建视图：create-view-viewname-as-select-statement"><a href="#9、说明：创建视图：create-view-viewname-as-select-statement" class="headerlink" title="9、说明：创建视图：create view viewname as select statement"></a>9、说明：创建视图：create view viewname as select statement</h3><p>删除视图：drop view viewname</p>
<p>待更新。。。</p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Texlive和TexStudio的安装与使用</title>
    <url>/posts/bc17736e.html</url>
    <content><![CDATA[<h2 id="TexLive2021"><a href="#TexLive2021" class="headerlink" title="TexLive2021"></a>TexLive2021</h2><p>首先我们要安装Texlive，它是一个Tex的发行版。</p>
<p>详细安装配置过程建议参考：<a href="https://blog.csdn.net/Mikchy/article/details/94448707">https://blog.csdn.net/Mikchy/article/details/94448707</a></p>
<p>以及<a href="https://github.com/OsbertWang/install-latex-guide-zh-cn%E3%80%82">https://github.com/OsbertWang/install-latex-guide-zh-cn。</a></p>
<span id="more"></span>

<p>如果出现一些TexLive的安装问题，看这个：<a href="https://blog.csdn.net/dogfat/article/details/106962966%E3%80%82">https://blog.csdn.net/dogfat/article/details/106962966。</a></p>
<ul>
<li><p>注意：路径中不要出现中文，一些特殊符号和空格</p>
</li>
<li><p>特别提一点，安装教程中提到的.bat文件，如果双击打开闪退，就尝试右键管理员身份打开。</p>
</li>
<li><p>如果两种方式都会闪退，说明大概率是你没有<strong>配置好环境变量</strong>。</p>
</li>
<li><p> 配置环境变量时还可能会出问题：提示你此环境变量太大，最长为2047个字符。</p>
</li>
</ul>
<p>这时候新建了一个Path1,把要添加的变量放到Path1里，再在Path里新建变量%Path1%就OK了。</p>
<ul>
<li><p>如果安装时出现如下图所示错误：</p>
<p><img src="/posts/bc17736e/image-20210411205554694.png" alt="image-20210411205554694"></p>
</li>
</ul>
<p>多半是因为系统用户名含有中文！！！</p>
<p>这个问题困扰我很久，才发现大佬的<a href="https://mp.weixin.qq.com/s/9aE4AlHj2XfnymmT8P3I5Q">解决方案</a>。</p>
<p>还有这篇文章给了我提示：<a href="https://www.zhihu.com/people/zhang-shao-fan-45%E3%80%82">https://www.zhihu.com/people/zhang-shao-fan-45。</a></p>
<p>按照文章的提示来做，就能够成功安装上TexLive2021了。(PS：安装过程可能要等很久时间，约1h40min)</p>
<p>注意：千万不要点Abrobt！！！会直接退出安装，后期还要重装。</p>
<p>直到出现这个，才表示安装成功！！！</p>
<p><img src="/posts/bc17736e/image-20210412072427033.png" alt="image-20210412072427033"></p>
<p>接下来到cmd中测试是否成功安装上，输入命令：tex -version。</p>
<p>如果提示’tex’不是内部或外部命令等，说明可能是没有配置好环境变量。</p>
<p>那么我们找到TexLive的安装目录中的bin目录下的win32，将它加入系统变量Path。</p>
<p><img src="/posts/bc17736e/image-20210411230107676.png" alt="image-20210411230107676"></p>
<p>然后继续输入命令：tex -version测试。</p>
<p><img src="/posts/bc17736e/image-20210411230204922.png" alt="image-20210411230204922"></p>
<p>如图表示成功安装，否则需要重新安装。</p>
<h2 id="Tex-Studio"><a href="#Tex-Studio" class="headerlink" title="Tex Studio"></a>Tex Studio</h2><p>下面我们跟着<a href="https://blog.csdn.net/Mikchy/article/details/94448707">教程</a>继续安装Tex Studio。</p>
<p>安装过程非常简单。</p>
<p>安装好之后，我们来测试一下。新建一个文件复制以下内容。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 导言区</span></span><br><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">% 导入中文宏</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;ctex&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 构建命令,取别名，使用degree 代替 ^ circ</span></span><br><span class="line"><span class="keyword">\newcommand</span><span class="keyword">\degree</span>&#123;<span class="built_in">^</span><span class="keyword">\circ</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\title</span>&#123;<span class="keyword">\heiti</span> 浅谈勾股定理&#125;</span><br><span class="line"><span class="keyword">\author</span>&#123;<span class="keyword">\kaishu</span> 张一根&#125;</span><br><span class="line"><span class="keyword">\date</span>&#123;<span class="keyword">\today</span>&#125;</span><br><span class="line"><span class="comment">% 正文区</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">	<span class="keyword">\maketitle</span></span><br><span class="line">	hello world!</span><br><span class="line">	</span><br><span class="line">	勾股定理可以用现代的语言描述如下：</span><br><span class="line">	</span><br><span class="line">	直角三角形斜边的平方等于两腰的平法和。</span><br><span class="line">	</span><br><span class="line">	可以用符号语言描述为：设直角三角形 </span><br><span class="line">	<span class="built_in">$</span><span class="keyword">\angle</span> C=90<span class="keyword">\degree</span> <span class="built_in">$</span>则有：</span><br><span class="line">	<span class="built_in">$</span><span class="built_in">$</span> </span><br><span class="line">	AB<span class="built_in">^</span>2 = BC<span class="built_in">^</span>2 + AC<span class="built_in">^</span>2 </span><br><span class="line">	<span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line">	这就是勾股定理</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>

<p>出现<strong>完成</strong>表示安装成功。</p>
<p><img src="/posts/bc17736e/image-20210412072609787.png" alt="image-20210412072609787"></p>
]]></content>
      <categories>
        <category>Latex</category>
      </categories>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows Termial使用及美化教程</title>
    <url>/posts/b2e908af.html</url>
    <content><![CDATA[<p>参考自：<a href="https://blog.csdn.net/yuanlaijike/article/details/107599983">https://blog.csdn.net/yuanlaijike/article/details/107599983</a></p>
<h2 id="如何安装Windows-Terminal"><a href="#如何安装Windows-Terminal" class="headerlink" title="如何安装Windows Terminal"></a>如何安装Windows Terminal</h2><p>直接从Microsoft Store下载就行。</p>
<span id="more"></span>

<p>首先添加git bash到Windows Terminal：</p>
<p><img src="/posts/b2e908af/image-20210426220918332.png" alt="image-20210426220918332"></p>
<p>在命令行选择Git\bin\bash.exe路径。</p>
<p>如果想要添加一个图标，可以下载添加路径就可以了。</p>
<p>常用的配置方式是直接打开JSON文件进行修改。</p>
<h2 id="如何美化"><a href="#如何美化" class="headerlink" title="如何美化"></a>如何美化</h2><p>配置文件的大致布局如下所示，对于我们美化来说，只需要关注 <code>profiles</code> 和 <code>schemes</code> 两块即可。</p>
<p><img src="/posts/b2e908af/20200530155138893.png" alt="img"></p>
<p>让我们先牛刀小试下，调整下终端的字体和字体大小。因为我想对所有终端都应用这个配置。所以我写在了 <code>defaults</code> 中，如下图所示即可。</p>
<p><img src="/posts/b2e908af/2020053015560247.png" alt="img"></p>
<h2 id="把windows-terminal添加到右键菜单"><a href="#把windows-terminal添加到右键菜单" class="headerlink" title="把windows terminal添加到右键菜单"></a>把windows terminal添加到右键菜单</h2><p><a href="https://blog.csdn.net/willingtolove/article/details/109167629?ops_request_misc=&request_id=&biz_id=102&utm_term=windows%20terminal%E5%8F%B3%E9%94%AE%E6%89%BE%E4%B8%8D%E5%88%B0%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-109167629.first_rank_v2_pc_rank_v29">参考教程</a></p>
<p>记得修改<code>startingDirectory</code>属性为<code>null</code>；（PS：没有自己加上就可以）</p>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="/posts/b2e908af/image-20210426221738253.png" alt="image-20210426221738253"></p>
<p><img src="/posts/b2e908af/image-20210426221823207.png" alt="image-20210426221823207"></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>Termial</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>hexo相关问题汇总</title>
    <url>/posts/ec93326a.html</url>
    <content><![CDATA[<blockquote>
<p>本文将介绍总结一些hexo的常见/不常见/棘手问题的解决方法。</p>
</blockquote>
<span id="more"></span>

<h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><h2 id="1-插入图片"><a href="#1-插入图片" class="headerlink" title="1.插入图片"></a>1.插入图片</h2><p>只需在 md 文件里使用 <code>![title](同名文件夹/图片名.jpg)</code> ，无需路径名就可以插入图片。</p>
<h2 id="2-文章摘要"><a href="#2-文章摘要" class="headerlink" title="2.文章摘要"></a>2.文章摘要</h2><p>在文章<code>&lt;!--more--&gt;</code>之前的内容将作为首页的摘要部分！</p>
<h2 id="3-解决busuanzi不显示问题必看"><a href="#3-解决busuanzi不显示问题必看" class="headerlink" title="3.解决busuanzi不显示问题必看"></a>3.<a href="https://muyuuuu.github.io/2019/11/22/busuanzi-notdisplay/">解决busuanzi不显示问题必看</a></h2><p>其实核心问题就是找到span id里是否有style = “display: none”，找到对应文件对应位置的代码并删除即可</p>
<h2 id="4-hexo-s本地样式与网页样式不一致？"><a href="#4-hexo-s本地样式与网页样式不一致？" class="headerlink" title="4.hexo s本地样式与网页样式不一致？"></a>4.hexo s本地样式与网页样式不一致？</h2><ul>
<li>其实原因很简单，拉到服务器之前要<code>hexo clean</code>清理一下缓存，然后再生成和部署，你学会了吗？</li>
</ul>
<p>（可能<code>hexo c &amp;&amp; hexo g &amp;&amp; hexo d</code>一步到位，有时候不太行，分开写）</p>
<ul>
<li>或者清理一下浏览器缓存就可以解决。</li>
</ul>
<h2 id="5-markdown语法速成宝典"><a href="#5-markdown语法速成宝典" class="headerlink" title="5.markdown语法速成宝典"></a>5.<a href="https://www.kuangstudy.com/bbs/1356475333565587458">markdown语法速成宝典</a></h2><h2 id="6-推荐hexo搭建文章："><a href="#6-推荐hexo搭建文章：" class="headerlink" title="6.推荐hexo搭建文章："></a>6.推荐hexo搭建文章：</h2><p><a href="https://tding.top/archives/aad98408.html">https://tding.top/archives/aad98408.html</a></p>
<h2 id="7-使用插件备份博客源文件："><a href="#7-使用插件备份博客源文件：" class="headerlink" title="7.使用插件备份博客源文件："></a>7.使用插件备份博客源文件：</h2><p><a href="https://blog.csdn.net/qq_41793001/article/details/103151182">https://blog.csdn.net/qq_41793001/article/details/103151182</a></p>
<hr>
<p>有关备份问题：</p>
<p><img src="/posts/ec93326a/image-20210321201128176.png" alt="image-20210321201128176"></p>
<p>解决方案：<a href="https://cloud.tencent.com/developer/article/1572090">https://cloud.tencent.com/developer/article/1572090</a></p>
<p>文章中提到的<code>.ssh</code>文件夹一般位于C:\Users\你的用户名\xxx。</p>
<p><img src="/posts/ec93326a/image-20210321201346184.png" alt="image-20210321201346184"></p>
<p>如果出现下图的情况，一般就成功了：</p>
<p><img src="/posts/ec93326a/image-20210321201521647.png" alt="image-20210321201521647"></p>
<p>这时我们再检查github上的hexo仓库，会发现用于备份的backup分支已经成功备份。</p>
<p><img src="/posts/ec93326a/image-20210321201725486.png" alt="image-20210321201725486"></p>
<h2 id="8-hexo博客使用Valine添加评论系统："><a href="#8-hexo博客使用Valine添加评论系统：" class="headerlink" title="8.hexo博客使用Valine添加评论系统："></a>8.hexo博客使用<a href="https://valine.js.org/">Valine</a>添加评论系统：</h2><p>参见博客 <a href="https://www.luanzhuxian.com/post/c49d1b87.html">https://www.luanzhuxian.com/post/c49d1b87.html</a>  和 <a href="https://www.zhyong.cn/posts/95cb/">https://www.zhyong.cn/posts/95cb/</a></p>
<p>第三方插件增强邮件提醒：<a href="https://blog.csdn.net/AC916305619/article/details/110379680">https://blog.csdn.net/AC916305619/article/details/110379680</a> 和 <a href="https://github.com/DesertsP/Valine-Admin">https://github.com/DesertsP/Valine-Admin</a></p>
<h2 id="9-文章加密处理："><a href="#9-文章加密处理：" class="headerlink" title="9.文章加密处理："></a>9.文章加密处理：</h2><p>参考<a href="https://blog.csdn.net/weixin_45750972/article/details/111396124">https://blog.csdn.net/weixin_45750972/article/details/111396124</a></p>
<ul>
<li>password: 该Blog使用的密码，注意单词不要拼错，尬</li>
<li>abstract: Blog摘要文字（少量）</li>
<li>message: 密码框上的描述性文字</li>
</ul>
<h2 id="10-添加打赏功能："><a href="#10-添加打赏功能：" class="headerlink" title="10.添加打赏功能："></a>10.添加打赏功能：</h2><p>参考<a href="https://www.dazhuanlan.com/2020/01/20/5e25021a447f6/">https://www.dazhuanlan.com/2020/01/20/5e25021a447f6/</a></p>
<h2 id="11-hexo-d时网络不稳定"><a href="#11-hexo-d时网络不稳定" class="headerlink" title="11.hexo d时网络不稳定"></a>11.hexo d时网络不稳定</h2><p>当执行<code>hexo d</code>命令时出现如下错误时，OpenSSL SSL_read: Connection was aborted, errno 10053…</p>
<p>参考解决方案：<a href="https://blog.csdn.net/weixin_43945983/article/details/110882074">https://blog.csdn.net/weixin_43945983/article/details/110882074</a></p>
<p>先执行<code>git config --global http.sslVerify &quot;false&quot;</code>命令，再执行<code>hexo d</code>就行了。<br>如果还有错，多试几次，网络不好。</p>
<h2 id="12-文章生成永久化链接"><a href="#12-文章生成永久化链接" class="headerlink" title="12.文章生成永久化链接"></a>12.文章生成永久化链接</h2><p>参考：<a href="https://blog.csdn.net/u011063477/article/details/105929290/">https://blog.csdn.net/u011063477/article/details/105929290/</a></p>
<p>安装hexo-abbrlink插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>

<p>站点配置文件(_config.yml)里:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">post/:abbrlink.html</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>  <span class="comment"># 算法：crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>    <span class="comment"># 进制：dec(default) and hex</span></span><br></pre></td></tr></table></figure>

<p>先使用<code>hexo c &amp;&amp; hexo g</code>，清除缓存，重新生成，再使用<code>hexo g</code>会自动在你的文章中加上<code>abbrlink: fbf5310d</code>。</p>
<p>如果打开网站发现打开不同文章都会重定向到一篇文章，而且都会出现undefined.html，说明没有清除缓存。</p>
<p>图像不显示问题：<a href="https://www.pianshen.com/article/65241119972/">https://www.pianshen.com/article/65241119972/</a></p>
<p>如果还是不显示，就<code>hexo s</code>，在md文件中先删除<code>![picture](arctile/image.jpg)</code>其中的<code>arctile/</code>，再粘贴回去，在浏览器刷新一下就能看到了。（PS：一篇文章有多张图片时只要第一张这样做就行了）</p>
<p>个人无意中发现的，原理不清楚。可能是插入图片时会自动把文章同名目录下的图片设定为相对路径，不需要加上文章同名的上一级目录。</p>
<p>一顿操作下来，不停CV，我手都摁麻了。</p>
<h2 id="14-购买域名与绑定域名"><a href="#14-购买域名与绑定域名" class="headerlink" title="14.购买域名与绑定域名"></a>14.购买域名与绑定域名</h2><p>处理域名花了我一下午功夫，事情起因是我突然想着要不要买个域名玩玩，然后去B站搜了一下，发现一个UP做的系列视频，觉得讲得还不错，推荐给大家。</p>
<p>视频地址：<a href="https://www.bilibili.com/video/BV18a4y1Y7e9?share_source=copy_web">https://www.bilibili.com/video/BV18a4y1Y7e9?share_source=copy_web</a></p>
<p>我是在阿里云买的域名，其实腾讯云也还不错。一次性买了三年，花了不到100软妹币。</p>
<p>参考教程：</p>
<p><a href="https://noshore.cn/shuangxianbushu.html#2-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90">https://noshore.cn/shuangxianbushu.html#2-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90</a></p>
<p>其实我更推荐看腾讯云的官方文档，看不懂的话还有人工客服。因为博客的内容毕竟不是最新的，而且不一定适合所有人。</p>
<p>折腾老半天最后还是成功了。</p>
<p><a href="https://www.grantdrew.top/%E5%92%8Chttp://www.grantdrew.top/%E9%83%BD%E8%83%BD%E8%AE%BF%E9%97%AE%E5%BD%93%E5%89%8D%E7%AB%99%E7%82%B9%E3%80%82">https://www.grantdrew.top/和http://www.grantdrew.top/都能访问当前站点。</a></p>
<p>以后用<code>hexo d -g</code>进行双线部署。</p>
<h2 id="15-配置域名后评论区出现code403"><a href="#15-配置域名后评论区出现code403" class="headerlink" title="15.配置域名后评论区出现code403"></a>15.配置域名后评论区出现code403</h2><p>参考：<a href="https://blog.csdn.net/weixin_43868299/article/details/107601150">https://blog.csdn.net/weixin_43868299/article/details/107601150</a></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>oj刷题注意事项</title>
    <url>/posts/5f4a89a.html</url>
    <content><![CDATA[<h2 id="1-oj赛制介绍"><a href="#1-oj赛制介绍" class="headerlink" title="1.oj赛制介绍"></a>1.oj赛制介绍</h2><p>参考自：<a href="https://zhuanlan.zhihu.com/p/129311302">https://zhuanlan.zhihu.com/p/129311302</a></p>
<p>介绍一下编程比赛中最常见的三种赛制：ACM赛制、OI赛制、IOI赛制。</p>
<span id="more"></span>

<p><strong>ACM赛制</strong>：每道题提交之后都有反馈，可以看到“通过”、“运行错误”、“答案错误”等等结果，但看不到错误的测试样例（leetcode周赛可以看到），每道题都有多个测试点，每道题必须通过了所有的测试点才算通过。每道题不限制提交次数，但没通过的话会有罚时，仅以最后一次提交为准。比赛过程中一般可以看到实时排名，通过题数相同的情况下按照答题时间+罚时来排名。</p>
<p><strong>ACM赛制的比赛</strong>：ICPC、CCPC、codeforces比赛、leetcode周赛及全国编程大赛、牛客小白赛练习赛挑战赛、传智杯。</p>
<p><strong>OI赛制</strong>：每道题提交之后都没有任何反馈，每道题都有多个测试点，根据每道题通过的测试点的数量获得相应的分数。每道题不限制提交次数，如果提交错误没有任何惩罚，仅以最后一次提交为准。比赛过程中看不到实时排名，赛后按照总得分来排名。</p>
<p><strong>OI赛制的比赛</strong>：NOI全国青少年信息学奥林匹克竞赛、CCF CSP、考研机试、蓝桥杯、牛客OI赛、全国高校计算机能力挑战赛。</p>
<p><strong>IOI赛制</strong>：每道题提交之后都有反馈，可以看到“通过”、“运行错误”、“答案错误”等等结果，甚至可以实时看到自己每道题得了多少分，但看不到错误的测试样例。每道题都有多个测试点，根据每道题通过的测试点的数量获得相应的分数。每道题不限制提交次数，如果提交错误没有任何惩罚，仅以最后一次提交为准。比赛过程中一般可以看到实时排名（如果是考试，一般看不到排名），按照总得分来排名。可以说，IOI赛制是结合了OI赛制和ACM赛制的特点。</p>
<p><strong>IOI赛制的比赛</strong>：PAT、团体程序设计天梯赛、CCF CCSP、洛谷月赛。</p>
<h2 id="2-输出格式问题"><a href="#2-输出格式问题" class="headerlink" title="2.输出格式问题"></a>2.输出格式问题</h2><p>acwing对于输出格式非常宽松，末尾空格空行都能过，但有不少oj会卡输出格式，注意审题。</p>
<p>平时做题，最好控制一下输出格式，否则爆0就很难受。</p>
<p>末尾不要有空格做法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++).<span class="comment">//a[0]先输出了，故循环从1开始</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Java刷题注意事项"><a href="#3-Java刷题注意事项" class="headerlink" title="3.Java刷题注意事项"></a>3.Java刷题注意事项</h2><p>参考1：<a href="https://www.acwing.com/blog/content/431/">https://www.acwing.com/blog/content/431/</a></p>
<p>参考2：<a href="https://www.acwing.com/blog/content/593/">https://www.acwing.com/blog/content/593/</a></p>
<p>参考3：<a href="https://www.acwing.com/blog/content/2414/">https://www.acwing.com/blog/content/2414/</a></p>
<p>参考4：<a href="https://www.cnblogs.com/HardBass/p/11702918.html">https://www.cnblogs.com/HardBass/p/11702918.html</a></p>
<h2 id="4-Java与C-刷题的多方位对比"><a href="#4-Java与C-刷题的多方位对比" class="headerlink" title="4.Java与C++刷题的多方位对比"></a>4.Java与C++刷题的多方位对比</h2><p>参考1：<a href="https://www.cnblogs.com/hx97/p/12347699.html">https://www.cnblogs.com/hx97/p/12347699.html</a></p>
<p>参考2：我的转载文章<a href="https://grant1499.github.io/2021/04/04/C-STL%E4%B8%8EJava-util%E5%AF%B9%E6%AF%94/">C++ STL与Java util对比</a></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>个人文章导航</title>
    <url>/posts/e3eddb2e.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="fa781bfa9eb1724b866fd0e7ed9cbd4abb90c1e31b191dcbff5427cfd5498be4">fb26124e0d85f363a66baed35993e1a030a29d879278383cdad8c23dffda92240ccbdc389387e891ef1face681f359603f288e8635728b416fa8ddd02ba8ed640ed55f7ceece7d41ecf73c14c8b72ef2a860b12c355a2481d538e4cd7611fcd39741fb7af5a30d23e4438dd282ddd929222aeb2a7e0e709822624947b615d57a521dec22f63f34d9acd2c4a9c144d67a0ca272e978ac90cc2cf54197d288722fef70ade0517db02bed71420c290c995baf7aeb0e6f84abff04923033809a1acd7d0f1090e0fa53a873c78151cd9c1f48bfa32cd6468f3c27ee0d99bdea4bba5dafb34835b2a9ab91256339d281463aa5348dc358ae240bcf8e3181fbb639a76a5419f536875d857961606453555d2deea32aa15af5e5d2fc09f8b7bc3e468108c443c9845f388f84b83c801cdacbe56237aa2271c03310d115966441c08df14e7b362d468a0934ed76784b577b1e5d24ddfd4b8fbe5afc9c7c53b8f51c2b7b3f364e0d01a520318b5f3e3449f852b8a3a51f7aa700a3b146613d70f4af8e215216392cf8cb79f9a5d5b3702705c06b788167c7106d23e2e0d38ca4730e5d348756557c1af97193c7094a5c26a1d8452e16c3c6a2416825a99787ac975e4aceb0879d5922a1793267010050839dd400976fcb5d3f345831afc40ea8e7d0c53f52dba6e508c18c7a7cbb59d9642ebda1f45d2b4987e7cd2708e083de642b21c0d0c3cd1b41c3ff14722b1e24e818d1efd7c2300707fcf829bfc68f2e888933554af5d5d5986b918cf9b26e323a3cf3a2d01319984e40c515b5e3e580026040d5a0858522e8900d9aacf124b3d2c6e73b34b9480305152da216bbc016779fa09677d7000859e32a90393bdfe8347cda75c1cd1122bec656ef1edd1cbc6e9d3821abee339650a6af4824d1d4ef3243a119cfebbd08b7e54680c811379c7f30552fd3914f5279c85c350339a2c2d689ffd89c0e352369deccbf60975194e1f272540a4d903fcabf0b7ff0982d573f19089385707436b7fffc6172dc292aa5d016b2d9c3ad60488268941bd4915a61d0cd2a7e4799a8cb8d33c6e15b7d0de2cc138f9ce73c9721cbe055d96d415bcbc69a44af86c91c4356737a1ce98d999dc316028a4f893adddec271d33346101f7c321014d7c77b3b3b1c0762b6d07806d5be8a01a82053f1cb5ba4c39734ebab244bc6cb4ed0320bb1d3b7a5eecf77bf323adaf9b7cec2bf0519690bc6043eb68863b01ef80348c5296d2348f35bc1c54eada3cfc29c5974c7d7c464b7bd1ec7828d478596da7f1c659ad1b2468d89954ab161921f18b9dae26ae59a7359ff1976b84d9ff599bc793fb04c666153af10885212d85ed71a4b842dc7d5b33ef95fb7979a3a8e3fdeb25d7495a8dac94ee1188108cf5d51371787c06519175db449ef2e26eae272f5319ff5114395a6dbdb9785f87eed6fe605acf04d500c4754fbc80732be096cc58892caba994a5caac7b20acf621bb9a16680bc7f8db69fdbe3b5a9536b120793c4859e20542f6a3eec568a623fb76baef3dacd0990fe59ba821ac6f8d13cae9bcd727ef59f7fc60e18f1f81e30df87aab56278f6c46d13a620f31f7c8a42e1379e7c1be33bed3ceaa5ee08b1b2220f342cc4a2353b328fb19105f76cfefdefad7a98108161af7f62a8d6047bf7d7617949089ecd9fa45d257ef94a3a2b73f5cbda7650d1db6334511164f04c13d7903b29be31f4a6fef91c9861fd1f298a00dea27b78b92aa499b16bac383b62cc91fdee0d5a64f0f6f3c043859a809db4b3aaeca3ec15afaaf66ef9b4c17ce818ef7f0e05fe9d34283a668a247a5f3035dde2a9510de1fc5daeedbdc44286024eddd68e5ad578de81f0ee682e65a4069f72b78e39f9664dbb55e8edc82a1d82038b792708e0896e4e1bf9d71d2ccabfab08d141858a72e1295169efaba1599bc3a66e604c9b6ab3c1a841d64c4d79f626d1c5d602d40f89e8fd38c8145c0e3cf26bafd8a351ea761b483d6ededf753a2ea8ef3331a2e004a5d8aef345f9febf2003494b7c038e3d84d1ab76b857252b9ffd409c5a7401ef884133f81f9cb3c7d2bdddd48197ae4953df40a626695c6319aa34be19560a538fd390bb0725640ef0ba1c3609a6a15220f3745f5a490333c9217a35707ec383b29fc2c5f3b1f696a6942d89d81d363795d62d27f3e875a9082aa795bc3ad1350a785faeabf9005ebdf500e6f178e0e826be257c48148702ff2c497358481b944785cdcb4cf3fbdc09c883b7c57134c320d330df80544ef4625757460d8bbd42fb27528afd9adda4448d72b589259b075280db6d121060c0cc36dad1da0b211bfccc2e6bfde8cf084546c75c6777e218de9008a885997d1eb4b1e1effe3b66cc70288d19986481b147218ca65c44c8a87a8f23f96db2055120a3776c7aa93f2d3952eec9da8e0af9f2f17f274f58679d272fc1d65f285e4b90e1ca10bc0eca2a94e32a0a7db0b9701e5375e9b342a740d09d768900f3b16b886ea9d4fedae826e4bfaba47e739c72dba2d5fc065a68155ab66aa3e9edfdb4037d070dc5f2384c74bf16c1cc79cade6a4c9b05a5a7c7e53b50f5669cbb3eaa0a77e6d2dadcc8d68a6301d61946536116072edde160f418d6c63e6012f86f5c35f4837ffc7566eb50d9d4af50f157ac31e5c0243bd8700616f45639e648cb005ab1c0f61138b575d4d3d6db5a1230e5d1afbf39f2c32f91883ec8ff6cc873e3c731e9588592ea73fec836205360b06d58a328d47256edeea9e01fe8fdc06e06d04f5524d45c3153ac8592f5d037fd03fd4c997b135e8bae316534976988e5b2fcd2b0129f87d9f585d5113c15b3356198d396d94813b585a5ec0e5758ef7c927bab26df8720d26fceff973e0b689091fb3e37217679bd1f5ed1891fcef623edede20ec86a0f7d51224a46891070628fb7dc5158b69048b0c4be3dff089394c53f7e33ec6e27df912b02cfc669b27cb93a8adcbde893bea2e2d2582fe0c3a8368aa40345005a6b8335e4dbbc7b620d9765e4f57925a24fdd52ffb7ba40a72e80230c7750441c5fc9638a52cf21ece5d815164c73bae1ab5ae802d8f1430fb845e03f3d3b5a1385fe26a881931decb344fb0154d6e90484b390ceac8091678e194ddb8c4a15d7092eccadf112ddcc3858310eaab4d499749617ac6ae2567dcf4bab000efb6fdf5fe2de6e44322dade4ab3ea8ccd6301a7eeba641132ebd39c282e6de9d2b6bfc19e1e9a17fd98927c7ac2011b5980f7fa01ce205cc3176b9c2097ef2611d9ce1fca2759bb53c23a49bfd37fe95e1c60981f182a50bfa890ce4d64c64f14d23b4795e5e45030e4ea8870494f2f13968dfc4117a37a637c25cb46ab556254504eecd96157c8a558a9456820c9ee63f98ad7bba9443ae731ec8d2a1d77c8b66443e411404670e643a7b8c22b1054ff1e19462c0574ef07b0718fa8f1d516e039972292be4ff2aa7406aef96de43e256eb65ef7977aa4aebe87dfd0d36b447dce5e9a7d45b5b8e64b6b3541f2e73081e8b33f095167f87c7ce4ccca8d3d8853eebe503c8d5b90e3ff15b8abcd196119883f93d401635ff8140c2f7718323e825a1b2022a5785c0abd49fb0ab83acdbb985fdd4ffc195c7e4737e184f69fad88fe71c2c816d2bd7cd692f30c93af9c0e51469bb9a5c3275a07f3c58403f5f59a2d72da035718f6c0b1a08bdf5650d6b80baf682d3783c5fdfc3d8fa5aa8cffd3cfad07505ea0ceb77cadded2eade6f89d32cb7035c5f178231a5bfa4df76ca71b6744c4dc7e626d6c69b737abab8999de0ebf539b49a5f2a3fd355f08ae14b629c1c1eadcdc27611224f4b784182f696a73eb0b9a319612e18031f5d5bb8d347839a2a5651b8adf25ec56cc4622e384aac71ede447097614521abadb98b01021f307a778a25dfa8acd51f600eda0b59e6a54415574137830703baeb45aaef69be4546e95b1ff43f83287e671528443a751a03634e1ac455d9b47492e0e4d8e630be96cb56627f3285e245275404b93530cfe5a9ca7131f874f46755e0dab16cee7893ffe67f2f8c14106389c5514d3813a93b34ecaaf5a629f8a4bc797d781080fe63986278b3eedcce5e40d87b42d00910444bbdfa2cea48ac5c4f522e8ad2a95610e59f3b9802b1ef77a96c33f2fb8506208b0e1ef70e5c2d9a0620f14375c2858302c225dd6f641e22dd59caef429be5f65181743897584fea67f54ed5d75c6816a639fbc9643a7c6e03e75e615a028096b2d1f3e0f6a9084f31d94b1353e68cfb13bbbcaee5794de00eafcc5331b3ca372fdb94d2151452d6c160f332985bdb8da818114c351b7c501fd98b5da5b2348d2b529328546bf3d45da786d507d87a67d4da2e42b12d55c1221e3087d8677b2d04f2a8d1efaf2129cf55d312019b15928bc77708d9f924580e0f709d1fb587249f0020ef7dd8e20e5686682dc8ad49624ca4c4966f3bcc9ede1f17bde40c14f537cd6f8d96f0b05e6a47a2286102e21b544cad694b25d78a157285d0de55b4c1112c53948af2baad280943bee2322a7d90e6740e00831b18f97d35477daa22811825a46032b196aae9538a08b4b5a18193ed9b6475cbee622ebfa93fc351ebeee38656800b91662af1dd373f92e0d4827e94ab27f70fadb09d747a277f6675bda16a7f6f5d328ed07323f89711abf86d824a6eb5d5afbd8eb3652494b079c9802dca1e7c95ac02c7eae339fb4a0414d5a9d340ecb478781b1210791d938433412093c89620161bf4770efe71a2a6d77e6f9a55003a38a9c1237a0e4904055e3a6e2ae1f624902116b58172c6b9e70f6b8c7cb107acd76b25f0a508bd4812529e54daf60ba5e743a0f724c6d9b2ba03bd4c98b99d830470e1a21b08947b2d962e218e0b18835f97390af80a18ea669676a0ef036457481deb36ef3f6ed6fc9517a7e939842ee2f0d439074992b6f58600fe197867bf5ca51e9ecdec89233c9cec2b1654f18630a619def3babcad7e3599efad8ac725afafe71c366f14c94b1edb68b5a03f4f2106ff322b7c5c9036bb42b5754a472ac411f5ed431dd19438f3698cbd0eb14d77f0d865036a1bcbda696a2ba647de044c9c042656d62656b5988b5d0e852eaee75daa869e23f472737026e40d3a8e097912ccf113bfec8c566164a4a45e1917f362364f395bcad0b2a26518e4e6be0483ad5e6ce00c5455a89dffb5812fbc74006f1782d97a478e8c97d3fe704d344d408ec2b01561f6ff5726121a30aa7dfab78df0ba319f2913a5065193ae342cbb385ed55f281d9da716f6fb445ff512a8c5ca657e8d71d06e9f6be5e36465c7de1ef0a064132670c85a3814e9716bb5bb0810695826af0b28ab39bb29362c1353a3ca475961ac0c8d778d4af7b6bf0e747bd4a2b073e42247971f3c5a697922693b314e33f67d93e275038e31bf2452066c63c37bb34ab78a77ab6ed0b4f772b314300a1545ebf656afa1409d7d310b41c216f9dc42adec539e3cddb517e168d5922f99529fc952894b42e219d325512ef3c81704326e34207a0364e17143a01340a3ec117501519be23288bbb7ed14035a2a88aebca19df37ae8f87ccb68f7247510076b3bcb9ad61ee52e06f9e0bccecc565d58b08b3fc9e782d31b5daf210957550679c6881952e2e4af13d794259d2ac5fd48db2b8702e08f3b7b69958e89a4b3e30aaff7cef56f9b59cc9faf6b377e17ebcb6cff7a7b7285ba3e851b9814907fe94db5176ee6b22c3fb7cb89b0115b22ad8b770fbebc4d16bd9209827fbd6e8c2773ec292d5ec7452fef3ad40feea9997cc00d201db0fd212535051c5ca46f40a52953a35c5a5b40d09e4c02727356e034230e27087b2843c0e4574afe184fa7228746327da62ba108f47108d4e37eb19ae3b88464d1a433c3b48378c51bdd3abfdc6d82ee5963fb00c7cf62e65d8299887114f04e06deab54506d889ffd0ee4a20896fc1aa261f1e9bca1d7cf67982801203e298b7ff47b297ef381cd0117a7e1abd5ac2facede746c0f637dd1d162413abb366139bbad78b38cfc7ede3bab6df3b4099b8c2a762b17f657e4f674119069a0a5773c8955ee8970186d9d89906b3b0e92052133e55426bacc3bf59ff84677dde8cc00d4c27c5076920def7d0ee10b292d64907a9b26fc14a500781bc10408ba37b61d966bc56b5b8079145a27389a59f9a14fd180f64a8ba74ea2072ecb58c38ce1f9cdf3df18fe353a36ef87b9f95f6515914c98d1a6889bcd944eca46f92314656c484613158f1122d45b6a57fa4ea7d7730fb55919ef2c3540c0dcb76166f227796052cfe4bbdff3e44410df81182b292cf1894a4835e302d57fe5064239a3c237576e94ba1d42e676031a03b4a1ba250a33daab861594fa9538a0cc3bcc7b1e4766f4740fa6f563358971991630010fd5c7b3ee8f3cf5dd5110ada44d4bb80aa4d298efd378b6f25ff553a7b78d3364b52447c0517d8d5d5422c4b9404c8c95a2524dd570a42e0d293e26ded82ebd9ab994143e5614f41e7a0187351b0bba17ce72ed946ae5ae3543705a10e5b0f73e007ead173896161902aad15807a8654fcd9b647c6aff88f2d89d0c8acf11473858ceef7c48ad7509e5aa9bffd405b0625b59207d614a993682d5aca0f6616af12135faca4547970124c5b6e73a14f1d83b5b9d2b0ab6e3dca41fe832292b1be99011c770e5a6fa9bd54d4f0bf1ec502291761fc5478d42cf641c2fce1a2eea28e8d4bc0ec118d1ef0d98ef6a43d442ebd111305350b3278ac6949da2cd3c03a838035a9a69ccc154687681f1a2e6fa4e00f8ebd0c3a4eb11d7fc7562d658597f386ec0ca348107effc521f9c352e44c86cf68388ec0b89c68dd2219d44f883062173d57ac5e5b66fc814e72b984d91892d0f1d651dff58fc4f44d57aa3a6016229583ea40eb5ea044866f2ab42c25f159e0af1f526ca4f79f970b41039358079810d218cdf5e419de6ffa42488541b29767c2802ab323fd8ef9f946546fe83d61399efb956b167b2fdff65c8183e1a14384350c5dd3d5a8ae8f0bcd2cebe05084ffca34ae8a616b8c087e722c3630be33c3838e7040be163e32a2fba1b61192c0c25f36fa7bf82548e972bc8ab504f80e5831b2f5f0a245e1cf69b974b0463d24f501c12cdf6e18f439b649f9c011424955a8eb486e6448d5d1a48a8cdad59d650ca564ee2b90b260e4d71a7e55bc2c64c408bdd6618ccece25893caaeee5277ce38600fa9c996bd616ef03dc4abfaf571d7d844398fbaaf03a3bc3635b6a23878deeac38bfd0ff74b900e8b3e53d075ae2d988ce9c46f862a34c4b3fd7f610e46711f20cbf8808a4dca90b9ac1644c2f3a278a090b23221d0534f8bcb78e2f28fe8e03086afbeaf0190ed50b608eac8fff03b70e673361be4eb371442968c6fd42e1e00ea58032fcbd6ca07a0c89dcb671c105de78eb65a81cd2ed992b7e72d74d7154e4774e95dcc56e18f85ac58f8e78b2583d5e410852273f696e0ade8a00aae95e14451a9f3801d0d9601afaaa953e4ab13533e8db86e8ba929b2825890253d35cdfba7224d766ca92c083bf018d9f99fe9054ff08c3cd324a8a0f845e2cd1ad1cca5287e703bec16d55825c7cbe767eaa5d448961dc4086a9e2ed7f2bde2d975c95aef0e89dc93cea88c08615f473294963835ac29e4f69487b4c2a40b475dc4a834407e16075c3850541ec56fbe1d2387cefc414f493f5342ee670903b5901b2713d9f73aedbd756e79d0c4d9125baf253e859f64d8267360a06fea3f24d0bf1299fefd6308a5cc27de35375f87326f9c40ba7dd789c3d1aaabeb4f94620e196489660415b3c7e5e52570ccddc1c4eec1c27507c4e6498acf7ceb92d10874347bdf295b6251cbded71ad2540ace301bef79584bbbe0456031f770660e4aec3d5ce2c57df93e70a5fe1882436f4afb2c82dab3c6fe983ab00cbab0ae0afb266f4783e0b3e5e7821e5a36c9ee9933668025b2691f86aecd61df669e92e48fa0465b71463a220e9057d84923ca592872031c53147c29b27c0332459c323bb0a45e2206627a124a34a2fe5543e33e513414a89faa3c145018bbed5a899ab25f3ab2fee1374d381608007a601cb032ad80219c729b2a8f8b112acb45eaabc5ce00e02fddd4e5df8af5d2284900dc254c96a4c4ffbabbd5e2421b7ad06440195160fcaddbcb7048538708225b8d69666f81b44be838902b6008f145781a4cf9c5eac1ba007ab3bd211592b66427665801d4768a97492e0c48c1680c163fe133270eec0565acbcc5a81e9d11158d6bcf8085c7f0a121da3088b81bf04b709676abaa5841b53552bd4ab9d655a922bda7700be2d9ae2d7dace038a8860e678bd73b77f7d286f1f342395ffe756162ece9270b8325c717a83ca557360bea791fdeac4516bf74e5e86cacaaebcd4e2dd93cda4ab8356395ba782262fba6bb631d39c1c51ceaba8cc44b581606570b0126544cf70d9d9b2e7b05b8debee781a8a4d6fcacc64e21983840057409d2be444395d3f6ee34bdd842a9fb34c05bee8d681d6489eb3ad224884d6ce61cf1289797db61dca77e91e2d2f03ae61b4b5dbbac86fbf949812c0cbbe8c996c110c12ca5ef11eed39d49ebb1a7c0b4e33df670164efa0d71bd2366fb0bbfa22d0f3bc2074f2d42ec140100cae424c56a74ade38e005441828d1d4fa8e996675e6258d510d0f2ab13b4a1caa222fbadd14f0749cabdb8789bb951ccdd2057a76fdcb22341a530b4fd3a788097fe5540a171a7c927e9e7e0f0d733d3b342085bbe8ff39babf4ac5061965df601b31901d769e6490835f788f78f5d649603cc4654d4292d8587ffa6fe960571c1450356d75c6d801f8621a49df8ba0549a5abd9a30729a5d5e8487cf7e264ead538d2032c70485a0eab2bc823f7987e7f375a6ae125489e98198f6cc9b242471ff022b7053c38773350dea7d4bad48659fe7de909a8a3714581edb52d50919c6817889e0e3444dcf336a55b946568a1b1cabec69e4c36733619f7b0e34a082d6bfcef123d1ff95727beae23a80ee9cd08a0bae0a5a30b6216016969aa161687456c303c1d1d3d6e08b5098335e81d61938cb066d657795ff2bca54d7118f038b11410ee17dd20c37b3e5b36b57391564f513a96f7cc9b60c76d93c375c40cce96143e995c10e5ebd33b72eddc54ef45e76e54605219d8529506a63ba03b6d51df3d5f6a3f5f67a47256f6a022ebbe7140de6d87eebe5c8aba7e9faa3520adea69a0cc212300174154e4fea3f8db066bb91defb389e9cb02c4d1f74b776f7af484c50b468e4393a55b82a02cb129d8b1e94a8113ebddcdd26b591abd1b8b21d43761da0df09ce8815fdf8e28d73f798719b01579a682a7afcfca1ecc11251344d2f5d9ef630d397d88e009ded55d54a70db3c30e36aac47b9eeca62abfd82c9396f00effa955f159d74da2a9431beb61e707d8e8d27ef4f97e79236e6860531bb1ef47cc9a06f78ebdca2a2de36a9a8ccc1476ace4acca6a1eecd6069d634b7c238b8828ce6803909847657c7164cc143edb08fb788d22e12679a1471ea214499b26699545929715fa01bc4735c75e87fb0decbbc80929f1ecc4d565fa1ea422c0a966261edfaaf8797aadc3f736baf7f0c898cbc7da9195087a85ff406a6cebc3386031df3ca2110498385259eec2379f58bb7b08985bc8d8ae60dac8217ec82df8639ef07ed47f8fc538379585dbe43a7c93e1bc8607caedb7c6c2461c11a0b2d2d7481734f59fe5e7ed9854183689ecee38d907b5a2adde176deba405f18bb03429f952f862f475f6c354b591852bedf698c20ed59edd13d6ccdc6fb465bad85e591c8a8774fa168b44f23beeb9ef96fb3863883ba511a83e555f9298a37a1537c0e1dd73d09b7df98f0980600f77699f838131619ab467e8159f8fbf569cd7120c60f886d094b637370da450ca75c66ac8540ee277aca56740eb84c6bffcea8104ed9e6d7e511c3054df25b7222a8de4d67297e03ddcca7aa89148472c584a243524cc64a73d3f77cd0a90811ce97d3691b68907d01b9ffe0579df4747081a479e4f7ba76d291536b518543bc925860214881b00a5a5b0cc4fcbd6c7763a0917ef043245836fbee728b55ddca0158edd863f1b75a9225e12807caf9bcd958f63d9c8cea3eaa5e3db08d0a0fcb8d78adfcd28d330f45df1e0d464d22ce7ae102f14f9e80c04c368bc84b61ac5c194da5077b99d7c02c5517e190c9b301f0734b7fe0c58201b10fa23d6bcc642f865318534c04b57d4862602173efcc1a453f67e5148fac42a3b43846fe12788a5019a3b8f76a0d42ec60d779e0373f5ff0f86946cdd02135ca737e651ac1249bf917e822502115317d716a074e92c76cbc2e3401ca3857dad0cd988c03e2a74c67c4fe2fc8f28b312b70eb931af912f821b77f5945d192fdc82788213035b8c488d9f525560ab0dd0f13ad661b28d0ab3c5b16990959354fbd05b856e699d73212f8d6e992316ac4421746f877d9cff1fcde0f6f829787c16c6caa838b85f3511152a811c56362a41ac626b89c6d24ad6defc05ebba2fda51f83e7fd2a353f2e6773ac603c9e3b2c99a106cc1feba3f52ffb3011bfedaa8143a9c5f67b6023c3d375cf7bb098a472e91b3a13a1df59857ac71ef8ea71347bfd69853e422c02a1278adb722ef4a6ff0d8e7af49653bf5e7894afe0835a8c2cd500f0c95db58d417c476d7935cfe5353de5133443a3835d867f4b8332e709ac6279cca973dd5bdcff7f4fc4ae4f32fbd197bfcaa72dde0cd76fc54c73b2dc11179d8e71deba479da3b26086d8bf5e6f5d7cfd3c561665632a1c8aa9ccc48345c5eb4cb500b214563a2796199be0beadd4114fb4d40bc912390e6ab3772119fde00ceb688c40c8e00a90da9e1721b608be2472b39481f8a1c0742da1c27ad98fe2c1893509237a13cb419d859303d9a0664a70deaa8b52e6dcfe99aaf6de9bafd954dac45232e78ab81b2a29535e36b02f70f7ff2c8090bda5bf47e889e6ead471cde3db86a75a96fc10d6a37e760c55f05d75c3638fd72752084fccad8dfd21ac0de366c228a31dc8c73bba39889242ae413af052473b9dc03168c8705a2c73de2d88974e41f6806bd4b003318686494850ba1c022624c1d57876da93cefd5c5ccdae443fa2729fe7c6013a8b505b3f122465713b3bc20aab8581ec9a8545039957d1a337eb08cb4f471e2222bbe8d5fd95f2e54f53e44276a44fb692f42a3a5bc46fe12489812cad0cc724b0866ee6e3f40c1d3384f2f4f7bd9fe82ba53e42452bf7ecc60a1c7e4cf56c11b195d011840f053f88663302a55db7438d31b8b323047328316b0f26a25d33c910f9ac19e896597084978926e32ace444d2a16861bcc925554718efbfb6b87e058ab49a0f18b3fa548ff052fc6ec9a50d245310c880d05838aa4d4f72c11a207e3184d5e5d634b1178d666f87e13d85c8e7c003dbd8f2de71544a19ff738884514e88ecb2573fa572c0aaa5cc28d434f61556eaa906a5dbc5ef5015eee9f58d5345c47a49db211adee4ab01a2a22981a3d7ab313addf7171abdaee583cb1956474b8f5637e2587fca6c86991d4ebccb7168f82fc897d9b6fe607e4452e9e1bd05687e959095389279a6c74a7716e1b608ed96de9b945ffd8d236d6cb2136f59890dcc15e03c9c6f532adeea812c2f849b8a72bbb7e62a75e02776fc9dcec78c604b321f585d65d96959c480def8c682cefb9d3c69af281ad6e3f123f55279ac8fca611d02e8df9dc4983aef6737894b4362efe6fc7d6f730559c91efd959f6a024d08020ab229c1ba1acc07e1898fabab1cff9f2eca00615dd96998fd6a13701e57e67963b2dee37ff489600c051eeac0e430a03c6d2630de798aa7ed865dd83c4a4b7e5923c31817c3c68802d95ec49deda5680be207aea08593598fd9e86e3f30aef53b2b5144a7015d0ad5c33dc5b0010ff7d9877546423de70f067e40b4dc636c5482111f5b4a9d0f07772cb151e086a9acd7f8449065f24846f6897ae4731a8b69b4fd764cc653294ca1abc8c869aed38c4d92153175c45c934a520fac018115c7058e260ec487e0186d2a32cc5aad3358bd16413f1c8eaa6c46bb8db6f9c5a78b0f069d1743193d9856f0643b198cbf5deacc4a2879d477d66974e923f1a2518526e7a0ecf646bef081d8b878dea50e0bd856b2121ab8f4598c966ac8e93b0dc6b13234eda9217eb05172c68b17747e831aef65912f8f24cd7f217b1c32196be055283452af890a83e1b156b6a0e6db28e5f1cfb3914a47b9c9c3aa71bd2a4c06f01ea591dbecd6bca154b56d42ec77fa5709bad5ac34b2157cfd7ec64755d84d733c6e14fcc47360e320402a46e0db1b59c504dce25d6f92e0243ea9dabfe8257d10d75b8dd219b2774d100da68bcdc468a0ebe6e042022703c8e3583256482c1a631e63e9a274f21abf03a0018f50a178c31abe13afbc4dbc38c3dd5d65032a529219c98499d2cdfd693e81589dea14f4685fb7e7b1092f783f4f6a6b4101332e0f8543a28971cbb97b9c80b49c9c522ee5fd1348ff276d88c74e748b751bd2ed8eae029d1c447884b523df1156398d7bfeb62de07f540da72ced4e74f396dcb87ef82754a293407a709dbb6a4fd508397fbd0e0ae4cdf459c407b33bb692ce10e55e3218afb727a6f140f49816402de8e8ea60e6cf2cb9fa4e684e5543b3384b1f99aed78bc976ca3001216fe49fc8a877003c9b4bbeec0d709c1bcb924f5ae357a21c38240291abb6ab164a775ba4c942d42b3a6330ac46f5371dee201e85cadcc14df7d165600ae3c91d0a823471e088a99c03c4d67ebdea133de763fb187cd283e4568c881a613009876cc9f788c29a123252903b456e57f989ed0522c77004aa8f03b05c6411206b41f30722febc12f37f1471f19c0facf1947ecab6cfee0ddec67b5d1aef915dbc09ae838ebebdbcc23c7ff47ac77c38b918480e4f6dc21a6047c53cb0bdb1c4bc7c913528656f4230defd835c450a16e763dc46dae6ca5e71e608a16799bed6820aa646a0c2e5cc12e62180de47765cbb083537686b41a4b5d81d32072715afa6715483925b56842fd3247061036fc6c86bca0d9516dc208d710a4081421f035a0c210c1d95b90273b9e344f64944fc7db3b6930f1191d63f406d5dd7f4f6edc148a48a7c7888baf5ea4b195fbe4978befc4ab86362149e5761c1cbec411d29053787ef4415b56e80e590068441a4c6caae7e92cdaccd4a52943727fdbdb6976958dd769c0e9c0114805e1c467e9fbbb8c5705334ffae9e4dff4ea0cf740279f4744ba7fbbe9bf305d938c328b530134dd3c2e9a2f0e34717ef19059fc67971b598986f6c517d7b1929c98fcf3e505136b1737c067b56686ce1f7a5741d4d02d27b8fa7f2ce1c81d72f7b4d6af5f607fb53259ca9293ae9763a42d501ca73fe15ade6cd32c1e9a558ed31e4785e97d2a0b03df07549be122027b9d690ec13c4455bf3826ff0e9673fcbaac3ccef0364878c27ffc89f0ce290c99de714e09628fb4b14ad39f3bee0716edc43295278d73db71d38a8c489b4d11041dd147cb2f6a18ea4089ea0ba34bad747371f5e68fd49f29e9fb725973c4cb65b3268e0c7e9b3faad82c7c032e1ad0a1a6b8fe84e9ddb927fd9248f238bd093bb5b022deb65cb6a71f69477be83c8337a94e51fc1875ff5e74475de9d3edacd809d55ab7b51b85c0a4ffd97f0d62a5fb71510b0d2706ba9960cfa8bc4d3b8c59792dfa5b77d7d04316567bd9171f78d9d13b6e48f67cf55d374ac06a384da470413bd86080a752b0d84a3d81b68dc422d2b19ef4bf691a4b9b05c5fa961d294983394d66c0341b40098b3328e73b0509b92e7037207695c32f3a0b7ec043686fe06468a54c6ed99f3382432864165e732417b9fc64ea58b3dd5ea17fb2f1853cbcbea7c2badb44c4ed0123321bfb086cc1a2dcefdf2f15182b6e4aa34a6e9cf467b56ae13e9b21ba48ce082711665d7a2421e9e6d9c104d97ee004eda8db26b8a0b8dc60eeefb6e6fa497b3f18a263e350c7e61d4e432c207a0905501c4780aaff3c4b5e58ba290c144586cce5341ade130b29449d1edef0012d6488c13f5c869f2cf2c5e54da77f56ef749dd1d80ab7ff9233e1cef6e98d595f9f30120ace4adddc0590a8a9bda5f1a7fec7c58cafba0551a7e91d4adf04766d788b77c1d2dbeb5cdafc6dfca764b84856fbf13fa0cddbc788f7b3e81ac416c86e17e11cbf0e93c697f03820dc9fdf98c1b98d67e87bf4dd76e22f9f41c1caccc86e14b62dbf2cad24108e2d9e6e68d310a299ecce264cf838a18884390d73158f9ffd59102617132f954dce500b45f42a46fb155536cd2064a59b115d305c39f467ffafd7cca9af345963d45494a8ca82d78f316cec401a70a96e7745fe5d09a35f1881f3d780717fb443e26a7ec26e0c95510df3b9deb948a31362979e4cbe43b47a999ff36345c5b5e76a0cf77f7c7423d2f7b7de4345390d968400696af974ef59dca858b99131bb15ed7cb97aaeaece299bcc59d5d4940b94efd316452d5a49cc520d02631cd662dcf144ee4ae92a1d79f04ceb55a4953ce71a3e7ace16332fb99b2dedeb11ba7fea98560d0c2e520d2b7d78c01f228df7a8417168b88c0d70ce93dc5089d0691392838d68dd77084aebe4ccd0c11a7e647cff3cfc7a0a60e4a1fdc47d8f5760f57086023ca6fdf9e171316863ed13e92c855b587f8d4466d5217df80288eab518ecc7270ba121c3ce21c17d0fa510669fbb2980488543b6596ff6cb44ae322136c54d5bd108ea90ad532571e348e3e01a8ce316297d3a500d5c2b23fdc0bb4c338050650ea20e0eec49a0e25b74c990d3e5ae9a53aac17c00f43f0a135ca0f1f455d090dfa75729a40f0baf735a7c1a460c7f0b3d5cdca4f3fb755315f3985a2391708191b01162ac56859668d0d198c536cefd7c10ae17ef13190a46b117843baa075642c95f0799c936e679c18e3e8177b370145d96fa1370d1b9eee3e02c8fbbb3903f889f3cd1e6c2168c3bfd8adb43f17dfb6e6753a397b6bcd3ffd672d825bd45d115344f4ed48314675f61b441c599be2aab8f5a1336abadc16138e1da4649a0f8fe3c7dab1e5f61b272c881d9ff9887fdceae6a06d8bb88d093f905f2263d31fc4c9f558f096a18c59abd3c567fbd9c2b1791d600bfeb1e6535fc6770a72e3c13d64e62ba7a997efa91b3c3f1f50926a634af3323682f1d782ae9bc430fbce37c05662f2d1af8fc5bc06adb1a718ecdb616cc775ab74d9607099eccd795473ca7b99e4e70b5a7cd16cad4e29af92327d4d50d074cb2cbd36c7b6f2d9621eeeaa9c29faaeb2dc8fda1cccb15442296d91bd652d7079666c46d63a04a15de79a42a1324e924541ba35868f71f4634180a0bf8c26750aeba06c0d25b9af21cc3df4a934121e9cee2de6c104be378804fe892886e7532fdfdc364bb52ff5838af368268875f2e0a9d993c895be6ab44ba07554521d138eeee936413b03e7fea6136d46ae9c990b256e66ea5e09754728a49f8d0b20b7495d41943c373fc738d74c2288bbaaab4ceb83f7ddbb66e9083a28fb4f534b084e68a313c7e04f26f140bf807e8a2980885565a69fdcb4d4ae590d3e7a97cdc33cf9ffa9a122be4856c98bbb8d08788f0e22e2d055a94d738e7d4809a97561d9f23e8a5585f8783e16a9b99e47ddd43977e004eeff32149a7eef4e07119e95b8460719ffc5c3dc91a526391a575211e68f4045a72d646dfcd046506291a63e3d40029698330176faaa3c8a50ff2ed81f8214d5dfc161814e4bdf3cc3b2a20bb8cf12c673e5a682128ce4914430ad8603351b4819016d9a71172020af763b3767c6dcbe6b31aa9ac3f799e80ad308672d7f7c41621e9d10dd27748b98dee72a43c8f29606c2338f7e18babfaa92eeb98ff7f224c654659499b90a6742bbc225b4ce60c434c05edbab88caa06bcbb7378dd75a93eeaa22af2f4961ccb9b6f370468f4a70709718127e2e423a3b5b4ffaea9345686b92f6ce30be6f56f388dbf79a3e0cc00bbacaebd90cdf947cae0f4999edc2d5e3db996c4f2ae747160ef3bfa5ce778b7959380676bfe6b65d64a59fcaa3cc1758692b92b0edeac224b5bca2a8483e120ef3e5894e9713004d2859526d7c9f9789b910b694c5c0a8ee0609db0434efb6da69cdcf8b982200899adfa747314f3f955dff9f0ff9d3fef5f940cdde2a74d848b9620dbcaf1915187e4be0ba94206b4fa0204e6e186113e0aa1787cbef27b776ca94a90fc6f70ab782dd4f476da16e23b8a0cfe9aab6e1a0f9b632dddf55f0c4bd8837e947222ee5e382288d23c8ffb979e29a1f41e1f9e25b8bbfec4688170515e9935d439f088675a50783f5230f093cd9a701a3c300fdfede1f55ae92f5db88f761e4b30ca39463161311eba2468162518bd4b3dee68afb4198d9e7ecf14b542d0b7b439d9ee770a68888d9d6d73347aeacdab44b226b13cd285719e498fd96295ef419f52413591f5d5b863c19ae344cfd241e93c802e5eff7de8cf9b0a02a4ecbbcc8061e487026054231c57df115aff4147a92548c15d1b631b434c69f1c2bfb443616b6d5f400632c8c925d6097bb5281fc2a23a53432fa5fea8646d530f3cfddc8e8b6e7ca2514023625d6fee73ec4bc291c5ce2841450879bc10c252905461a9139fb0acf395dbc3941530fb3864035c984d6d5399eb1bb41ad43f736b70dd0f1c7913bf95d0ff07e296f0a9257c14bda9379085d3a6cd64a1979a84c7012cd55036eb52838a10fc061510902f17f70ebdb158fbb391cc41d044b3820e7604e810c8fe5e6a1542fa0f92ee8d5846db8b58d662987106514b3368deffaf362482439209f907ea63ac87adb70522fa58e7d552f8f28b36d6fe3d46edd6b3cf3a6e40caf4d2ac7a5c5919723555100e60aee535d2438fd00814ecadc7690b079928ea2886c7b437194f89f4a5d43c996cc3a8663b94132237bad4ba1c75f7c04d295a068e8322f474274bacc2c53227bd17b1fa7bb2be217a373b9fe7018e582c375c37c7129f8d3464dee143b34b149f865f5bc65bb545d2ea99e50916d80da1da1ff2387fa26a6b84246d25654c8bb89371b782005b74235af079474d58e18d080c1474e98afb82ca3bf1d9cd6dca663562b8470936a056a267419d80889a42ce05142292015e339b7d70920ac740d7711eaa0569c0c0c711edecf22ae61bdf48a7fbdfcc373ea6356938a902b23981ba157746354865d93d95c6efd5210a5e170e731a36e492783b3f2da744a1f8f1040383a63ed39e7d478c79da2841544f211a68ff6d7094fd2d627a89931ff0339b6fef2b0ff50de889262805cae85bffc7c0d8cc0137c01d00c2e395018d076a2a36421bcbb93a3addcbc5228b1d206a75b124231c4fbf26d54a6227d3c8a07e362065fa1b582be6251f756fb1dec7ccd6a21cd76e097540f63e9684019b3976c58131b6a6cfa742d3c0cfc153f47070fd9837df85f2bc63924ab5c82f432396743dea80373afd0458a70035e20f083d43400b61ae9edadf394598ba8db2864cca30a76eceb0de1e677a776ded895a37b608dc41e9579482179933371ab43224cb9c54b44fac19925f7a4d5fa6dfb99cf11af358bf254ce204135f138c6a9f224b9e3877e980d53e097d6a4188c69a2dd18fc2f838abf8b0862a9f089a9dbd8aa81bf8edcb5250ef9330ae3659c774f095d7639ffce384073a7ff3c4bb2e64193fb8fd6b906471dbc5935734641c4baca06221bdc7de63e9d1f9940acf9c816efd182d318f73147de4132831d3b04789c574c50af307531f13b2535f0e20031bf1de4f9f583ff922f7555455b7f97c5e6018526e3d11d748dc60bdef3f611ada2e07d97841c8d89b647fb973815acdfa69950a59c67114ac3be9cf1223433126b3664c3320cc9587acf17bdbce2328f257e9d8cbd9395733d77d7841c6579ad382936e93f11638bccb7df0df57fe6af04d8bb456d7fc7d2d78b8f85efd6b8fc4cd0b27d8bd31d193678c3772d41a9210159c14d7229b10b7c366982da7e719d81d905399990873286d23ff76e34bbed4cc7d7d733a157a03fa16f78508132ce32d1fe6aa99ab8fdf442fcd9f9e4c4ad1364c7102292dc254a71f5134fb49008bb9a47e0f9a3f52530c05aad2cd7df4cc0086561bf9390de2eff1b86f679d321d11368724689559975f37e6b3a7df847e6ff9c88669472ae283476e0671867cc0bc2948445fa87ae663b930f8c78bfb237355d6b4d34e393b664125c895da3fa94e539fefed9b3c661ad898e390587e18d789f2dff8b721837f4160026a0fbddc6bcef3be923fe3f8236bfdddf775cebe3e0a2bb3a98b4334d2358859a7e63fdd21c6448915991bff2fd28e14964f84043d96b987b06eb0850164d6996fc8b6e3e46dde75f750b6a8f01aaf4232612b8ce6172894e2ec430b2c53e685ff5baa24bb484c68634f7b74bf65f5cd401dd855f02ca9e5f4348abd4504537e7723a9dc658dfe8489dda0e4fe2578b2f945e75a1030d22eaaf0e909501fb7a132805635ce16d05cfea14034f0f9d6dbf792436a83fd749b77a834fc996dd0bb3ad66883688a4ebee0e21f1bcca773a6c39a979d85bef0c7111ee885f53aa1c2b247bd215bf17f3cc4016f31432f389011f333c1407462572c5602c1a63336aa172707f9b0a755a1659b7b105bae28575e7c15a2663892d604b13761c5a357dedbbf92609f4078de3e9bc1cd6cd453770b81df7e90872ee9690c9742382d7144235c435e807948663ed0a906207c7bb538660ab8b958e32460e2580be7b3f56ac7bcbfec4dbef03cc07750aedefa402d0cda1408d9585d9da3e2421ea327c8913fa9be8de7b994411c52aa793446bc57e85268cd8cef4deab797319037229f77313f550a17cbb1daab0cc09a19ff661c5fad290bc2dbf209318146f369cab4ff7188313e2549f769209b3de20937d64f4ef0bc7896e8cb4043b2ac1441bc50c1c2632da0c67bca1bfbd25a72e5ee95a1b07ccbb66b4dd856d582417fc6db733ae4beb3ee075450d48acc30e4bc93495e8e8000de9582558fce507d67c1577e962fb0d6b61547f588716852d714ed4b10b30ea154dde13359ecf5901844bd3923f6cecc9a2f7bc8617a0775ad50deb4ada1572361142c43bbf79e1929fdb6a87dd453632a2047bdedf2c95f82c493b7633914802bb7ed08130ebc941f0a649f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>two pointers思想与归并排序</title>
    <url>/posts/2aed1d1d.html</url>
    <content><![CDATA[<p>参考自：<a href="https://www.cnblogs.com/coderJiebao/p/Algorithmofnotes08.html">https://www.cnblogs.com/coderJiebao/p/Algorithmofnotes08.html</a></p>
<h2 id="什么是-two-pointers"><a href="#什么是-two-pointers" class="headerlink" title="什么是 two pointers"></a>什么是 two pointers</h2><p>以一个例子引入：给定一个递增的正整数序列和一个正整数 M，求序列中的两个不同位置的数 a 和 b，使得它们的和恰好为 M，输出所有满足条件的方案。</p>
<p>　　本题的一个最直观的想法是，使用二重循环枚举序列中的整数 a 和 b，判断它们的和是否为 M。时间复杂度为 O(n^2)。当n的规模足够大时，这显然是不可取的。</p>
<span id="more"></span>

<p>two pointers 将利用有序序列的枚举特性来有效降低复杂度。它针对本题的算法如下：</p>
<p>令下标 i 的初值为0，下标 j 的初值为 n-1，即令 i、j 分别指向序列的第一个元素和最后一个元素，接下来根据 a[i]+a[j] 与 M 的大小来进行下面三种选择，使 i 不断向右移动、使 j 不断向左移动，直到 i≥j 成立</p>
<ul>
<li><p>若 a[i]+a[j]==M ，说明找到了其中一种方案，令 i=i+1、j=j-1。</p>
</li>
<li><p>若 a[i]+a[j]&gt;M，令 j=j-1。</p>
</li>
<li><p>若 a[i]+a[j]&lt;M，令 i=i+1。</p>
</li>
</ul>
<p>　　反复执行上面三个判断，直到 i≥j 成立，在递增序列的前提下，循环只需要进行到i&gt;=j时停止，所以理想状态下只需要遍历半个序列，**时间复杂度只需要O(n)**。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]+a[j] == M) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, i, j);</span><br><span class="line">        i++; j--;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a[i]+a[j] &lt; M) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="序列合并问题"><a href="#序列合并问题" class="headerlink" title="序列合并问题"></a>序列合并问题</h2><p>再来看<strong>序列合并问题</strong>。假设有两个递增序列 A 与 B，要求将它们合并为一个递增序列 C。</p>
<p>　　同样的，可以设置两个下标 i 和 j ，初值均为0，表示分别指向序列 A 的第一个元素和序列 B 的第一个元素，然后根据 A[i] 与 B[j] 的大小来决定哪一个放入序列 C。</p>
<ul>
<li>若 A[i]≤B[j]，把 A[i] 加入序列 C 中，并让 i 加1</li>
<li>若 A[i]&gt;B[j]，把 B[j] 加入序列 C 中，并让 j 加1</li>
</ul>
<p>上面的分支操作直到 i、j 中的一个到达序列末端为止，然后将另一个序列的所有元素依次加入序列 C 中，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> B[], <span class="keyword">int</span> C[], <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>, index=<span class="number">0</span>;    <span class="comment">// i指向A，j指向B，index指向C</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;n &amp;&amp; j&lt;m) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &lt;= B[j]) &#123;            <span class="comment">// 若 A[i]≤B[j]</span></span><br><span class="line">            C[index++] = A[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                    <span class="comment">// 若 A[i]&gt;B[j]</span></span><br><span class="line">            C[index++] = B[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)    C[index++] = A[i++];    <span class="comment">// 若 A 有剩余</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;m)    C[index++] = B[j++];    <span class="comment">// 若 B 有剩余</span></span><br><span class="line">    <span class="keyword">return</span> index;        <span class="comment">// 返回 C 长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>广义上的 two pointers 是利用问题本身与序列的特性，使用两个下标 i、j 对序列进行扫描（可以同向扫描，也可以反向扫描），以较低的复杂度（一般为 O(n) ）解决问题。 </p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是一种基于“归并”思想的排序方法，本节主要介绍其中最基本的 2-路归并排序。2-路归并排序的原理是，将序列两两分组，将序列归并为$\lceil \frac n 2 \rceil$个组，组内单独排序；然后将这些组再两两归并，生成$\lceil \frac n 4 \rceil$个组，组内再单独排序；以此类推，直到只剩下一个组为止。时间复杂度为 O(nlogn)。</p>
<p>说明：对于偶数个的数组正常对半分就行，对于奇数个的数组，留下最后1个多余的单独1组，其余两两1组。</p>
<h3 id="1-递归实现"><a href="#1-递归实现" class="headerlink" title="1. 递归实现"></a>1. 递归实现</h3><p>只需反复将当前区间 [left,right] 分为两半，对两个子区间 [left,mid] 与 [mid+1, right] 分别递归进行归并排序，然后将两个已经有序的子区间合并为有序序列即可。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 将数组A的 [L1,R1] 与 [L2,R2] 合并为有序区间（此处 L2=R1+1 ）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> L1, <span class="keyword">int</span> R1, <span class="keyword">int</span> L2, <span class="keyword">int</span> R2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=L1, j=L2;</span><br><span class="line">    <span class="keyword">int</span> temp[maxn], index=<span class="number">0</span>;    <span class="comment">// temp 临时储存合并序列</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=R1 &amp;&amp; j&lt;=R2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &lt;= A[j]) &#123;            <span class="comment">// 若 A[i] ≤A[j]</span></span><br><span class="line">            temp[index++] = A[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                    <span class="comment">// 若 A[i] &gt; A[j]</span></span><br><span class="line">            temp[index++] = A[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= R1) temp[index++] = A[i++];</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= R2) temp[index++] = A[j++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;index; ++i) &#123;</span><br><span class="line">            A[L1+i] = temp[i];    <span class="comment">// 将合并后的序列赋值回 A</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 归并排序递归实现</span></span><br><span class="line"><span class="comment">// 只需反复将当前区间 [left,right] 分为两半，对两个子区间 [left,mid] 与 [mid+1, right]</span></span><br><span class="line"><span class="comment">// 分别递归进行归并排序，然后将两个已经有序的子区间合并为有序序列即可。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;    <span class="comment">// 当 left==right 时，只有一个元素，认定为有序</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(A, left, mid);            <span class="comment">// 分为左区间和右区间</span></span><br><span class="line">        mergeSort(A, mid+<span class="number">1</span>, right);</span><br><span class="line">        merge(A, left, mid, mid+<span class="number">1</span>, right);    <span class="comment">// 将左区间和右区间合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-非递归实现"><a href="#2-非递归实现" class="headerlink" title="2.非递归实现"></a>2.非递归实现</h3><p>非递归实现主要考虑到这样一点：每次分组时组内元素个数上限都是2的幂次。于是就可以想到这样的思路：令步长 step 的初值为2，然后将数组中每 step 个元素作为一组，将其内部进行排序；再令 step 乘以2，重复上面的操作，直到 step/2 超过元素个数 n 。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组A的 [L1,R1] 与 [L2,R2] 合并为有序区间（此处 L2=R1+1 ）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> L1, <span class="keyword">int</span> R1, <span class="keyword">int</span> L2, <span class="keyword">int</span> R2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=L1, j=L2;</span><br><span class="line">    <span class="keyword">int</span> temp[maxn], index=<span class="number">0</span>;    <span class="comment">// temp 临时储存合并序列</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=R1 &amp;&amp; j&lt;=R2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &lt;= A[j]) &#123;            <span class="comment">// 若 A[i] ≤A[j]</span></span><br><span class="line">            temp[index++] = A[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                    <span class="comment">// 若 A[i] &gt; A[j]</span></span><br><span class="line">            temp[index++] = A[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= R1) temp[index++] = A[i++];</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= R2) temp[index++] = A[j++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;index; ++i) &#123;</span><br><span class="line">            A[L1+i] = temp[i];    <span class="comment">// 将合并后的序列赋值回 A</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序非递归实现</span></span><br><span class="line"><span class="comment">// 令步长 step 的初值为2，然后将数组中每 step 个元素作为一组，</span></span><br><span class="line"><span class="comment">// 将其内部进行排序；再令 step 乘以2，重复上面的操作，直到 step/2 超过元素个数 n 。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> A[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// step 为组内元素个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> step=<span class="number">0</span>; step/<span class="number">2</span> &lt;= n; step *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += step) &#123;    <span class="comment">// 对每一组，数组下标从1开始</span></span><br><span class="line">            <span class="keyword">int</span> mid = i + step/<span class="number">2</span> <span class="number">-1</span>;    <span class="comment">// 左区间元素个数为 step/2</span></span><br><span class="line">            <span class="keyword">if</span>(mid+<span class="number">1</span> &lt;= n) &#123;    <span class="comment">// 右区间存在元素</span></span><br><span class="line">                <span class="comment">// 左区间为 [left,mid]，右区间为 [mid+1, min(i+step-1,n)</span></span><br><span class="line">                merge(A, i, mid, mid+<span class="number">1</span>, min(i+step<span class="number">-1</span>, n));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            // 28-32行也可以用 sort 代替 merge 函数，只要时间允许</span></span><br><span class="line"><span class="comment">            sort(A+i, A+min(i+step, n+1));</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用 sort 代替，此处输出归并排序的某一趟结束时的序列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果题目只要求给出归并排序每一趟结束时的序列，可以用sort函数代替 merge 函数，只要时间允许。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>tow pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>使用SQL的两个工具</title>
    <url>/posts/61cc3832.html</url>
    <content><![CDATA[<h2 id="1-Navicat15下载安装教程"><a href="#1-Navicat15下载安装教程" class="headerlink" title="1.Navicat15下载安装教程"></a>1.Navicat15下载安装教程</h2><p>这个实在太小白了，跟着教程一步一步来就行了。</p>
<span id="more"></span>

<p>安装教程：<a href="https://www.cnblogs.com/xuexianqi/p/12797170.html">https://www.cnblogs.com/xuexianqi/p/12797170.html</a></p>
<p>官方下载地址：<a href="http://www.navicat.com.cn/download/direct-download?product=navicat_premium_cs_x64.exe&amp;location=1">http://www.navicat.com.cn/download/direct-download?product=navicat_premium_cs_x64.exe&amp;location=1</a></p>
<h2 id="2-SQLyog13安装与使用教程"><a href="#2-SQLyog13安装与使用教程" class="headerlink" title="2.SQLyog13安装与使用教程"></a>2.SQLyog13安装与使用教程</h2><p>SQLyog13如下：（需要安装的Ultimate版本，应该是已经免激活的）</p>
<p>链接：<a href="https://pan.baidu.com/s/1HjkFYDpojuqANSXttGdL5Q">https://pan.baidu.com/s/1HjkFYDpojuqANSXttGdL5Q</a></p>
<p>提取码：myn9</p>
<p>安装完成后打开SQLyog界面，然后开始连接MySQL。</p>
<p>参考自：<a href="https://www.jianshu.com/p/ced6e0537444">https://www.jianshu.com/p/ced6e0537444</a></p>
<p>首先打开cmd输入命令：<code>mysql -u root -p</code>,</p>
<p>然后输入密码就进入了MySQL，exit退出。</p>
<p><img src="/posts/61cc3832/image-20210427230432635.png" alt="image-20210427230432635"></p>
<p>下一步，输入：<code>mysql -u用户名(root) -p密码</code>，</p>
<p>出现下图表示正确连接。</p>
<p><img src="/posts/61cc3832/image-20210427230514742.png" alt="image-20210427230514742"></p>
<p>最后将SQLyog连接MySQL。</p>
<p>文件–&gt;新建一个连接，名字随意。</p>
<p>一般会帮你把大部分地方都填好了，你只要输入MySQL的密码就行了。</p>
<p><img src="/posts/61cc3832/image-20210427230858468.png" alt="image-20210427230858468"></p>
<p>然后就可以看到服务器上的数据库，并进行图形化操作了。</p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/posts/e8eb0481.html</url>
    <content><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>首先，我们抛出一个经典的问题：如何在一个严格递增序列A中找出给定的数x。</p>
<span id="more"></span>

<p>最直接的办法就是对序列进行现行扫描所有元素，如果找到x则成功，如果没找到就失败。</p>
<p>这种顺序查找的时间复杂度为O(n)，当查询数据较小时，是个很好的选择，但数据量太大就不行了。</p>
<hr>
<p>由此，我们可以通过二分查找来缩短时间。</p>
<h3 id="一般的二分做法（严格递增递减序列）"><a href="#一般的二分做法（严格递增递减序列）" class="headerlink" title="一般的二分做法（严格递增递减序列）"></a>一般的二分做法（严格递增递减序列）</h3><p>明确一点，二分查找是基于<strong>有序序列</strong>的查找算法，这里仅以严格递增序列为例子，对于其他有序序列做法类似。</p>
<p>二分查找的高效在于每一步二分都能够去除当前区间一半的元素，所以时间复杂度为$O(log n)$。</p>
<p>我们先设[left,right]为序列A的整个下标区间，然后不断二分查找。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// A为严格递增序列，left为二分下界，right为二分上界，x为查找的数</span></span><br><span class="line"><span class="comment">// 二分区间为[left,right]，传入[0,n-1]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123; <span class="comment">// 注意&lt;=，取=时还要再判断是否找到x</span></span><br><span class="line">        mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(A[mid] == x) <span class="keyword">return</span> mid;<span class="comment">// 找到x，返回下标</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A[mid] &gt; x) right = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> left = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">// 查找失败，返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> A[n]  = &#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">19</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; binarySearch(A,<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">13</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; binarySearch(A,<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">8</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的循环条件是<code>left &lt;= right</code>，当<code>left&gt;right</code>时可以作为元素x不存在的判定条件。</p>
<p>注意：<code>mid= (left+right)/2</code>中的left+right有可能超出int范围而溢出，所以一般用<code>imd=left + (right-left) &gt;&gt; 1</code>，是等价的。（位运算会稍快一点）</p>
<blockquote>
<p>以下所涉及的序列未说明是严格递增递减序列。</p>
</blockquote>
<p>对于递增（递减）序列，要在其中找到x（如果有多个）的位置范围。如果我们能够求出序列中第一个大于等于x的元素的位置L，以及序列中第一个大于x的元素的位置R，这样元素x在序列中的存在区间就是<code>[L,R)</code>。</p>
<h3 id="如何求序列中第一个大于等于x的元素的位置（下界）"><a href="#如何求序列中第一个大于等于x的元素的位置（下界）" class="headerlink" title="如何求序列中第一个大于等于x的元素的位置（下界）"></a>如何求序列中第一个大于等于x的元素的位置（下界）</h3><p>如果序列中存在元素x，那么序列中第一个大于等于x的元素的位置也就是第一个x的位置，下界；</p>
<p>如果序列中不存在元素x，那么返回值是序列中下标，或者是n。</p>
<p>这里仅以递增序列为例子。</p>
<p>注意：**这里的二分区间是[0,n]**，不再是上面的[0,n-1]，因为x可能比序列中所有元素都大。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// A为递增序列，left为二分下界，right为二分上界，x为查找的数</span></span><br><span class="line"><span class="comment">// 二分区间为[left,right]，传入[0,n]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)&#123; <span class="comment">// 注意&lt;，取=时意味着找到唯一的位置</span></span><br><span class="line">        mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(A[mid] &gt;= x) right =  mid;</span><br><span class="line">        <span class="keyword">else</span> left = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;<span class="comment">// 返回夹出来的位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> A[n]  = &#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">19</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; lower_bound(A,<span class="number">0</span>,n,<span class="number">7</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; lower_bound(A,<span class="number">0</span>,n,<span class="number">20</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p><strong>当<code>A[mid]&gt;=x</code>时，说明第一个大于等于x的元素的位置一定在mid处或mid的左侧，所以往<code>[left,mid]</code>查找。</strong></p>
<p><strong>当<code>A[mid]&lt;x</code>时，说明第一个大于等于x的元素的位置一定在mid右侧，所以往<code>[mid+1,right]</code>查找。</strong></p>
<p><img src="/posts/e8eb0481/image-20210331213556498.png" alt="image-20210331213556498"></p>
<p>​                                                                            配图请细品:)</p>
<p>由于第一个大于等于x的元素的位置肯定存在，所以当<code>left==right</code>时，所夹出来的位置就是所求下标，这里返回right也是一样的。</p>
<h3 id="如何求序列中第一个大于x的元素的位置（上界往上）"><a href="#如何求序列中第一个大于x的元素的位置（上界往上）" class="headerlink" title="如何求序列中第一个大于x的元素的位置（上界往上）"></a>如何求序列中第一个大于x的元素的位置（上界往上）</h3><p>做法类似上一个问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// A为递增序列，left为二分下界，right为二分上界，x为查找的数</span></span><br><span class="line"><span class="comment">// 二分区间为[left,right]，传入[0,n]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)&#123; <span class="comment">// 注意&lt;，取=时意味着找到唯一的位置</span></span><br><span class="line">        mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(A[mid] &gt; x) right =  mid;</span><br><span class="line">        <span class="keyword">else</span> left = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;<span class="comment">// 返回夹出来的位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> A[n]  = &#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">19</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; lower_bound(A,<span class="number">0</span>,n,<span class="number">7</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; lower_bound(A,<span class="number">0</span>,n,<span class="number">20</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>眼力好的同学肯定发现了，这里只是把上一问中的<code>A[mid]&gt;=x</code>换成了<code>A[mid]&gt;x</code>，其他完全一样。</p>
<p>说明：</p>
<p><strong>当<code>A[mid]&gt;x</code>时，说明第一个大于x的元素的位置一定在mid处或mid的左侧，所以往<code>[left,right]</code>查找。</strong></p>
<p><strong>当<code>A[mid]&lt;=x</code>时，说明第一个大于x的元素的位置一定在mid的右侧，所以往<code>[mid+1,right]</code>查找。</strong></p>
<p><img src="/posts/e8eb0481/image-20210331212741322.png" alt="image-20210331212741322"></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>在STL中，C++其实已经帮我们写好了二分的lower_bound和upper_bound函数。</p>
<p>详见：<a href="https://grant1499.github.io/2021/02/24/C-%E7%AB%9E%E8%B5%9B%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88%E4%B9%9D%EF%BC%89/">https://grant1499.github.io/2021/02/24/C-%E7%AB%9E%E8%B5%9B%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88%E4%B9%9D%EF%BC%89/</a></p>
<p>如何深入理解二分法以及处理好边界问题：<a href="https://mp.weixin.qq.com/s/3fjDhS3lb5CBrzx6p0XIxw">https://mp.weixin.qq.com/s/3fjDhS3lb5CBrzx6p0XIxw</a></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>关于VScode终端乱码问题的解决办法</title>
    <url>/posts/cfb19e20.html</url>
    <content><![CDATA[<p>在Windows下使用VSCode编译运行，都出现中文乱码的问题，今天我就遇见了这种情况，上网搜了半天也没有找到正确的解决方法，现将我把我的方法晒一下。</p>
<span id="more"></span>

<p>中文的windows下的cmd默认使用GBK的编码, 每次需要的时候只要在VSCode终端输入命令:<code>chcp 65001</code>, 切换代码页到使用UTF-8就可以解决中文代码的问题，只不过这种方法太麻烦了，每次进入终端都要输入命令，那有没有永久性解决的呢？当然有了。</p>
<p>永久性地修改为VSCode的控制台代码页为65001:</p>
<p>在VSCode中通过打开“文件”–“首选项”–“设置”, 然后在setting.json中设置, 把下面三行复制到里面:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;editor.fontSize&quot;</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="string">&quot;terminal.integrated.shellArgs.windows&quot;</span>: [<span class="string">&quot;/K chcp 65001 &gt;nul&quot;</span>],</span><br><span class="line">  <span class="string">&quot;terminal.integrated.fontFamily&quot;</span>: <span class="string">&quot;Lucida Console&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>/K chcp 65001 &gt;nul的含义是在运行cmd的时候将编码设置为65001;</p>
<p>&gt;nul是避免在控制台输出修改编码的信息，否则会输出active code page: 65001;</p>
<p>同时，赠送两个彩蛋，例如:</p>
<p>editor.fontSize: 20(修改字体大小为 20);</p>
<p>terminal.integrated.fontFamily:”Courier New”(字体修改为 “Courier New”).</p>
<p>这个可以根据自己的需求填写，当然如果不需要的话，可以不写。</p>
<p>如果上述方法出错的话可以试一试下方评论区的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;terminal.integrated.shellArgs.windows&quot;: [&quot;-NoExit&quot;, &quot;&#x2F;c&quot;, &quot;chcp 65001&quot;]</span><br></pre></td></tr></table></figure>

<p>当然了，如果你能通过修改右下方的GBK或者UTF-8可以解决的话就没必要选择上面的两种方法：</p>
<p><img src="/posts/cfb19e20/2020080614045655.png" alt="img"></p>
<p>发现如果改成UTF-8的话，通过Run Code运行的话是正常的，但是到了F5调试，弹出的黑框是乱码的，如果改成GBK，那么F5调试是正常的，Run Code是乱码，反正二者不可兼得，大家自己选择。总结下来就是，Run Code运行改成UTF-8，F5调试运行改成GBK，当然这个不是绝对的，还要看一看”terminal.integrated.shellArgs.windows”修改的是什么，如果”terminal.integrated.shellArgs.windows”没有填，好像改成GBK就行了。</p>
<p>到此这篇关于永久解决VSCode终端中文乱码问题的文章就介绍到这了,更多相关VSCode终端中文乱码内容请搜索脚本之家以前的文章或继续浏览下面的相关文章希望大家以后多多支持脚本之家！</p>
<p>本文作者：ityanger  </p>
<p>转载自<a href="https://www.jb51.net/article/192736.htm">脚本之家</a></p>
<hr>
<p>补充：关于VScode出现卡顿、打字缓慢、滚动和选择延迟等问题的解决方法。</p>
<p>参考：<a href="https://www.codeprj.com/blog/bc42ba1.html">https://www.codeprj.com/blog/bc42ba1.html</a></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>VScode</tag>
      </tags>
  </entry>
  <entry>
    <title>声明与定义的区别详解</title>
    <url>/posts/2ecba42c.html</url>
    <content><![CDATA[<p>参考自：<a href="https://blog.csdn.net/gatieme/article/details/50640424">https://blog.csdn.net/gatieme/article/details/50640424</a></p>
<span id="more"></span>

<h2 id="变量声明和变量定义"><a href="#变量声明和变量定义" class="headerlink" title="变量声明和变量定义"></a>变量声明和变量定义</h2><p>在C/C++中：</p>
<ul>
<li>变量定义：用于为变量分配存储空间，还可为变量指定初始值。程序中，变量有且仅有一个定义。</li>
<li>变量声明：用于向程序表明变量的类型和名字。程序中，变量可以有多次声明。</li>
<li>定义也是声明，extern声明不是定义。</li>
</ul>
<blockquote>
<ul>
<li>定义也是声明：当定义变量时我们声明了它的类型和名字。</li>
<li>extern声明不是定义：通过使用extern关键字声明变量名而不定义它。<br><strong>[注意]</strong><br>变量在使用前就要被定义或者声明。<br>在一个程序中，变量只能定义一次，却可以声明多次。<br>定义分配存储空间，而声明不会。</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C++程序通常由许多文件组成，为了让多个文件访问相同的变量，C++区分了声明和定义。</span><br><span class="line"></span><br><span class="line">  变量的定义（definition）用于为变量分配存储空间，还可以为变量指定初始值。在程序中，变量有且仅有一个定义。</span><br><span class="line"></span><br><span class="line">  声明（declaration）用于向程序表明变量的类型和名字。定义也是声明：当定义变量的时候我们声明了它的类型和名字。可以通过使用extern声明变量名而不定义它。不定义变量的声明包括对象名、对象类型和对象类型前的关键字extern。</span><br><span class="line"></span><br><span class="line">  extern声明不是定义，也不分配存储空间。事实上它只是说明变量定义在程序的其他地方。程序中变量可以声明多次，但只能定义一次。</span><br><span class="line"></span><br><span class="line">  只有当声明也是定义时，声明才可以有初始化式，因为只有定义才分配存储空间。初始化式必须要有存储空间来进行初始化。如果声明有初始化式，那么它可被当作是定义，即使声明标记为extern。</span><br><span class="line"></span><br><span class="line">  任何在多文件中使用的变量都需要有与定义分离的声明。在这种情况下，一个文件含有变量的定义，使用该变量的其他文件则包含该变量的声明（而不是定义）。</span><br></pre></td></tr></table></figure>
<p>在Java中：</p>
<p>并不区分变量的声明和定义！</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>如何在Word2019中更好地使用数学公式</title>
    <url>/posts/9964d56c.html</url>
    <content><![CDATA[<h2 id="1-为什么用Word"><a href="#1-为什么用Word" class="headerlink" title="1.为什么用Word"></a>1.为什么用Word</h2><p>关于该用Word还是用Latex的争论由来已久，这里就不再讨论，我们可以灵活使用这两种工具，它们可以在不同的场景发挥作用。</p>
<p>有时候，用Word会更加方便省事，我们接下来就讲一讲如何在Word2019中更好地使用数学公式。</p>
<span id="more"></span>

<p><strong>友情提示：本文仅仅针对Word2019！！！</strong></p>
<h2 id="2-Mathtype公式编辑器"><a href="#2-Mathtype公式编辑器" class="headerlink" title="2.Mathtype公式编辑器"></a>2.Mathtype公式编辑器</h2><p>Word2019虽然自带了公式插入功能，但是功能不是很强大，这里我们使用Mathtype公式编辑器。</p>
<p>Mathtype下载安装教程：<a href="https://www.bilibili.com/video/BV1cV41117SR?from=search&seid=6028489259985023645">MathType7.4安装、加载至word</a></p>
<p>视频讲解算是很详细了，跟着做就没什么大问题。</p>
<p>需要用到的工具：<a href="https://pan.baidu.com/s/1aeRHoUv3iS5x8mTLRr4m4Q">https://pan.baidu.com/s/1aeRHoUv3iS5x8mTLRr4m4Q</a> 提取码:hand</p>
<p>讲一讲会遇到的问题：</p>
<ol>
<li>出现Word2019的’53’错误：将破解包里的MathPage.wll文件复制到<br><code>&quot;C:\Program Files\Microsoft Office\root\Office16 &quot;</code>中</li>
<li>Word有两个mathtype选项卡：你需要去除没用的那一个，具体参照<a href="https://www.mathtype.cn/jiqiao/an-niu-shanchu.html">这里</a></li>
</ol>
<p>如果没什么问题了，你就可以开心地使用Mathtype编辑器了，效率杠杠滴！</p>
<p><strong>使用技巧：</strong>推荐一个<a href="https://www.mathtype.cn/">使用说明网站</a></p>
<p><img src="/posts/9964d56c/image-20210416141150533.png" alt="image-20210416141150533"></p>
<p>点击内联后会弹出公式编辑窗口，然后就能编辑公式了。</p>
<p><img src="/posts/9964d56c/image-20210416141119196.png" alt="image-20210416141119196"></p>
<p>编辑完成后，点击文件–&gt;更新 XXX就能看到公式已经显示出来了。</p>
<p> <strong>如何实现MathType公式转换LaTeX代码</strong></p>
<p>参考：<a href="https://www.mathtype.cn/jiqiao/gongshi-daima.html">https://www.mathtype.cn/jiqiao/gongshi-daima.html</a></p>
<p>这里介绍最简单的一种：点击切换Tex，再点一次就会再变回来。</p>
<p><img src="/posts/9964d56c/image-20210416141814068.png" alt="image-20210416141814068"></p>
<h2 id="3-原生插入Latex公式"><a href="#3-原生插入Latex公式" class="headerlink" title="3.原生插入Latex公式"></a>3.原生插入Latex公式</h2><p>参考：<a href="https://www.cnblogs.com/qq-757617012/p/12098279.html">https://www.cnblogs.com/qq-757617012/p/12098279.html</a></p>
<p>自带的公式编辑器也能转换成Latex公式。</p>
<h2 id="4-推荐一个Latex-OCR识别工具"><a href="#4-推荐一个Latex-OCR识别工具" class="headerlink" title="4.推荐一个Latex OCR识别工具"></a>4.推荐一个Latex OCR识别工具</h2><p>效果是非常不错的，亲身体验。</p>
<p><img src="/posts/9964d56c/image-20210416143919671.png" alt="image-20210416143919671"></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>Latex</tag>
        <tag>Word</tag>
      </tags>
  </entry>
  <entry>
    <title>寒假每日一题入门题（一）</title>
    <url>/posts/baabc5c0.html</url>
    <content><![CDATA[<h2 id="Day-01-104-货仓选址"><a href="#Day-01-104-货仓选址" class="headerlink" title="Day_01 104.货仓选址"></a>Day_01 104.货仓选址</h2><p><strong>这题考察绝对值不等式</strong></p>
<p><a href="https://www.acwing.com/solution/content/36228/">参考题解</a></p>
<p><img src="/posts/baabc5c0/image-20210222105937470.png" alt="image-20210222105937470"></p>
<p>由绝对值不等式可证明：<br>将n个数两两分组，如果n是奇数，货仓取中位数时取到不等式的等号，此时为最小值；如果n是偶数，货仓取中间两个数的中间即可。<br><strong>结论：中位数就是此题的最优解。</strong></p>
<span id="more"></span>

<hr>
<h3 id="算法1：排序-中位数"><a href="#算法1：排序-中位数" class="headerlink" title="算法1：排序+中位数"></a><strong>算法1：排序+中位数</strong></h3><p><strong>时间复杂度</strong>：$O(nlogn)$</p>
<p>中位数有非常优秀的性质，比如说在这道题目中，每一个点到中位数的距离，都是满足全局的最有性，而不是局部最优性。</p>
<p>具体的来说，我们设在仓库左边的所有点，到仓库的距离之和为p,右边的距离之和则为q，那么我们就必须让p+q的值尽量小。</p>
<p>当仓库向左移动的话，p会减少x，但是q会增加n−x，所以说当为仓库中位数的时候,p+q最小。</p>
<p>还是同样的一句话，画图理解很重要。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    sort(a,a+n);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++) res += a[i] - a[i&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// ==&gt; res += abs(a[i] - a[n&gt;&gt;1])</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>将 abs(a[i] - a[n &gt;&gt; 1]) 改为 a[i] - a[i &gt;&gt; 1]也可以 AC（这样可以不用取绝对值）</p>
<p>证明如下：<br><img src="/posts/baabc5c0/image-20210222110203712.png" alt="image-20210222110203712"></p>
<h3 id="算法2：快速选择-中位数"><a href="#算法2：快速选择-中位数" class="headerlink" title="算法2：快速选择+中位数"></a><strong>算法2：快速选择+中位数</strong></h3><p>快速选择函数nth_element(数组初位置，寻找元素，数组末位置)（STL）</p>
<p>C++的STL库中的nth_element()方法，默认是求区间<strong>第k小</strong>的（划重点）。</p>
<p>举个栗子求第3小，对于 a[9]={4,7,6,9,1,8,2,3,5};</p>
<p>nth_element(a,a+2,a+9)，**将下标为2，也就是第3个数放在正确的位置，求的是第3小的数a[2]**。（下标从零开始）</p>
<p><strong>nth_element(a,a+k,a+n)，函数只是把下标为k的元素放在了正确位置，对其它元素并没有排序，当然k左边元素都小于等于它，右边元素都大于等于它，所以可以利用这个函数快速定位某个元素</strong>。</p>
<p>那求第k大时呢？我们可以转化成求第n-k+1小，此时下标应该是n - k。</p>
<p><strong>nth_element(a,a+n-k,a+n)，将下标为n-k，也就是第n-k+1个数放在正确的位置，求的是第k大的数a[n-k]。</strong></p>
<p><strong>时间复杂度</strong>：$O(n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,s=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;p[i];</span><br><span class="line">    nth_element(p,p+n/<span class="number">2</span>,p+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) s+=<span class="built_in">abs</span>(p[i]-p[n/<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>中位数</tag>
        <tag>绝对值不等式</tag>
      </tags>
  </entry>
  <entry>
    <title>常用STL速查手册</title>
    <url>/posts/a70a6c57.html</url>
    <content><![CDATA[<p>作者：自豪的澡巾QAQ<br>链接：<a href="https://www.acwing.com/blog/content/6096/">https://www.acwing.com/blog/content/6096/</a><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<span id="more"></span>

<p>这是我目前水平下能接触到的,如果有补充欢迎留言.<br>别抬杠,杠就是你对.</p>
<p><code>#include&lt;string&gt;:</code></p>
<p>常用操作:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">s.begin();</span><br><span class="line">s.end();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s.c_str()); <span class="comment">//使用scanf读入string类型的变量或者希望通过strcpy对字符串进行复制,请使用c_str();</span></span><br><span class="line">s[i] == s.at(i);        <span class="comment">//允许索引寻址</span></span><br><span class="line"><span class="keyword">int</span> indxe = s.find(<span class="keyword">char</span> ch);    <span class="comment">//返回ch在s中的索引</span></span><br><span class="line">s.size();</span><br><span class="line">s.append(<span class="built_in">string</span> post);      </span><br><span class="line">s.pop_back();</span><br><span class="line"><span class="comment">//返回s[begin,begin + len - 1],注意与java中的substring的区别,当len == -1时表示截取到最后</span></span><br><span class="line">s.substr(<span class="keyword">int</span> begin,<span class="keyword">int</span> len);</span><br><span class="line">insert(iterator iter,type val);</span><br><span class="line">erase(iterator iter);</span><br></pre></td></tr></table></figure>

<p><code>#include&lt;pair&gt;</code></p>
<p>常用操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; PII;<span class="comment">//常结合map和sort使用</span></span><br><span class="line">PII a;</span><br><span class="line">a = <span class="built_in">make_pair</span>(<span class="number">5</span>,<span class="string">&#x27;f&#x27;</span>);<span class="comment">//等价于a = &#123;5,&#x27;f&#x27;&#125;;</span></span><br><span class="line">a.first;a.second;<span class="comment">//返回第一和第二关键字</span></span><br></pre></td></tr></table></figure>

<p><code>#include&lt;vector&gt;：</code></p>
<p>vector的常用初始化操作:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vector支持比较运算</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; <span class="title">g</span><span class="params">(n,i)</span></span>;        <span class="comment">//创建一个长度为n初值为i的一维向量(数组)</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; <span class="title">f</span><span class="params">(g.begin() + [offset],g.end())</span></span>;       <span class="comment">//通过g来创建一个f向量,offset可有可无</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">c</span><span class="params">(v)</span></span>;        <span class="comment">//将v复制给c</span></span><br><span class="line">v.assign (<span class="number">7</span>,<span class="number">100</span>);             <span class="comment">// 7 ints with a value of 100</span></span><br></pre></td></tr></table></figure>

<p>vector的常用函数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">clear();</span><br><span class="line">begin();</span><br><span class="line">end();</span><br><span class="line">size();</span><br><span class="line">empty();</span><br><span class="line">front();</span><br><span class="line">back();</span><br><span class="line">push_back(member_type x);</span><br><span class="line">pop_back();</span><br><span class="line">erase(iterator l[,iterator r]);        <span class="comment">// 删除第l[到r]个值</span></span><br><span class="line">v.at[i] == v[i]</span><br></pre></td></tr></table></figure>

<p><code>#include&lt;stack&gt;:</code></p>
<p>常用操作:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">push(type x);   <span class="comment">//压栈</span></span><br><span class="line">pop()   <span class="comment">//出栈</span></span><br><span class="line">empty();    </span><br><span class="line">size();</span><br><span class="line">top();  <span class="comment">//返回栈顶</span></span><br></pre></td></tr></table></figure>

<p><code>#include&lt;queue&gt;</code></p>
<p>常用操作:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">queue&lt;int&gt; q;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">q.push(<span class="keyword">int</span> x);   <span class="comment">//入队</span></span><br><span class="line">q.pop();  <span class="comment">//出队</span></span><br><span class="line">q.empty();</span><br><span class="line">q.size();</span><br><span class="line">q.front();    <span class="comment">//队首</span></span><br><span class="line"></span><br><span class="line">q.back(); <span class="comment">//队尾</span></span><br><span class="line">-------------------</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">priority_queue&lt;int&gt; heap;   //优先队列,即堆,默认为大根堆</span></span><br><span class="line"><span class="comment">定义小根堆:</span></span><br><span class="line"><span class="comment">    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; tt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">heap.size();</span><br><span class="line">heap.empty();</span><br><span class="line">heap.push(<span class="keyword">int</span> x);</span><br><span class="line">heap.pop();     <span class="comment">//移除堆顶元素</span></span><br><span class="line">heap.top();     <span class="comment">//返回堆顶元素</span></span><br></pre></td></tr></table></figure>

<p><code>#include&lt;deque&gt;</code></p>
<p>常用操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">deque&lt;int&gt; q;//支持随机寻址,效率相较低</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">q.empty();</span><br><span class="line">q.size();</span><br><span class="line">q.front();</span><br><span class="line">q.back();</span><br><span class="line">q.push_back(<span class="keyword">int</span> x);</span><br><span class="line">q.push_front(<span class="keyword">int</span> x);</span><br><span class="line">q.pop_back();</span><br><span class="line">q.pop_front();</span><br></pre></td></tr></table></figure>

<p><code>#include&lt;map&gt;</code></p>
<p>常用操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//存储的类型为pair，因此可以通过类似dic.begin().first(second)来访问键值对</span></span><br><span class="line"><span class="comment">map&lt;string,int&gt; dic;//不可以有重复的键值,multimap可以有重复的键值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">dic.empty();</span><br><span class="line">dic.size();</span><br><span class="line">dic.insert(&#123;<span class="string">&quot;hello&quot;</span>,<span class="number">1</span>&#125;);    <span class="comment">//参数类型为pair,等价于dic[&quot;hello&quot;] = 1;</span></span><br><span class="line">dic.erase(&#123;<span class="string">&quot;hello&quot;</span>,<span class="number">1</span>&#125;);     <span class="comment">//参数类型为pair或者iterator</span></span><br><span class="line">dic.find(<span class="string">&quot;hello&quot;</span>);          <span class="comment">//注意返回的是迭代器</span></span><br><span class="line">dic.count(<span class="string">&quot;hello&quot;</span>);         <span class="comment">//返回0或者1</span></span><br></pre></td></tr></table></figure>

<p><code>#include&lt;set&gt;</code></p>
<p>常用操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">set的含义是集合,元素有序,支持插入,删除,查找等操作,所有的操作的都是严格在logn时间之内完成,效率非常高。</span></span><br><span class="line"><span class="comment">set和multiset的区别是：set插入的元素不能相同，但是multiset可以相同。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">set</span>/<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">s.insert(<span class="keyword">int</span> x);</span><br><span class="line">s.find(<span class="keyword">int</span> x);  <span class="comment">//返回迭代器</span></span><br><span class="line">s.erase(<span class="keyword">int</span> x/iterator);<span class="comment">//如果参数为整数,意为删除集合内所有x;如果是迭代器,则删除这个迭代器</span></span><br></pre></td></tr></table></figure>

<p><code>#include&lt;unordered_set/multiset/unordered_map/multimap&gt;</code></p>
<p>常用操作<br>带有unordered意味着底层为hash,与上面的操作类似,但时间复杂度为O(1)<br><code>#include&lt;algorithm&gt;</code></p>
<p>常用函数<br><strong>最大值,最小值,交换</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">max(max(a,b),c);</span><br><span class="line">min();</span><br><span class="line">swap(a,b);</span><br></pre></td></tr></table></figure>

<p><strong>快速排序,默认排序结果为升序;</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num[] = &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">2</span>&#125;;</span><br><span class="line">sort(num,num + <span class="number">6</span>,cmp);<span class="comment">//cmp可省略,可以手动实现cmp定义排序规则,通常与struct、pair形成combo</span></span><br></pre></td></tr></table></figure>

<p><strong>字符串反转</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;hello wolrd&quot;</span>;</span><br><span class="line">reverse(s.begin(),s.end());<span class="comment">//能够将string,vector等类型进行翻转,返回迭代器</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//    &quot;dlrow olleh&quot;;</span></span><br></pre></td></tr></table></figure>

<p><strong>去重</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(num,num + <span class="number">9</span>)</span></span>;</span><br><span class="line">sort(v.begin(),v.end());</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">删除重复出现的系列点,unique()函数将所有不重复的点放在数组前面,重复的点放在后面,</span></span><br><span class="line"><span class="comment">返回第一个起始重复元素的迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">v.erase(unique(v.begin(),v.end()),v.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> a : v) <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span>;      <span class="comment">//10 20 30</span></span><br></pre></td></tr></table></figure>

<p><strong>全排列</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">next_permutation()将按字母表顺序生成给定序列的下一个较大的排列,直到整个序列为降序为止。</span></span><br><span class="line"><span class="comment">prev_permutation()与之相反,是生成给定序列的上一个较小的排列。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> num[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (next_permutation(num,num + <span class="number">5</span>)) &#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : num) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cnt;<span class="comment">// cnt == 5! == 120</span></span><br></pre></td></tr></table></figure>

<p><strong>本内容仅用作STL简单使用字典</strong></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂算法</title>
    <url>/posts/50ce0ed6.html</url>
    <content><![CDATA[<p>我们首先来看一个问题：</p>
<blockquote>
<p>给定三个正整数a，b，m(a&lt;10^9, b&lt;10^18, 1&lt;m&lt;10^9)，求a^b%m。</p>
</blockquote>
<span id="more"></span>

<p>如果用循环来写，不断乘上a再取模，时间复杂度为O(b)。很容易超时。</p>
<p>所以我们考虑快速幂算法。它<strong>基于二分的思想</strong>，也被称为<strong>二分幂</strong>。</p>
<h2 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h2><p>1.如果b是偶数，那么有：$a^b = a*a^{b-1}$</p>
<p>2.如果b是奇数，那么有：$a^b = a^{b/2}*a^{b/2}$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="comment">// 递归求a^b%m</span></span><br><span class="line"><span class="function">LL <span class="title">binaryPow</span><span class="params">(LL a,LL b,LL m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b%<span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> a * binaryPow(a,b<span class="number">-1</span>,m) % m;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        LL mul = binaryPow(a,b &gt;&gt;<span class="number">1</span>,m);</span><br><span class="line">        <span class="keyword">return</span> mul * mul % m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果初始时a&gt;=m，需要执行函数时先对a%m。</li>
<li>如果m==1，直接在函数外部特判为0。</li>
</ul>
<h2 id="迭代写法"><a href="#迭代写法" class="headerlink" title="迭代写法"></a>迭代写法</h2><p>把b写成二进制的形式，那么b可以写成若干二次幂之和。</p>
<p>例如13的二进制形式为1101，$13=2^3+2^2+2^0,a^{13}=a^8<em>a^4</em>a^1$。</p>
<p>不难推出：当b的二进制的第i（从0开始）位是1时，初值ans=1要乘上$a^{2{^i}}$。由于我们每次迭代时令a平方</p>
<p>（$a=a^{2i}$），所以枚举当前第i位时，a已经迭代到初始a的$2^i$次方，如果是1，就令ans乘上a。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="comment">//  迭代求a^b%m</span></span><br><span class="line"><span class="function">LL <span class="title">binaryPow</span><span class="params">(LL a,LL b,LL m)</span></span>&#123;</span><br><span class="line">    LL ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 等价于b%2 == 1</span></span><br><span class="line">        <span class="keyword">if</span> (b&amp;<span class="number">1</span>) ans = ans*a%m;</span><br><span class="line">        a = a*a%m;</span><br><span class="line">        b &gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际应用场景，两种写法效率差不多。</p>
<p><strong>大数取模公式总结：</strong><br><img src="/posts/50ce0ed6/image-20210407222650012.png" alt="image-20210407222650012"></p>
<p>参考资料1：<a href="https://www.cnblogs.com/llsq/p/5810262.html">博客园</a></p>
<p>参考资料2：《算法笔记》</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>二分</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法（C++实现）</title>
    <url>/posts/578803b6.html</url>
    <content><![CDATA[<h1 id="初等排序算法"><a href="#初等排序算法" class="headerlink" title="初等排序算法"></a>初等排序算法</h1><p><strong>排序算法的稳定性</strong></p>
<p>仅仅用执行效率和内存消耗来衡量排序算法的好坏是不够的。针对排序算法，我们还有一个重要的度量指标，稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p>
<span id="more"></span>

<p><strong>空间复杂度</strong></p>
<p>我们前面讲过，算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，<strong>原地排序</strong>（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。</p>
<p><strong>时间复杂度</strong></p>
<p>我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。为什么要区分这三种时间复杂度呢？第一，有些排序算法会区分，为了好对比，所以我们最好都做一下区分。第二，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。</p>
<h3 id="1-Bubble-Sort（冒泡排序）"><a href="#1-Bubble-Sort（冒泡排序）" class="headerlink" title="1.Bubble Sort（冒泡排序）"></a>1.Bubble Sort（冒泡排序）</h3><p>时间复杂度：$O(n^2)$.</p>
<p>稳定排序算法。</p>
<p>冒泡排序是最基础的排序算法之一。</p>
<p>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。</p>
<p>最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 $O(n^2)$，平均情况下的时间复杂度就是 $O(n^2)$。</p>
<p>冒泡排序的本质就是<strong>交换</strong>；第一层循环确定冒泡（交换）执行的趟数，n个数执行n趟，每一趟选出一个最大数或最小数；第二层循环进行相邻数的比较。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++板子</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[N];</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>;k &lt; N;k ++)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[k];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// k是元素个数</span></span><br><span class="line">	<span class="comment">// Bubble Sort</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k<span class="number">-1</span>;i ++)<span class="comment">// 循环k-1趟</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; k - i - <span class="number">1</span>;j ++)</span><br><span class="line">		&#123;</span><br><span class="line">            	<span class="comment">// 注意：这里加上等号会失去稳定性</span></span><br><span class="line">			<span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) swap(a[j],a[j+<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x : a) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="number">10</span>);<span class="comment">// 输出回车</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java板子，极客时间</span></span><br><span class="line"><span class="comment">// 冒泡排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="comment">// 提前退出冒泡循环的标志位，优化</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">        <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">        a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">        a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">        flag = <span class="keyword">true</span>;  <span class="comment">// 表示有数据交换      </span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;  <span class="comment">// 没有数据交换，说明已经是有序的，提前退出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Selection-Sort（选择排序）"><a href="#2-Selection-Sort（选择排序）" class="headerlink" title="2.Selection Sort（选择排序）"></a>2.Selection Sort（选择排序）</h3><p>时间复杂度：$O(n^2)$.</p>
<p><strong>不稳定</strong>排序算法。正是因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。</p>
<p>选择排序（据y总说）是最简单的排序算法。</p>
<p>首先，选择排序空间复杂度为 O(1)，是一种原地排序算法。选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 $O(n^2)$。你可以自己来分析看看。</p>
<p>第一层循环对n个数进行n-1趟选择，因为最后一个多出来的数不用再选择。第二层循环对待排序区域的数进行选择，选出最大（最小）的数。每一趟选择就会选出一个最大（最小）的数。</p>
<p><img src="/posts/578803b6/image-20210310165553787.png" alt="image-20210310165553787"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++板子</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[N];</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>;k &lt; N;k ++)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[k];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// k是元素个数</span></span><br><span class="line">	<span class="comment">// Selection Sort</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k<span class="number">-1</span>;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> min = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; k;j ++)<span class="comment">// 注意边界</span></span><br><span class="line">		<span class="comment">// 从a[i+1]到a[k-1]选出最小的数，下标为min</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j] &lt; a[min]) min = j;<span class="comment">//可以写成a[j] != a[k]</span></span><br><span class="line">		&#125;</span><br><span class="line">		swap(a[i],a[min]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x : a) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 $O(n^2)$ 的时间复杂度。所以用到它的时候，数据规模越小越好。好处可能就是不占用额外的内存空间了吧。</p>
<p>由于选择排序每一趟总是从无序区中选出全局最小（或最大）的元素，所以适用于从大量元素中选择一部分排序元素。例如，从10000个元素中选出最小的前10位元素。</p>
<h3 id="3-Insertion-Sort（插入排序）"><a href="#3-Insertion-Sort（插入排序）" class="headerlink" title="3.Insertion Sort（插入排序）"></a>3.Insertion Sort（插入排序）</h3><p>时间复杂度：$O(n^2)$.</p>
<p>稳定排序算法。</p>
<p>原地排序算法。</p>
<p>插入排序也是一种常见的简单算法。</p>
<p>输入数据的顺序能大幅度影响它的复杂度。</p>
<p>插入排序将数组分成已排序和未排序两个部分，过程就是将待插入元素插入如有序部分。这里的做法是<strong>从后往前枚举有序部分</strong>来确定插入位置。</p>
<p>如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为 O(n)。注意，这里是<strong>从尾到头遍历已经有序的数据</strong>。</p>
<p>如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为$O(n^2)$。</p>
<p>还记得我们在数组中插入一个数据的平均时间复杂度是多少吗？没错，是 O(n)。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为$O(n^2)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++板子</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[N];</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>;k &lt; N;k ++)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[k];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Insertion Sort</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; k;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//temp临时存放待插入元素，j是有序部分最后一个元素的下标</span></span><br><span class="line">        <span class="keyword">int</span> temp = a[i],j = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; a[j])<span class="comment">//j枚举完所有有序部分</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[j+<span class="number">1</span>] = a[j];<span class="comment">//元素后移</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j+<span class="number">1</span>] = temp;<span class="comment">//插入元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x : a) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java板子，极客时间</span></span><br><span class="line"><span class="comment">// 插入排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> value = a[i];</span><br><span class="line">    <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 查找插入的位置</span></span><br><span class="line">    <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">        a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[j+<span class="number">1</span>] = value; <span class="comment">// 插入数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h3><ul>
<li>以上三种都是原地排序算法。</li>
<li>虽然冒泡排序和插入排序在时间复杂度上是一样的，都是$O(n^2)$，但是如果我们希望把性能优化做到极致，那肯定首选插入排序。插入排序的算法思路也有很大的优化空间，我们只是讲了最基础的一种。</li>
<li>如果你对插入排序的优化感兴趣，可以自行学习一下希尔排序。</li>
<li>它们的时间复杂度都是 O(n2)，比较高，适合小规模数据的排序。</li>
</ul>
<h3 id="5-补充"><a href="#5-补充" class="headerlink" title="5.补充"></a>5.补充</h3><ol>
<li><p>这里附上一份十大经典排序算法大梳理 (动图+代码)，这是经过系统整理过的！</p>
<p>链接奉上：<a href="https://mp.weixin.qq.com/s/ekGdneZrMa23ALxt5mvKpQ">https://mp.weixin.qq.com/s/ekGdneZrMa23ALxt5mvKpQ</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/zwtgyh/p/10631760.html">常见排序算法及其对应的时间复杂度和空间复杂度</a> （PS：部分分析不完整，请参照王争专栏）</p>
</li>
<li><p>帅地大佬的文章：<a href="https://www.iamshuaidi.com/608.html%EF%BC%88%E5%B0%8F%E7%A0%B4%E7%AB%99%E5%A5%BD%E4%B8%9C%E8%A5%BF%E4%B8%8D%E5%B0%91%EF%BC%89">https://www.iamshuaidi.com/608.html（小破站好东西不少）</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数学专业常用英语表达总结</title>
    <url>/posts/1773bf6f.html</url>
    <content><![CDATA[<h2 id="Mathematical-English-1"><a href="#Mathematical-English-1" class="headerlink" title="Mathematical English 1"></a>Mathematical English 1</h2><span id="more"></span>

<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><p><img src="/posts/1773bf6f/image-20210308193302431.png" alt="image-20210308193302431"></p>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><p><img src="/posts/1773bf6f/image-20210308193353557.png" alt="image-20210308193353557"></p>
<h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a>Example 3:</h3><p><img src="/posts/1773bf6f/image-20210308193518529.png" alt="image-20210308193518529"></p>
<h3 id="Example-4"><a href="#Example-4" class="headerlink" title="Example 4:"></a>Example 4:</h3><p><img src="/posts/1773bf6f/image-20210308193555454.png" alt="image-20210308193555454"></p>
<h3 id="Example-5"><a href="#Example-5" class="headerlink" title="Example 5:"></a>Example 5:</h3><p><img src="/posts/1773bf6f/image-20210308193635558.png" alt="image-20210308193635558"></p>
<h3 id="Example-6"><a href="#Example-6" class="headerlink" title="Example 6:"></a>Example 6:</h3><p><img src="/posts/1773bf6f/image-20210308193713986.png" alt="image-20210308193713986"></p>
<h3 id="Example-7"><a href="#Example-7" class="headerlink" title="Example 7:"></a>Example 7:</h3><p><img src="/posts/1773bf6f/image-20210308195015812.png" alt="image-20210308195015812"></p>
<h3 id="Example-8"><a href="#Example-8" class="headerlink" title="Example 8:"></a>Example 8:</h3><p><img src="/posts/1773bf6f/image-20210308195119005.png" alt="image-20210308195119005"></p>
<h3 id="Example-9"><a href="#Example-9" class="headerlink" title="Example 9:"></a>Example 9:</h3><p><img src="/posts/1773bf6f/image-20210308195215619.png" alt="image-20210308195215619"></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学专业词汇</tag>
      </tags>
  </entry>
  <entry>
    <title>数学专业常用英语表达总结（二）</title>
    <url>/posts/78fe420d.html</url>
    <content><![CDATA[<h2 id="Mathematical-English-2"><a href="#Mathematical-English-2" class="headerlink" title="Mathematical English 2"></a>Mathematical English 2</h2><span id="more"></span>

<p>1.表达正数：positive number a</p>
<p>同样地，关于负数有：negative number a</p>
<p>2.绝对值的表达：$|x-x_0|$，the absolute value of the difference of $x$ and $x_0$</p>
<p>3.可微与可积：differentiable and integrable</p>
<p>导数与积分（名词）：derivative and integral</p>
<p>4.表达极限的两种方式：</p>
<ul>
<li><p>$\displaystyle\lim_{x \rightarrow x_0}f(x) = A$,the limit of <em>f</em> of <em>x</em> is equal to <em>A</em> as <em>x</em> approaches <em>x</em>0</p>
</li>
<li><p>${f(x) \rightarrow A} \ as\ {x\rightarrow x_0}$,<em>f</em> of <em>x</em> approaches <em>A</em> as <em>x</em> tends to <em>x</em>0</p>
</li>
</ul>
<p>5.表达某一定理等成立：with this one hold</p>
<p>6.常见希腊字母：</p>
<p><img src="/posts/78fe420d/image-20210311115529635.png" alt="image-20210311115529635"></p>
<p>7.分数（fraction），分母（denominator），分子（numerator）</p>
<p>8.微分与积分</p>
<p><img src="/posts/78fe420d/image-20210317230557415.png" alt="image-20210317230557415"></p>
<p><img src="/posts/78fe420d/image-20210317230606292.png" alt="image-20210317230606292"></p>
<p><img src="/posts/78fe420d/image-20210317230613942.png" alt="image-20210317230613942"></p>
<p><img src="/posts/78fe420d/image-20210317230622050.png" alt="image-20210317230622050"></p>
<p>修正：定积分改正为from a to b of f of x。</p>
<p>9.线性代数</p>
<p><img src="/posts/78fe420d/image-20210317230646313.png" alt="image-20210317230646313"></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学专业词汇</tag>
      </tags>
  </entry>
  <entry>
    <title>日期处理与进制转换问题</title>
    <url>/posts/f95a0d7f.html</url>
    <content><![CDATA[<blockquote>
<p>这篇文章将介绍常见的日期处理与进制转换问题。</p>
</blockquote>
<span id="more"></span>

<h2 id="1-日期处理"><a href="#1-日期处理" class="headerlink" title="1.日期处理"></a>1.日期处理</h2><p>以题目为例：<a href="http://codeup.hustoj.com/problem.php?cid=100000578&amp;pid=0">http://codeup.hustoj.com/problem.php?cid=100000578&amp;pid=0</a></p>
<h3 id="问题-A-日期差值"><a href="#问题-A-日期差值" class="headerlink" title="问题 A: 日期差值"></a>问题 A: 日期差值</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>有两个日期，求两个日期之间的天数，如果两个日期是连续的我们规定他们之间的天数为两天。</p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>有多组数据，每组数据有两行，分别表示两个日期，形式为YYYYMMDD</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>每组数据输出一行，即日期差值</p>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20130101</span><br><span class="line">20130105</span><br></pre></td></tr></table></figure>
<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><p>我们需要处理平年和闰年，大月和小月的问题。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们不妨设第一个日期是早于第二个日期的（如果不是就交换顺序）。</p>
<p>求日期差值的问题很直接的一个思路就是让第一个日期不断加1天，直到和第二个日期相等为止。</p>
<p>为了存放平年和闰年每个月的天数，我们建立一个二维数组<code>int month[13][2]</code>，第一维存放月份，从1到12，第0位不用，第二维为0表示平年，为1表示闰年。</p>
<p>我们可以先让第一个日期的年份加到与第二个日期的年份相差1为止，这样可以加快速度。对于其中的年份，只要根据平年还是闰年加365或366天即可。之后再不断让天数加1就行。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeap</span><span class="params">(<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (y%<span class="number">4</span>==<span class="number">0</span> &amp;&amp;y%<span class="number">100</span>!=<span class="number">0</span>) || (y%<span class="number">400</span>==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> month[<span class="number">13</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">28</span>,<span class="number">29</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,</span><br><span class="line">	&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    <span class="keyword">int</span> time1,time2;</span><br><span class="line">    <span class="keyword">int</span> y1,m1,d1;</span><br><span class="line">    <span class="keyword">int</span> y2,m2,d2;     </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;time1,&amp;time2) != EOF)&#123;<span class="comment">// 有多组测试数据</span></span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (time1 &gt; time2) swap(time1,time2);</span><br><span class="line">    	<span class="keyword">if</span>(time1 == time2) &#123;<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">1</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">     </span><br><span class="line">    	y1 = time1/<span class="number">10000</span>,m1 = time1%<span class="number">10000</span>/<span class="number">100</span>,d1 = time1%<span class="number">100</span>;</span><br><span class="line">    	y2 = time2/<span class="number">10000</span>,m2 = time2%<span class="number">10000</span>/<span class="number">100</span>,d2 = time2%<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (y1 &lt; y2 || m1 &lt; m2 || d1 &lt; d2)&#123;			</span><br><span class="line">			<span class="keyword">if</span> (y1 &lt; y2 <span class="number">-1</span>)&#123; <span class="comment">// 优化判断</span></span><br><span class="line">				y1 ++;</span><br><span class="line">				<span class="keyword">if</span> (isLeap(y1)) ans+=<span class="number">366</span>;</span><br><span class="line">				<span class="keyword">else</span> ans += <span class="number">365</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			d1++; <span class="comment">// 注意这里放优化判断之后</span></span><br><span class="line">			<span class="keyword">if</span> (d1==month[m1][isLeap(y1)]+<span class="number">1</span>)&#123;</span><br><span class="line">				d1 = <span class="number">1</span>;m1++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (m1 == <span class="number">13</span>)&#123;</span><br><span class="line">				m1 = <span class="number">1</span>;y1++;</span><br><span class="line">			&#125;</span><br><span class="line">			ans++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化代码参考：<a href="https://blog.csdn.net/numb123r/article/details/112722689">https://blog.csdn.net/numb123r/article/details/112722689</a></p>
<p>这题一般写法还是比较简单，但是优化时WA好几发，注意写法。</p>
<h2 id="2-进制转换"><a href="#2-进制转换" class="headerlink" title="2.进制转换"></a>2.进制转换</h2><p>以题目为例：</p>
<p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805299301433344">https://pintia.cn/problem-sets/994805260223102976/problems/994805299301433344</a></p>
<h3 id="1022-D进制的A-B-20-分"><a href="#1022-D进制的A-B-20-分" class="headerlink" title="1022 D进制的A+B (20 分)"></a>1022 D进制的A+B (20 分)</h3><p>输入两个非负 10 进制整数 <em>A</em> 和 <em>B</em> (≤230−1)，输出 <em>A</em>+<em>B</em> 的 <em>D</em> (1&lt;<em>D</em>≤10)进制数。</p>
<h4 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h4><p>输入在一行中依次给出 3 个整数 <em>A</em>、<em>B</em> 和 <em>D</em>。</p>
<h4 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h4><p>输出 <em>A</em>+<em>B</em> 的 <em>D</em> 进制数。</p>
<h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123 456 8</span><br></pre></td></tr></table></figure>

<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1103</span><br></pre></td></tr></table></figure>

<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>将一个P进制数转换为Q进制数，分两步：</p>
<ol>
<li>将P进制数x转换为10进制数y:</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> y = <span class="number">0</span>,product = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (x!=<span class="number">0</span>)&#123;</span><br><span class="line">    y += (x%<span class="number">10</span>)*product; <span class="comment">// x%10取最后一位数</span></span><br><span class="line">    x /= <span class="number">10</span>; <span class="comment">// 舍去x的最后一位数</span></span><br><span class="line">    product *= P; <span class="comment">// product作为权</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>搞不清楚的话，可以拿二进制数转换为十进制数作为参考。<br>2. 将10进制数y转换为Q进制数z:</p>
<p>除基取余法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> z[<span class="number">40</span>],num = <span class="number">0</span>; <span class="comment">// 数组z用于存放Q进制数y的每一位，num为位数</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    z[num++]  = y % Q;</span><br><span class="line">    y /= Q;</span><br><span class="line">&#125;<span class="keyword">while</span> (y != <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>最后将数组z从高位z[num-1]到低位z[0]输出，就是Q进制数z。</p>
<p>搞不清楚的话，可以拿十进制数转换为二进制数作为参考。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;d);</span><br><span class="line">    a  = a+b;</span><br><span class="line">    <span class="keyword">int</span> ans[<span class="number">31</span>],num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        ans[num++] = a%d;</span><br><span class="line">        a /= d;</span><br><span class="line">    &#125;<span class="keyword">while</span> (a != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=num<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提一点，PAT的编译器，如果按照scanf的一般写法可能会警告，将<code>scanf(&quot;%d&quot;,&amp;t);</code>改成<code>if(scanf(&quot;%d&quot;,&amp;t))&#123;&#125;;</code>就不会警告了。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>进制转换</tag>
        <tag>日期处理</tag>
      </tags>
  </entry>
  <entry>
    <title>最大公因数与最小公倍数问题</title>
    <url>/posts/e808698d.html</url>
    <content><![CDATA[<h2 id="1-最大公因数"><a href="#1-最大公因数" class="headerlink" title="1.最大公因数"></a>1.最大公因数</h2><p>最大公因数，也即最大公约数。</p>
<p>最大公约数即为 Greatest Common Divisor，常缩写为 gcd。</p>
<p>我们求出最大公因数可以用于分数的约分问题，只要分子、分母都除以最大公因数d。</p>
<span id="more"></span>

<p>最常用的求最大公因数的方法时欧几里得算法，也即辗转相除法。时间复杂度为$O(logn)$。</p>
<p>欧几里得算法基于下面的定理：</p>
<p>设a，b为均正整数，则<code>gcd(a,b) = gcd(b,a%b)</code>。</p>
<p><img src="/posts/e808698d/image-20210409151251806.png" alt="image-20210409151251806"><img src="/posts/e808698d/image-20210409151324778.png" alt="image-20210409151324778"></p>
<h3 id="1-1递归写法"><a href="#1-1递归写法" class="headerlink" title="1.1递归写法"></a>1.1递归写法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常规写法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a; <span class="comment">// 退出边界</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a % b);<span class="comment">//递归</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化写法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span>	</span>&#123;<span class="keyword">return</span> !b?a:gcd(b,a%b);&#125; <span class="comment">// 注意加上&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2循环写法"><a href="#1-2循环写法" class="headerlink" title="1.2循环写法"></a>1.2循环写法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>)&#123;</span><br><span class="line">        r = a%b,a = b,b = r; <span class="comment">// 辗转相除</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：循环写法相对代码多一点，但是递归写法内存消耗大一点。</p>
<p>个人还是推荐递归写法，毕竟码字快一点。</p>
<p>注意：这里要求a&gt;b，如果a&lt;b需要swap一下。</p>
<h2 id="2-最小公倍数"><a href="#2-最小公倍数" class="headerlink" title="2.最小公倍数"></a>2.最小公倍数</h2><p>接下来我们介绍如何求解最小公倍数（Least Common Multiple, LCM）。</p>
<p>我们容易发现，对于两个正整数a和b，它们的最小公倍数是ab/d(d是最大公因数)。</p>
<p>注意：<code>为了避免a*b可能存在的溢出问题，我们可以改写为a/d*b</code>。</p>
<p>如果你对详细证明过程感兴趣的话，推荐食用文章：<a href="https://oi-wiki.org/math/gcd/%E3%80%82">https://oi-wiki.org/math/gcd/。</a></p>
<h2 id="3-例题"><a href="#3-例题" class="headerlink" title="3.例题"></a>3.例题</h2><p>题目链接：<a href="https://www.dotcpp.com/oj/problem2229.html">C语言网</a>。</p>
<p>题目描述</p>
<p>已知一个正整数N，问从1~N中任选出三个数，他们的最小公倍数最大可以为多少。</p>
<p>输入</p>
<p>输入一个正整数N。</p>
<p>1 &lt;= N &lt;= 10^6。</p>
<p>输出</p>
<p>输出一个整数，表示你找到的最小公倍数。</p>
<p><strong>思路：</strong>参考自<a href="https://blog.csdn.net/qq_36403227/article/details/88677874">CSDN</a>。</p>
<p>题目要求我们在1 ~ N之间任意选择三个数，使得它们的最小公倍数最大。<br> 要使得最小公倍数最大，那么思路可以是：</p>
<blockquote>
<p>1.这三个数要两两互质<br>        2.在满足1的前提下，使得三个整数取最大值</p>
</blockquote>
<p> 第一点已经在上面分析过了。而第2点也很好理解，其实就是贪心策略。</p>
<ol>
<li><p>N为奇数时<br> 当N为奇数时，N - 1为偶数，N - 2为奇数，显然，数学知识告诉我们，相邻的两个正整数互质。同样的，相邻的两个奇数也是互质的，那么此时题目要求的答案为N * (N - 1) * (N - 2)。</p>
</li>
<li><p>N为偶数时<br> 因为当N &gt;3时，N 和当N - 3是可能不是互质的，例如3和6。所以偶数时又分为两种可能性：</p>
</li>
</ol>
<p>  2.1 当3不能整除N时<br>    当N为偶数时，N - 2同样为偶数，那么就不能满足上面思路的第1点了。但是N和N - 1还是互质的，所以</p>
<p>在贪心策略下，我们优先考虑使用更小的值去替换N - 2，而不是替换N 和 N - 1。</p>
<p>​        经计算发现 N - 3满足要求，所以此时答案为N * (N - 1) * (N - 3)。</p>
<p>  2.2 当3能整除N时</p>
<p>​        因为N能够被3整除，所以N - 3同样能被3整除，为了不违反第1点，我们再次优先用更小的值替代 N -3（为什么又是换掉第三个？因为我贪心啊）。</p>
<p>  所以根据贪心策略，在放弃修改最小的数（在这里是N - 3）时，我们优先考虑换掉第中间大小的数（在这里是N - 2）。但是会发现，无论是使用N - 3、N - 4、N - 5……中的哪一个去替换N - 2，其结果都是跟替换最小的数（在这里是N - 3）的结果是一样的。</p>
<p>​        所以我们只能开始考虑使用更小的值去替换最大的数，也就是N。<br>    因为采用的是贪心策略，所以我们优先考虑使用N - 1去替换N，此时结果是：(N - 1) * (N - 2) * ( N - 3)。<br>  显然相邻的两个正整数是互质的，我们只要考虑N - 1和N - 3是否互质就可以了。</p>
<p>因为N - 1和 N - 3实际上等同于第1种情况，即N为奇数时，故 (N - 1) * (N - 2) * ( N - 3) 就是题目答案了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n%<span class="number">2</span> != <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; n*(n<span class="number">-1</span>)*(n<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n%<span class="number">3</span> != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n*(n<span class="number">-1</span>)*(n<span class="number">-3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; (n<span class="number">-1</span>)*(n<span class="number">-2</span>)*(n<span class="number">-3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>公因数</tag>
        <tag>公倍数</tag>
      </tags>
  </entry>
  <entry>
    <title>求解线性方程组的三种迭代法</title>
    <url>/posts/23cd5066.html</url>
    <content><![CDATA[<p>在Matlab快速入门笔记（二）中已经提到了两种迭代法，但是并没有对敛散性进行判断。</p>
<p>参考：</p>
<ul>
<li><p>《Numerical Analysis》(Seventh Edition)–Richard L. Burden</p>
</li>
<li><p>《数值分析及其MATLAB实现》–任玉杰</p>
</li>
</ul>
<p>这里根据其书加上对敛散性的判断。</p>
<span id="more"></span>

<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 用Jacobi迭代法求解AX=b，X0为初始向量，p为范数名称(1,2,inf)，error为误差，t为迭代次数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">X</span> = <span class="title">Jacobi</span><span class="params">(A,b,X0,p,error,t)</span></span></span><br><span class="line">[n,m] = <span class="built_in">size</span>(A);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:m</span><br><span class="line">        a(<span class="built_in">j</span>) = sum(<span class="built_in">abs</span>(A(:,<span class="built_in">j</span>))) - <span class="number">2</span>*(<span class="built_in">abs</span>(A(<span class="built_in">j</span>,<span class="built_in">j</span>)));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">        <span class="keyword">if</span> a(<span class="built_in">i</span>) &gt;= <span class="number">0</span></span><br><span class="line">            <span class="built_in">disp</span>(<span class="string">&#x27;系数矩阵A不是严格对角占优阵，Jacobi迭代不一定收敛&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> a(<span class="built_in">i</span>) &lt; <span class="number">0</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;系数矩阵A是严格对角占优阵，Jacobi迭代一定收敛&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:t</span><br><span class="line">    k;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:m</span><br><span class="line">        X(<span class="built_in">j</span>) = (b(<span class="built_in">j</span>)-A(<span class="built_in">j</span>,[<span class="number">1</span>:<span class="built_in">j</span><span class="number">-1</span>,<span class="built_in">j</span>+<span class="number">1</span>:m])*X0([<span class="number">1</span>:<span class="built_in">j</span><span class="number">-1</span>,<span class="built_in">j</span>+<span class="number">1</span>:m]))/A(<span class="built_in">j</span>,<span class="built_in">j</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    djwcx = norm(X&#x27;-X0,p);xdwcx = djwcx/(norm(X&#x27;,p)+<span class="built_in">eps</span>);</span><br><span class="line">    X0 = X&#x27;;X1 = A\b;</span><br><span class="line">    <span class="keyword">if</span> (djwcx&lt;error)&amp;(xdwcx&lt;error)</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;Jacobi迭代收敛，方程组的精确解jX和近似解X如下：&#x27;</span>)</span><br><span class="line">        k</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span>(djwcx&gt;error)&amp;(xdwcx&gt;error)</span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;Jacobi迭代次数超过上限次数 t &#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">a,X = X;jX = X1&#x27;,</span><br><span class="line"><span class="comment">% A = [2 -1 1;1 1 1;-1 -1 2]</span></span><br><span class="line"><span class="comment">% b = [1 ;2 ;-5]</span></span><br><span class="line"><span class="comment">% X0 = [0 0 0]&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/23cd5066/image-20210423184726484.png" alt="image-20210423184726484"></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 用Gauss迭代法求解AX=b，X0为初始向量，p为范数名称(1,2,inf)，error为误差，t为迭代次数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">X</span> = <span class="title">Gauss</span><span class="params">(A,b,X0,p,error,t)</span></span></span><br><span class="line">D = <span class="built_in">diag</span>(<span class="built_in">diag</span>(A));U = -<span class="built_in">triu</span>(A,<span class="number">1</span>);</span><br><span class="line">L = -<span class="built_in">tril</span>(A,<span class="number">-1</span>);dD = det(D);</span><br><span class="line"><span class="keyword">if</span> dD == <span class="number">0</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;因为对角矩阵D奇异，方程组无解&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;因为对角矩阵D非奇异，方程组有解&#x27;</span>)</span><br><span class="line">    iD = inv(D-L);B2 = iD*U;f2 = iD*b;jX = A\b;</span><br><span class="line">    X = X0;[n m] = <span class="built_in">size</span>(A);</span><br><span class="line">    <span class="keyword">for</span> k = <span class="number">1</span>:t</span><br><span class="line">        X1 = B2*X+f2;djwcx = norm(X1-X,p);</span><br><span class="line">        xdwcx = djwcx/(norm(X,p)+<span class="built_in">eps</span>);</span><br><span class="line">        <span class="keyword">if</span> (djwcx&lt;error) | (xdwcx&lt;error)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            K = k+<span class="number">1</span>;X= X1;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> (djwcx&lt;error) | (xdwcx&lt;error)</span><br><span class="line">        k</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;Gauss迭代法收敛,方程组的精确解jX和近似解X如下：&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;Gauss迭代法没有达到给定精度，迭代次数超过上限t，方程组的精确解jX和迭代向量X如下：&#x27;</span>)</span><br><span class="line">        X = X&#x27;;jX = jX&#x27;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">X = X&#x27;;D,U,L,jX = jX&#x27;</span><br><span class="line"><span class="comment">% A = [10 -1 -2;-1 10 -2;-1 -1 0.5]</span></span><br><span class="line"><span class="comment">% b = [7.2;8.3;4.2]</span></span><br><span class="line"><span class="comment">% X0 = [0 0 0]&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/23cd5066/image-20210423190047226.png" alt="image-20210423190047226"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">% 用SOR迭代法求解AX=b，X为初始向量，om为松弛因子，error为误差，t为迭代次数</span><br><span class="line">function X = SOR(A,b,X,om,error,t)</span><br><span class="line">D = diag(diag(A));U = -triu(A,<span class="number">1</span>);</span><br><span class="line">L = -tril(A,<span class="number">-1</span>);jX = A\b;[n m] = size(A);</span><br><span class="line">iD = inv(D-om*L);B2= iD*(om*U + (<span class="number">1</span>-om)*D);</span><br><span class="line">H = eig(B2);mH = norm(H,inf);</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:t</span><br><span class="line">    iD = inv(D-om*L);B2= iD*(om*U + (<span class="number">1</span>-om)*D);</span><br><span class="line">    f2 = om*iD*b;X1 = B2*X+f2;</span><br><span class="line">    X = X1;djwcx = norm(X1-jX,inf);xdwcx = djwcx/(norm(X,inf)+eps);</span><br><span class="line">end</span><br><span class="line"><span class="keyword">if</span> mH &gt;= <span class="number">1</span></span><br><span class="line">    disp(&#x27;因为谱半径不小于1，SOR序列发散&#x27;)</span><br><span class="line">    disp(&#x27;谱半径mH，A的分解矩阵D，U，L和方程组的精确解jX和近似解X如下：&#x27;)</span><br><span class="line">    mH,D,U,L,jX,</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    disp(&#x27;因为谱半径小于1，SOR序列收敛&#x27;)</span><br><span class="line">    <span class="keyword">if</span> (djwcx&lt;error)|(xdwcx&lt;error)</span><br><span class="line">        disp(&#x27;谱半径mH，A的分解矩阵D，U，L和方程组的精确解jX和近似解X如下：&#x27;)</span><br><span class="line">        mH,D,U,L,jX = jX<span class="number">&#x27;</span>,</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        disp(&#x27;迭代次数已经超过上限t，谱半径mH，方程组的精确解jX和迭代向量X如下：&#x27;)</span><br><span class="line">        mH,D,U,L,X = X1<span class="number">&#x27;</span>;jX = jX<span class="number">&#x27;</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">% A = [<span class="number">5</span> <span class="number">1</span> <span class="number">-1</span> <span class="number">-2</span>;<span class="number">2</span> <span class="number">8</span> <span class="number">1</span> <span class="number">3</span>;<span class="number">1</span> <span class="number">-2</span> <span class="number">-4</span> <span class="number">-1</span>;<span class="number">-1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">7</span>;]</span><br><span class="line">% b = [<span class="number">4</span>;<span class="number">1</span>;<span class="number">6</span>;<span class="number">-3</span>]</span><br><span class="line">% X = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]&#x27;</span><br><span class="line">% X = SOR(A,b,X,<span class="number">1.15</span>,<span class="number">0.001</span>,<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/posts/23cd5066/image-20210423191102860.png" alt="image-20210423191102860"></p>
]]></content>
      <categories>
        <category>Matlab</category>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title>汇编入门笔记（一）</title>
    <url>/posts/52680586.html</url>
    <content><![CDATA[<h2 id="汇编语言的产生"><a href="#汇编语言的产生" class="headerlink" title="汇编语言的产生"></a>汇编语言的产生</h2><p>汇编语言的主体就是汇编指令，可以说汇编指令是机器指令便于记忆的书写格式。</p>
<p><a href="https://www.bilibili.com/video/BV1ni4y1G7B9?p=2">推荐配合食用视频</a></p>
<span id="more"></span>

<p>编译器：将汇编指令转换成机器指令的翻译程序。</p>
<p><img src="/posts/52680586/image-20210319191835269.png" alt="image-20210319191835269"></p>
<p>我们在不断向上学习的过程中，不应该忘掉基础的底层知识，汇编语言就是了解底层核心的重要内容之一。</p>
<p>向上学习是应用，向下学习是本质，这就是精髓。</p>
<p><img src="/posts/52680586/image-20210319191956762.png" alt="image-20210319191956762"></p>
<h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><ul>
<li>N进制：逢N进一。</li>
</ul>
<p><img src="/posts/52680586/image-20210319192751867.png" alt="image-20210319192751867"></p>
<ul>
<li>进制的计算：本质也就是查数进行运算。通过构建加法表、乘法表来快速运算。</li>
</ul>
<p>事实上，减法、乘法和除法本质上都是由加法实现的。</p>
<p><img src="/posts/52680586/image-20210319195853542.png" alt="image-20210319195853542"></p>
<ul>
<li>进制的应用：</li>
</ul>
<p>可以自己定义进制的符号，以此来加密解密。</p>
<ul>
<li>为什么要用十六进制？</li>
</ul>
<p>为了我们方便理解二进制。二进制与十六进制的转换很方便，最好不要混入十进制。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 二进制</span></span><br><span class="line">0 1 10 11 100 101 110 111 1000 1001 1010 1011 1100 1101 1110 1111</span><br><span class="line"><span class="meta">#</span><span class="bash"> 十六进制</span></span><br><span class="line">0 1 2 3 4 5 6 7 8 9 a b c d e f</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么要学习理解二进制？</li>
</ul>
<p>为了理解寄存器、内存、位。底层的每一个位都是有含义的。这是汇编入门理解的基础。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">十进制 二进制</span><br><span class="line">2     10</span><br><span class="line">4     100</span><br><span class="line">8     1000</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h2 id="数据宽度"><a href="#数据宽度" class="headerlink" title="数据宽度"></a>数据宽度</h2><p><img src="/posts/52680586/image-20210319204923167.png" alt="image-20210319204923167"></p>
<p>C等强类型语言之所以要定义数据的类型，是因为计算机底层需要给数据定义宽度。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">位 0 1</span><br><span class="line">字节 0~0xFF (一个F对应二进制的1111，四个位) 8位</span><br><span class="line">字 0~0xFFFF 16位</span><br><span class="line">双字 0~0xFFFFFFFF 32位</span><br></pre></td></tr></table></figure>

<p>在计算机中，每一个数据都需要给他定义类型，也就是定义宽度，在内存中的宽度。</p>
<h2 id="有符号数无符号数"><a href="#有符号数无符号数" class="headerlink" title="有符号数无符号数"></a>有符号数无符号数</h2><p>现在我们给二进制的解码增加一些规则。</p>
<p><strong>无符号规则</strong></p>
<p>数字原来是多少，就是多少。</p>
<p><strong>有符号规则</strong></p>
<p>最高位设定为符号位：1为负数，0为正数</p>
<h2 id="原码反码补码"><a href="#原码反码补码" class="headerlink" title="原码反码补码"></a>原码反码补码</h2><p><strong>有符号数的编码规则</strong></p>
<ol>
<li><p>原码：最高位是符号位，其余位是数值位，原码又称为带符号的绝对值。</p>
</li>
<li><p>反码：</p>
<ul>
<li>正数：它的反码与它的原码相同</li>
<li>负数：符号位一定是1，其余位对原码取反</li>
</ul>
</li>
<li><p>补码：</p>
<ul>
<li><p>在计算机中，所有数都是用补码表示</p>
</li>
<li><p>用到mod的概念，正数关于模的补数就是本身，负数加上关于模的补数就是模</p>
</li>
<li><p>正数：它的补码与它的原码相同</p>
</li>
<li><p>负数：符号位一定是1，反码+1</p>
</li>
</ul>
</li>
</ol>
<p><img src="/posts/52680586/image-20210319212114263.png" alt="image-20210319212114263"></p>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="1-与运算（and-amp-）"><a href="#1-与运算（and-amp-）" class="headerlink" title="1.与运算（and &amp;）"></a>1.与运算（and &amp;）</h3><p>两个都是1才是1.</p>
<h3 id="2-或运算（or-）"><a href="#2-或运算（or-）" class="headerlink" title="2.或运算（or |）"></a>2.或运算（or |）</h3><p>有一个是1就是1.</p>
<h3 id="3-异或运算（xor-）"><a href="#3-异或运算（xor-）" class="headerlink" title="3.异或运算（xor  ^）"></a>3.异或运算（xor  ^）</h3><p>两个不同就是1.</p>
<h3 id="4-非运算（not-）"><a href="#4-非运算（not-）" class="headerlink" title="4.非运算（not ~）"></a>4.非运算（not ~）</h3><p>取反.</p>
<p><img src="/posts/52680586/image-20210319215558791.png" alt="狂神的XOR电路"></p>
<h3 id="5-移位运算"><a href="#5-移位运算" class="headerlink" title="5.移位运算"></a>5.移位运算</h3><p><img src="/posts/52680586/image-20210319215902762.png" alt="image-20210319215902762"></p>
<h3 id="6-位运算的加减乘除（这是精华）"><a href="#6-位运算的加减乘除（这是精华）" class="headerlink" title="6.位运算的加减乘除（这是精华）"></a>6.位运算的加减乘除（这是精华）</h3><p>计算机只认识 0 1</p>
<p>基本数学是建立在 加减乘除。（加法）</p>
<p>4+5？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 计算机是怎么操作的！</span></span><br><span class="line">0000 0100</span><br><span class="line">0000 0101</span><br><span class="line">---------- （加法：计算机是不会直接加的）</span><br><span class="line">0000 1001</span><br><span class="line"><span class="meta">#</span><span class="bash"> 计算机的实现原理</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第一步：异或： 如果不考虑进位，异或就可以直接出结果。</span></span><br><span class="line">0000 0100</span><br><span class="line">0000 0101</span><br><span class="line">------------</span><br><span class="line">0000 0001</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二步：与运算（判断进位，如果与运算结果为0，没有进位。）</span></span><br><span class="line">0000 0100</span><br><span class="line">0000 0101</span><br><span class="line">------------</span><br><span class="line">0000 0100</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第三步：将与运算的结果，左移一位。 0000 1000 <span class="comment"># 进位的结果</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第四步：异或！</span></span><br><span class="line">0000 0001</span><br><span class="line">0000 1000</span><br><span class="line">-------------</span><br><span class="line">0000 1001</span><br><span class="line"><span class="meta">#</span><span class="bash"> 第五步：与运算（判断进位，如果与运算结果为0，没有进位。）</span></span><br><span class="line">0000 0001</span><br><span class="line">0000 1000</span><br><span class="line">-----------</span><br><span class="line">0000 0000</span><br><span class="line"><span class="meta">#</span><span class="bash"> 所以最终的结果就是与运算为0的结果的上一个异或运算。</span></span><br></pre></td></tr></table></figure>

<p>4-5?</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 计算机是怎么操作的！</span></span><br><span class="line">4+(-5)</span><br><span class="line">0000 0100</span><br><span class="line">1111 1011</span><br><span class="line">---------- （减法：计算机是不会直接减的）</span><br><span class="line">1111 1111</span><br><span class="line"></span><br><span class="line">0000 0100</span><br><span class="line">1111 1011</span><br><span class="line">----------- 异或(如果不考虑进位，异或就可以直接出结果。)</span><br><span class="line">1111 1111</span><br><span class="line"></span><br><span class="line">0000 0100</span><br><span class="line">1111 1011</span><br><span class="line">----------- 与（判断进位，如果与运算结果为0，没有进位。）</span><br><span class="line">0000 0000</span><br><span class="line"></span><br><span class="line">最终结果 1111 1111 (16) ff (10) -1</span><br></pre></td></tr></table></figure>

<p>乘：x*y， 就是 y 个 x 相加，还是加法</p>
<p>除：x/y， 本质就是减法，就是X 能减去多少个Y。</p>
<p><strong>计算机只会做加法！</strong></p>
<p><strong>机器语言就是位运算。都是电路来实现的。这就是计算机的最底层的本质。</strong></p>
<p>通过机器语言来实现加法计算器。设计电路。</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出计算机组成原理（一）</title>
    <url>/posts/834810f8.html</url>
    <content><![CDATA[<h2 id="计算机底层知识的第一课"><a href="#计算机底层知识的第一课" class="headerlink" title="计算机底层知识的第一课"></a>计算机底层知识的第一课</h2><p>“计算机组成原理”是入门和底层层面的第一课。</p>
<p>除此之外，组成原理是计算机其他核心课程的一个“导引”。</p>
<p><img src="/posts/834810f8/image-20210314205006877.png" alt="image-20210314205006877"></p>
<span id="more"></span>

<h2 id="计算机的基本硬件组成"><a href="#计算机的基本硬件组成" class="headerlink" title="计算机的基本硬件组成"></a>计算机的基本硬件组成</h2><p>早年，要自己组装一台计算机，要先有<strong>三大件，CPU、内存和主板</strong>。</p>
<p>在这三大件中，我们首先要说的是 CPU，它是<strong>计算机最重要的核心配件</strong>，全名你肯定知道，叫中央处理器（Central Processing Unit）。为什么说 CPU 是“最重要”的呢？因为计算机的所有“计算”都是由 CPU 来进行的。自然，CPU 也是整台计算机中造价最昂贵的部分之一。</p>
<p>第二个重要的配件，就是内存（Memory）。你撰写的程序、打开的浏览器、运行的游戏，都要加载到内存里才能运行。程序读取的数据、计算得到的结果，也都要放在内存里。内存越大，能加载的东西自然也就越多。</p>
<p>存放在内存里的程序和数据，需要被 CPU 读取，CPU 计算完之后，还要把数据写回到内存。然而 CPU 不能直接插到内存上，反之亦然。于是，就带来了最后一个大件——主板（Motherboard）。</p>
<p>主板是一个有着各种各样，有时候多达数十乃至上百个插槽的配件。我们的 CPU 要插在主板上，内存也要插在主板上。主板的芯片组（Chipset）和总线（Bus）解决了 CPU 和内存之间如何通信的问题。芯片组控制了数据传输的流转，也就是数据从哪里到哪里的问题。总线则是实际数据传输的高速公路。因此，总线速度（Bus Speed）决定了数据能传输得多快。</p>
<p>有了三大件，只要配上电源供电，计算机差不多就可以跑起来了。但是现在还缺少各类输入（Input）/ 输出（Output）设备，也就是我们常说的 I/O 设备。如果你用的是自己的个人电脑，那显示器肯定必不可少，只有有了显示器我们才能看到计算机输出的各种图像、文字，这也就是所谓的输出设备。同样的，鼠标和键盘也都是必不可少的配件。这样我才能输入文本，写下这篇文章。它们也就是所谓的输入设备。</p>
<p>最后，你自己配的个人计算机，还要配上一个硬盘。这样各种数据才能持久地保存下来。绝大部分人都会给自己的机器装上一个机箱，配上风扇，解决灰尘和散热的问题。不过机箱和风扇，算不上是计算机的必备硬件，我们拿个纸板或者外面放个电风扇，也一样能用。</p>
<p>说了这么多，其实你应该有感觉了，显示器、鼠标、键盘和硬盘这些东西并不是一台计算机必须的部分。你想一想，我们其实只需要有 I/O 设备，能让我们从计算机里输入和输出信息，是不是就可以了？答案当然是肯定的。</p>
<p>你肯定去过网吧吧？不知道你注意到没有，很多网吧的计算机就没有硬盘，而是直接通过局域网，读写远程网络硬盘里面的数据。我们日常用的各类云服务器，只要让计算机能通过网络，SSH 远程登陆访问就好了，因此也没必要配显示器、鼠标、键盘这些东西。这样不仅能够节约成本，还更方便维护。</p>
<p>还有一个很特殊的设备，就是显卡（Graphics Card）。现在，使用图形界面操作系统的计算机，无论是 Windows、Mac OS 还是 Linux，显卡都是必不可少的。有人可能要说了，我装机的时候没有买显卡，计算机一样可以正常跑起来啊！那是因为，现在的主板都带了内置的显卡。如果你用计算机玩游戏，做图形渲染或者跑深度学习应用，你多半就需要买一张单独的显卡，插在主板上。显卡之所以特殊，是因为显卡里有除了 CPU 之外的另一个“处理器”，也就是 GPU（Graphics Processing Unit，图形处理器），GPU 一样可以做各种“计算”的工作。</p>
<p>鼠标、键盘以及硬盘，这些都是插在主板上的。作为外部 I/O 设备，它们是通过主板上的南桥（SouthBridge）芯片组，来控制和 CPU 之间的通信的。“南桥”芯片的名字很直观，一方面，它在主板上的位置，通常在主板的“南面”。另一方面，它的作用就是作为“桥”，来连接鼠标、键盘以及硬盘这些外部设备和 CPU 之间的通信。</p>
<h2 id="冯·诺依曼体系结构"><a href="#冯·诺依曼体系结构" class="headerlink" title="冯·诺依曼体系结构"></a>冯·诺依曼体系结构</h2><p>刚才我们讲了一台计算机的硬件组成，这说的是我们平时用的个人电脑或者服务器。那我们平时最常用的智能手机的组成，也是这样吗？</p>
<p>我们手机里只有 SD 卡（Secure Digital Memory Card）这样类似硬盘功能的存储卡插槽，并没有内存插槽、CPU 插槽这些东西。没错，因为手机尺寸的原因，手机制造商们选择把 CPU、内存、网络通信，乃至摄像头芯片，都封装到一个芯片，然后再嵌入到手机主板上。这种方式叫 SoC，也就是 System on a Chip（系统芯片）。</p>
<p>这样看起来，个人电脑和智能手机的硬件组成方式不太一样。可是，我们写智能手机上的 App，和写个人电脑的客户端应用似乎没有什么差别，都是通过“高级语言”这样的编程语言撰写、编译之后，一样是把代码和数据加载到内存里来执行。这是为什么呢？因为，无论是个人电脑、服务器、智能手机，还是 Raspberry Pi 这样的微型卡片机，<u>都遵循着同一个“计算机”的抽象概念</u>。这是怎么样一个“计算机”呢？这其实就是，计算机祖师爷之一冯·诺依曼（John von Neumann）提出的<strong>冯·诺依曼体系结构</strong>（Von Neumann architecture），也叫<strong>存储程序计算机</strong>。</p>
<p>什么是存储程序计算机呢？这里面其实暗含了两个概念，<strong>一个是“可编程”计算机，一个是“存储”计算机</strong>。</p>
<p>说到“可编程”，估计你会有点懵，你可以先想想，什么是“不可编程”。计算机是由各种门电路组合而成的，然后通过组装出一个固定的电路板，来完成一个特定的计算程序。一旦需要修改功能，就要重新组装电路。这样的话，计算机就是“不可编程”的，因为程序在计算机硬件层面是“写死”的。最常见的就是老式计算器，电路板设好了加减乘除，做不了任何计算逻辑固定之外的事情。</p>
<blockquote>
<p>例如计算器的本质是一个不可编程的计算机。</p>
</blockquote>
<p>我们再来看“存储”计算机。这其实是说，程序本身是存储在计算机的内存里，可以通过加载不同的程序来解决不同的问题。有“存储程序计算机”，自然也有不能存储程序的计算机。典型的就是早年的“Plugboard”这样的插线板式的计算机。整个计算机就是一个巨大的插线板，通过在板子上不同的插头或者接口的位置插入线路，来实现不同的功能。这样的计算机自然是“可编程”的，但是编写好的程序不能存储下来供下一次加载使用，不得不每次要用到和当前不同的“程序”的时候，重新插板子，重新“编程”。</p>
<p>可以看到，无论是“不可编程”还是“不可存储”，都会让使用计算机的效率大大下降。而这个对于效率的追求，也就是“存储程序计算机”的由来。</p>
<p>祖师爷冯诺依曼在EDVAC的第一份草案First Draft 里面说了一台计算机应该有哪些部分组成，我们一起来看看。</p>
<p>首先是一个包含<strong>算术逻辑单元</strong>（Arithmetic Logic Unit，ALU）和处理器寄存器（Processor Register）的<strong>处理器单元</strong>（Processing Unit），用来完成各种算术和逻辑运算。因为它能够完成各种数据的处理或者计算工作，因此也有人把这个叫作数据通路（Datapath）或者运算器。</p>
<p>然后是一个包含指令寄存器（Instruction Register）和程序计数器（Program Counter）的<strong>控制器单元</strong>（Control Unit/CU），用来控制程序的流程，通常就是不同条件下的分支和跳转。在现在的计算机里，<strong>上面的算术逻辑单元和这里的控制器单元，共同组成了我们说的 CPU</strong>。</p>
<p>接着是用来存储数据（Data）和指令（Instruction）的内存。以及更大容量的外部存储，在过去，可能是磁带、磁鼓这样的设备，现在通常就是硬盘。</p>
<p>最后就是各种输入和输出设备，以及对应的输入和输出机制。我们现在无论是使用什么样的计算机，其实都是和输入输出设备在打交道。个人电脑的鼠标键盘是输入设备，显示器是输出设备。我们用的智能手机，触摸屏既是输入设备，又是输出设备。而跑在各种云上的服务器，则是通过网络来进行输入和输出。这个时候，网卡既是输入设备又是输出设备。</p>
<p><strong>任何一台计算机的任何一个部件都可以归到运算器、控制器、存储器、输入设备和输出设备中，而所有的现代计算机也都是基于这个基础架构来设计开发的。</strong></p>
<p>而所有的计算机程序，也都可以抽象为从输入设备读取输入信息，通过运算器和控制器来执行存储在存储器里的程序，最终把结果输出到输出设备中。而我们所有撰写的无论高级还是低级语言的程序，也都是基于这样一个抽象框架来进行运作的。</p>
<p><img src="/posts/834810f8/image-20210314212309527.png" alt="冯·诺依曼体系结构示意图"></p>
<h2 id="冯·诺依曼机与图灵机的思考"><a href="#冯·诺依曼机与图灵机的思考" class="headerlink" title="冯·诺依曼机与图灵机的思考"></a>冯·诺依曼机与图灵机的思考</h2><p>计算机行业的两大祖师爷之一，除了冯·诺依曼机之外，还有一位就是著名的图灵（Alan Mathison Turing）。对应的，我们现在的计算机也叫图灵机（Turing Machine）。那么图灵机和冯·诺依曼机是两种不同的计算机么？图灵机是一种什么样的计算机抽象呢？</p>
<p>两者有交叉但是不同，根据了解整理如下：<br>- 图灵机是一种思想模型（计算机的基本理论基础），是一种有穷的、构造性的问题的问题求解思路，图灵认为凡是能用算法解决的问题也一定能用图灵机解决；<br>- 冯诺依曼提出了“存储程序”的计算机设计思想，并“参照”图灵模型设计了历史上第一台电子计算机，即冯诺依曼机。<br>ps：有看到一种有争议说法：冯诺依曼机是图灵机的实现，感觉这有点过于片面，所以上述姑且改为参照</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编入门笔记（二）</title>
    <url>/posts/627ee95e.html</url>
    <content><![CDATA[<blockquote>
<p>学汇编不是为了写代码，而是为了理解编程的本质。</p>
</blockquote>
<span id="more"></span>

<h2 id="如何学习汇编"><a href="#如何学习汇编" class="headerlink" title="如何学习汇编"></a>如何学习汇编</h2><p>《汇编语言》 16位的汇编 32位 64位（本质架构区别不大，寻址能力增加。）</p>
<p><strong>建议大家可以直接学习32位汇编！</strong></p>
<p><strong>汇编入门：了解汇编和程序的对应关系，程序的本质即可！</strong></p>
<h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p><img src="/posts/627ee95e/image-20210319223115888.png" alt="image-20210319223115888"></p>
<p>32位通用寄存器的存值的范围：0 ~ FFFFFFFF</p>
<p>32位通用寄存器只有8个</p>
<p>计算机如何向寄存器存值？</p>
<p>通过<strong>mov指令</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov 存的地址,存的数</span><br><span class="line">mov 存的地址1,存的地址2</span><br></pre></td></tr></table></figure>

<p>可以将数字写入寄存器，也可以将寄存器的值写到寄存器。</p>
<p><img src="/posts/627ee95e/image-20210319223856408.png" alt="image-20210319223856408"></p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>寄存器地址有限，不够用，所以将数据放到内存。</p>
<p><img src="/posts/627ee95e/image-20210319224440106.png" alt="image-20210319224440106"></p>
<p>32位操作系统的最大寻址能力就是$2^{32}$个字节，也就是4GB。</p>
<p><img src="/posts/627ee95e/image-20210319225424942.png" alt="image-20210319225424942"></p>
<p><img src="/posts/627ee95e/image-20210319225853237.png" alt="image-20210319225853237"></p>
<p>汇编向内存写入值。</p>
<p><img src="/posts/627ee95e/image-20210319230235118.png" alt="image-20210319230235118"></p>
<p><img src="/posts/627ee95e/image-20210319230803539.png" alt="image-20210319230803539"></p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出计算机组成原理（七）</title>
    <url>/posts/91fdbf16.html</url>
    <content><![CDATA[<h2 id="编译、链接和装载：拆解程序执行"><a href="#编译、链接和装载：拆解程序执行" class="headerlink" title="编译、链接和装载：拆解程序执行"></a>编译、链接和装载：拆解程序执行</h2><p>我们说过，写好的 C 语言代码，可以通过编译器编译成汇编代码，然后汇编代码再通过汇编器变成 CPU 可以理解的机器码，于是 CPU 就可以执行这些机器码了。你现在对这个过程应该不陌生了，但是这个描述把过程大大简化了。下面，我们一起具体来看，C 语言程序是如何变成一个可执行程序的。</p>
<span id="more"></span>

<p>不知道你注意到没有，过去几节，我们通过 <code>gcc</code> 生成的文件和 <code>objdump</code> 获取到的汇编指令都有些小小的问题。我们先把前面的 add 函数示例，拆分成两个文件 <code>add_lib.c</code> 和 <code>link_example.c</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add_lib.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// link_example.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> c = add(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %d\n&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过 <code>gcc</code> 来编译这两个文件，然后通过 <code>objdump</code> 命令看看它们的汇编代码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -g -c add_lib.c link_example.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> objdump -d -M intel -S add_lib.o</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> objdump -d -M intel -S link_example.o</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">add_lib.o:     file format elf64-x86-64</span><br><span class="line">Disassembly of section .text:</span><br><span class="line">0000000000000000 &lt;add&gt;:</span><br><span class="line">   0:   55                      push   rbp</span><br><span class="line">   1:   48 89 e5                mov    rbp,rsp</span><br><span class="line">   4:   89 7d fc                mov    DWORD PTR [rbp-0x4],edi</span><br><span class="line">   7:   89 75 f8                mov    DWORD PTR [rbp-0x8],esi</span><br><span class="line">   a:   8b 55 fc                mov    edx,DWORD PTR [rbp-0x4]</span><br><span class="line">   d:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]</span><br><span class="line">  10:   01 d0                   add    eax,edx</span><br><span class="line">  12:   5d                      pop    rbp</span><br><span class="line">  13:   c3                      ret    </span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">link_example.o:     file format elf64-x86-64</span><br><span class="line">Disassembly of section .text:</span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:   55                      push   rbp</span><br><span class="line">   1:   48 89 e5                mov    rbp,rsp</span><br><span class="line">   4:   48 83 ec 10             sub    rsp,0x10</span><br><span class="line">   8:   c7 45 fc 0a 00 00 00    mov    DWORD PTR [rbp-0x4],0xa</span><br><span class="line">   f:   c7 45 f8 05 00 00 00    mov    DWORD PTR [rbp-0x8],0x5</span><br><span class="line">  16:   8b 55 f8                mov    edx,DWORD PTR [rbp-0x8]</span><br><span class="line">  19:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]</span><br><span class="line">  1c:   89 d6                   mov    esi,edx</span><br><span class="line">  1e:   89 c7                   mov    edi,eax</span><br><span class="line">  20:   b8 00 00 00 00          mov    eax,0x0</span><br><span class="line">  25:   e8 00 00 00 00          call   2a &lt;main+0x2a&gt;</span><br><span class="line">  2a:   89 45 f4                mov    DWORD PTR [rbp-0xc],eax</span><br><span class="line">  2d:   8b 45 f4                mov    eax,DWORD PTR [rbp-0xc]</span><br><span class="line">  30:   89 c6                   mov    esi,eax</span><br><span class="line">  32:   48 8d 3d 00 00 00 00    lea    rdi,[rip+0x0]        # 39 &lt;main+0x39&gt;</span><br><span class="line">  39:   b8 00 00 00 00          mov    eax,0x0</span><br><span class="line">  3e:   e8 00 00 00 00          call   43 &lt;main+0x43&gt;</span><br><span class="line">  43:   b8 00 00 00 00          mov    eax,0x0</span><br><span class="line">  48:   c9                      leave  </span><br><span class="line">  49:   c3                      ret    </span><br></pre></td></tr></table></figure>

<p>既然代码已经被我们“编译”成了指令，我们不妨尝试运行一下 <code>./link_example.o</code>。</p>
<p>不幸的是，文件没有执行权限，我们遇到一个 <code>Permission denied</code> 错误。即使通过 <code>chmod</code> 命令赋予 <code>link_example.o</code> 文件可执行的权限，运行<code>./link_example.o</code> 仍然只会得到一条 <code>cannot execute binary file: Exec format error</code> 的错误。</p>
<p>我们再仔细看一下 objdump 出来的两个文件的代码，会发现两个程序的地址都是从 0 开始的。如果地址是一样的，程序如果需要通过 call 指令调用函数的话，它怎么知道应该跳转到哪一个文件里呢？</p>
<p>这么说吧，无论是这里的运行报错，还是 objdump 出来的汇编代码里面的重复地址，都是因为 add_lib.o 以及 link_example.o 并不是一个<strong>可执行文件</strong>（Executable Program），而是<strong>目标文件</strong>（Object File）。只有通过链接器（Linker）把多个目标文件以及调用的各种函数库链接起来，我们才能得到一个可执行文件。</p>
<p>我们通过 gcc 的 -o 参数，可以生成对应的可执行文件，对应执行之后，就可以得到这个简单的加法调用函数的结果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -o link-example add_lib.o link_example.o</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./link_example</span></span><br><span class="line">c = 15</span><br></pre></td></tr></table></figure>

<p>实际上，<strong>“C 语言代码 - 汇编代码 - 机器码”</strong> 这个过程，在我们的计算机上进行的时候是由两部分组成的。</p>
<p>第一个部分由编译（Compile）、汇编（Assemble）以及链接（Link）三个阶段组成。在这三个阶段完成之后，我们就生成了一个可执行文件。</p>
<p>第二部分，我们通过装载器（Loader）把可执行文件装载（Load）到内存中。CPU 从内存中读取指令和数据，来开始真正执行程序。</p>
<p><img src="/posts/91fdbf16/image-20210426213114946.png" alt="image-20210426213114946"></p>
<h2 id="ELF-格式和链接：理解链接过程"><a href="#ELF-格式和链接：理解链接过程" class="headerlink" title="ELF 格式和链接：理解链接过程"></a>ELF 格式和链接：理解链接过程</h2><p>程序最终是通过<strong>装载器</strong>变成指令和数据的，所以其实我们生成的可执行代码也并不仅仅是一条条的指令。我们还是通过 objdump 指令，把可执行文件的内容拿出来看看。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">link_example:     file format elf64-x86-64</span><br><span class="line">Disassembly of section .init:</span><br><span class="line">...</span><br><span class="line">Disassembly of section .plt:</span><br><span class="line">...</span><br><span class="line">Disassembly of section .plt.got:</span><br><span class="line">...</span><br><span class="line">Disassembly of section .text:</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"> 6b0:   55                      push   rbp</span><br><span class="line"> 6b1:   48 89 e5                mov    rbp,rsp</span><br><span class="line"> 6b4:   89 7d fc                mov    DWORD PTR [rbp-0x4],edi</span><br><span class="line"> 6b7:   89 75 f8                mov    DWORD PTR [rbp-0x8],esi</span><br><span class="line"> 6ba:   8b 55 fc                mov    edx,DWORD PTR [rbp-0x4]</span><br><span class="line"> 6bd:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]</span><br><span class="line"> 6c0:   01 d0                   add    eax,edx</span><br><span class="line"> 6c2:   5d                      pop    rbp</span><br><span class="line"> 6c3:   c3                      ret    </span><br><span class="line">00000000000006c4 &lt;main&gt;:</span><br><span class="line"> 6c4:   55                      push   rbp</span><br><span class="line"> 6c5:   48 89 e5                mov    rbp,rsp</span><br><span class="line"> 6c8:   48 83 ec 10             sub    rsp,0x10</span><br><span class="line"> 6cc:   c7 45 fc 0a 00 00 00    mov    DWORD PTR [rbp-0x4],0xa</span><br><span class="line"> 6d3:   c7 45 f8 05 00 00 00    mov    DWORD PTR [rbp-0x8],0x5</span><br><span class="line"> 6da:   8b 55 f8                mov    edx,DWORD PTR [rbp-0x8]</span><br><span class="line"> 6dd:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]</span><br><span class="line"> 6e0:   89 d6                   mov    esi,edx</span><br><span class="line"> 6e2:   89 c7                   mov    edi,eax</span><br><span class="line"> 6e4:   b8 00 00 00 00          mov    eax,0x0</span><br><span class="line"> 6e9:   e8 c2 ff ff ff          call   6b0 &lt;add&gt;</span><br><span class="line"> 6ee:   89 45 f4                mov    DWORD PTR [rbp-0xc],eax</span><br><span class="line"> 6f1:   8b 45 f4                mov    eax,DWORD PTR [rbp-0xc]</span><br><span class="line"> 6f4:   89 c6                   mov    esi,eax</span><br><span class="line"> 6f6:   48 8d 3d 97 00 00 00    lea    rdi,[rip+0x97]        # 794 &lt;_IO_stdin_used+0x4&gt;</span><br><span class="line"> 6fd:   b8 00 00 00 00          mov    eax,0x0</span><br><span class="line"> 702:   e8 59 fe ff ff          call   560 &lt;printf@plt&gt;</span><br><span class="line"> 707:   b8 00 00 00 00          mov    eax,0x0</span><br><span class="line"> 70c:   c9                      leave  </span><br><span class="line"> 70d:   c3                      ret    </span><br><span class="line"> 70e:   66 90                   xchg   ax,ax</span><br><span class="line">...</span><br><span class="line">Disassembly of section .fini:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>你会发现，可执行代码 dump 出来内容，和之前的目标代码长得差不多，但是长了很多。因为在 Linux 下，可执行文件和目标文件所使用的都是一种叫 <strong>ELF</strong>（Execuatable and Linkable File Format）的文件格式，中文名字叫<strong>可执行与可链接文件格式</strong>，这里面不仅存放了编译成的汇编指令，还保留了很多别的数据。</p>
<p>比如我们过去所有 objdump 出来的代码里，你都可以看到对应的函数名称，像 add、main 等等，乃至你自己定义的全局可以访问的变量名称，都存放在这个 ELF 格式文件里。这些名字和它们对应的地址，在 ELF 文件里面，存储在一个叫作<strong>符号表</strong>（Symbols Table）的位置里。符号表相当于一个地址簿，把名字和地址关联了起来。</p>
<p>我们先只关注和我们的 add 以及 main 函数相关的部分。你会发现，这里面，main 函数里调用 add 的跳转地址，不再是下一条指令的地址了，而是 add 函数的入口地址了，这就是 EFL 格式和链接器的功劳。</p>
<p><img src="/posts/91fdbf16/image-20210426213311974.png" alt="image-20210426213311974"></p>
<p>ELF 文件格式把各种信息，分成一个一个的 Section 保存起来。ELF 有一个基本的文件头（File Header），用来表示这个文件的基本属性，比如是否是可执行文件，对应的 CPU、操作系统等等。除了这些基本属性之外，大部分程序还有这么一些 Section：</p>
<ol>
<li>首先是.text Section，也叫作<strong>代码段或者指令段</strong>（Code Section），用来保存程序的代码和指令；</li>
<li>接着是.data Section，也叫作<strong>数据段</strong>（Data Section），用来保存程序里面设置好的初始化数据信息；</li>
<li>然后就是.rel.text Secion，叫作<strong>重定位表</strong>（Relocation Table）。重定位表里，保留的是当前的文件里面，哪些跳转地址其实是我们不知道的。比如上面的 link_example.o 里面，我们在 main 函数里面调用了 add 和 printf 这两个函数，但是在链接发生之前，我们并不知道该跳转到哪里，这些信息就会存储在重定位表里；</li>
<li>最后是.symtab Section，叫作<strong>符号表</strong>（Symbol Table）。符号表保留了我们所说的当前文件里面定义的函数名称和对应地址的地址簿。</li>
</ol>
<p>链接器会扫描所有输入的目标文件，然后把所有符号表里的信息收集起来，构成一个全局的符号表。然后再根据重定位表，把所有不确定要跳转地址的代码，根据符号表里面存储的地址，进行一次修正。最后，把所有的目标文件的对应段进行一次合并，变成了最终的可执行代码。这也是为什么，可执行文件里面的函数调用的地址都是正确的。</p>
<p><img src="/posts/91fdbf16/image-20210426213521613.png" alt="image-20210426213521613"></p>
<p>在链接器把程序变成可执行文件之后，要装载器去执行程序就容易多了。装载器不再需要考虑地址跳转的问题，只需要解析 ELF 文件，把对应的指令和数据，加载到内存里面供 CPU 执行就可以了。</p>
<h2 id="总结延伸"><a href="#总结延伸" class="headerlink" title="总结延伸"></a>总结延伸</h2><p>为什么同样一个程序，在 Linux 下可以执行而在 Windows 下不能执行了。其中一个非常重要的原因就是，两个操作系统下<strong>可执行文件的格式不一样</strong>。</p>
<p>我们今天讲的是 Linux 下的 ELF 文件格式，而 Windows 的可执行文件格式是一种叫作 <strong>PE</strong>（Portable Executable Format）的文件格式。Linux 下的装载器只能解析 ELF 格式而不能解析 PE 格式。</p>
<p>我们去写可以用的程序，也不仅仅是把所有代码放在一个文件里来编译执行，而是可以拆分成不同的函数库，最后通过一个静态链接的机制，使得不同的文件之间既有分工，又能通过静态链接来“合作”，变成一个可执行的程序。</p>
<p>对于 ELF 格式的文件，为了能够实现这样一个静态链接的机制，里面不只是简单罗列了程序所需要执行的指令，还会包括链接所需要的重定位表和符号表。</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出计算机组成原理（三）</title>
    <url>/posts/fe405f72.html</url>
    <content><![CDATA[<h2 id="功耗：CPU-的“人体极限”"><a href="#功耗：CPU-的“人体极限”" class="headerlink" title="功耗：CPU 的“人体极限”"></a>功耗：CPU 的“人体极限”</h2><p>我们的 CPU，一般都被叫作<strong>超大规模集成电路</strong>（Very-Large-Scale Integration，VLSI）。这些电路，实际上都是一个个晶体管组合而成的。CPU 在计算，其实就是让晶体管里面的“开关”不断地去“打开”和“关闭”，来组合完成各种运算和功能。</p>
<p>如果要提升计算机的性能，我们可以从指令数、CPI 以及 CPU 主频这三个地方入手。要搞定指令数或者 CPI，乍一看都不太容易。于是，研发 CPU 的硬件工程师们，从 80 年代开始，就挑上了 CPU 这个“软柿子”。在 CPU 上多放一点晶体管，不断提升 CPU 的时钟频率，这样就能让 CPU 变得更快，程序的执行时间就会缩短。</p>
<span id="more"></span>

<p>想要计算得快，一方面，我们要在 CPU 里，同样的面积里面，多放一些晶体管，也就是<strong>增加密度</strong>；另一方面，我们要让晶体管“打开”和“关闭”得更快一点，也就是<strong>提升主频</strong>。<strong>而这两者，都会增加功耗</strong>，带来耗电和散热的问题。</p>
<p>这么说可能还是有点抽象，我还是给你举一个例子。你可以把一个计算机 CPU 想象成一个巨大的工厂，里面有很多工人，相当于 CPU 上面的晶体管，互相之间协同工作。</p>
<p>为了工作得快一点，我们要在工厂里多塞一点人。你可能会问，为什么不把工厂造得大一点呢？这是因为，人和人之间如果离得远了，互相之间走过去需要花的时间就会变长，这也会导致性能下降。这就好像如果 CPU 的面积大，晶体管之间的距离变大，电信号传输的时间就会变长，运算速度自然就慢了。</p>
<p>除了多塞一点人，我们还希望每个人的动作都快一点，这样同样的时间里就可以多干一点活儿了。这就相当于提升 CPU 主频，但是动作快，每个人就要出汗散热。要是太热了，对工厂里面的人来说会中暑生病，对 CPU 来说就会崩溃出错。</p>
<p>我们会在 CPU 上面抹硅脂、装风扇，乃至用上水冷或者其他更好的散热设备，就好像在工厂里面装风扇、空调，发冷饮一样。但是同样的空间下，装上风扇空调能够带来的散热效果也是有极限的。</p>
<p>因此，<strong>在 CPU 里面，能够放下的晶体管数量和晶体管的“开关”频率也都是有限的</strong>。一个 CPU 的功率，可以用这样一个公式来表示：</p>
<p>功耗 ~= 1/2 ×负载电容×电压的平方×开关频率×晶体管数量</p>
<p>那么，为了要提升性能，我们需要不断地增加晶体管数量。同样的面积下，我们想要多放一点晶体管，就要把晶体管造得小一点。这个就是平时我们所说的<strong>提升“制程”</strong>。从 28nm 到 7nm，相当于晶体管本身变成了原来的 1/4 大小。</p>
<p>这个就相当于我们在工厂里，同样的活儿，我们要找瘦小一点的工人，这样一个工厂里面就可以多一些人。我们还要<strong>提升主频</strong>，让开关的频率变快，也就是要找手脚更快的工人。</p>
<p>但是，功耗增加太多，就会导致 CPU 散热跟不上，这时，我们就需要<strong>降低电压</strong>。这里有一点非常关键，在整个功耗的公式里面，功耗和电压的平方是成正比的。这意味着电压下降到原来的 1/5，整个的功耗会变成原来的 1/25。</p>
<h2 id="并行优化，理解阿姆达尔定律"><a href="#并行优化，理解阿姆达尔定律" class="headerlink" title="并行优化，理解阿姆达尔定律"></a>并行优化，理解阿姆达尔定律</h2><h3 id="并行优化"><a href="#并行优化" class="headerlink" title="并行优化"></a>并行优化</h3><p>虽然制程的优化和电压的下降，在过去的 20 年里，让我们的 CPU 性能有所提升。但是从上世纪九十年代到本世纪初，软件工程师们所用的“面向摩尔定律编程”的套路越来越用不下去了。</p>
<p>于是，从奔腾 4 开始，Intel 意识到通过提升主频比较“难”去实现性能提升，边开始推出 Core Duo 这样的多核 CPU，<strong>通过提升“吞吐率”而不是“响应时间”</strong>，来达到目的。</p>
<p>提升响应时间，就好比提升你用的交通工具的速度，比如原本你是开汽车，现在变成了火车乃至飞机。本来开车从上海到北京要 20 个小时，换成飞机就只要 2 个小时了，但是，在此之上，再想要提升速度就不太容易了。我们的 CPU 在奔腾 4 的年代，就好比已经到了飞机这个<strong>速度极限</strong>。</p>
<p>那你可能要问了，接下来该怎么办呢？相比于给飞机提速，工程师们又想到了新的办法，可以一次同时开 2 架、4 架乃至 8 架飞机，这就好像我们现在用的 2 核、4 核，乃至 8 核的 CPU。</p>
<p>虽然从上海到北京的时间没有变，但是一次飞 8 架飞机能够运的东西自然就变多了，也就是所谓的“吞吐率”变大了。所以，不管你有没有需要，现在 CPU 的性能就是提升了 2 倍乃至 8 倍、16 倍。这也是一个最常见的提升性能的方式，<strong>通过并行提高性能</strong>。</p>
<h3 id="并行优化的条件"><a href="#并行优化的条件" class="headerlink" title="并行优化的条件"></a>并行优化的条件</h3><p>但是，并不是所有问题，都可以通过并行提高性能来解决。如果想要使用这种思想，需要满足这样几个条件。</p>
<p>第一，需要进行的计算，本身可以分解成几个可以并行的任务。好比上面的乘法和加法计算，几个人可以同时进行，不会影响最后的结果。</p>
<p>第二，需要能够分解好问题，并确保几个人的结果能够汇总到一起。</p>
<p>第三，在“汇总”这个阶段，是没有办法并行进行的，还是得顺序执行，一步一步来。</p>
<h3 id="阿姆达尔定律"><a href="#阿姆达尔定律" class="headerlink" title="阿姆达尔定律"></a>阿姆达尔定律</h3><p>这就引出了我们在进行性能优化中，常常用到的一个经验定律，<strong>阿姆达尔定律</strong>（Amdahl’s Law）。这个定律说的就是，对于一个程序进行优化之后，处理器并行运算之后效率提升的情况。具体可以用这样一个公式来表示：</p>
<p>优化后的执行时间 = 受优化影响的执行时间 / 加速倍数 + 不受影响的执行时间</p>
<p>在刚刚的向量点积例子里，4 个人同时计算向量的一小段点积，就是通过并行提高了这部分的计算性能。但是，这 4 个人的计算结果，最终还是要在一个人那里进行汇总相加。这部分汇总相加的时间，是不能通过并行来优化的，也就是上面的公式里面不受影响的执行时间这一部分。</p>
<p>比如上面的各个向量的一小段的点积，需要 100ns，加法需要 20ns，总共需要 120ns。这里通过并行 4 个 CPU 有了 4 倍的加速度。那么最终优化后，就有了 100/4+20=45ns。即使我们增加更多的并行度来提供加速倍数，比如有 100 个 CPU，整个时间也需要 100/100+20=21ns。</p>
<h2 id="总结延伸"><a href="#总结延伸" class="headerlink" title="总结延伸"></a>总结延伸</h2><p>我们可以看到，无论是简单地通过提升主频，还是增加更多的 CPU 核心数量，通过并行来提升性能，都会遇到相应的瓶颈。仅仅简单地通过“堆硬件”的方式，在今天已经不能很好地满足我们对于程序性能的期望了。于是，工程师们需要从其他方面开始下功夫了。</p>
<p>在“摩尔定律”和“并行计算”之外，在整个计算机组成层面，还有这样几个原则性的性能提升方法。</p>
<p><strong>1.加速大概率事件</strong>。最典型的就是，过去几年流行的深度学习，整个计算过程中，99% 都是向量和矩阵计算，于是，工程师们通过用 GPU 替代 CPU，大幅度提升了深度学习的模型训练过程。本来一个 CPU 需要跑几小时甚至几天的程序，GPU 只需要几分钟就好了。Google 更是不满足于 GPU 的性能，进一步地推出了 TPU。后面的文章，我也会为你讲解 GPU 和 TPU 的基本构造和原理。</p>
<p><strong>2.通过流水线提高性能</strong>。现代的工厂里的生产线叫“流水线”。我们可以把装配 iPhone 这样的任务拆分成一个个细分的任务，让每个人都只需要处理一道工序，最大化整个工厂的生产效率。类似的，我们的 CPU 其实就是一个“运算工厂”。我们把 CPU 指令执行的过程进行拆分，细化运行，也是现代 CPU 在主频没有办法提升那么多的情况下，性能仍然可以得到提升的重要原因之一。我们在后面也会讲到，现代 CPU 里是如何通过流水线来提升性能的，以及反面的，过长的流水线会带来什么新的功耗和效率上的负面影响。</p>
<p><strong>3.通过预测提高性能</strong>。通过预先猜测下一步该干什么，而不是等上一步运行的结果，提前进行运算，也是让程序跑得更快一点的办法。典型的例子就是在一个循环访问数组的时候，凭经验，你也会猜到下一步我们会访问数组的下一项。后面要讲的“分支和冒险”、“局部性原理”这些 CPU 和存储系统设计方法，其实都是在利用我们对于未来的“预测”，提前进行相应的操作，来提升我们的程序性能。</p>
<p>三种思路的例子</p>
<p>1.加速大概率事件</p>
<p>各种缓存(内存缓存、CDN缓存)</p>
<p>2.流水线</p>
<p>并发编程、异步编程</p>
<p>音视频播放器边播放边缓冲</p>
<p>3.预测</p>
<p>小说的下一页预加载</p>
<p>电商大促的CDN预热</p>
<p>好了，到这里，我们讲完了计算机组成原理这门课的“前情提要”。<strong>一方面，整个组成乃至体系结构，都是基于冯·诺依曼架构组成的软硬件一体的解决方案。另一方面，你需要明白的就是，这里面的方方面面的设计和考虑，除了体系结构层面的抽象和通用性之外，核心需要考虑的是“性能”问题。</strong></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出计算机组成原理（二）</title>
    <url>/posts/b35efc20.html</url>
    <content><![CDATA[<h2 id="计算机组成原理知识地图"><a href="#计算机组成原理知识地图" class="headerlink" title="计算机组成原理知识地图"></a>计算机组成原理知识地图</h2><p><a href="https://www.acwing.com/blog/content/5543/">计算机组成原理知识地图点此查看</a></p>
<p>计算机组成原理的英文叫 Computer Organization。这里的 Organization 是“组织机构”的意思。计算机由很多个不同的部件放在一起，变成了一个“组织机构”。这个组织机构最终能够进行各种计算、控制、读取输入，进行输出，达成各种强大的功能。</p>
<p>在这张图里面，我们把整个计算机组成原理的知识点拆分成了四大部分，分别是<strong>计算机的基本组成、计算机的指令和计算、处理器设计，以及存储器和 I/O 设备</strong>。</p>
<span id="more"></span>

<p>首先，我们来看计算机的基本组成。</p>
<p>这一部分，你需要学习计算机是由哪些硬件组成的。这些硬件，又是怎么对应到经典的冯·诺依曼体系结构中的，也就是<strong>运算器、控制器、存储器、输入设备和输出设备这五大基本组件</strong>。除此之外，你还需要了解计算机的<strong>两个核心指标，性能和功耗</strong>。性能和功耗也是我们在应用和设计五大基本组件中需要重点考虑的因素。</p>
<p>了解了组成部分，接下来你需要掌握计算机的指令和计算。</p>
<p>在计算机指令部分，你需要搞明白，我们每天撰写的一行行 C、Java、PHP 程序，是怎么在计算机里面跑起来的。这里面，你既需要了解我们的程序是怎么通过编译器和汇编器，变成一条条机器指令这样的编译过程（如果把编译过程展开的话，可以变成一门完整的编译原理课程），还需要知道我们的操作系统是怎么链接、装载、执行这些程序的（这部分知识如果再深入学习，又可以变成一门操作系统课程）。而这一条条指令执行的控制过程，就是由计算机五大组件之一的控制器来控制的。</p>
<p>在计算机的计算部分，你要从二进制和编码开始，理解我们的数据在计算机里的表示，以及我们是怎么从数字电路层面，实现加法、乘法这些基本的运算功能的。实现这些运算功能的 ALU（Arithmetic Logic Unit/ALU），也就是算术逻辑单元，其实就是我们计算机五大组件之一的运算器。</p>
<h2 id="入门书籍"><a href="#入门书籍" class="headerlink" title="入门书籍"></a>入门书籍</h2><p>对于非计算机科班出身的同学，建议你先对计算机组成原理这门课有个基本概念。建立这个概念，有两种方法，第一，你可以把上面那张地图的核心内容记下来，对这些内容之间的关系先有个大致的了解。</p>
<p>第二，推荐你阅读两本书，准确地说，这其实是两本小册子，因为它们非常轻薄、好读，而且图文并茂，非常适合初学者和想要入门组成原理的同学。一本是《计算机是怎样跑起来的》，另一本是《程序是怎样跑起来的》。我要特别说一下后面这本，它可以说是一个入门微缩版本的“计算机组成原理”。</p>
<h2 id="深入学习书籍"><a href="#深入学习书籍" class="headerlink" title="深入学习书籍"></a>深入学习书籍</h2><p><a href="https://www.bilibili.com/video/BV1t4411e7LH?p=1">b站计算机组成原理</a>（哈工大刘宏伟）  </p>
<p>刘宏伟老师主讲，他的课不仅适合考研人，也非常适合初学者，初学者也听得懂。建议 1.5 倍速食用。之前有一个一百多万播放量的视频，不知道为啥没了…</p>
<p>对于想要深入掌握计算机组成的同学，我推荐你去读一读《计算机组成与设计：硬件 / 软件接口》和经典的《深入理解计算机系统》这两本书。后面这本被称为 CSAPP 的经典教材，网上也有配套的视频课程。我在这里给你推荐两个不同版本的链接（<a href="https://www.bilibili.com/video/av31289365/?spm_id_from=333.788.b_636f6d6d656e74.4">Bilibili 版</a>和<a href="https://www.youtube.com/playlist?list=PLmBgoRqEQCWy58EIwLSWwMPfkwLOLRM5R">Youtube 版</a> ）。不过这两本都在 500 页以上，坚持啃下来需要不少实践经验。</p>
<h2 id="什么是性能？时间的倒数"><a href="#什么是性能？时间的倒数" class="headerlink" title="什么是性能？时间的倒数"></a>什么是性能？时间的倒数</h2><p>在计算机组成原理乃至体系结构中，<strong>“性能”都是最重要的一个主题</strong>。我在前面说过，学习和研究计算机组成原理，就是在理解计算机是怎么运作的，以及为什么要这么运作。“为什么”所要解决的事情，很多时候就是提升“性能”。</p>
<p>计算机的性能，其实和我们干体力劳动很像，好比是我们要搬东西。对于计算机的性能，我们需要有个标准来衡量。这个标准中主要有两个指标。</p>
<p>第一个是<strong>响应时间</strong>（Response time）或者叫执行时间（Execution time）。想要提升响应时间这个性能指标，你可以理解为让计算机“跑得更快”。</p>
<p>第二个是吞吐率（Throughput）或者带宽（Bandwidth），想要提升这个指标，你可以理解为让计算机“搬得更多”。</p>
<p>所以说，响应时间指的就是，我们执行一个程序，到底需要花多少时间。花的时间越少，自然性能就越好。</p>
<p>而吞吐率是指我们在一定的时间范围内，到底能处理多少事情。这里的“事情”，在计算机里就是处理的数据或者执行的程序指令。</p>
<p>我们一般把性能，定义成响应时间的倒数，也就是：性能 = 1/ 响应时间</p>
<p>这样一来，响应时间越短，性能的数值就越大。</p>
<h2 id="计算机的计时单位：CPU-时钟"><a href="#计算机的计时单位：CPU-时钟" class="headerlink" title="计算机的计时单位：CPU 时钟"></a>计算机的计时单位：CPU 时钟</h2><p>虽然时间是一个很自然的用来衡量性能的指标，但是用时间来衡量时，有两个问题。</p>
<p><strong>第一个就是时间不“准”</strong>。计算机可能同时运行着好多个程序，CPU 实际上不停地在各个程序之间进行切换。在这些走掉的时间里面，很可能 CPU 切换去运行别的程序了。而且，有些程序在运行的时候，可能要从网络、硬盘去读取数据，要等网络和硬盘把数据读出来，给到内存和 CPU。所以说，<strong>要想准确统计某个程序运行时间，进而去比较两个程序的实际性能，我们得把这些时间给刨除掉</strong>。</p>
<p><strong>其次，即使我们已经拿到了 CPU 时间，我们也不一定可以直接“比较”出两个程序的性能差异</strong>。即使在同一台计算机上，CPU 可能满载运行也可能降频运行，降频运行的时候自然花的时间会多一些。</p>
<p>除了 CPU 之外，时间这个性能指标还会受到主板、内存这些其他相关硬件的影响。所以，我们需要对“时间”这个我们可以感知的指标进行拆解，把程序的 CPU 执行时间变成 CPU 时钟周期数（CPU Cycles）和 时钟周期时间（Clock Cycle）的乘积。</p>
<p><strong>程序的 CPU 执行时间 =CPU 时钟周期数×时钟周期时间</strong></p>
<p>我们先来理解一下什么是时钟周期时间。你在买电脑的时候，一定关注过 CPU 的主频。比如我手头的这台电脑就是 Intel Core-i7-7700HQ 2.8GHz，这里的 2.8GHz 就是电脑的主频（Frequency/Clock Rate）。这个 2.8GHz，我们可以先粗浅地认为，CPU 在 1 秒时间内，可以执行的简单指令的数量是 2.8G 条。</p>
<p>如果想要更准确一点描述，这个 2.8GHz 就代表，我们 CPU 的一个“钟表”能够识别出来的最小的时间间隔。就像我们挂在墙上的挂钟，都是“滴答滴答”一秒一秒地走，所以通过墙上的挂钟能够识别出来的最小时间单位就是秒。</p>
<p>而在 CPU 内部，和我们平时戴的电子石英表类似，有一个叫晶体振荡器（Oscillator Crystal）的东西，简称为<strong>晶振</strong>。我们把<strong>晶振当成 CPU 内部的电子表</strong>来使用。晶振带来的每一次“滴答”，就是时钟周期时间。</p>
<p>在我这个 2.8GHz 的 CPU 上，这个时钟周期时间，就是 1/2.8G。我们的 CPU，是按照这个“时钟”提示的时间来进行自己的操作。主频越高，意味着这个表走得越快，我们的 CPU 也就“被逼”着走得越快。</p>
<p>最简单的提升性能方案，自然缩短时钟周期时间，也就是提升主频。换句话说，就是换一块好一点的 CPU。不过，这个是我们这些软件工程师控制不了的事情，所以我们就把目光挪到了乘法的另一个因子——CPU 时钟周期数上。如果能够减少程序需要的 CPU 时钟周期数量，一样能够提升程序性能。</p>
<p>对于 CPU 时钟周期数，我们可以再做一个分解，把它变成“指令数×每条指令的平均时钟周期数（Cycles Per Instruction，简称 CPI）”。不同的指令需要的 Cycles 是不同的，加法和乘法都对应着一条 CPU 指令，但是乘法需要的 Cycles 就比加法要多，自然也就慢。在这样拆分了之后，我们的程序的 CPU 执行时间就可以变成这样三个部分的乘积。</p>
<p><strong>程序的 CPU 执行时间 = 指令数×CPI×Clock Cycle Time</strong></p>
<p>因此，如果我们想要解决性能问题，其实就是要优化这三者。</p>
<p>我们可以把自己想象成一个 CPU，坐在那里写程序。计算机主频就好像是你的打字速度，打字越快，你自然可以多写一点程序。CPI 相当于你在写程序的时候，熟悉各种快捷键，越是打同样的内容，需要敲击键盘的次数就越少。指令数相当于你的程序设计得够合理，同样的程序要写的代码行数就少。如果三者皆能实现，你自然可以很快地写出一个优秀的程序，你的“性能”从外面来看就是好的。</p>
<h2 id="总结延伸"><a href="#总结延伸" class="headerlink" title="总结延伸"></a>总结延伸</h2><p>好了，学完这一讲，对“性能”这个名词，你应该有了更清晰的认识。我主要对于“响应时间”这个性能指标进行抽丝剥茧，拆解成了计算机时钟周期、CPI 以及指令数这三个独立的指标的乘积，并且为你指明了优化计算机性能的三条康庄大道。也就是，提升计算机主频，优化 CPU 设计使得在单个时钟周期内能够执行更多指令，以及通过编译器来减少需要的指令数。</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出计算机组成原理（五）</title>
    <url>/posts/26f38350.html</url>
    <content><![CDATA[<h2 id="CPU中的寄存器"><a href="#CPU中的寄存器" class="headerlink" title="CPU中的寄存器"></a>CPU中的寄存器</h2><p>一个 CPU 里面会有很多种不同功能的寄存器。我这里给你介绍三种比较特殊的。</p>
<span id="more"></span>

<p>一个是 <strong>PC 寄存器</strong>（Program Counter Register），我们也叫指令地址寄存器（Instruction Address Register）。顾名思义，它就是用来存放下一条需要执行的计算机指令的内存地址。</p>
<p>第二个是<strong>指令寄存器</strong>（Instruction Register），用来存放当前正在执行的指令。</p>
<p>第三个是<strong>条件码寄存器</strong>（Status Register），用里面的一个一个标记位（Flag），存放 CPU 进行算术或者逻辑计算的结果。</p>
<p>除了这些特殊的寄存器，CPU 里面还有更多用来存储数据和内存地址的寄存器。这样的寄存器通常一类里面不止一个。我们通常根据存放的数据内容来给它们取名字，比如整数寄存器、浮点数寄存器、向量寄存器和地址寄存器等等。<strong>有些寄存器既可以存放数据，又能存放地址，我们就叫它通用寄存器。</strong></p>
<p>实际上，一个程序执行的时候，CPU 会根据 PC 寄存器里的地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。可以看到，一个程序的一条条指令，在内存里面是连续保存的，也会一条条顺序加载。</p>
<p>而有些特殊指令，比如上一讲我们讲到 J 类指令，也就是跳转指令，会修改 PC 寄存器里面的地址值。这样，下一条要执行的指令就不是从内存里面顺序加载的了。事实上，这些跳转指令的存在，也是我们可以在写程序的时候，使用 if…else 条件语句和 while/for 循环语句的原因。</p>
<h2 id="从-if…else-来看程序的执行和跳转"><a href="#从-if…else-来看程序的执行和跳转" class="headerlink" title="从 if…else 来看程序的执行和跳转"></a>从 if…else 来看程序的执行和跳转</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  srand(time(<span class="literal">NULL</span>));</span><br><span class="line">  <span class="keyword">int</span> r = rand() % <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">if</span> (r == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>

<p>以上就是一个包含if…else 的简单程序。</p>
<p>我们再编译成汇编代码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  if (r == 0)</span><br><span class="line">3b:   83 7d fc 00             cmp    DWORD PTR [rbp-0x4],0x0</span><br><span class="line">3f:   75 09                        jne    4a &lt;main+0x4a&gt;</span><br><span class="line">  &#123;</span><br><span class="line">      a = 1;</span><br><span class="line">41:   c7 45 f8 01 00 00 00    mov    DWORD PTR [rbp-0x8],0x1</span><br><span class="line">48:   eb 07                   	 jmp    51 &lt;main+0x51&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">      a = 2;</span><br><span class="line">4a:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2</span><br><span class="line">51:   b8 00 00 00 00             mov    eax,0x0</span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>

<p>我们用 rand 生成了一个随机数 r，r 要么是 0，要么是 1。当 r 是 0 的时候，我们把之前定义的变量 a 设成 1，不然就设成 2。</p>
<p>可以看到，这里对于 r == 0 的条件判断，被编译成了 cmp 和 jne 这两条指令。</p>
<p>cmp 指令比较了前后两个操作数的值，这里的 DWORD PTR 代表操作的数据类型是 32 位的整数，而[rbp-0x4]则是一个寄存器的地址。所以，第一个操作数就是从寄存器里拿到的变量 r 的值。第二个操作数 0x0 就是我们设定的常量 0 的 16 进制表示。cmp 指令的比较结果，会存入到<strong>条件码寄存器</strong>当中去。</p>
<p>在这里，如果比较的结果是 True，也就是 r == 0，就把<strong>零标志条件码</strong>（对应的条件码是 ZF，Zero Flag）设置为 1。除了零标志之外，Intel 的 CPU 下还有<strong>进位标志</strong>（CF，Carry Flag）、符号标志（SF，Sign Flag）以及<strong>溢出标志</strong>（OF，Overflow Flag），用在不同的判断条件下。</p>
<p>cmp 指令执行完成之后，PC 寄存器会自动自增，开始执行下一条 jne 的指令。</p>
<p>跟着的 jne 指令，是 jump if not equal 的意思，它会查看对应的零标志位。如果为 0，会跳转到后面跟着的操作数 4a 的位置。这个 4a，对应这里汇编代码的行号，也就是上面设置的 else 条件里的第一条指令。当跳转发生的时候，PC 寄存器就不再是自增变成下一条指令的地址，而是被直接设置成这里的 4a 这个地址。这个时候，CPU 再把 4a 地址里的指令加载到指令寄存器中来执行。</p>
<p>跳转到执行地址为 4a 的指令，实际是一条 mov 指令，第一个操作数和前面的 cmp 指令一样，是另一个 32 位整型的寄存器地址，以及对应的 2 的 16 进制值 0x2。mov 指令把 2 设置到对应的寄存器里去，相当于一个赋值操作。然后，PC 寄存器里的值继续自增，执行下一条 mov 指令。</p>
<p>这条 mov 指令的第一个操作数 eax，代表累加寄存器，第二个操作数 0x0 则是 16 进制的 0 的表示。这条指令其实没有实际的作用，它的作用是一个占位符。我们回过头去看前面的 if 条件，如果满足的话，在赋值的 mov 指令执行完成之后，有一个 jmp 的无条件跳转指令。跳转的地址就是这一行的地址 51。我们的 main 函数没有设定返回值，而 mov eax, 0x0 其实就是给 main 函数生成了一个默认的为 0 的返回值到累加器里面。if 条件里面的内容执行完成之后也会跳转到这里，和 else 里的内容结束之后的位置是一样的。</p>
<p><img src="/posts/26f38350/image-20210328180423547.png" alt="image-20210328180423547"></p>
<p>读取打孔卡的机器会顺序地一段一段地读取指令，然后执行。执行完一条指令，它会自动地顺序读取下一条指令。如果执行的当前指令带有跳转的地址，比如往后跳 10 个指令，那么机器会自动将卡片带往后移动 10 个指令的位置，再来执行指令。同样的，机器也能向前移动，去读取之前已经执行过的指令。这也就是我们的 while/for 循环实现的原理。</p>
<h2 id="如何通过-if…else-和-goto-来实现循环？"><a href="#如何通过-if…else-和-goto-来实现循环？" class="headerlink" title="如何通过 if…else 和 goto 来实现循环？"></a>如何通过 if…else 和 goto 来实现循环？</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a += i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再看一段简单的利用 for 循环的程序。我们循环自增变量 i 三次，三次之后，i&gt;=3，就会跳出循环。整个程序，对应的 Intel 汇编代码就是这样的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  for (int i = 0; i &lt;= 2; i++)</span><br><span class="line"> b:   c7 45 f8 00 00 00 00    mov    DWORD PTR [rbp-0x4],0x0</span><br><span class="line">12:   eb 0a                   	jmp    1e </span><br><span class="line">  &#123;</span><br><span class="line">      a += i;</span><br><span class="line">14:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x4]</span><br><span class="line">17:   01 45 fc                 add    DWORD PTR [rbp-0x8],eax</span><br><span class="line"></span><br><span class="line">1a:   83 45 f8 01             add    DWORD PTR [rbp-0x4],0x1</span><br><span class="line">1e:   83 7d f8 02             cmp    DWORD PTR [rbp-0x4],0x2</span><br><span class="line">22:   7e f0                        jle    14 </span><br><span class="line">24:   b8 00 00 00 00        mov    eax,0x0</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，对应的循环也是用 1e 这个地址上的 cmp 比较指令，和紧接着的 jle 条件跳转指令来实现的。主要的差别在于，这里的 jle 跳转的地址，在这条指令之前的地址 14，而非 if…else 编译出来的跳转指令之后。往前跳转使得条件满足的时候，PC 寄存器会把指令地址设置到之前执行过的指令位置，重新执行之前执行过的指令，直到条件不满足，顺序往下执行 jle 之后的指令，整个循环才结束。</p>
<p><img src="/posts/26f38350/image-20210328180636866.png" alt="image-20210328180636866"></p>
<p>如果你看一长条打孔卡的话，就会看到卡片往后移动一段，执行了之后，又反向移动，去重新执行前面的指令。</p>
<p>其实，你有没有觉得，jle 和 jmp 指令，有点像程序语言里面的 goto 命令，直接指定了一个特定条件下的跳转位置。虽然我们在用高级语言开发程序的时候反对使用 goto，但是实际在机器指令层面，无论是 if…else…也好，还是 for/while 也好，都是用和 goto 相同的跳转到特定指令位置的方式来实现的。</p>
<h2 id="总结延伸"><a href="#总结延伸" class="headerlink" title="总结延伸"></a>总结延伸</h2><p>这一节，我们在单条指令的基础上，学习了程序里的多条指令，究竟是怎么样一条一条被执行的。除了简单地通过 PC 寄存器自增的方式顺序执行外，条件码寄存器会记录下当前执行指令的条件判断状态，然后通过跳转指令读取对应的条件码，修改 PC 寄存器内的下一条指令的地址，最终实现 if…else 以及 for/while 这样的程序控制流程。</p>
<p>你会发现，虽然我们可以用高级语言，可以用不同的语法，比如 if…else 这样的条件分支，或者 while/for 这样的循环方式，来实现不用的程序运行流程，但是回归到计算机可以识别的机器指令级别，其实都只是一个简单的地址跳转而已，也就是一个类似于 goto 的语句。</p>
<p>想要在硬件层面实现这个 goto 语句，除了本身需要用来保存下一条指令地址，以及当前正要执行指令的 PC 寄存器、指令寄存器外，我们只需要再增加一个条件码寄存器，来保留条件判断的状态。这样简简单单的三个寄存器，就可以实现条件判断和循环重复执行代码的功能。</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出计算机组成原理（八）</title>
    <url>/posts/66969755.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出计算机组成原理（六）</title>
    <url>/posts/43fdc889.html</url>
    <content><![CDATA[<p>今天，我们就从程序的函数调用开始，讲讲函数间的相互调用，在计算机指令层面是怎么实现的，以及什么情况下会发生栈溢出这个错误。</p>
<p>超长预警！！！</p>
<span id="more"></span>

<h2 id="为什么我们需要程序栈？"><a href="#为什么我们需要程序栈？" class="headerlink" title="为什么我们需要程序栈？"></a>为什么我们需要程序栈？</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function_example.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="keyword">static</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> u = add(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序定义了一个简单的函数 add，接受两个参数 a 和 b，返回值就是 a+b。而 main 函数里则定义了两个变量 x 和 y，然后通过调用这个 add 函数，来计算 u=x+y，最后把 u 的数值打印出来。</p>
<p>我们来看一看对应的汇编代码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">int static add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">   0:   55                      push   rbp</span><br><span class="line">   1:   48 89 e5                mov    rbp,rsp</span><br><span class="line">   4:   89 7d fc                mov    DWORD PTR [rbp-0x4],edi</span><br><span class="line">   7:   89 75 f8                mov    DWORD PTR [rbp-0x8],esi</span><br><span class="line">    return a+b;</span><br><span class="line">   a:   8b 55 fc                mov    edx,DWORD PTR [rbp-0x4]</span><br><span class="line">   d:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]</span><br><span class="line">  10:   01 d0                   add    eax,edx</span><br><span class="line">&#125;</span><br><span class="line">  12:   5d                      pop    rbp</span><br><span class="line">  13:   c3                      ret    </span><br><span class="line">0000000000000014 &lt;main&gt;:</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  14:   55                            push   rbp</span><br><span class="line">  15:   48 89 e5                  mov    rbp,rsp</span><br><span class="line">  18:   48 83 ec 10             sub    rsp,0x10</span><br><span class="line">    int x = 5;</span><br><span class="line">  1c:   c7 45 fc 05 00 00 00    mov    DWORD PTR [rbp-0x4],0x5</span><br><span class="line">    int y = 10;</span><br><span class="line">  23:   c7 45 f8 0a 00 00 00    mov    DWORD PTR [rbp-0x8],0xa</span><br><span class="line">    int u = add(x, y);</span><br><span class="line">  2a:   8b 55 f8                mov    edx,DWORD PTR [rbp-0x8]</span><br><span class="line">  2d:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]</span><br><span class="line">  30:   89 d6                   mov    esi,edx</span><br><span class="line">  32:   89 c7                   mov    edi,eax</span><br><span class="line">  34:   e8 c7 ff ff ff          call   0 &lt;add&gt;</span><br><span class="line">  39:   89 45 f4                mov    DWORD PTR [rbp-0xc],eax</span><br><span class="line">  3c:   b8 00 00 00 00          mov    eax,0x0</span><br><span class="line">&#125;</span><br><span class="line">  41:   c9                      leave  </span><br><span class="line">  42:   c3                      ret    </span><br></pre></td></tr></table></figure>

<p>可以看出来，在这段代码里，main 函数和上一节我们讲的的程序执行区别并不大，它主要是把 jump 指令换成了函数调用的 call 指令。call 指令后面跟着的，仍然是跳转后的程序地址。</p>
<p>这些你理解起来应该不成问题。我们下面来看一个有意思的部分。</p>
<p>我们来看 add 函数。可以看到，add 函数编译之后，代码先执行了一条 push 指令和一条 mov 指令；在函数执行结束的时候，又执行了一条 pop 和一条 ret 指令。这四条指令的执行，其实就是在进行我们接下来要讲<strong>压栈</strong>（Push）和<strong>出栈</strong>（Pop）操作。</p>
<p>你有没有发现，函数调用和上一节我们讲的 if…else 和 for/while 循环有点像。它们两个都是在原来顺序执行的指令过程里，执行了一个内存地址的跳转指令，让指令从原来顺序执行的过程里跳开，从新的跳转后的位置开始执行。</p>
<p>但是，这两个跳转有个区别，if…else 和 for/while 的跳转，是跳转走了就不再回来了，就在跳转后的新地址开始顺序地执行指令，就好像徐志摩在《再别康桥》里面写的：“我挥一挥衣袖，不带走一片云彩”，继续进行新的生活了。而函数调用的跳转，在对应函数的指令执行完了之后，还要再回到函数调用的地方，继续执行 call 之后的指令，就好像贺知章在《回乡偶书》里面写的那样：“少小离家老大回，乡音未改鬓毛衰”，不管走多远，最终还是要回来。</p>
<p>那我们有没有一个可以不跳转回到原来开始的地方，来实现函数的调用呢？直觉上似乎有这么一个解决办法。你可以把调用的函数指令，直接插入在调用函数的地方，替换掉对应的 call 指令，然后在编译器编译代码的时候，直接就把函数调用变成对应的指令替换掉。</p>
<p>不过，仔细琢磨一下，你会发现这个方法有些问题。如果函数 A 调用了函数 B，然后函数 B 再调用函数 A，我们就得面临在 A 里面插入 B 的指令，然后在 B 里面插入 A 的指令，这样就会产生无穷无尽地替换。就好像两面镜子面对面放在一块儿，任何一面镜子里面都会看到无穷多面镜子。</p>
<p>那我们就换一个思路，能不能把后面要跳回来执行的指令地址给记录下来呢？就像前面讲 PC 寄存器一样，我们可以专门设立一个“程序调用寄存器”，来存储接下来要跳转回来执行的指令地址。等到函数调用结束，从这个寄存器里取出地址，再跳转到这个记录的地址，继续执行就好了。</p>
<p>但是在多层函数调用里，简单只记录一个地址也是不够的。我们在调用函数 A 之后，A 还可以调用函数 B，B 还能调用函数 C。这一层又一层的调用并没有数量上的限制。在所有函数调用返回之前，每一次调用的返回地址都要记录下来，但是我们 CPU 里的寄存器数量并不多。像我们一般使用的 Intel i7 CPU 只有 16 个 64 位寄存器，调用的层数一多就存不下了。</p>
<p>最终，计算机科学家们想到了一个比单独记录跳转回来的地址更完善的办法。我们在内存里面开辟一段空间，用栈这个<strong>后进先出</strong>（LIFO，Last In First Out）的数据结构。栈就像一个乒乓球桶，每次程序调用函数之前，我们都把调用返回后的地址写在一个乒乓球上，然后塞进这个球桶。这个操作其实就是我们常说的<strong>压栈</strong>。如果函数执行完了，我们就从球桶里取出最上面的那个乒乓球，很显然，这就是<strong>出栈</strong>。</p>
<p>拿到出栈的乒乓球，找到上面的地址，把程序跳转过去，就返回到了函数调用后的下一条指令了。如果函数 A 在执行完成之前又调用了函数 B，那么在取出乒乓球之前，我们需要往球桶里塞一个乒乓球。而我们从球桶最上面拿乒乓球的时候，拿的也一定是最近一次的，也就是最下面一层的函数调用完成后的地址。乒乓球桶的底部，就是<strong>栈底</strong>，最上面的乒乓球所在的位置，就是<strong>栈顶</strong>。</p>
<p><img src="/posts/43fdc889/image-20210328183759840.png" alt="image-20210328183759840"></p>
<p>在真实的程序里，压栈的不只有函数调用完成后的返回地址。比如函数 A 在调用 B 的时候，需要传输一些参数数据，这些参数数据在寄存器不够用的时候也会被压入栈中。整个函数 A 所占用的所有内存空间，就是函数 A 的<strong>栈帧</strong>（Stack Frame）。Frame 在中文里也有“相框”的意思，所以，每次到这里，我都有种感觉，整个函数 A 所需要的内存空间就像是被这么一个“相框”给框了起来，放在了栈里面。</p>
<p>而实际的程序栈布局，顶和底与我们的乒乓球桶相比是倒过来的。底在最上面，顶在最下面，这样的布局是因为栈底的内存地址是在一开始就固定的。而一层层压栈之后，栈顶的内存地址是在逐渐变小而不是变大。</p>
<p><img src="/posts/43fdc889/image-20210328183847854.png" alt="image-20210328183847854"></p>
<p>对应上面函数 add 的汇编代码，我们来仔细看看，main 函数调用 add 函数时，add 函数入口在 0～1 行，add 函数结束之后在 12～13 行。</p>
<p>我们在调用第 34 行的 call 指令时，会把当前的 PC 寄存器里的下一条指令的地址压栈，保留函数调用结束后要执行的指令地址。而 add 函数的第 0 行，push rbp 这个指令，就是在进行压栈。这里的 rbp 又叫栈帧指针（Frame Pointer），是一个存放了当前栈帧位置的寄存器。push rbp 就把之前调用函数，也就是 main 函数的栈帧的栈底地址，压到栈顶。</p>
<p>接着，第 1 行的一条命令 mov rbp, rsp 里，则是把 rsp 这个栈指针（Stack Pointer）的值复制到 rbp 里，而 rsp 始终会指向栈顶。这个命令意味着，rbp 这个栈帧指针指向的地址，变成当前最新的栈顶，也就是 add 函数的栈帧的栈底地址了。</p>
<p>而在函数 add 执行完成之后，又会分别调用第 12 行的 pop rbp 来将当前的栈顶出栈，这部分操作维护好了我们整个栈帧。然后，我们可以调用第 13 行的 ret 指令，这时候同时要把 call 调用的时候压入的 PC 寄存器里的下一条指令出栈，更新到 PC 寄存器中，将程序的控制权返回到出栈后的栈顶。</p>
<h2 id="如何利用函数内联进行性能优化？"><a href="#如何利用函数内联进行性能优化？" class="headerlink" title="如何利用函数内联进行性能优化？"></a>如何利用函数内联进行性能优化？</h2><p>上面我们提到一个方法，把一个实际调用的函数产生的指令，直接插入到的位置，来替换对应的函数调用指令。尽管这个通用的函数调用方案，被我们否决了，但是如果被调用的函数里，没有调用其他函数，这个方法还是可以行得通的。</p>
<p>事实上，这就是一个常见的编译器进行自动优化的场景，我们通常叫<strong>函数内联</strong>（Inline）。我们只要在 GCC 编译的时候，加上对应的一个让编译器<strong>自动优化的参数 -O</strong>，编译器就会在可行的情况下，进行这样的指令替换。</p>
<p>我们来看一段代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="keyword">static</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">int</span> x = rand() % <span class="number">5</span></span><br><span class="line">    <span class="keyword">int</span> y = rand() % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> u = add(x, y)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;u = %d\n&quot;</span>, u)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免编译器优化掉太多代码，我小小修改了一下 function_example.c，让参数 x 和 y 都变成了，通过随机数生成，并在代码的最后加上将 u 通过 printf 打印出来的语句。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -g -c -O function_example_inline.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> objdump -d -M intel -S function_example_inline.o</span></span><br></pre></td></tr></table></figure>

<p>上面的 function_example_inline.c 的编译出来的汇编代码，没有把 add 函数单独编译成一段指令顺序，而是在调用 u = add(x, y) 的时候，直接替换成了一个 add 指令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">  return a+b;</span><br><span class="line">4c:   01 de                   add    esi,ebx</span><br></pre></td></tr></table></figure>

<p>除了依靠编译器的自动优化，你还可以在定义函数的地方，加上 inline 的关键字，来提示编译器对函数进行内联。</p>
<p><strong>内联带来的优化是，CPU 需要执行的指令数变少了</strong>，根据地址跳转的过程不需要了，压栈和出栈的过程也不用了。</p>
<p>如果一个函数在很多地方都被调用了，那么就会展开很多次，整个程序占用的空间就会变大了。</p>
<p>这样没有调用其他函数，只会被调用的函数，我们一般称之为<strong>叶子函数</strong>（或叶子过程）。</p>
<h2 id="总结延伸"><a href="#总结延伸" class="headerlink" title="总结延伸"></a>总结延伸</h2><p>这一节，我们讲了一个程序的函数间调用，在 CPU 指令层面是怎么执行的。其中一定需要你牢记的，就是<strong>程序栈</strong>这个新概念。</p>
<p>我们可以方便地通过压栈和出栈操作，使得程序在不同的函数调用过程中进行转移。而函数内联和栈溢出，一个是我们常常可以选择的优化方案，另一个则是我们会常遇到的程序 Bug。</p>
<p>通过加入了程序栈，我们相当于在指令跳转的过程种，加入了一个“记忆”的功能，能在跳转去运行新的指令之后，再回到跳出去的位置，能够实现更加丰富和灵活的指令执行流程。这个也为我们在程序开发的过程中，提供了“函数”这样一个抽象，使得我们在软件开发的过程中，可以复用代码和指令，而不是只能简单粗暴地复制、粘贴代码和指令。</p>
<p>补充理解：<a href="https://manybutfinite.com/post/journey-to-the-stack/">https://manybutfinite.com/post/journey-to-the-stack/</a></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数中的向量和矩阵范数</title>
    <url>/posts/8c66907d.html</url>
    <content><![CDATA[<h2 id="向量范数与矩阵范数"><a href="#向量范数与矩阵范数" class="headerlink" title="向量范数与矩阵范数"></a>向量范数与矩阵范数</h2><span id="more"></span>

<h3 id="1范数概念的引入"><a href="#1范数概念的引入" class="headerlink" title="1范数概念的引入"></a>1范数概念的引入</h3><p>为了度量线性空间中向量或矩阵的“大小”，我们引入范数。</p>
<h3 id="2向量范数：向量的长度模"><a href="#2向量范数：向量的长度模" class="headerlink" title="2向量范数：向量的长度模"></a>2向量范数：向量的长度模</h3><p><img src="/posts/8c66907d/image-20210416145257456.png" alt="image-20210416145257456"></p>
<p><strong>定义：</strong></p>
<p><img src="/posts/8c66907d/image-20210416145311430.png" alt="image-20210416145311430"></p>
<p><strong>常见的几种范数：</strong></p>
<p><img src="/posts/8c66907d/image-20210416145429022.png" alt="image-20210416145429022"></p>
<p><strong>定义向量间的距离：</strong></p>
<p><img src="/posts/8c66907d/image-20210416145554010.png" alt="image-20210416145554010"></p>
<p><strong>从几何角度理解范数：</strong></p>
<p><img src="/posts/8c66907d/image-20210416145707027.png" alt="image-20210416145707027"></p>
<h3 id="3矩阵范数"><a href="#3矩阵范数" class="headerlink" title="3矩阵范数"></a>3矩阵范数</h3><p><img src="/posts/8c66907d/image-20210416145806961.png" alt="image-20210416145806961"></p>
<p><img src="/posts/8c66907d/image-20210416145818249.png" alt="image-20210416145818249"></p>
<p><strong>常见矩阵范数：</strong></p>
<p><img src="/posts/8c66907d/image-20210416145900729.png" alt="image-20210416145900729"></p>
<p><strong>求矩阵范数：</strong></p>
<p><img src="/posts/8c66907d/image-20210416145927592.png" alt="image-20210416145927592"></p>
<p><img src="/posts/8c66907d/image-20210416145938628.png" alt="image-20210416145938628"></p>
<p><img src="/posts/8c66907d/image-20210416145947626.png" alt="image-20210416145947626"></p>
<p><strong>从几何角度理解范数：</strong></p>
<p><img src="/posts/8c66907d/image-20210416150018177.png" alt="image-20210416150018177"></p>
<p><img src="/posts/8c66907d/image-20210416150029711.png" alt="image-20210416150029711"></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>范数</tag>
      </tags>
  </entry>
  <entry>
    <title>群的定义与基本性质</title>
    <url>/posts/a91f2eaa.html</url>
    <content><![CDATA[<p>转载自知乎用户：<a href="https://zhuanlan.zhihu.com/p/162840687?utm_source=qq&utm_medium=social&utm_oi=1122533587357892608">@0003</a>抽象代数不抽象专栏。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol>
<li><p>群是代数学中最基本的代数结构，群论也是抽象代数中最基础的一部分。群是某个群及其在该群上规定的某种二元运算的集合，并且该集合满足一定的条件。集合中的元素可以是数，也可以是集合，在群论中都可以抽象为互异的元素。</p>
<span id="more"></span>
</li>
<li><p>如果需要应对抽象代数的考试，请适当多做一些习题。如果不是，请适当多看一些习题。</p>
</li>
<li><p>本章主要包括群的定义、基本性质、群的阶与元素的阶、循环群等基本概念。有关子群、陪集、Lagrange定理、群同态与群同构、群同态基本定理等内容放在下一篇文章中。在本科低年级的抽象代数课程中，群论通常占教学内容的一半。</p>
</li>
</ol>
<h2 id="1-1-群的定义"><a href="#1-1-群的定义" class="headerlink" title="1.1 群的定义"></a>1.1 群的定义</h2><p>群有几种不同的等价定义，这里先给出其中广泛采用的一种。</p>
<blockquote>
<p> 群的定义</p>
<p>如果一个非空集合 $G$ 上定义了一个二元运算 $\bullet$ ，满足如下性质：</p>
<p>(1) 封闭性, 即对于 $\forall a, b \in G$, 有 $a \bullet b \in G$;</p>
<p>(2) 结合律, 即对于 $\forall a, b, c \in G$, 有 $(a \bullet b) \bullet c=a \bullet(b \bullet c)$;</p>
<p>(3) 存在 $e \in G$, 使得 $\forall a \in G$, 有 $e \bullet a=a$;</p>
<p>(4) 对于 $\forall a \in G$, 存在 $b \in G$, 使得 $b \bullet a=e$, </p>
<p>则称 $G$ 关于运算 $\bullet$ 构成一个群, 记为 $(G, \bullet)$, 或简记为 $G$ 。</p>
</blockquote>
<p>上述定义中，第 $(3)$ 条中的元素 $e$ 称为<strong>单位元</strong> (identity)，第 $(4)$ 条中的 $b$ 称为 $a$ 的<strong>逆元</strong> (inverse)， 通常也记作 $a^{-1}$ 。只成立 (1) 的集合 $G$ 称为原群 (magma) ; 只成立 (1)(2) 的集合 $G$ 称为<strong>半群</strong> (semigroup) ; 只成立 (1)(2) (3) 的集合 $G$ 称为<strong>幺半群</strong> (monoid) 。例如，在 $\mathbb{R}^{3}$ 上的向量积由于不满足结合律，无法构成半群。全体正整数对于整数加法构成半群，全体自然数对于整数加法构成幺半群，全体整数对于整数加法构成群。与上述定 义等价的一种定义可以称为群的单边定义，即</p>
<blockquote>
<p>群的单边定义 </p>
<p>如果一个非空集合 $G$ 上定义了一个二元运算 $\bullet$ ，满足如下性质:</p>
<p>(1) 封闭性, 即对于 $\forall a, b \in G$, 有 $a \bullet b \in G ;$</p>
<p>(2) 结合律, 即对于 $\forall a, b, c \in G$, 有 $(a \bullet b) \bullet c=a \bullet(b \bullet c) ;$</p>
<p>(3’) 存在 $e \in G$, 使得 $\forall a \in G$, 有 $e \bullet a=a$;</p>
<p>(4’) 对于 $\forall a \in G$, 存在 $b \in G$, 使得 $b \bullet a=e$, </p>
<p>则称 $G$ 关于运算 $\bullet$ 构成一个群，记为 $(G, \bullet)$, 或简记为 $G$ 。</p>
</blockquote>
<p>上述定义中, 第 $\left(3^{\prime}\right)$ 条中的元素 $e$ 称为左单位元, 第 $\left(4^{\prime}\right)$ 条中的 $b$ 称为 $a$ 的左逆元。群的单边定义与定义的等价性通常作为教科书的习题, 证明非常简单。同样地, 有右单位元和右逆元的 半群也是群。</p>
<blockquote>
<p>思考：有左单位元和右逆元的半群是群吗? 即在半群 $G$ 中，</p>
<p>(3’) 存在 $e \in G$, 使得 $\forall a \in G$, 有 $e \bullet a=a$;</p>
<p>(4’’) 对于 $\forall a \in G$, 存在 $b \in G$, 使得 $a \bullet b=e$,</p>
</blockquote>
<p>上述思考中，对于 “右逆元” 的定义可能会产生歧义, 这里明确第 (4’’) 条中的 $e$ 指的是第 (3’) 条中的左单位元，否则没有讨论的价值。答案是, 这样的半群并不能构成群, 而是一个可以 称之为left-right system的结构。例：规定集合中所有元素的运算规则为 $a \bullet b=b$, 则可以证 明该运算封闭、满足结合律，且集合中存在左单位元和右逆元，但并不存在右单位元。这里再给出 一种群的等价定义，其等价性也很容易证明。</p>
<blockquote>
<p>群的第二定义 如果一个非空集合 $G$ 上定义了一个二元运算 $\bullet$ ，满足如下性质：</p>
<p>(1) 封闭性, 即对于 $\forall a, b \in G$, 有 $a \bullet b \in G$;</p>
<p>(2) 结合律, 即对于 $\forall a, b, c \in G$, 有 $(a \bullet b) \bullet c=a \bullet(b \bullet c)$;</p>
<p>(5) 对于 $\forall a, b \in G$, 方程 $x \bullet a=b$ 与 $a \bullet y=b$ 在 $G$ 中都有解, </p>
<p>则称 $G$ 关于运算 $\bullet$ 构成一个群, 记为 $(G, \bullet)$, 或简记为 $G$ 。</p>
</blockquote>
<p>Remarks：群是一个带有某种运算的集合。这个运算如何表示并不重要，可以是加法和乘法, 也可 以是其他的运算。在群论中通常将运算符号省略不写，并不失一般性地称群中的运算为乘法。乘法 群中的单位元通常写作1或 $e$; 加法群中的单位元通常写作0，逆元通常写作 $-a$.</p>
<p>群的分类方式有很多，最常见的是根据群中元素的个数分为有限群和无限群。另外，还有一种重要的群称为交换群，定义如下：</p>
<blockquote>
<p>交换群的定义 </p>
<p>如果一个群 $G$ 中的任意两个元素 $a, b$ 都满足 $a b=b a$, 则该群称为<strong>交换群</strong>或<strong>Abel群</strong>。</p>
</blockquote>
<p>后续部分请参看<a href="https://zhuanlan.zhihu.com/p/162840687?utm_source=qq&utm_medium=social&utm_oi=1122533587357892608">原文</a>。</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>群论</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（一）</title>
    <url>/posts/a8eb63b6.html</url>
    <content><![CDATA[<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>1.有足够的刷题量（最好200+）</p>
<p>2.锻炼自己的调试能力</p>
<p>3.最好参加模拟赛</p>
<p>4.安排：周日（知识点+例题，取自真题）；周六（扩展+练习）</p>
<p>5.在参考时间内AC（从开始写到AC的时间），练熟练度</p>
<p>6.强调，算法一定要落实到代码的具体实现上</p>
<span id="more"></span>

<p><img src="/posts/a8eb63b6/image-20210219144746547.png" alt="image-20210219144746547"></p>
<h2 id="由数据范围反推算法复杂度以及算法内容"><a href="#由数据范围反推算法复杂度以及算法内容" class="headerlink" title="由数据范围反推算法复杂度以及算法内容"></a>由数据范围反推算法复杂度以及算法内容</h2><p>一般ACM或者笔试题的时间限制是1秒或2秒。<br>在这种情况下，C++代码中的操作次数控制在 10$^7$∼10$^8$最佳。</p>
<p>题目中的数据范围可以给我们很大的提示！！！</p>
<p>注：</p>
<ol>
<li>O(logn)一般指$\log_2n$.</li>
<li>int范围约是2*10$^9$.</li>
<li>long long的范围约是10$^{18}$.</li>
</ol>
<p>下面给出在<strong>不同数据范围下</strong>，代码的时间复杂度和算法该如何选择：</p>
<ol>
<li>n≤30, 指数级别, dfs+剪枝，状态压缩dp</li>
<li>n≤100 =&gt; O(n$^3$)，floyd，dp，高斯消元</li>
<li>n≤1000 =&gt; O(n$^2$)，O($n^2logn$)，dp，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford</li>
<li>n≤10000 =&gt; O(n∗$\sqrt n$)，块状链表、分块、莫队</li>
<li>n≤100000 =&gt; O($nlogn$) =&gt; 各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分</li>
<li>n≤1000000 =&gt; O(n), 以及常数较小的 O($nlogn$) 算法 =&gt; 单调队列、 hash、双指针扫描、并查集，kmp、AC自动机，常数比较小的 O($nlogn$)的做法：sort、树状数组、heap、dijkstra、spfa</li>
<li>n≤10000000 =&gt; O(n)，双指针扫描、kmp、AC自动机、线性筛素数</li>
<li>n≤10$^9$=&gt; O($\sqrt n$)，判断质数</li>
<li>n≤10$^{18}$ =&gt; O($logn$)，最大公约数，快速幂（接近long long范围）</li>
<li>n≤10$^{1000}$=&gt; O($(logn)^2$)，高精度加减乘除</li>
<li>n≤10$^{100000}$=&gt; O($logk×loglogk$)，k表示位数，高精度加减、FFT/NTT</li>
</ol>
<p>作者：yxc<br>链接：<a href="https://www.acwing.com/blog/content/32/">https://www.acwing.com/blog/content/32/</a><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="一-递归与递推"><a href="#一-递归与递推" class="headerlink" title="一 递归与递推"></a>一 递归与递推</h2><h3 id="1-关于scanf-printf与cin-cout的比较："><a href="#1-关于scanf-printf与cin-cout的比较：" class="headerlink" title="1.关于scanf/printf与cin/cout的比较："></a>1.关于<code>scanf/printf</code>与<code>cin/cout</code>的比较：</h3><p><code>cin/cout</code>速度稍慢，当数据范围&lt; 10$^5$时用；</p>
<p><code>scanf/printf</code>速度巨快，当数据范围&gt;= 10$^5$时用。</p>
<h3 id="2-递归-dfs"><a href="#2-递归-dfs" class="headerlink" title="2.递归(dfs)"></a>2.递归(dfs)</h3><p>dfs也即深度优先搜索。</p>
<p>所有递归问题都能画出一棵递归搜索树，方便分析。</p>
<p><img src="/posts/a8eb63b6/image-20210219154349224.png" alt="image-20210219154349224"></p>
<p>常用数字最好记一下：</p>
<p><img src="/posts/a8eb63b6/image-20210219154600997.png" alt="image-20210219154600997"></p>
<h4 id="2-1-acwing-92-递归实现指数型枚举"><a href="#2-1-acwing-92-递归实现指数型枚举" class="headerlink" title="2.1 acwing.92. 递归实现指数型枚举"></a>2.1 acwing.92. 递归实现指数型枚举</h4><p>从 1~n 这 n 个整数中随机选取任意多个，输出所有可能的选择方案。</p>
<p>输入格式</p>
<p>输入一个整数n。</p>
<p>输出格式</p>
<p>每行输出一种方案。</p>
<p><strong>同一行内的数必须升序排列</strong>，相邻两个数用恰好1个空格隔开。</p>
<p>对于没有选任何数的方案，输出空行。</p>
<p>本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。</p>
<p>数据范围</p>
<p>1≤n≤15</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>y总思路：</strong></p>
<p>从数据范围推断时间复杂度约为O(2$^n$)/O(n*2$^n$)。</p>
<p><strong>递归最重要</strong>的是顺序，要把所有方案不重复不遗漏的找出来。</p>
<p>先画图：</p>
<p><img src="/posts/a8eb63b6/image-20210219160249609.png" alt="image-20210219160249609"></p>
<p>注意边界问题：</p>
<p><img src="/posts/a8eb63b6/image-20210222114352254.png" alt="image-20210222114352254"></p>
<p>再考虑代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// soluition 1，y总题解，直接输出排列</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;// 4个最常见的头文件先写上</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> st[N];<span class="comment">// 状态，记录每个位置当前状态，0表示还没考虑，1表示选他，2表示不选</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="comment">// 记录方案，，下标从1开始</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st[i] == <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    st[u] = <span class="number">1</span>;<span class="comment">// 第一个分支</span></span><br><span class="line">    dfs(u+<span class="number">1</span>);</span><br><span class="line">    st[u] = <span class="number">0</span>;<span class="comment">// 恢复现场</span></span><br><span class="line">    </span><br><span class="line">    st[u] = <span class="number">2</span>;<span class="comment">// 第二个分支</span></span><br><span class="line">    dfs(u+<span class="number">1</span>);</span><br><span class="line">    st[u] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// solution 2，用vector存储数组再输出，y总思路</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> st[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ways;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; way;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )  <span class="comment">// 记录方案，下标从1开始</span></span><br><span class="line">            <span class="keyword">if</span> (st[i] == <span class="number">1</span>)</span><br><span class="line">                way.push_back(i);</span><br><span class="line">        ways.push_back(way);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    st[u] = <span class="number">2</span>;</span><br><span class="line">    dfs(u + <span class="number">1</span>);     <span class="comment">// 第一个分支：不选</span></span><br><span class="line">    st[u] = <span class="number">0</span>;  <span class="comment">// 恢复现场</span></span><br><span class="line"></span><br><span class="line">    st[u] = <span class="number">1</span>;</span><br><span class="line">    dfs(u + <span class="number">1</span>);     <span class="comment">// 第二个分支：选</span></span><br><span class="line">    st[u] = <span class="number">0</span>;  <span class="comment">// 恢复现场</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ways.size(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ways[i].size(); j ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ways[i][j]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">作者：Bug_FreeOωO</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/6682/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h4 id="2-2-acwing-94-递归实现排列型枚举"><a href="#2-2-acwing-94-递归实现排列型枚举" class="headerlink" title="2.2 acwing.94.递归实现排列型枚举"></a>2.2 acwing.94.递归实现排列型枚举</h4><p> <a href="http://www.grantdrew.top/posts/f62c90a7.html">语法课有一道类似题目823.排列</a></p>
<p>把 1~n 这 n 个整数排成一行后随机打乱顺序，输出所有可能的次序。</p>
<p>输入格式<br>            一个整数n。</p>
<p>输出格式<br>        按照从小到大的顺序输出所有方案，每行1个。</p>
<p>首先，同一行相邻两个数用一个空格隔开。</p>
<p>其次，对于两个不同的行，对应下标的数一一比较，<strong>字典序较小的排在前面</strong>。</p>
<p>数据范围<br>         1≤n≤9<br>        输入样例：<br>              3<br>        输出样例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h5 id="1思路："><a href="#1思路：" class="headerlink" title="1思路："></a>1思路：</h5><p>顺序1：依次枚举每个数放在哪个位置；</p>
<p>顺序2：依次枚举每个位置放哪个数。</p>
<h5 id="2画出递归搜索树（以顺序2为例）："><a href="#2画出递归搜索树（以顺序2为例）：" class="headerlink" title="2画出递归搜索树（以顺序2为例）："></a><strong>2画出递归搜索树</strong>（以顺序2为例）：</h5><p><img src="/posts/a8eb63b6/image-20210225172255694.png" alt="image-20210225172255694"></p>
<h5 id="3代码实现："><a href="#3代码实现：" class="headerlink" title="3代码实现："></a><strong>3代码实现</strong>：</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>  state[N]; <span class="comment">// 0表示还没放数，1~n表示放了哪个数</span></span><br><span class="line"><span class="keyword">bool</span> used[N]; <span class="comment">// true表示用过，false表示没用过</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (u &gt; n)<span class="comment">// 边界</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,state[i]);<span class="comment">// 打印方案</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 依次枚举每个分支，当前位置可以填哪些数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!used[i])</span><br><span class="line">		&#123;</span><br><span class="line">			state[u] = i;<span class="comment">// 第一个位置放1</span></span><br><span class="line">			used[i] = <span class="literal">true</span>;</span><br><span class="line">			dfs(u+<span class="number">1</span>);<span class="comment">// 在第2到n个位置放数</span></span><br><span class="line">			<span class="comment">// 恢复现场</span></span><br><span class="line">			state[u] = <span class="number">0</span>;<span class="comment">// 其实没必要加</span></span><br><span class="line">			used[i] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	dfs(<span class="number">1</span>);<span class="comment">// 注意：下标从1开始，所以dfs(1)</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>u代表层数（也就是放数的第n个位置），n代表分支数。搜索完一个分支，再搜索另一个分支。递归其实就是函数调用，你手动模拟一下函数的执行过程就清楚了。</p>
<h5 id="4时间复杂度分析："><a href="#4时间复杂度分析：" class="headerlink" title="4时间复杂度分析："></a><strong>4时间复杂度分析</strong>：</h5><p>（作为扩展内容，蓝桥杯不要求掌握，但以后面试会用到）</p>
<p><img src="/posts/a8eb63b6/image-20210225175859772.png" alt="image-20210225175859772"></p>
<p><img src="/posts/a8eb63b6/image-20210225180930832.png" alt="image-20210225180930832"></p>
<p>第一层：枚举分支，有一个for循环，复杂度为n；</p>
<p>第二层：有n个函数，每个函数有一个for循环，复杂度为n*n；</p>
<p>第三层：填完一个位置后，还有n-1个位置，复杂度为<code>n*(n-1)*n</code>；</p>
<p>…</p>
<p>最后一层：每个叶子节点输出方案，有一个for循环，复杂度为<code>n!*n</code>。</p>
<p>加起来，通过不等式放缩证明：<code>n! &lt;= (1+n+n(n-1)+n(n-1)(n-2)+...+n!) &lt;= 3*n!</code>，因为括号外层还有个n，所以最终时间复杂度为$O(n*n!)$</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（七）</title>
    <url>/posts/ba5ecc58.html</url>
    <content><![CDATA[<h4 id="1-7-acwing-1227-分巧克力（蓝桥杯省赛C-A-B组）"><a href="#1-7-acwing-1227-分巧克力（蓝桥杯省赛C-A-B组）" class="headerlink" title="1.7 acwing.1227. 分巧克力（蓝桥杯省赛C++A/B组）"></a>1.7 acwing.1227. 分巧克力（蓝桥杯省赛C++A/B组）</h4><span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">儿童节那天有 K 位小朋友到小明家做客。</span><br><span class="line">小明拿出了珍藏的巧克力招待小朋友们。</span><br><span class="line">小明一共有 N 块巧克力，其中第 i 块是 Hi×Wi 的方格组成的长方形。</span><br><span class="line">为了公平起见，小明需要从这 N 块巧克力中切出 K 块巧克力分给小朋友们。</span><br><span class="line">切出的巧克力需要满足：</span><br><span class="line">形状是正方形，边长是整数</span><br><span class="line">大小相同</span><br><span class="line">例如一块 <span class="number">6</span>×<span class="number">5</span> 的巧克力可以切出 <span class="number">6</span> 块 <span class="number">2</span>×<span class="number">2</span> 的巧克力或者 <span class="number">2</span> 块 <span class="number">3</span>×<span class="number">3</span> 的巧克力。</span><br><span class="line">当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少么？</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含两个整数 N 和 K。</span><br><span class="line">以下 N 行每行包含两个整数 Hi 和 Wi。</span><br><span class="line">输入保证每位小朋友至少能获得一块 <span class="number">1</span>×<span class="number">1</span> 的巧克力。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出切出的正方形巧克力最大可能的边长。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤N,K≤<span class="number">105</span>,</span><br><span class="line"><span class="number">1</span>≤Hi,Wi≤<span class="number">105</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">2</span> <span class="number">10</span></span><br><span class="line"><span class="number">6</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>y总思路：</p>
<p><img src="/posts/ba5ecc58/image-20210421181429479.png" alt="image-20210421181429479"></p>
<p><img src="/posts/ba5ecc58/image-20210421225102950.png" alt="image-20210421225102950"></p>
<p>时间复杂度：求f(mid)是O(N)，二分是O(logH)，总的是<code>O(N*logH)</code>，也就是<code>10^5*log10^5</code>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> h[N],w[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        res += (h[i]/mid)*(w[i]/mid); <span class="comment">// res求边长为mid时的块数,h[i]/mid下取整</span></span><br><span class="line">        <span class="keyword">if</span> (res &gt;= k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;h[i],&amp;w[i]);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>,r = <span class="number">1e5</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r+<span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细题解思路请参考：<a href="https://www.acwing.com/solution/content/6883/">https://www.acwing.com/solution/content/6883/</a></p>
<h3 id="2-前缀和"><a href="#2-前缀和" class="headerlink" title="2.前缀和"></a>2.前缀和</h3><h4 id="2-1-acwing-795-前缀和（模板题）"><a href="#2-1-acwing-795-前缀和（模板题）" class="headerlink" title="2.1 acwing.795. 前缀和（模板题）"></a>2.1 acwing.795. 前缀和（模板题）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入一个长度为 n 的整数序列。</span><br><span class="line">接下来再输入 m 个询问，每个询问输入一对 l,r。</span><br><span class="line">对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含两个整数 n 和 m。</span><br><span class="line">第二行包含 n 个整数，表示整数数列。</span><br><span class="line">接下来 m 行，每行包含两个整数 l 和 r，表示一个询问的区间范围。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">共 m 行，每行输出一个询问的结果。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤l≤r≤n,</span><br><span class="line"><span class="number">1</span>≤n,m≤<span class="number">100000</span>,</span><br><span class="line">−<span class="number">1000</span>≤数列中元素的值≤<span class="number">1000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">6</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/ba5ecc58/image-20210423220147521.png" alt="image-20210423220147521"></p>
<p><img src="/posts/ba5ecc58/image-20210423220250988.png" alt="image-20210423220250988"></p>
<p>预处理计算完$S_i$之后，查询L到R的和的时间复杂度就从O(n)降低到O(1)。</p>
<p>暴力做法的话<u>每次</u>查询都得遍历数组，时间复杂度为O(n)。</p>
<p>前缀和思想虽然很简单，但是<strong>非常的重要</strong>。</p>
<p><strong>前缀和能快速查询，但不支持修改。</strong></p>
<p><strong>关于前缀和的问题，为了防止-1下标越界，统一从1开始。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[N],s[N];<span class="comment">// 表示原数组和前缀和数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="comment">// i从1开始，不然i-1越界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        s[i] = s[i<span class="number">-1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（三）</title>
    <url>/posts/d5e32c3c.html</url>
    <content><![CDATA[<blockquote>
<p>续蓝桥杯学习总结（二）。</p>
</blockquote>
<h3 id="3-递推"><a href="#3-递推" class="headerlink" title="3.递推"></a>3.递推</h3><p>关于递归与递推的区别：</p>
<p><strong>递推</strong>：从初值出发反复进行某一运算得到所需结果。—–从<strong>已知到未知</strong>，从小到达（比如每年长高9cm，20年180，30后270）</p>
<p><strong>递归</strong>：从所需结果出发不断回溯前一运算直到回到初值再递推得到所需结果—-从<strong>未知到已知</strong>，从大到小，再从小到大(你想进bat，那么编程就得牛逼，就得卸载玩者农药，努力学习）。<strong>递归(Recursion)是从归纳法(Induction)衍生出来的</strong>。</p>
<span id="more"></span>

<h4 id="3-1-acwing-717-简单斐波那契（语法课）"><a href="#3-1-acwing-717-简单斐波那契（语法课）" class="headerlink" title="3.1 acwing.717.简单斐波那契（语法课）"></a>3.1 acwing.717.简单斐波那契（语法课）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">以下数列<span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> …被称为斐波纳契数列。</span><br><span class="line"></span><br><span class="line">这个数列从第<span class="number">3</span>项开始，每一项都等于前两项之和。</span><br><span class="line"></span><br><span class="line">输入一个整数N，请你输出这个序列的前N项。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">一个整数N。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">在一行中输出斐波那契数列的前N项，数字之间用空格隔开。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">0</span>&lt;N&lt;<span class="number">46</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">5</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> fabo[<span class="number">48</span>];</span><br><span class="line">    fabo[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    fabo[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= n;i ++) fabo[i] = fabo[i<span class="number">-1</span>]+fabo[i<span class="number">-2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="built_in">cout</span> &lt;&lt; fabo[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化版本，节省空间，和语法课相同</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>,b =<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> fn = a + b;</span><br><span class="line">	a = b,b = fn;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-2-acwing-95-费解的开关（算法竞赛进阶指南，难）"><a href="#3-2-acwing-95-费解的开关（算法竞赛进阶指南，难）" class="headerlink" title="3.2 acwing.95.费解的开关（算法竞赛进阶指南，难）"></a>3.2 acwing.95.费解的开关（算法竞赛进阶指南，难）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">你玩过“拉灯”游戏吗？</span><br><span class="line"><span class="number">25</span> 盏灯排成一个 <span class="number">5</span>×<span class="number">5</span> 的方形。</span><br><span class="line">每一个灯都有一个开关，游戏者可以改变它的状态。</span><br><span class="line">每一步，游戏者可以改变某一个灯的状态。</span><br><span class="line">游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。</span><br><span class="line">我们用数字 <span class="number">1</span> 表示一盏开着的灯，用数字 <span class="number">0</span> 表示关着的灯。</span><br><span class="line">下面这种状态</span><br><span class="line"><span class="number">10111</span></span><br><span class="line"><span class="number">01101</span></span><br><span class="line"><span class="number">10111</span></span><br><span class="line"><span class="number">10000</span></span><br><span class="line"><span class="number">11011</span></span><br><span class="line">在改变了最左上角的灯的状态后将变成：</span><br><span class="line"><span class="number">01111</span></span><br><span class="line"><span class="number">11101</span></span><br><span class="line"><span class="number">10111</span></span><br><span class="line"><span class="number">10000</span></span><br><span class="line"><span class="number">11011</span></span><br><span class="line">再改变它正中间的灯后状态将变成：</span><br><span class="line"><span class="number">01111</span></span><br><span class="line"><span class="number">11001</span></span><br><span class="line"><span class="number">11001</span></span><br><span class="line"><span class="number">10100</span></span><br><span class="line"><span class="number">11011</span></span><br><span class="line">给定一些游戏的初始状态，编写程序判断游戏者是否可能在 <span class="number">6</span> 步以内使所有的灯都变亮。</span><br><span class="line">输入格式</span><br><span class="line">第一行输入正整数 n，代表数据中共有 n 个待解决的游戏初始状态。</span><br><span class="line">以下若干行数据分为 n 组，每组数据有 <span class="number">5</span> 行，每行 <span class="number">5</span> 个字符。</span><br><span class="line">每组数据描述了一个游戏的初始状态。</span><br><span class="line">各组数据间用一个空行分隔。</span><br><span class="line">输出格式</span><br><span class="line">一共输出 n 行数据，每行有一个小于等于 <span class="number">6</span> 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。</span><br><span class="line">对于某一个游戏初始状态，若 <span class="number">6</span> 步以内无法使所有灯变亮，则输出 −<span class="number">1</span>。</span><br><span class="line">数据范围</span><br><span class="line"><span class="number">0</span>&lt;n≤<span class="number">500</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">00111</span></span><br><span class="line"><span class="number">01011</span></span><br><span class="line"><span class="number">10001</span></span><br><span class="line"><span class="number">11010</span></span><br><span class="line"><span class="number">11100</span></span><br><span class="line"></span><br><span class="line"><span class="number">11101</span></span><br><span class="line"><span class="number">11101</span></span><br><span class="line"><span class="number">11110</span></span><br><span class="line"><span class="number">11111</span></span><br><span class="line"><span class="number">11111</span></span><br><span class="line"></span><br><span class="line"><span class="number">01111</span></span><br><span class="line"><span class="number">11111</span></span><br><span class="line"><span class="number">11111</span></span><br><span class="line"><span class="number">11111</span></span><br><span class="line"><span class="number">11111</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>先枚举第一行的灯，每个灯有按或不按两种选择，可以用到<u>指数型枚举</u>。</p>
<p>第二行的灯受第一行影响，如果第一行灯是灭的，它下方第二行灯必须按，因为只有第二行这个灯能影响它的状态；同理，第一行灯是亮的，它下方第二行灯必须不能按。</p>
<p>由此我们知道，<strong>每一行灯按或不按由前一行状态唯一确定</strong>。</p>
<p><img src="/posts/d5e32c3c/image-20210314090051648.png" alt="image-20210314090051648"></p>
<p><img src="/posts/d5e32c3c/image-20210314092102637.png" alt="image-20210314092102637"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;<span class="comment">// 按一次开关改变5个灯的状态</span></span><br><span class="line"><span class="keyword">char</span> g[N][N], backup[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个操作是把(x, y)以及上下左右的灯都变成相反的颜色</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><span class="comment">// 通过坐标偏移量实现</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        <span class="comment">//如果在边界外边，直接忽略即可</span></span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= <span class="number">5</span> || b &lt; <span class="number">0</span> || b &gt;= <span class="number">5</span>) <span class="keyword">continue</span>;</span><br><span class="line">        g[a][b] ^= <span class="number">1</span>;   <span class="comment">//异或，值不同时结果为1，相同为0</span></span><br><span class="line">        <span class="comment">// &#x27;0&#x27;是48 所以 ^1就是49 ==&#x27;1&#x27;</span></span><br><span class="line">        <span class="comment">// &#x27;0&#x27;对应十进制48,110000（2），110000 ^ 000001 = 110001(对应十进制49，&#x27;1&#x27;)</span></span><br><span class="line">       <span class="comment">// &#x27;0&#x27;^1 = &#x27;1&#x27;,&#x27;1&#x27;^1=&#x27;0&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 按行输入，把每一行当成一个字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ ) <span class="built_in">cin</span> &gt;&gt; g[i];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 这里我们枚举了第一行的32种按法，不用管是亮是灭，把第一行所有情况都按一遍</span></span><br><span class="line">        <span class="comment">// 按每种情况的第一行，去遍历接下来的行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> op = <span class="number">0</span>; op &lt; <span class="number">32</span>; op ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 我在对这种情况操作的时候，得先备用一下</span></span><br><span class="line">            <span class="comment">// 把原始数组备份一下，然后操作g，操作完了还原，然后再操作</span></span><br><span class="line">            <span class="built_in">memcpy</span>(backup, g, <span class="keyword">sizeof</span> g);</span><br><span class="line">            <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 第一行的按法(在这里 1 表示按了, 0 表示不按)，这里只是为了输出第一行按完之后的状态</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ )</span><br><span class="line">                <span class="keyword">if</span> (op &gt;&gt; i &amp; <span class="number">1</span>)  <span class="comment">// 取op对应二进制数的第i位数字</span></span><br><span class="line">                                  <span class="comment">// 00010 &gt;&gt; 1 &amp; 1  是1 所以turn(0, 1) 就是第一行第二个位置</span></span><br><span class="line">                &#123;                 <span class="comment">// 数字3 对应了00011 表示第1 和第2个位置的按一下</span></span><br><span class="line">                    step ++ ;</span><br><span class="line">                    turn (<span class="number">0</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// 然后通过第一行按完之后的状态，按234行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )<span class="comment">// 枚举行数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>;j ++ )<span class="comment">// 枚举每行的灯</span></span><br><span class="line">                    <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        step ++;</span><br><span class="line">                        turn (i + <span class="number">1</span>, j);  <span class="comment">// 如果这个位置是灭的，就按下一行对应的位置</span></span><br><span class="line">                    &#125;</span><br><span class="line">            <span class="keyword">bool</span> dark = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j ++ )</span><br><span class="line">                <span class="keyword">if</span> (g[<span class="number">4</span>][j] == <span class="string">&#x27;0&#x27;</span>)<span class="comment">// 判断最后一行的灯，如果至少有一个暗就无解</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dark = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对于32种情况的这一种，如果所有的全亮就记录下步数(事实上只记录了最后一行是否dark)</span></span><br><span class="line">            <span class="keyword">if</span> (!dark) res = min(res, step);</span><br><span class="line">            <span class="built_in">memcpy</span> (g, backup, <span class="keyword">sizeof</span> g);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res &gt; <span class="number">6</span>) res = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h5><ul>
<li><strong>细节很多，一定要自己多动手写写，最好打一下挑战模式</strong></li>
<li>枚举第一行时：1表示按一下，0表示不按(当然反过来也可以啦~看你)</li>
<li>在遍历整个矩阵时：1是灯亮，0是灯灭</li>
<li>memcpy 可以用来复制数组，这里是先把原数组备份一下，然后对本数组操作，本次操作结束后，要再把备份数组还原回来，再进行下一次操作啦~</li>
<li>从第一行开始递推，若达到第n行不全为0，说明这种点击方式不合法。<br>在所有合法的点击方式中取点击次数最少的就是答案。<br>对第一行的32次枚举涵盖了该问题的整个状态空间，因此该做法是正确的</li>
<li>时间复杂度：<code>32*25*5*500</code><br>对第一行操作有32种可能 * 共有25个灯 * 每一次操作改变5个灯的状态 * 最多读入的时候可能有500次light矩阵</li>
<li>如果是一个偶数^1,那么答案是偶数+1.如果是一个奇数^1,那么答案是奇数-1。</li>
</ul>
<p>代码 by y总</p>
<p>注释 by 小张同学 &amp; grant</p>
<p><a href="https://www.acwing.com/solution/content/8747/">链接</a></p>
<h5 id="补充说明："><a href="#补充说明：" class="headerlink" title="补充说明："></a>补充说明：</h5><p>首先，这题根本就没有什么所谓的状压dp，而且只有一个地方用到了状态压缩，即第一行按开关的方式</p>
<p>本题主要的考察内容其实就是位运算，暴力以及一些递推思想</p>
<p><strong>1.高票题解代码中的 if (k &gt;&gt; j &amp; 1) 究竟什么意思？</strong></p>
<p>其中，k保存的根本就不是第一行的灯所有可能的状态，不然它第j位都为1了还按它干嘛？ k单纯只是保存了第一行按开关的32种方式，与输入数据无关。</p>
<p>且大多数题解代码中都规定了k在二进制下某位为1就代表我们选择按下这一位所在编号的开关，你也可以自己规定k在二进制下某位为0才代表我们选择按下这一位所在编号的开关，这都无所谓。</p>
<p>比如k在二进制下表示为10001，就代表我们选择按第一行编号为0和编号为4的开关，然后对输入数据中第一行这两位执行turn操作。</p>
<p><strong>2.递推思想</strong></p>
<p>当前行若某一位(i,j)为0，那就用其所在列的下一行(i+1,j)去执行turn操作，以使(i,j)变为1，即变亮。</p>
<p>如果对(i,j)执行turn操作，使(i,j)变为1，就会破坏上一行的灯的状态。</p>
<p>所以只能从下一行去改变上一行的灯的状态。</p>
<p>作者：月入星河晚<br>链接：<a href="https://www.acwing.com/solution/content/22367/">https://www.acwing.com/solution/content/22367/</a><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（九）</title>
    <url>/posts/37f8c544.html</url>
    <content><![CDATA[<p><strong>100里程碑！！！</strong></p>
<p><img src="/posts/37f8c544/image-20210428224908874.png" alt="image-20210428224908874"></p>
<span id="more"></span>

<h4 id="2-4-acwing-1230-K倍区间（蓝桥杯第八届B组）"><a href="#2-4-acwing-1230-K倍区间（蓝桥杯第八届B组）" class="headerlink" title="2.4 acwing.1230. K倍区间（蓝桥杯第八届B组）"></a>2.4 acwing.1230. K倍区间（蓝桥杯第八届B组）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定一个长度为 N 的数列，A1,A2,…AN，如果其中一段连续的子序列 Ai,Ai+<span class="number">1</span>,…Aj 之和是 K 的倍数，我们就称这个区间 [i,j] 是 K 倍区间。</span><br><span class="line">你能求出数列中总共有多少个 K 倍区间吗？</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含两个整数 N 和 K。</span><br><span class="line">以下 N 行每行包含一个整数 Ai。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，代表 K 倍区间的数目。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤N,K≤<span class="number">100000</span>,</span><br><span class="line"><span class="number">1</span>≤Ai≤<span class="number">100000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>在比赛时，未必能一下就想到最优的解法，可以先从简单的暴力做法写起，拿到一部分分数，不要放弃。</p>
<p><img src="/posts/37f8c544/image-20210428230845430.png" alt="image-20210428230845430"></p>
<p>对于第三重循环计算一段区间的总和，可以用前缀和简化。</p>
<p>我们发现可以存余数来判断是否满足要求，则可以优化成O(n)。</p>
<p>先开一个数组cnt[i]来存余数是i的数有多少个，用空间换时间。</p>
<p>附上一份高赞题解：<a href="https://www.acwing.com/solution/content/6909/">https://www.acwing.com/solution/content/6909/</a></p>
<p>我们可以用一个数组cnt，规定cnt[i]表示当前位置之前，前缀和取模后等于i的个数，以后每出现一次前缀和</p>
<p>（取模后）和它相等，那么k倍区间就加上<code>cnt[s[i] % k]</code>，然后<code>cnt[s[i] % k]++</code>。</p>
<p><code>res += cnt[s[i] % k];</code>先执行，因为要判断当前区间右端点的左边的同余元素，再更新当前位置。</p>
<p><code>cnt=0</code>必须加上，当右端点为1时，若刚好是k的倍数，此时答案应该+1，若没有这句不会+1。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL; <span class="comment">// 可能爆int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line">LL s[N],cnt[N];</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;s[i]);</span><br><span class="line">        s[i] += s[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    cnt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        res += cnt[s[i]%k];</span><br><span class="line">        cnt[s[i]%k]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充：有关段错误的调试方法，使用exit(0)进行二分判断出错位置。</p>
<p>对于类似的没有输出信息的错误都可以采用这种二分找错的方法。</p>
<p><img src="/posts/37f8c544/image-20210429081035194.png" alt="image-20210429081035194"></p>
<h2 id="三-数学与简单DP"><a href="#三-数学与简单DP" class="headerlink" title="三 数学与简单DP"></a>三 数学与简单DP</h2><h3 id="1-数学问题"><a href="#1-数学问题" class="headerlink" title="1.数学问题"></a>1.数学问题</h3><p>关于数学问题，OIwiki是个好东西！</p>
<h4 id="1-1-acwing-1205-买不到的数目（第四届A组）"><a href="#1-1-acwing-1205-买不到的数目（第四届A组）" class="headerlink" title="1.1 acwing.1205. 买不到的数目（第四届A组）"></a>1.1 acwing.1205. 买不到的数目（第四届A组）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">小明开了一家糖果店。</span><br><span class="line">他别出心裁：把水果糖包成<span class="number">4</span>颗一包和<span class="number">7</span>颗一包的两种。</span><br><span class="line">糖果不能拆包卖。</span><br><span class="line">小朋友来买糖的时候，他就用这两种包装来组合。</span><br><span class="line">当然有些糖果数目是无法组合出来的，比如要买 <span class="number">10</span> 颗糖。</span><br><span class="line">你可以用计算机测试一下，在这种包装情况下，最大不能买到的数量是<span class="number">17</span>。</span><br><span class="line"></span><br><span class="line">大于<span class="number">17</span>的任何数字都可以用<span class="number">4</span>和<span class="number">7</span>组合出来。</span><br><span class="line">本题的要求就是在已知两个包装的数量时，求最大不能组合出的数字。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">两个正整数 n,m，表示每种包装中糖的颗数。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">一个正整数，表示最大不能买到的糖数。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">2</span>≤n,m≤<span class="number">1000</span>，</span><br><span class="line">保证数据一定有解。</span><br><span class="line"></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">4</span> <span class="number">7</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>这是一个非常经典的问题，可以当作一个定理来用。（靠数学积累了）</p>
<p>先分析一下：</p>
<p>根据学过的代数知识，对于给定的数n，m，显然有：$(n,m)|n,(n,m)|m$，推出：$(n,m)|xn+ym$</p>
<p>也就是说，n和m的线性组合一定是(n,m)的倍数，只有这种情况才有解。</p>
<p><strong>给定a，b，若d=gcd(a,b)&gt;1,则一定不能凑出最大数。答案要求a，b互质！</strong></p>
<p>有线性代数线性相关、无关，线性表出內味了！</p>
<p>没思路？试试打表找规律！（对于数学问题，没思路不妨试试打表）</p>
<p><strong>补充知识：裴蜀定理</strong>，<a href="https://oi-wiki.org/math/bezouts/">https://oi-wiki.org/math/bezouts/</a></p>
<p>是一个关于最大公约数的定理。</p>
<blockquote>
<p>其内容是：</p>
<p>设a, b是不全为零的整数, 则存在整数x, y,使 $a x+b y=\operatorname{gcd}(a, b).$</p>
</blockquote>
<p>证明过程看上面链接。它的一个重要推论是：a,b互质的充分必要条件是存在整数x,y使ax+by=1.</p>
<p>其实在高等代数的多项式部分有相关的定理、结论。</p>
<p>尝试dfs打表：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (m &gt;= p &amp;&amp; dfs(m-p,p,q)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (m &gt;= q &amp;&amp; dfs(m-q,p,q)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p,q;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; p &gt;&gt; q;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1000</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfs(i,p,q)) res = i;</span><br><span class="line">        <span class="comment">// res会不断更新到最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 2 1</span></span><br><span class="line"><span class="comment">3 4 5</span></span><br><span class="line"><span class="comment">3 5 7</span></span><br><span class="line"><span class="comment">3 7 11</span></span><br><span class="line"><span class="comment">4 9 23</span></span><br><span class="line"><span class="comment">5 9 31</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>m表示当前要凑的总数量，如果m == 0，就表示m已经被凑出来了，否则枚举当前选哪种糖，如果选p并且m - p可以被凑出来，那就是说明m可以被凑出；同理如果选q并且m - q可以被凑出来，那就说明m可以被凑出。</p>
<p>找规律：固定p不变，观察q变化时，答案怎么变化，再固定q不变，观察p变化时，答案怎么变化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>:n+<span class="number">2</span> m+<span class="number">2</span></span><br><span class="line"><span class="number">3</span>:n+<span class="number">1</span> m+<span class="number">2</span></span><br><span class="line"><span class="number">4</span>:n+<span class="number">2</span> m+<span class="number">6</span>    <span class="number">3</span>: m = <span class="number">2</span>n<span class="number">-3</span></span><br><span class="line">                 <span class="number">1</span> = <span class="number">2</span>*<span class="number">2</span> + x x=<span class="number">-3</span>   <span class="number">2</span>n<span class="number">-3</span> = m</span><br><span class="line">             <span class="number">4</span>: m = <span class="number">3</span>n<span class="number">-4</span></span><br><span class="line">             <span class="number">5</span>: m = <span class="number">4</span>n<span class="number">-5</span></span><br><span class="line">             p q</span><br><span class="line">             ans = (q<span class="number">-1</span>)p - q</span><br></pre></td></tr></table></figure>

<p>找到规律直接给出代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 证明比较复杂，以后可以当作结论直接记住</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p,q;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; p &gt;&gt; q;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (p<span class="number">-1</span>)*(q<span class="number">-1</span>)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>前缀和</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（二）</title>
    <url>/posts/98fd8f6e.html</url>
    <content><![CDATA[<blockquote>
<p>续蓝桥杯学习总结（一）。</p>
</blockquote>
<h4 id="2-3-acwing-93-递归实现组合型枚举"><a href="#2-3-acwing-93-递归实现组合型枚举" class="headerlink" title="2.3 acwing.93.递归实现组合型枚举"></a>2.3 acwing.93.递归实现组合型枚举</h4><p>从 1∼n 这 n 个整数中随机选出 m 个，输出所有可能的选择方案。</p>
<span id="more"></span>

<p><strong>输入格式</strong><br>两个整数 n,m ,在同一行用空格隔开。</p>
<p><strong>输出格式</strong><br>按照<strong>从小到大的顺序输出</strong>所有方案，每行 1 个。</p>
<p>首先，同一行内的数升序排列，相邻两个数用一个空格隔开。</p>
<p>其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如 1 3 5 7 排在 1 3 6 8 前面）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">数据范围</span><br><span class="line">n&gt;<span class="number">0</span> ,</span><br><span class="line"><span class="number">0</span>≤m≤n ,</span><br><span class="line">n+(n−m)≤<span class="number">25</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">5</span> <span class="number">3</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">5</span> </span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span> </span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">5</span> </span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br></pre></td></tr></table></figure>

<p>思考题：如果要求使用非递归方法，该怎么做呢？</p>
<h5 id="1思路："><a href="#1思路：" class="headerlink" title="1思路："></a>1思路：</h5><p>先在纸上模拟一遍（不要空想，为难自己），拿笔写一写。</p>
<p><img src="/posts/98fd8f6e/image-20210312223816678.png" alt="image-20210312223816678"></p>
<p>为避免方案的重复，需要限制方案内部是升序的。（与排列型的关键区别）</p>
<p><img src="/posts/98fd8f6e/image-20210312224313978.png" alt="image-20210312224313978"></p>
<h5 id="2画出递归搜索树："><a href="#2画出递归搜索树：" class="headerlink" title="2画出递归搜索树："></a>2画出递归搜索树：</h5><p><img src="/posts/98fd8f6e/image-20210312225045977.png" alt="image-20210312225045977"></p>
<p><img src="/posts/98fd8f6e/image-20210312231046206.png" alt="image-20210312231046206"></p>
<h5 id="3代码实现："><a href="#3代码实现：" class="headerlink" title="3代码实现："></a>3代码实现：</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> way[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 当前进行dfs(u...)，已经选u-1个数，剩下n-strat+1个数可选</span></span><br><span class="line">    <span class="comment">// u-1 + n-strat+1 &lt; m，把后面所有的数都选上，加起来也不够m，直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (u + n - start &lt; m) <span class="keyword">return</span>;<span class="comment">// 递归搜索的剪枝优化，快了近三倍</span></span><br><span class="line">    <span class="keyword">if</span> (u == m + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i ++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,way[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        way[u] = i;</span><br><span class="line">        dfs(u+<span class="number">1</span>,i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        way[u] = <span class="number">0</span>; <span class="comment">//恢复现场</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-acwing-1209-带分数（cpp-B-C组）"><a href="#2-4-acwing-1209-带分数（cpp-B-C组）" class="headerlink" title="2.4 acwing.1209.带分数（cpp B/C组）"></a>2.4 acwing.1209.带分数（cpp B/C组）</h4><p>100可以表示为带分数的形式：$100=3+\frac{69258}{714}$</p>
<p>还可以表示为：$100=82+\frac{3546}{197}$</p>
<p>注意特征：带分数中，数字 1∼9 分别出现且只出现一次（不包含 0）。</p>
<p>类似这样的带分数，100 有 11种表示法。</p>
<p>输入格式</p>
<p>一个正整数。</p>
<p>输出格式</p>
<p>输出输入数字用数码 1∼9不重复不遗漏地组成带分数表示的全部种数。</p>
<p>数据范围</p>
<p>1≤N&lt;$10^6$</p>
<p>输入样例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure>

<p>输出样例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure>

<p>输入样例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">105</span><br></pre></td></tr></table></figure>

<p>输出样例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>

<h5 id="y总思路："><a href="#y总思路：" class="headerlink" title="y总思路："></a>y总思路：</h5><p><img src="/posts/98fd8f6e/image-20210313103504053.png" alt="image-20210313103504053"></p>
<p>剪枝优化：</p>
<p>根据等式，实际上只需要枚举两个变量，另外一个可以算出来。</p>
<p><img src="/posts/98fd8f6e/image-20210313111557554.png" alt="image-20210313111557554"></p>
<p>补充空间复杂度的计算：</p>
<p><img src="/posts/98fd8f6e/image-20210313112130572.png" alt="image-20210313112130572"></p>
<p>代码如下：</p>
<p>两层dfs嵌套是扩展内容，不要求掌握，会一般的全排列暴力搜索就行。</p>
<p>太难了，恐怖如斯。</p>
<p><a href="https://www.acwing.com/solution/content/38879/">参考思路</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> st[N], backup[N];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> b = n * (<span class="keyword">long</span> <span class="keyword">long</span>)c - a * c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!a || !b || !c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(backup, st, <span class="keyword">sizeof</span> st);<span class="comment">// 将st数组复制到backup</span></span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = b % <span class="number">10</span>;     <span class="comment">// 取个位</span></span><br><span class="line">        b /= <span class="number">10</span>;    <span class="comment">// 个位删掉</span></span><br><span class="line">        <span class="keyword">if</span> (!x || backup[x]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        backup[x] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!backup[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_c</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> a, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &gt; <span class="number">9</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (check(a, c)) ans ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            dfs_c(u + <span class="number">1</span>, a, c * <span class="number">10</span> + i);</span><br><span class="line">            st[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_a</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt;= n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (a) dfs_c(u, a, <span class="number">0</span>);<span class="comment">// 对于每一个a，再对c进行枚举</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            dfs_a(u + <span class="number">1</span>, a * <span class="number">10</span> + i);</span><br><span class="line">            st[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    dfs_a(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/activity/content/code/content/159648/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h5 id="解题思路2（看懂这个就行）："><a href="#解题思路2（看懂这个就行）：" class="headerlink" title="解题思路2（看懂这个就行）："></a>解题思路2（看懂这个就行）：</h5><ul>
<li>暴力枚举出9个数的全排列，然后用一个长度为9的数组保存全排列的结果</li>
<li>从全排列的结果中用两重循环暴力分解出三段，每段代表一个数</li>
<li>验证枚举出来的三个数是否满足题干条件，若满足则计数<br>代码如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> target; <span class="comment">//题目给出的目标数</span></span><br><span class="line"><span class="keyword">int</span> num[N]; <span class="comment">//保存全排列的结果</span></span><br><span class="line"><span class="keyword">bool</span> used[N]; <span class="comment">//生成全排列过程中标记是否使用过</span></span><br><span class="line"><span class="keyword">int</span> cnt; <span class="comment">//计数，最后输出的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算num数组中一段的数是多少</span></span><br><span class="line"><span class="comment">//因为c*n == a*c+b有概率会爆int 保险起见longlong </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;<span class="comment">//l是num[l]之前,r是num[r]之后</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">        res = res * <span class="number">10</span> + num[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="comment">//当全排列生成后进行分段</span></span><br><span class="line">    <span class="comment">//用两层循环分成三段</span></span><br><span class="line">    <span class="keyword">if</span>(u == <span class="number">9</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)<span class="comment">// 枚举分隔点1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="number">8</span>; j++)&#123;<span class="comment">// 枚举分隔点2</span></span><br><span class="line">                <span class="keyword">if</span>(j-i+<span class="number">1</span>&lt;<span class="number">9</span>-j)<span class="keyword">continue</span>; <span class="comment">// 剪枝优化1，b的位数一定&gt;=c的位数</span></span><br><span class="line">                <span class="comment">// 位数,a:i + 1; b:j - i; c:8-j</span></span><br><span class="line">                <span class="keyword">int</span> a = calc(<span class="number">0</span>, i);</span><br><span class="line">                <span class="keyword">if</span> (a &gt;= target) <span class="keyword">continue</span>; <span class="comment">// 剪枝优化2，参考自别人</span></span><br><span class="line">                <span class="keyword">int</span> b = calc(i + <span class="number">1</span>, j);</span><br><span class="line">                <span class="keyword">int</span> c = calc(j + <span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">                <span class="comment">//注意判断条件，因为C++中除法是整除，所以要转化为加减乘来计算</span></span><br><span class="line">                <span class="keyword">if</span>(a * c + b == c * target) cnt++;<span class="comment">// 小心爆int</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成全排列</span></span><br><span class="line">    <span class="comment">//搜索模板</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(!used[i])&#123;</span><br><span class="line">            used[i] = <span class="literal">true</span>; <span class="comment">//标记使用</span></span><br><span class="line">            num[u] = i;</span><br><span class="line">            dfs(u + <span class="number">1</span>);</span><br><span class="line">            used[i] = <span class="literal">false</span>; <span class="comment">//还原现场</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;target);</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：Daniel丶y</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/6724/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p><img src="/posts/98fd8f6e/image-20210426123909755.png" alt="image-20210426123909755"></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（五）</title>
    <url>/posts/d50f01e.html</url>
    <content><![CDATA[<h2 id="二-二分与前缀和"><a href="#二-二分与前缀和" class="headerlink" title="二 二分与前缀和"></a>二 二分与前缀和</h2><span id="more"></span>

<h3 id="1-二分"><a href="#1-二分" class="headerlink" title="1.二分"></a>1.二分</h3><h4 id="1-1-整数二分"><a href="#1-1-整数二分" class="headerlink" title="1.1 整数二分"></a>1.1 整数二分</h4><blockquote>
<p>推荐配合<a href="https://grant1499.github.io/2021/03/30/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#more">二分查找</a>食用。最好先看一遍，方便理解。</p>
</blockquote>
<p>对于整数二分，我们可以分成两个模版，下图中给出的是模板1的代码。</p>
<p><img src="/posts/d50f01e/image-20210407173812233.png" alt="image-20210407173812233"></p>
<p>注意：当M取红色时，有<code>L=M</code>，这里的模板1必须保证M等于<code>(L+R+1)/2</code>，括号里加上1对<code>(L+R)/2</code>向上取整，否则会对它向下取整，会导致左边界L一直取到M，陷入死循环。</p>
<p>模板2：</p>
<p><img src="/posts/d50f01e/image-20210407175954091.png" alt="image-20210407175954091"></p>
<p>总结：</p>
<p><img src="/posts/d50f01e/image-20210407180349572.png" alt="image-20210407180349572"></p>
<h4 id="1-2-acwing-789-数的范围（模板题）"><a href="#1-2-acwing-789-数的范围（模板题）" class="headerlink" title="1.2 acwing.789. 数的范围（模板题）"></a>1.2 acwing.789. 数的范围（模板题）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。</span><br><span class="line">对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 <span class="number">0</span> 开始计数）。</span><br><span class="line">如果数组中不存在该元素，则返回 <span class="number">-1</span> <span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含整数 n 和 q，表示数组长度和询问个数。</span><br><span class="line">第二行包含 n 个整数（均在 <span class="number">1</span>∼<span class="number">10000</span> 范围内），表示完整数组。</span><br><span class="line">接下来 q 行，每行包含一个整数 k，表示一个询问元素。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。</span><br><span class="line">如果数组中不存在该元素，则返回 <span class="number">-1</span> <span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤n≤<span class="number">100000</span></span><br><span class="line"><span class="number">1</span>≤q≤<span class="number">10000</span></span><br><span class="line"><span class="number">1</span>≤k≤<span class="number">10000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">6</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>题解1：STL</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// soluition 1，自己写的STL写法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,q,k,i;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">        <span class="keyword">int</span> l = lower_bound(num, num +i, k)-num;</span><br><span class="line">        <span class="keyword">int</span> r = upper_bound(num, num +i, k)-num;</span><br><span class="line">        <span class="comment">//特判一下，l==r时说明上下界重合，未找到</span></span><br><span class="line">        <span class="keyword">if</span> (l==r) <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; r<span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题解2：手打二分</p>
<p><img src="/posts/d50f01e/image-20210410123858425.png" alt="image-20210410123858425"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解，更快一点</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="comment">// 求二分左端点</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = n<span class="number">-1</span>;<span class="comment">// 确定区间范围</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l+r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (q[mid]&gt;=x) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (q[r] == x)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,r);</span><br><span class="line">            <span class="comment">// 求二分x的右端点</span></span><br><span class="line">            r = n<span class="number">-1</span>;<span class="comment">// 右端点一定在[左端点, n - 1] 之间</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">                <span class="comment">// 因为写的是l = mid，所以需要补上1</span></span><br><span class="line">                <span class="keyword">int</span> mid = l+r+<span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (q[mid]&lt;=x) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;-1 -1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-实数二分"><a href="#1-3-实数二分" class="headerlink" title="1.3 实数二分"></a>1.3 实数二分</h4><p>实数二分比整数二分简单多了。</p>
<p><img src="/posts/d50f01e/image-20210410131010056.png" alt="image-20210410131010056"></p>
<p>注意：这里的二分除法是严格的除法，不是整数除法。</p>
<h4 id="1-4-acwing-790-数的三次方根"><a href="#1-4-acwing-790-数的三次方根" class="headerlink" title="1.4 acwing.790.数的三次方根"></a>1.4 acwing.790.数的三次方根</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定一个浮点数 n，求它的三次方根。</span><br><span class="line">输入格式</span><br><span class="line">共一行，包含一个浮点数 n。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">共一行，包含一个浮点数，表示问题的解。</span><br><span class="line">注意，结果保留 <span class="number">6</span> 位小数。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">−<span class="number">10000</span>≤n≤<span class="number">10000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">1000.00</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">10.000000</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">-10000</span>,r = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">while</span> (r-l&gt;<span class="number">1e-8</span>)&#123; <span class="comment">// 比题目要求多求几位</span></span><br><span class="line">        <span class="keyword">double</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid*mid*mid&gt;=n) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>,r); <span class="comment">// 默认输出6位小数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（八）</title>
    <url>/posts/4d35e41b.html</url>
    <content><![CDATA[<h4 id="2-2-acwing-796-子矩阵的和（二维模板题）"><a href="#2-2-acwing-796-子矩阵的和（二维模板题）" class="headerlink" title="2.2 acwing.796.子矩阵的和（二维模板题）"></a>2.2 acwing.796.子矩阵的和（二维模板题）</h4><span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入一个 n 行 m 列的整数矩阵，再输入 q 个询问，每个询问包含四个整数 x1,y1,x2,y2，表示一个子矩阵的左上角坐标和右下角坐标。</span><br><span class="line">对于每个询问输出子矩阵中所有数的和。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含三个整数 n，m，q。</span><br><span class="line">接下来 n 行，每行包含 m 个整数，表示整数矩阵。</span><br><span class="line">接下来 q 行，每行包含四个整数 x1,y1,x2,y2，表示一组询问。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">共 q 行，每行输出一个询问的结果。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤n,m≤<span class="number">1000</span>,</span><br><span class="line"><span class="number">1</span>≤q≤<span class="number">200000</span>,</span><br><span class="line"><span class="number">1</span>≤x1≤x2≤n,</span><br><span class="line"><span class="number">1</span>≤y1≤y2≤m,</span><br><span class="line">−<span class="number">1000</span>≤矩阵内元素的值≤<span class="number">1000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">7</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span> <span class="number">2</span> <span class="number">8</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>前缀和矩阵每个格子的数就是从原矩阵(1,1)到当前格子构成矩阵的和。</p>
<p>二维前缀和和一维一样，<strong>有一个起始点</strong>，然后再计算前缀和序列。</p>
<p><img src="/posts/4d35e41b/image-20210428170329381.png" alt="image-20210428170329381"></p>
<p>那么如何计算前缀和矩阵呢？</p>
<p>我们采用<strong>容斥原理</strong>的思想。</p>
<p><img src="/posts/4d35e41b/image-20210428170757661.png" alt="image-20210428170757661"></p>
<p>计算(1,1)到(2,3)的矩阵和：</p>
<p>先计算1,7,3,6，再计算1,7,2，最后加上最后格子的2。</p>
<p>所以黄色格子算了1次，蓝色格子算了2次。</p>
<p>由此可以得到前缀和矩阵的推导公式：$S_{x,y} = S_{x-1,y}+S_{x,y-1}-S_{x-1,y-1}+a_{x,y}$</p>
<p>正如一维一样，二维前缀和也能得到一个类似递推的公式。</p>
<p>这样计算的话是线性时间复杂度，而通过循环将非常费时间。</p>
<p>接下来怎么根据前缀和矩阵计算子矩阵的和呢？</p>
<p><img src="/posts/4d35e41b/image-20210428172127766.png" alt="image-20210428172127766"></p>
<p>计算(1,1)到(2,3)的矩阵和：</p>
<p>原理和上面类似，先减去左边一列，再减去上面一行，最后加上左上角被多减去的部分。</p>
<p>直接给出公式：$S_{x_2,y_2}-S_{x_2,y_1-1}-S_{x_1-1,y_2}+S_{x_1-1,y_1-1}$</p>
<p>通过前缀和算法，我们将时间复杂度从$O(n*m)$降低到$O(1)$。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N][N],s[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m,q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">            <span class="comment">// 求前缀和矩阵</span></span><br><span class="line">            s[i][j] = s[i<span class="number">-1</span>][j]+s[i][j<span class="number">-1</span>]-s[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[x2][y2]-s[x2][y1<span class="number">-1</span>]-s[x1<span class="number">-1</span>][y2]+s[x1<span class="number">-1</span>][y1<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-acwing-99-激光炸弹（进阶指南）"><a href="#2-3-acwing-99-激光炸弹（进阶指南）" class="headerlink" title="2.3 acwing.99. 激光炸弹（进阶指南）"></a>2.3 acwing.99. 激光炸弹（进阶指南）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">地图上有 N 个目标，用整数 Xi,Yi 表示目标在地图上的位置，每个目标都有一个价值 Wi。</span><br><span class="line">注意：不同目标可能在同一位置。</span><br><span class="line">现在有一种新型的激光炸弹，可以摧毁一个包含 R×R 个位置的正方形内的所有目标。</span><br><span class="line">激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和 x，y 轴平行。</span><br><span class="line">求一颗炸弹最多能炸掉地图上总价值为多少的目标。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行输入正整数 N 和 R，分别代表地图上的目标数目和正方形的边长，数据用空格隔开。</span><br><span class="line">接下来 N 行，每行输入一组数据，每组数据包括三个整数 Xi,Yi,Wi，分别代表目标的 x 坐标，y 坐标和价值，数据用空格隔开。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">0</span>≤R≤<span class="number">10</span>^<span class="number">9</span></span><br><span class="line"><span class="number">0</span>&lt;N≤<span class="number">10000</span>,</span><br><span class="line"><span class="number">0</span>≤Xi,Yi≤<span class="number">5000</span></span><br><span class="line"><span class="number">0</span>≤Wi≤<span class="number">1000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>按照题意，就是求边长为R的正方形的覆盖的最大值。<strong>本质上就是二维前缀和的应用。</strong></p>
<p>参考大佬题解1：<a href="https://www.acwing.com/solution/content/10116/">https://www.acwing.com/solution/content/10116/</a></p>
<p>参考大佬题解2：<a href="https://www.acwing.com/solution/content/31983/">https://www.acwing.com/solution/content/31983/</a></p>
<p><img src="/posts/4d35e41b/image-20210428183858344.png" alt="image-20210428183858344"></p>
<p><strong>注意子矩阵和的公式</strong>，套用上一题的公式时，3-R+1与公式里的x1-1,y1-1抵消了一个1，所以变成x-R,y-R了。</p>
<p><img src="/posts/4d35e41b/image-20210428214224102.png" alt="image-20210428214224102"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="comment">// 目标坐标从0到5000，移动到1到5001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5010</span>;</span><br><span class="line"><span class="keyword">int</span> s[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt,R;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;cnt,&amp;R);</span><br><span class="line">    R = min(<span class="number">5001</span>,R);</span><br><span class="line">    n = m = R;</span><br><span class="line">    <span class="keyword">while</span> (cnt--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;w);</span><br><span class="line">        <span class="comment">// 坐标+1，防止越界问题</span></span><br><span class="line">        x++,y++;</span><br><span class="line">        <span class="comment">// 枚举的上限是最大坐标和R的最大值</span></span><br><span class="line">        n = max(n,x),m = max(m,y);</span><br><span class="line">        <span class="comment">// 这里必须是+=，因为目标可能重复</span></span><br><span class="line">        s[x][y] += w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 预处理前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)</span><br><span class="line">            s[i][j] += s[i<span class="number">-1</span>][j]+s[i][j<span class="number">-1</span>]-s[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 必须保证n,m &gt;= R，才能保证至少循环一次</span></span><br><span class="line">    <span class="comment">// 枚举所有边长是R的矩形，枚举(i, j)为右下角</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = R;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = R;j &lt;= m;j++)&#123;</span><br><span class="line">            res = max(res,s[i][j]-s[i-R][j]-s[i][j-R]+s[i-R][j-R]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意卡空间，题目上限是168MB，开两个<code>s[5000][5000]</code>大概是200MB，所以只开一个数组。</p>
<p>因为同用一个数组，所以求前缀和矩阵的公式里<code>+a[i][j]</code>变成了<code>+s[i][j]</code>。</p>
<p>所以以后用二维前缀和，完全可以只开一个数组。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（六）</title>
    <url>/posts/685ebbc7.html</url>
    <content><![CDATA[<blockquote>
<p> 续蓝桥杯学习总结（五）。</p>
</blockquote>
<span id="more"></span>

<h4 id="1-5-acwing-730-机器人跳跃问题（头条2019笔试题）"><a href="#1-5-acwing-730-机器人跳跃问题（头条2019笔试题）" class="headerlink" title="1.5 acwing.730. 机器人跳跃问题（头条2019笔试题）"></a>1.5 acwing.730. 机器人跳跃问题（头条2019笔试题）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">机器人正在玩一个古老的基于 DOS 的游戏。</span><br><span class="line">游戏中有 N+<span class="number">1</span> 座建筑——从 <span class="number">0</span> 到 N 编号，从左到右排列。</span><br><span class="line">编号为 <span class="number">0</span> 的建筑高度为 <span class="number">0</span> 个单位，编号为 i 的建筑高度为 H(i) 个单位。</span><br><span class="line">起初，机器人在编号为 <span class="number">0</span> 的建筑处。</span><br><span class="line">每一步，它跳到下一个（右边）建筑。</span><br><span class="line">假设机器人在第 k 个建筑，且它现在的能量值是 E，下一步它将跳到第 k+<span class="number">1</span> 个建筑。</span><br><span class="line">如果 H(k+<span class="number">1</span>)&gt;E，那么机器人就失去 H(k+<span class="number">1</span>)−E 的能量值，否则它将得到 E−H(k+<span class="number">1</span>) 的能量值。</span><br><span class="line">游戏目标是到达第 N 个建筑，在这个过程中能量值不能为负数个单位。</span><br><span class="line">现在的问题是机器人至少以多少能量值开始游戏，才可以保证成功完成游戏？</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行输入整数 N。</span><br><span class="line">第二行是 N 个空格分隔的整数，H(<span class="number">1</span>),H(<span class="number">2</span>),…,H(N) 代表建筑物的高度。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示所需的最少单位的初始能量值上取整后的结果。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤N,H(i)≤<span class="number">105</span>,</span><br><span class="line">输入样例<span class="number">1</span>：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line">输出样例<span class="number">1</span>：</span><br><span class="line"><span class="number">4</span></span><br><span class="line">输入样例<span class="number">2</span>：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line">输出样例<span class="number">2</span>：</span><br><span class="line"><span class="number">4</span></span><br><span class="line">输入样例<span class="number">3</span>：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">4</span></span><br><span class="line">输出样例<span class="number">3</span>：</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>y总思路：</p>
<p><img src="/posts/685ebbc7/image-20210417113943246.png" alt="image-20210417113943246"></p>
<p>题目具有二段性，假设有E满足条件，比E小的数都不满足，比E大的数都满足。这点可以简单论证一下。</p>
<p><img src="/posts/685ebbc7/image-20210417123437384.png" alt="image-20210417123437384"></p>
<p>注意一个坑：如果E接近h的最大值时，<code>E*2</code>容易爆int（记住：int范围约是2*10$^9$.），其实我们只要判断<code>E&gt;=max(h)</code>，满足的话后面E肯定是递增的，就不用再判断是否大于0了。证明如下：</p>
<p><img src="/posts/685ebbc7/image-20210417124151973.png" alt="image-20210417124151973"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解奉上</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> num[N]; <span class="comment">// num[0]默认为0</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)&#123;</span><br><span class="line">        m = <span class="number">2</span>*m - num[i];</span><br><span class="line">        <span class="keyword">if</span> (m &gt;= <span class="number">1e5</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (m &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 这里别忘了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="comment">// 从num[1]开始读，包括num[0]在内是n+1座建筑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num[i]);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">1e5</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid))r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-acwing-1221-四平方和（蓝桥杯省赛C-A-B组）"><a href="#1-6-acwing-1221-四平方和（蓝桥杯省赛C-A-B组）" class="headerlink" title="1.6 acwing.1221. 四平方和（蓝桥杯省赛C++A/B组）"></a>1.6 acwing.1221. 四平方和（蓝桥杯省赛C++A/B组）</h4><p>类似题目：acwing.75.和为S的两个数字，语法（九）题解有暴搜与哈希表两种做法。（PS：本题不可暴搜）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">四平方和定理，又称为拉格朗日定理：</span><br><span class="line">每个正整数都可以表示为至多 <span class="number">4</span> 个正整数的平方和。</span><br><span class="line">如果把 <span class="number">0</span> 包括进去，就正好可以表示为 <span class="number">4</span> 个数的平方和。</span><br><span class="line">比如：</span><br><span class="line"><span class="number">5</span>=<span class="number">0</span>^<span class="number">2</span>+<span class="number">0</span>^<span class="number">2</span>+<span class="number">1</span>^<span class="number">2</span>+<span class="number">2</span>^<span class="number">2</span></span><br><span class="line"><span class="number">7</span>=<span class="number">1</span>^<span class="number">2</span>+<span class="number">1</span>^<span class="number">2</span>+<span class="number">1</span>^<span class="number">2</span>+<span class="number">2</span>^<span class="number">2</span></span><br><span class="line">对于一个给定的正整数，可能存在多种平方和的表示法。</span><br><span class="line">要求你对 <span class="number">4</span> 个数排序：</span><br><span class="line"><span class="number">0</span>≤a≤b≤c≤d</span><br><span class="line">并对所有的可能表示法按 a,b,c,d 为联合主键升序排列，最后输出第一个表示法。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">输入一个正整数 N。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出<span class="number">4</span>个非负整数，按从小到大排序，中间用空格分开。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">0</span>&lt;N&lt;<span class="number">5</span>∗<span class="number">10</span>^<span class="number">6</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">5</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>强行三重循环爆搜会超时的，怎么优化都过不了。Java能过，C++不行，Java时限更长。</p>
<p>y总思路：</p>
<p><img src="/posts/685ebbc7/image-20210417155749683.png" alt="image-20210417155749683"></p>
<p>(与带分数的转换方法类似)</p>
<p>1、a^2+b^2+c^2+d^2=n可以转换成 c^2+d^2=n−a^2−b^2</p>
<p>2、通过排序数组（或哈希表）存储c^2+d^2的值</p>
<p>3、枚举a和b，若n−a^2−b^2在排序数组（或哈希表）中存在，则表示一定存在c和d，满足方程</p>
<p>哈希表由于某些原因过不了。</p>
<h5 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h5><p>时间复杂度：$O(n^2*logn)$，两重循环加一个二分查找</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总二分题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2500010</span>; <span class="comment">// 5*10^6的一半，后面枚举c、d</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s,c,d;</span><br><span class="line">    <span class="comment">// 结构体排序，重载小于号</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Sum&amp; t) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s != t.s) <span class="keyword">return</span> s &lt; t.s; <span class="comment">// s、c、d按字典序排序</span></span><br><span class="line">        <span class="keyword">if</span> (c != t.c) <span class="keyword">return</span> c &lt; t.c;</span><br><span class="line">        <span class="keyword">return</span> d &lt; t.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sum[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>;c*c&lt;= n;c++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = c;c*c+d*d&lt;= n;d++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[m++] = &#123;c*c+d*d,c,d&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    sort(sum,sum+m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>;a*a&lt;= n;a++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> b = a;a*a+b*b&lt;= n;b++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = n-a*a-b*b;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>,r = m<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (sum[mid].s &gt;= t) r = mid;</span><br><span class="line">                <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum[l].s == t)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,a,b,sum[l].c,sum[l].d);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h5><p>时间复杂度$O(n^2)$，本题超时，仅作为思路拓展！</p>
<p>不要轻信时间复杂度，这里二分与哈希表之间的常数不能忽略。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;// 哈希表</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;<span class="comment">// 必须放using...之后</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, PII&gt; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c * c &lt;= n; c ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = c; c * c + d * d &lt;= n; d ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = c * c + d * d;</span><br><span class="line">            <span class="keyword">if</span> (S.count(t) == <span class="number">0</span>) S[t] = &#123;c, d&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a * a &lt;= n; a ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; a * a + b * b &lt;= n; b ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = n - a * a - b * b;</span><br><span class="line">            <span class="keyword">if</span> (S.count(t))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, a, b, S[t].x, S[t].y);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（十一）</title>
    <url>/posts/a75e4e46.html</url>
    <content><![CDATA[<h3 id="2-简单DP"><a href="#2-简单DP" class="headerlink" title="2.简单DP"></a>2.简单DP</h3><p>动态规划（Dynamic Programming，DP）是一种用来解决一类<strong>最优化问题</strong>的算法思想。</p>
<p>背包问题是一类经典的DP问题，灵活多变。</p>
<p><a href="https://valen.blog.csdn.net/article/details/87878853?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">背包问题模板整理点这里</a></p>
<span id="more"></span>

<h4 id="2-1-acwing-2-01背包问题（背包九讲-模板题）"><a href="#2-1-acwing-2-01背包问题（背包九讲-模板题）" class="headerlink" title="2.1 acwing.2. 01背包问题（背包九讲 , 模板题）"></a>2.1 acwing.2. 01背包问题（背包九讲 , 模板题）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。</span><br><span class="line">第 i 件物品的体积是 vi，价值是 wi。</span><br><span class="line">求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</span><br><span class="line">输出最大价值。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。</span><br><span class="line">接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示最大价值。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">0</span>&lt;N,V≤<span class="number">1000</span></span><br><span class="line"><span class="number">0</span>&lt;vi,wi≤<span class="number">1000</span></span><br><span class="line">输入样例</span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>参考1：y总视频讲解，参考2：《算法笔记》，参考3：《LeetCode 101》刷题指南</p>
<p>如果采用暴力枚举每一件物品放或者不放进背包，有两种选择，所以时间复杂度为$O(2^n)$，非常大。</p>
<p>接下来考虑<strong>动态规划</strong>求解。</p>
<h5 id="先尝试二维解法。"><a href="#先尝试二维解法。" class="headerlink" title="先尝试二维解法。"></a>先尝试二维解法。</h5><p>我们可以定义一个二维数组dp存储最大价值，其中<code>dp[i][j]</code> 表示前i 件物品体积不超过j （<strong>即此时背包容量</strong></p>
<p><strong>为j</strong>）的情况下能达到的最大价值。</p>
<p>在我们遍历到第i 件物品时，在当前背包总容量为j 的情况下，</p>
<ol>
<li><p>如果我们不将物品i 放入背包，那么<code>dp[i][j]= dp[i-1][j]</code>，即前i 个物品的最大价值等于只取前i-1 个</p>
<p>物品时的最大价值；</p>
</li>
<li><p>如果我们将物品i 放入背包，假设第i 件物品体积为wi，价值为vi，那么我们得到</p>
<p><code>dp[i][j] = dp[i-1][j-w[i]] + v[i]</code>。我们只需在遍历过程中对这两种情况取最大值即可，总时间复杂度和空间复杂度都为$O(NV)$。</p>
</li>
</ol>
<p>综合上面提到的2种选择策略，我们可以得到状态转移方程：</p>
<p><code>dp[i][j] = max&#123;dp[i-1][j],dp[i-1][j-w[i]] + v[i]&#125;</code></p>
<p>确定初始化边界，<code>dp[0][0] = 0    </code>.</p>
<p>注意<strong>理解误区</strong>：</p>
<p><code>dp[i][j]</code>里的<code>i</code>不是表示选择了前i个物品，而是表示对前i个物品做出两中策略的选择；</p>
<p>里面的<code>j</code>不是表示当前物品的总体积等于j，而是表示前i 件物品体积不超过j 。</p>
<p>这里给出一位大佬的解释：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">无论 j 表示体积正好是 j 还是 不超过 j ，它的式子都是一样的 j - v[i]， 但是理解不同而已。</span><br><span class="line">有一点不同就是：如果 j 表示体积正好是 j 的话，那么答案就需要遍历求max。如果表示的是 不超过 j 的话，答案就是 f[n][m] 。</span><br><span class="line">如果只考虑第<span class="number">1</span>件物品的话，应该只有 f[<span class="number">1</span>][ v[<span class="number">1</span>] ] = w[<span class="number">1</span>] 其他的都是不存在最大质量的（都为<span class="number">0</span>）。</span><br><span class="line">但是按照 原来的初始化的话，f数组的第一行：f[<span class="number">1</span>][ v[<span class="number">1</span>] - v ] = v[<span class="number">1</span>]（而这样的式子却代表的是 j 表示不超过 j 的情况、可以把两种情况的 f 数组画出来）</span><br><span class="line">所以我认为：</span><br><span class="line"><span class="number">1</span>、j 表示 体积正好为 j ：需要 f[<span class="number">1</span>][ v[<span class="number">1</span>] ] = w[<span class="number">1</span>]，其余的赋值为零。这样得到的数组 f 才能被解释赋予意义。答案就需要遍历求max。</span><br><span class="line"><span class="number">2</span>、j 表示 体积不超过 j ：式子不变，初始化不变，只是求答案不需要遍历，答案就是 f[n][m]。</span><br></pre></td></tr></table></figure>

<p>再贴一位大佬的题解：（十分详细了）<a href="https://www.acwing.com/solution/content/1374/">https://www.acwing.com/solution/content/1374/</a></p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][N]; <span class="comment">// dp[0][0] = 0</span></span><br><span class="line"><span class="keyword">int</span> v[N],w[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= m;j++)&#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j - v[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-v[i]]+w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="再尝试一维优化。"><a href="#再尝试一维优化。" class="headerlink" title="再尝试一维优化。"></a>再尝试一维优化。</h5><p>我们可以进一步对0-1 背包进行空间优化，将空间复杂度降低为$O(V)$。时间复杂度已经不能再优化了。</p>
<p><img src="/posts/a75e4e46/image-20210430213638586.png" alt="image-20210430213638586"></p>
<p>这里可以发现我们<code>dp[i][j]</code>永远只依赖于上一排左边的信息，之前算过的其他物品都不需要再使用。因此我</p>
<p>们可以去掉dp 矩阵的第一个维度，在考虑物品i 时变成dp[j]= max(dp[j], dp[j-w] + v)。这里要注意我们在遍</p>
<p>历每一行的时候必须<strong>逆向遍历</strong>，这样才能够调用上一行物品i-1 时dp[j-w] 的值；若按照从左往右的顺序进行正</p>
<p>向遍历，则dp[j-w] 的值在遍历到j 之前就已经被更新成物品i 的值了。</p>
<p>从二维变成一维，相当于把二维中第一个维度变成循环滚动只有1行的数组dp[N]。</p>
<p>如果我们仍然从左往右计算dp[j]，那么可能存在污染，因为后面的数据根据前面递推而来，在滚动的时候可能要用到dp[i-1]（即上一次循环的数据时，实际上这个位置的数据已经在这次循环时被更新过了，用到的是dp[i]的数据，那么就出错了。</p>
<p>只有通过逆序枚举v，即从右往左滚动数组，这次计算dp[i]时依然根据上次循环递推而来，而且dp[i-v[i]]并没有被污染，才能得到正确结果。</p>
<p>模拟过程：<a href="https://www.acwing.com/activity/content/code/content/625657/">https://www.acwing.com/activity/content/code/content/625657/</a></p>
<p>我们注意到在处理数据时，我们是一个物品一个物品，一个一个体积的枚举。</p>
<p>因此我们可以不必开两个数组记录体积和价值，而是边输入边处理。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> v,w;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w; <span class="comment">// 边输入边处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m;j &gt;= v;j--)&#123;</span><br><span class="line">            dp[j] = max(dp[j],dp[j-v]+w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>DP</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（十二）</title>
    <url>/posts/9748a29e.html</url>
    <content><![CDATA[<span id="more"></span>]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>DP</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（十）</title>
    <url>/posts/b2cae080.html</url>
    <content><![CDATA[<h4 id="1-2-acwing-1211-蚂蚁感冒（第五届AB组）"><a href="#1-2-acwing-1211-蚂蚁感冒（第五届AB组）" class="headerlink" title="1.2 acwing.1211. 蚂蚁感冒（第五届AB组）"></a>1.2 acwing.1211. 蚂蚁感冒（第五届AB组）</h4><span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">长 <span class="number">100</span> 厘米的细长直杆子上有 n 只蚂蚁。</span><br><span class="line">它们的头有的朝左，有的朝右。</span><br><span class="line">每只蚂蚁都只能沿着杆子向前爬，速度是 <span class="number">1</span> 厘米/秒。</span><br><span class="line">当两只蚂蚁碰面时，它们会同时掉头往相反的方向爬行。</span><br><span class="line">这些蚂蚁中，有 <span class="number">1</span> 只蚂蚁感冒了。</span><br><span class="line">并且在和其它蚂蚁碰面时，会把感冒传染给碰到的蚂蚁。</span><br><span class="line">请你计算，当所有蚂蚁都爬离杆子时，有多少只蚂蚁患上了感冒。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行输入一个整数 n, 表示蚂蚁的总数。</span><br><span class="line">接着的一行是 n 个用空格分开的整数 Xi, Xi 的绝对值表示蚂蚁离开杆子左边端点的距离。</span><br><span class="line">正值表示头朝右，负值表示头朝左，数据中不会出现 <span class="number">0</span> 值，也不会出现两只蚂蚁占用同一位置。</span><br><span class="line">其中，第一个数据代表的蚂蚁感冒了。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出<span class="number">1</span>个整数，表示最后感冒蚂蚁的数目。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>&lt;n&lt;<span class="number">50</span>,</span><br><span class="line"><span class="number">0</span>&lt;|Xi|&lt;<span class="number">100</span></span><br><span class="line">输入样例<span class="number">1</span>：</span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">5</span> <span class="number">-2</span> <span class="number">8</span></span><br><span class="line">输出样例<span class="number">1</span>：</span><br><span class="line"><span class="number">1</span></span><br><span class="line">输入样例<span class="number">2</span>：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">-10</span> <span class="number">8</span> <span class="number">-20</span> <span class="number">12</span> <span class="number">25</span></span><br><span class="line">输出样例<span class="number">2</span>：</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>本题不属于任何算法。</p>
<p>首先要看出来，这里两只蚂蚁碰面掉头，其实等价于穿过去。掉头只是幌子，不要想复杂了。</p>
<p>因为相撞之后两只蚂蚁都感冒了，掉不掉头其实无所谓，毕竟都感冒了，这样的话这题就简单多了。</p>
<p><img src="/posts/b2cae080/image-20210429141227746.png" alt="image-20210429141227746"></p>
<p>以第一只感冒蚂蚁<strong>（向右走）</strong>为分界，考虑左右两边的蚂蚁。</p>
<p><img src="/posts/b2cae080/image-20210429142058395.png" alt="image-20210429142058395"></p>
<p>第一只感冒蚂蚁<strong>（向左走）</strong>情况类似。</p>
<p><img src="/posts/b2cae080/image-20210429143438497.png" alt="image-20210429143438497"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> x[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">cin</span> &gt;&gt; x[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 分别表示左边向有走的蚂蚁数量，和右边向左走的蚂蚁数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(x[i]) &lt; <span class="built_in">abs</span>(x[<span class="number">0</span>]) &amp;&amp; x[i] &gt; <span class="number">0</span>) left++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">abs</span>(x[i]) &gt; <span class="built_in">abs</span>(x[<span class="number">0</span>]) &amp;&amp; x[i] &lt; <span class="number">0</span>) right++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x[<span class="number">0</span>] &gt; <span class="number">0</span> &amp;&amp; right == <span class="number">0</span> || x[<span class="number">0</span>] &lt; <span class="number">0</span> &amp;&amp; left == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; left + right + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-acwing-1216-饮料换购（第六届C-A-C组）"><a href="#1-3-acwing-1216-饮料换购（第六届C-A-C组）" class="headerlink" title="1.3 acwing.1216. 饮料换购（第六届C++A/C组）"></a>1.3 acwing.1216. 饮料换购（第六届C++A/C组）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">乐羊羊饮料厂正在举办一次促销优惠活动。乐羊羊C型饮料，凭<span class="number">3</span>个瓶盖可以再换一瓶C型饮料，并且可以一直循环下去(但不允许暂借或赊账)。</span><br><span class="line">请你计算一下，如果小明不浪费瓶盖，尽量地参加活动，那么，对于他初始买入的 n 瓶饮料，最后他一共能喝到多少瓶饮料。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">输入一个整数 n,表示初始买入的饮料数量。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示一共能够喝到的饮料数量。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">0</span>&lt;n&lt;<span class="number">10000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">100</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">149</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>先手动模拟一下。</p>
<p><img src="/posts/b2cae080/image-20210430183558295.png" alt="image-20210430183558295"></p>
<p><img src="/posts/b2cae080/image-20210430184112849.png" alt="image-20210430184112849"></p>
<p>粗略计算一下，取n=10000时，每次除以3，大概需要迭代8,9次，时间完全没问题。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> res = n;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">        res += n / <span class="number">3</span>;</span><br><span class="line">        n = n / <span class="number">3</span> + n % <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充小知识：如何求上取整？</p>
<p>有一个公式，将上取整转化为下取整，因为C++计算int除法时默认下取整，$\lceil \frac a b \rceil = \lfloor \frac {a+b-1} b \rfloor$</p>
<p>证明如下：（PS：严格证明请参考<a href="https://blog.csdn.net/lanuage/article/details/78746606?ops_request_misc=&request_id=&biz_id=102&utm_term=%E6%80%8E%E4%B9%88%E6%B1%82%E5%90%91%E4%B8%8A%E5%8F%96%E6%95%B4&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-78746606.first_rank_v2_pc_rank_v29">这里</a>）</p>
<p>分情况讨论：</p>
<ol>
<li>当<code>a mod b = 1,2,...,b-1</code>时，<code>(a mod b)+b-1 = b,b+1,...,b+b-2 </code>，这多余部分除以b下取整都是1，而左右两边的整数部分又相同，所以成立；（即<code>a%b != 0</code>时，上取整等于下取整+1）</li>
<li>当<code>a mod b = 0</code>时，``(a mod b)+b-1 = b-1<code>，而$\frac &#123;b-1&#125;b$下取整是0，而左右两边的整数部分又相同，所以成立。（即</code>a%b = 0`时，上取整等于下取整）</li>
</ol>
<p>向下取整的运算称为Floor，用数学符号⌊⌋表示；向上取整的运算称为Ceiling，用数学符号⌈⌉表示。</p>
<p>例如：</p>
<p>⌊59/60⌋=0    ⌈59/60⌉=1    ⌊-59/60⌋=-1    ⌈-59/60⌉=0</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（四）</title>
    <url>/posts/62ce3559.html</url>
    <content><![CDATA[<blockquote>
<p>续蓝桥杯学习总结（三）。</p>
</blockquote>
<span id="more"></span>

<h4 id="3-3-acwing-1208-翻硬币-（简单）"><a href="#3-3-acwing-1208-翻硬币-（简单）" class="headerlink" title="3.3 acwing.1208. 翻硬币 （简单）"></a>3.3 acwing.1208. 翻硬币 （简单）</h4><blockquote>
<p>第四届C++ B组原题</p>
</blockquote>
<p>小明正在玩一个“翻硬币”的游戏。</p>
<p>桌上放着排成一排的若干硬币。我们用 * 表示正面，用 o 表示反面（是小写字母，不是零）。</p>
<p>比如，可能情形是：<code>**oo***oooo</code></p>
<p>如果同时翻转左边的两个硬币，则变为：<code>oooo***oooo</code></p>
<p>现在小明的问题是：如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币,那么对特定的局面，最少要翻动多少次呢？</p>
<p>我们约定：把翻动相邻的两个硬币叫做一步操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入格式</span><br><span class="line">两行等长的字符串，分别表示初始状态和要达到的目标状态。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">一个整数，表示最小操作步数</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">输入字符串的长度均不超过<span class="number">100</span>。</span><br><span class="line">数据保证答案一定有解。</span><br><span class="line"></span><br><span class="line">输入样例<span class="number">1</span>：</span><br><span class="line">**********</span><br><span class="line">o****o****</span><br><span class="line">输出样例<span class="number">1</span>：</span><br><span class="line"><span class="number">5</span></span><br><span class="line">输入样例<span class="number">2</span>：</span><br><span class="line">*o**o***o***</span><br><span class="line">*o***o**o***</span><br><span class="line">输出样例<span class="number">2</span>：</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>想象一下，每两个硬币中间看作由一个灯泡控制。其实就是费解的开关的简化版。</p>
<p>模拟法：</p>
<p>从最左侧开始遍历，如果该位置硬币状态与目标不同，就翻动该位置和该位置后面的两枚硬币。<br>因为题目说了有解，所以遍历到倒数第二枚的时候，所有硬币状态就与目标相同了。</p>
<p><img src="/posts/62ce3559/image-20210329205656532.png" alt="image-20210329205656532"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">char</span> start[N],aim[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start[a] == <span class="string">&#x27;*&#x27;</span>) start[a] = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> start[a] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; start &gt;&gt; aim;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(start);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (start[i] != aim[i])</span><br><span class="line">        &#123;</span><br><span class="line">            turn(i),turn(i+<span class="number">1</span>);</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：遍历了一边输出，时间复杂度是 O(n)。</p>
<p>该思路时间复杂度已是最优，要使起始状态变为目标状态，至少遍历一边来进行判断，时间复杂度最少是 O(n)。</p>
<p>空间复杂度：没有开辟与输入输出有关的空间，空间复杂度是O(1)。</p>
<h4 id="3-4-acwing-116-飞行员兄弟-（超长代码预警）"><a href="#3-4-acwing-116-飞行员兄弟-（超长代码预警）" class="headerlink" title="3.4 acwing.116.飞行员兄弟 （超长代码预警）"></a>3.4 acwing.116.飞行员兄弟 （超长代码预警）</h4><p>“飞行员兄弟”这个游戏，需要玩家顺利的打开一个拥有 16个把手的冰箱。</p>
<p>已知每个把手可以处于以下两种状态之一：打开或关闭。</p>
<p>只有当所有把手都打开时，冰箱才会打开。</p>
<p>把手可以表示为一个 4×4 的矩阵，您可以改变任何一个位置 [i,j]上把手的状态。</p>
<p>但是，这也会使得第 i 行和第 j列上的所有把手的状态也随着改变。</p>
<p>请你求出打开冰箱所需的切换把手的次数最小值是多少。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入格式</span><br><span class="line">输入一共包含四行，每行包含四个把手的初始状态。</span><br><span class="line">符号 + 表示把手处于闭合状态，而符号 - 表示把手处于打开状态。</span><br><span class="line">至少一个手柄的初始状态是关闭的。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">第一行输出一个整数 N，表示所需的最小切换把手次数。</span><br><span class="line">接下来 N 行描述切换顺序，每行输出两个整数，代表被切换状态的把手的行号和列号，数字之间用空格隔开。</span><br><span class="line">注意：如果存在多种打开冰箱的方式，则按照优先级整体从上到下，同行从左到右打开。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤i,j≤<span class="number">4</span></span><br><span class="line">输入样例：</span><br><span class="line">-+--</span><br><span class="line">----</span><br><span class="line">----</span><br><span class="line">-+--</span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>Solution 1:数组枚举法，对于所有操作暴力枚举</p>
<p><img src="/posts/62ce3559/image-20210329210942984.png" alt="image-20210329210942984"></p>
<p>注意：题中如果存在多种打开冰箱的方式，则按照优先级整体从上到下，同行从左到右打开。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second  <span class="comment">// 简化</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> g[N][N],backup[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*<span class="number">4</span> + y; <span class="comment">// 求二维坐标对应的0,1,2,...,15中的映射</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn_one</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g[x][y] == <span class="string">&#x27;+&#x27;</span>) g[x][y] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> g[x][y] = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把十字上的把手都反转</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn_all</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        turn_one(x,i);</span><br><span class="line">        turn_one(i,y);</span><br><span class="line">    &#125;</span><br><span class="line">    turn_one(x,y);<span class="comment">//前面操作把手两次，所以要多操作一次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) <span class="built_in">cin</span> &gt;&gt; g[i];</span><br><span class="line">    <span class="built_in">vector</span>&lt;PII&gt; res; <span class="comment">// 存放最终答案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> op = <span class="number">0</span>;op &lt; <span class="number">1</span> &lt;&lt; <span class="number">16</span>;op++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;PII&gt; temp; <span class="comment">// 存放当前答案</span></span><br><span class="line">        <span class="built_in">memcpy</span>(backup,g,<span class="keyword">sizeof</span> g); <span class="comment">// 备份</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据枚举的op进行反转操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (op &gt;&gt; get(i,j) &amp; <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(&#123;i,j&#125;);</span><br><span class="line">                    turn_all(i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 判断是否满足把手全部打开</span></span><br><span class="line">        <span class="keyword">bool</span> has_closed = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    has_closed = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(has_closed == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="comment">// 判断res是否已经求出或是否最优解</span></span><br><span class="line">            <span class="keyword">if</span> (res.empty() || res.size()&gt;temp.size()) res = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(g,backup,<span class="keyword">sizeof</span> g);  <span class="comment">// 还原</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;res.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> op:res) <span class="built_in">cout</span> &lt;&lt; op.x + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt;op.y+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// 输出实际坐标</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Solution 2:枚举+位运算法，对solution1的二进制优化</p>
<p>看不懂的话请参考：<a href="https://www.acwing.com/solution/content/983/">算法2：枚举+位运算</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4</span>, INF = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> change[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * N + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )<span class="comment">// change每个位置二进制表示将哪些位置取反</span></span><br><span class="line">        <span class="comment">//对照着solution1的turn_all &amp; turn_one函数就比较好理解啦</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; N; k ++ ) change[i][j] += (<span class="number">1</span> &lt;&lt; get(i, k)) + (<span class="number">1</span> &lt;&lt; get(k, j));</span><br><span class="line">            change[i][j] -= <span class="number">1</span> &lt;&lt; get(i, j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> state = <span class="number">0</span>;<span class="comment">// state用于存放所有把手的当前状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> line;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; line;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (line[j] == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">                state += <span class="number">1</span> &lt;&lt; get(i, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;PII&gt; path;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; <span class="number">16</span>; i ++ )<span class="comment">// 枚举对把手的所有操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now = state;</span><br><span class="line">        <span class="built_in">vector</span>&lt;PII&gt; temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>) <span class="comment">// 求i的第j位数字</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x = j / <span class="number">4</span>, y = j % <span class="number">4</span>;</span><br><span class="line">                now ^= change[x][y]; <span class="comment">// 对now的把手进行反转，异或取反</span></span><br><span class="line">                temp.push_back(&#123;x, y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 判断解存在且是最优解</span></span><br><span class="line">        <span class="keyword">if</span> (!now &amp;&amp; (path.empty() || path.size() &gt; temp.size())) path = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; path.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : path)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p.first + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p.second + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Solution 3:DFS法</p>
<p>对于每个把手，有选和不选两种情况。</p>
<p>这种写法满足题意：如果存在多种打开冰箱的方式，则按照优先级整体从上到下，同行从左到右打开。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dalao的优化版本，比solution1快了近10倍</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="built_in">vector</span>&lt;PII&gt; ans, tmp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn_one</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g[x][y] == <span class="string">&#x27;+&#x27;</span>) g[x][y] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> g[x][y] = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn_all</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        turn_one(x, i);</span><br><span class="line">        turn_one(i, y);</span><br><span class="line">    &#125;</span><br><span class="line">    turn_one(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果说所有的把手都操作完了就看看冰箱能否打开</span></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">3</span> &amp;&amp; y == <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> success = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;<span class="number">4</span>; j++)</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">                &#123;    </span><br><span class="line">                    success = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">goto</span> end;</span><br><span class="line">                &#125;</span><br><span class="line">        end:</span><br><span class="line">        <span class="keyword">if</span> (success)</span><br><span class="line">            <span class="comment">// 判断是否最优解</span></span><br><span class="line">            <span class="keyword">if</span> (ans.empty() || tmp.size() &lt; ans.size())</span><br><span class="line">                ans = tmp;</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">// 递归结束千万记得退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断边界，如果y出界了就往下一行移动</span></span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">4</span>) x++, y = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 操作把手(x, y)</span></span><br><span class="line">    turn_all(x, y);</span><br><span class="line">    tmp.push_back(&#123; x, y &#125;);</span><br><span class="line">    dfs(x, y + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 恢复现场，关键所在</span></span><br><span class="line">    tmp.pop_back();</span><br><span class="line">    turn_all(x, y);</span><br><span class="line">    <span class="comment">// 不操作把手(x, y)</span></span><br><span class="line">    dfs(x, y + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i]);</span><br><span class="line">    <span class="comment">// 从(0, 0)开始DFS</span></span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, ans[i].first + <span class="number">1</span>, ans[i].second + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title>记一道C++作业题</title>
    <url>/posts/a83020d5.html</url>
    <content><![CDATA[<p>如题：题目要求根据初始化时的日期加上一定的天数后计算得到的日期，这里用到的计算思路来自<a href="https://grant1499.github.io/2021/03/26/%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86%E4%B8%8E%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98/">这里</a>。</p>
<span id="more"></span>

<p><img src="/posts/a83020d5/image-20210412221018035.png" alt="image-20210412221018035"></p>
<p>只要稍做改动，就能写出代码来了，不过要注意原题计算的是日期差+1！</p>
<p>这题主要考察了日期问题、++前缀与后缀重载等知识点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// 判断闰年，是闰年返回true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeap</span><span class="params">(<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (y%<span class="number">4</span>==<span class="number">0</span> &amp;&amp;y%<span class="number">100</span>!=<span class="number">0</span>) || (y%<span class="number">400</span>==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//顺序存放平年、闰年每月对应天数</span></span><br><span class="line"><span class="keyword">int</span> month[<span class="number">13</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">28</span>,<span class="number">29</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,</span><br><span class="line">	&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Date()&#123;</span><br><span class="line">            y = <span class="number">2000</span>,m = <span class="number">1</span>,d = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Date(<span class="keyword">int</span> _y,<span class="keyword">int</span> _m,<span class="keyword">int</span> _d):</span><br><span class="line">        y(_y),m(_m),d(_d)&#123;&#125;</span><br><span class="line">        <span class="comment">// Copy Constructor</span></span><br><span class="line">        Date(Date&amp; t)&#123;</span><br><span class="line">            y = t.y,m = t.m,d = t.d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Y:%d,M:%2d,D:%2d\n&quot;</span>,y,m,d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">friend</span> Date <span class="keyword">operator</span>+ (Date&amp; D,<span class="keyword">int</span> n);<span class="comment">// 重载加号</span></span><br><span class="line">        <span class="keyword">friend</span> Date <span class="keyword">operator</span>++ (Date&amp; D,<span class="keyword">int</span>);<span class="comment">// 重载后缀++</span></span><br><span class="line">        <span class="keyword">friend</span> Date <span class="keyword">operator</span>++ (Date&amp; D);<span class="comment">// 重载++前缀</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line">Date <span class="keyword">operator</span>+ (Date&amp; D,<span class="keyword">int</span> n)&#123;</span><br><span class="line">    Date temp = D;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;<span class="comment">// 累加ans到n</span></span><br><span class="line">    <span class="comment">// ans == n退出</span></span><br><span class="line">    <span class="keyword">while</span> (ans &lt; n)&#123;</span><br><span class="line">        <span class="comment">// 优化，降低循环次数</span></span><br><span class="line">        <span class="keyword">if</span> (n- ans &gt; <span class="number">366</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (isLeap(temp.y)) ans += <span class="number">366</span>;</span><br><span class="line">            <span class="keyword">else</span> ans += <span class="number">365</span>;</span><br><span class="line">            temp.y ++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.d ++;</span><br><span class="line">        <span class="keyword">if</span> (temp.d == month[temp.m][isLeap(temp.y)]+<span class="number">1</span>)&#123;</span><br><span class="line">            temp.d = <span class="number">1</span>;temp.m ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp.m == <span class="number">13</span>)&#123;</span><br><span class="line">            temp.m = <span class="number">1</span>;temp.y ++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载后缀++</span></span><br><span class="line">Date <span class="keyword">operator</span>++ (Date&amp; D,<span class="keyword">int</span>)&#123;</span><br><span class="line">    Date temp = D;</span><br><span class="line">    D.d ++;</span><br><span class="line">    <span class="keyword">if</span> (D.d == month[D.m][isLeap(D.y)]+<span class="number">1</span>)&#123;</span><br><span class="line">        D.d = <span class="number">1</span>;D.m ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (D.m == <span class="number">13</span>)&#123;</span><br><span class="line">        D.m = <span class="number">1</span>;D.y ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载++前缀</span></span><br><span class="line">Date <span class="keyword">operator</span>++ (Date&amp; D)&#123;</span><br><span class="line">    D.d ++;</span><br><span class="line">    <span class="keyword">if</span> (D.d == month[D.m][isLeap(D.y)]+<span class="number">1</span>)&#123;</span><br><span class="line">        D.d = <span class="number">1</span>;D.m ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (D.m == <span class="number">13</span>)&#123;</span><br><span class="line">        D.m = <span class="number">1</span>;D.y ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> D;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Date d1(2019,12,31),d2,d3;</span><br><span class="line">    d2 = d1++;</span><br><span class="line">    d1.print();</span><br><span class="line">    d2.print();</span><br><span class="line">    d3 = ++d1;</span><br><span class="line">    d1.print();</span><br><span class="line">    d3.print();</span><br><span class="line">    d1 = d1 + <span class="number">365</span>;</span><br><span class="line">    d1.print();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag>日期处理</tag>
      </tags>
  </entry>
  <entry>
    <title>设计一个二维数组类并重载运算符</title>
    <url>/posts/ca18faac.html</url>
    <content><![CDATA[<p>如题：设计一个M*N的二维数组类，要求重载+、-运算符。</p>
<span id="more"></span>

<p><img src="/posts/ca18faac/image-20210415102641989.png" alt="image-20210415102641989"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">        Array()&#123;&#125;</span><br><span class="line">		Array(<span class="keyword">int</span> n[M][N])&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i ++)</span><br><span class="line">			    <span class="built_in">memcpy</span>(arr[i],n[i],<span class="keyword">sizeof</span>(n[N]));</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)&#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\t&#x27;</span> &lt;&lt; arr[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入2*3的整型数组：\n&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++) <span class="built_in">cin</span> &gt;&gt; arr[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        Array <span class="keyword">operator</span>+ (Array&amp; a)&#123;</span><br><span class="line">                Array temp;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)&#123;</span><br><span class="line">                        temp.arr[i][j] = <span class="keyword">this</span>-&gt;arr[i][j]+a.arr[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        Array <span class="keyword">operator</span>- (Array&amp; a)&#123;</span><br><span class="line">                Array temp;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)&#123;</span><br><span class="line">                        temp.arr[i][j] = <span class="keyword">this</span>-&gt;arr[i][j]-a.arr[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span> arr[M][N];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">	Array A(a),B,C,D;</span><br><span class="line">	B.<span class="built_in">set</span>();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Array A:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	A.show();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Array B:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	B.show();</span><br><span class="line">	C = A + B;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Array C=A+B:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	C.show();</span><br><span class="line">	D = A - B;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Array D=A-B:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	D.show();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>趣谈计算机网络协议（一）</title>
    <url>/posts/64abf487.html</url>
    <content><![CDATA[<h2 id="我们为什么需要网络协议？"><a href="#我们为什么需要网络协议？" class="headerlink" title="我们为什么需要网络协议？"></a>我们为什么需要网络协议？</h2><p>当”Hello World!”从显示器打印出来的时候，还记得你激动的心情吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你是程序员，一定看得懂上面这一段文字。这是每一个程序员向计算机世界说“你好，世界”的方式。但是，你不一定知道，这段文字也是一种协议，是人类和计算机沟通的协议，<strong>只有通过这种协议，计算机才知道我们想让它做什么。</strong></p>
<span id="more"></span>

<h3 id="协议三要素"><a href="#协议三要素" class="headerlink" title="协议三要素"></a>协议三要素</h3><p>当然，这种协议还是更接近人类语言，机器不能直接读懂，需要进行翻译，翻译的工作教给编译器，也就是程序员常说的 compile。</p>
<p>但是可以看得出，计算机语言作为程序员控制一台计算机工作的协议，具备了协议的三要素。</p>
<ul>
<li><strong>语法</strong>，就是这一段内容要符合一定的规则和格式。例如，括号要成对，结束要使用分号等。</li>
<li><strong>语义</strong>，就是这一段内容要代表某种意义。例如数字减去数字是有意义的，数字减去文本一般来说就没有意义。</li>
<li><strong>顺序</strong>，就是先干啥，后干啥。例如，可以先加上某个数值，然后再减去某个数值。</li>
</ul>
<p>但是，要想打造互联网世界的通天塔，只教给一台机器做什么是不够的，你需要学会教给一大片机器做什么。</p>
<p>这就需要网络协议<strong>。只有通过网络协议，才能使一大片机器互相协作、共同完成一件事。</strong></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>重磅推荐 | 史上最全面最标准的数学符号、公式的英语读法</title>
    <url>/posts/45403fc4.html</url>
    <content><![CDATA[<p>转载自<a href="https://mp.weixin.qq.com/s/gaHfVbXLSP3-hC5bMrdQHA">英文茶馆</a> <em>2017-10-29</em></p>
<p>说起英语和数学，大概每个人都有难忘的回忆。可是学了十几、二十年的英语和数学，你会用英语来表达数学吗？烂熟于心的数学符号和表达式用英语会说吗？想不想挑战一下自己？</p>
<span id="more"></span>

<p>先来一个最简单的：1+2=3 用英语怎么说？</p>
<p>One plus two equals three. 哎呦不错哦， 继续！</p>
<p> 尝试：$\sqrt {x + y}$英语怎么说？</p>
<p>就知道你说不出来咯～今天这篇文章，将从小学到博士后的数学符号和表达式的英文读法一网打尽，全都总结好了！惊不惊喜？意不意外？！</p>
<p>数学是所有理工学科的基础，是认识科学世界基本工具，数学的重要性不言而喻。所以，这篇文章是老少咸宜的、吐血总结的干货。可以帮助：</p>
<p><strong>中小学生：</strong>了解英语不仅是“I am a student.My name is XXX.”,而是真正用于学习数学、学习知识的工具。</p>
<p><strong>大学生：</strong>在外教课堂、国际会议、外企，面对常见的数学符号，简单得不能再简单的数学问题时，不再茶壶里煮饺子倒不出来。</p>
<p><strong>留学党：</strong>缩短刚到国外听懂老师课堂讲课的过渡期。</p>
<p><strong>学生家长</strong>可以为你家宝宝留着哦～</p>
<h2 id="基本数学符号"><a href="#基本数学符号" class="headerlink" title="基本数学符号"></a><strong>基本数学符号</strong></h2><h3 id="1-加减乘除"><a href="#1-加减乘除" class="headerlink" title="1. 加减乘除"></a><strong>1. 加减乘除</strong></h3><p><img src="/posts/45403fc4/image-20210310194431214.png" alt="image-20210310194431214"></p>
<p><strong>“+”**当作运算符</strong>加号**时读作plus，比如：</p>
<p>1+2 ➡️ one plus two</p>
<p>当”+”放在数字前表示<strong>正数</strong>时，读作positive，比如：</p>
<p>+4 ➡️ positive four</p>
<p>同样，<strong>“-”</strong>也有minus和negative两种读法，分别是<strong>减号</strong>和<strong>负数</strong>。</p>
<p><strong>“×”</strong> 两种读法都可以，国外的教授会常常读成times，可能因为比较简单吧，比如：</p>
<p>9x6 ➡️ nine times six</p>
<p><strong>“÷”</strong>只有一种读法divided by，就是被…分成几份</p>
<p>15÷3 ➡️ fifteen is divided by three</p>
<p><strong>注意</strong>：</p>
<p>其中plus和minus是不用第三人称单数形式的，因为plus和minus根本就不是动词，而是介词。</p>
<p>但是乘和除，的的确确是动词，出现第三人称单数的形式。您记住了吗？</p>
<h3 id="2-比较运算符"><a href="#2-比较运算符" class="headerlink" title="2. 比较运算符"></a><strong>2. 比较运算符</strong></h3><p><img src="/posts/45403fc4/image-20210310194516520.png" alt="image-20210310194516520"></p>
<p>比较运算符用来比较两个表达式的大小关系，比如：1+4&gt;3 ➡️ one plus four is greater than three</p>
<p>为什么用<strong>is</strong>？</p>
<p>这里one plus four 是介词plus 连接两个名词，但是one plus four 作为一个整体当作主语，因此不用are，而是is</p>
<p>4+5=9 ➡️ four plus five equals nine 或 four plus five is equal to nine</p>
<p>其他的类推，只要你认识数学符号，应该不难用英语说出来。</p>
<h3 id="3-括号"><a href="#3-括号" class="headerlink" title="3. 括号"></a><strong>3. 括号</strong></h3><p><img src="/posts/45403fc4/image-20210310194547442.png" alt="image-20210310194547442"></p>
<p>括号是最常见的数学符号了。</p>
<p>中文里同类词习惯有相同的部分，比如：卡车、消防车、救护车都有“车”字。<strong>小括号，中括号，大括号</strong>都是括号。（多么科学啊！）</p>
<p>而英语里卡车、消防车、救护车分别是truck, fire engine, ambulance一点都不像。</p>
<p>英语里<strong>小括号，中括号，大括号</strong>这三个词也是没有一点相似，分别是：parenthesis，bracket，brace.（太不科学了！）</p>
<p><strong>左括号</strong>叫做left或open，<strong>右括号</strong>叫做right或closed. 下次碰到了就大胆地说出来吧！</p>
<h3 id="4-级数表示"><a href="#4-级数表示" class="headerlink" title="4. 级数表示"></a><strong>4. 级数表示</strong></h3><p><img src="/posts/45403fc4/image-20210310194619498.png" alt="image-20210310194619498"></p>
<p>哇～到中学数学了～这张表里的**<em>“a”**</em>是变量，而不是冠词“一个”的意思哦。</p>
<p><strong><em>|a|</em></strong>是<em>a</em>的绝对值或绝对值<em>a</em>， 英文读作absolute value of <em>a</em>, 非常好理解。</p>
<p><strong><em>a’</em></strong>是什么？**<em>a****</em>撇*<em>就是与</em>a<em>相关又不想重复的时候会用一下，英语里读成</em>a* prime, 同样有两撇a double prime，三撇a triple prime…</p>
<p>但是注意了，如果**<em>a’**</em>表示时间分秒里的分，或者其他有具体意义的时候，就要按照具体意义读了。</p>
<p><strong>$a^n$是a的n次方</strong>，是n个<em>a</em>相乘的结果，读作<em>a</em> superscript <em>n</em>或者<em>a</em> to the <em>n</em></p>
<p>$\bar a$,$a^ <em>$这两个初中代数就出现了，读作</em>a* bar和<em>a</em> star. <strong>Bar</strong> 就是<strong>杆</strong>的意思。<em>a</em>上面有个杆。中文怎么读？<em>a</em>杠，<em>a</em>星。</p>
<p>square是数学里的平方，cube是立方，root是根号，这几个词用于表示<strong>开方</strong></p>
<p>$a_ n$是最常出现的了，读作<em>a</em> sub <em>n</em>，<strong>一定要记住了</strong>！！在数学上大量出现。<strong>根号a</strong>和<strong>三次方a</strong>读作square root of <em>a</em>和cube root of a</p>
<h3 id="5-微分和偏微分"><a href="#5-微分和偏微分" class="headerlink" title="5. 微分和偏微分"></a><strong>5. 微分和偏微分</strong></h3><p><img src="/posts/45403fc4/image-20210310195701402.png" alt="image-20210310195701402"></p>
<p>升级到了高等数学，经过高考的学生才会碰到这两个。</p>
<p>$d/dx$这是什么鬼？这是一个变量对<em>x</em>微分或偏微分的运算符，符号后面还要加上某一个变量。首先，小伙伴知道中文怎么念吗？</p>
<p>嘿嘿，<em>d</em>比<em>d x</em>？英文读作<em>d</em> by <em>d x</em>，严谨地读作the derivative with respect to <em>x</em>， with respect to 是<strong>关于</strong>的意思，就是关于<em>x</em>的微分。</p>
<p>$\partial/\partial x$偏 比偏x？英文读作the partial derivative with respect to <em>x</em>或者简单地读作partial over partial<em>x</em>，partial是部分的意思。</p>
<p>顺便显摆一下，<strong>微分是单变量时候叫法，如果是多变量就是偏微分喽</strong>！看咱这数学是不是杠杠滴！</p>
<h3 id="6-其他数学符号"><a href="#6-其他数学符号" class="headerlink" title="6. 其他数学符号"></a><strong>6. 其他数学符号</strong></h3><p><img src="/posts/45403fc4/image-20210310200651457.png" alt="image-20210310200651457"></p>
<h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a><strong>进阶篇</strong></h2><p>有点数学基础了吧，来点实用的！进阶篇！</p>
<h3 id="1-代数-1"><a href="#1-代数-1" class="headerlink" title="1. 代数(1)"></a><strong>1. 代数(1)</strong></h3><p><img src="/posts/45403fc4/image-20210310200750422.png" alt="image-20210310200750422"></p>
<p>以上几个是<strong>代数表达式</strong>，是符号之间的运算。表达式不是等式，所以其英文翻译也不是一个句子，类似一个名词短语。</p>
<p>比如*<strong>ab-c**<em>读作</em>a b* minus <em>c</em>，介词minus连接两个名词变量，结果还是一堆名词变量。*</strong>ab***直接读 <em>a b</em> 就行。</p>
<p>因为语言的本质是传递信息，懂数学的人已经明白了，没有二义性。</p>
<p>如要更清晰地表达**<em>ab****</em>，**是 <em>a</em> times <em>b</em>，times是谓语动词 time的第三人称单数。</p>
<p><strong><em>a-(b-c)</em></strong>和**<em>a(b+c)**</em>里有一对括号，不用把括号读出来，读出来是赵本山，读信件时读逗号、括号、括号完了(liǎo)</p>
<p><strong><em>a-(b-c)</em></strong>数学上的意思是<em>a</em>减去<em>b</em>与<em>c</em>的差，英文也是这个逻辑，读作<em>a</em> minus the difference <em>b</em> minus <em>c</em>，没有of，其中the difference是<strong>差</strong>的意思。</p>
<p><strong><em>a(b+c)</em></strong>读作<em>a</em> times the sum <em>b</em> plus <em>c</em>，应该很好理解了。</p>
<p><strong><em>a-(-b-c)</em></strong>读作a minus the quantity minus <em>b</em> minus <em>c</em>，使用quantity是英语语言习惯，避免plus和minus连在一起说。</p>
<h3 id="2-代数-2"><a href="#2-代数-2" class="headerlink" title="2. 代数(2)"></a><strong>2. 代数(2)</strong></h3><p><img src="/posts/45403fc4/image-20210310201140222.png" alt="image-20210310201140222"></p>
<p>这几个单独拿来说事，是因为太重要了！</p>
<p>在国外课堂上，老师一边写公式一边嘴里叨咕着，公式里分数是很多，一般都念做over！因为快！比如<strong>8/9</strong>直接念eight over nine</p>
<p>复杂点的第二个</p>
<p>$\frac {a+b} c + d$</p>
<p>中文读<strong>c分之a加b加d</strong>，中文读法有歧义，分不清加**<em>d**</em>是在分子上还是分数后面。</p>
<p>英文读作the quantity <em>a</em> plus <em>b</em> over <em>c</em>, that fraction plus <em>d</em>, 没有歧义！perfect！ </p>
<p>$\frac {x^2}{a^2}+\frac {y^2}{b^2}=1$</p>
<p>是拿来绕嘴的，读作the fraction <em>x</em> squared over <em>a</em> squared plus the fraction <em>y</em></p>
<p>squared over <em>b</em> squared equals 1，其中fraction是分数的意思。</p>
<p>$ax^2+bxy+cy^2+dx+ey+f=0$</p>
<p>这个是拿来是给你找信心的，很简单吧：<em>a x</em> squared plus <em>b x y</em> plus <em>c y</em> squared plus <em>d x</em> plus <em>e y</em> plus <em>f</em> equals zero完全读对的童鞋奖励自己一根棒棒糖。</p>
<h3 id="3-几个特殊的"><a href="#3-几个特殊的" class="headerlink" title="3. 几个特殊的"></a><strong>3. 几个特殊的</strong></h3><p><img src="/posts/45403fc4/image-20210310202105712.png" alt="image-20210310202105712"></p>
<p>这几个特殊的每一个都很珍贵！拿走不谢。</p>
<p>第一个</p>
<p>$a^x$简单读成<em>a</em> to the <em>x</em>，例子非常多，比如$3^4$读作three to four，也可以读的更完整点，three raised to the four power</p>
<p>$\log_ba$是以b为底的a的对数，log to the base <em>b</em> of <em>a</em>，其中the base就是为底了，介词严谨地表达了准确的数学定义。</p>
<p>$\lg3*4$是以10为底的3乘4的积的对数，读作log to the base 10 of the product 3 times 4</p>
<p>以此类推，</p>
<p>$\ln \frac2 5$中注意the fraction和the ratio是一样的，分数就是比的意思嘛。</p>
<p>$\ln x$是<em>x</em>的自然对数，读作the natural log of <em>x</em>。</p>
<p>自然对数底是多少？哼哼，百度啊，e=2.71828</p>
<p>注意：</p>
<p>$a_1+a_2+…+a_n$中的“点点点”就读做dot dot dot</p>
<p><strong><em>p(x)</em></strong>数学上是表示一个以<em>x</em>为自变量的函数<em>p</em>，读作p of x。为什么不读成<em>p x,</em> 汉语就是这么读的.应该是避免和<em>px</em>搞混吧。</p>
<p>另外注意，</p>
<p>$\ln x$里也有个<strong>of</strong></p>
<h3 id="4-带of的函数"><a href="#4-带of的函数" class="headerlink" title="4. 带of的函数"></a><strong>4. 带of的函数</strong></h3><p><img src="/posts/45403fc4/image-20210310203206521.png" alt="image-20210310203206521"></p>
<p>单独总结一下<strong>带of 的函数</strong>，数学上是以<em>x</em>为自变量的函数<em>p</em>，其他的都不复杂。</p>
<h3 id="5-专业课里常出的数学符号"><a href="#5-专业课里常出的数学符号" class="headerlink" title="5. 专业课里常出的数学符号"></a><strong>5. 专业课里常出的数学符号</strong></h3><p><img src="/posts/45403fc4/image-20210310203321975.png" alt="image-20210310203321975"></p>
<p>这些在工程学科的专业课里很容易见到，理论力学里用</p>
<p>$\sigma_x$表示正应力，读作sigma sub <em>x</em>，注意 sub 表示下标。</p>
<p>$Q_1$当有大写字母时，读作Capital <em>q</em> sub one。</p>
<p>$E(x)$有括号，读作Capital <em>e</em> of <em>x</em>，结合上面的**<em>p(x)**</em>印象应该很深吧。</p>
<p>$j_{(p)}$这个比较怪，下标带括号，汉语一般读成j 下标括号p，英文读作<em>j</em> sub <em>p</em> in parentheses，parentheses是括号的意思。</p>
<h3 id="6-高等数学里面的几个符号"><a href="#6-高等数学里面的几个符号" class="headerlink" title="6. 高等数学里面的几个符号"></a><strong>6. 高等数学里面的几个符号</strong></h3><p><img src="/posts/45403fc4/image-20210310203722674.png" alt="image-20210310203722674"></p>
<p> 这几个表达式是求和、求积和求极限。</p>
<p>$\sum\limits_{1}^{N}$汉语读<strong>西格玛1到大n</strong>，英文读作summation from one to capital <em>n</em></p>
<p>$\sum\limits_{i=1}^{\infty}x_i$英文里把希腊字母的意思说出来了，求和(summation), 这里多了<strong>正无穷</strong>，读作summation from <em>i</em> equals one to infinity of <em>x</em> sub <em>i</em></p>
<p>$\prod$是infinity就是正无穷。数学上是多个量求积的符号，英文<strong>积</strong>是product，是名词。</p>
<p>$\prod\limits_{1}^{n}$结构和求和一样，product from one to <em>n</em></p>
<p>同理，</p>
<p>$\prod\limits_{i=1}^{\infty}y_i$读成product from <em>i</em> equals one to infinity of <em>y</em> sub <em>i</em></p>
<p>$\displaystyle\lim_{x \rightarrow a}y = b$的意思是当x趋近a时y的极限等于b，limit as <em>x</em> approaches <em>a</em> of <em>y</em> equals <em>b</em>，limit是极限，名词，approaches 是趋紧的第三人称单数。</p>
<p>$\displaystyle\lim_{x \rightarrow a^-}f(x)$的数学意思是<strong>当x从左边趋紧a时关于x的函数f的极限</strong>，英文读作limit as <em>x</em> approaches <em>a</em> minus of <em>f</em>of <em>x</em>，从左边就是从minus方向</p>
<p>$\int f(x)dx$数学意思是<strong>函数fx的不定积分</strong>，英文读作integral of <em>f</em> of <em>x d x</em>，其中integral是积分的意思。</p>
<h3 id="7-线性代数中的英文读法"><a href="#7-线性代数中的英文读法" class="headerlink" title="7. 线性代数中的英文读法"></a><strong>7. 线性代数中的英文读法</strong></h3><p><img src="/posts/45403fc4/image-20210310210858177.png" alt="image-20210310210858177"></p>
<p>线性代数是大学生必学的科目，里面全是<strong>矩阵</strong>和<strong>向量</strong>，英文分别是matrix和vector，不明觉厉！</p>
<p>表里第一个是个矩阵，有四个元素，第一行是2 和 7, 第二行是3和10，用英文读时也和中文表达类似。</p>
<p>Two by two matrix (意思是2x2 矩阵)，first row two seven, second row tree ten</p>
<p>注意此处没有is 等动词。 </p>
<p>第二个是<strong>行向量</strong>，读作row vector </p>
<p>第三个是<strong>列向量</strong>，读作column vector</p>
<h3 id="8-其他常用的表达式"><a href="#8-其他常用的表达式" class="headerlink" title="8. 其他常用的表达式"></a><strong>8. 其他常用的表达式</strong></h3><p><img src="/posts/45403fc4/image-20210310211606203.png" alt="image-20210310211606203"></p>
<p>$\Delta y$读时汉语从不强调<strong>大写delta</strong>，英文要读capital delta <em>y</em></p>
<p>其他的都在前面出现过，列在此处再此强调一下。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a><strong>后记</strong></h2><p>目前国内绝大部分的英语学习，仍然停留在日常交流和一些常识性知识的英语。</p>
<p>说的直白一些，口语练的再棒，英语水平也仅相当于英语国家受教育程度低的人的英语水平。</p>
<p>很多人native speakers没有读过书，照样可以交流。但是在他们的语言里找不到自然科学、文学、艺术等英语的痕迹。</p>
<p>我们虽然受过高等教育，但是专业的、学术的英语学习仍然匮乏。我们的课本是中文的、老师用中文授课、我们的知识体系也是中文的。</p>
<p>所以在阅读原版教材、写英文论文、参加国际学术交流等很多时候，会遇到英语瓶颈。真正能够应用英语来进行知识的学习，工作等，起码需要明白数学中的英语，希望这篇文章能给您带来帮助。</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学专业词汇</tag>
      </tags>
  </entry>
  <entry>
    <title>高等排序算法</title>
    <url>/posts/7ff5bb67.html</url>
    <content><![CDATA[<h1 id="高等排序算法"><a href="#高等排序算法" class="headerlink" title="高等排序算法"></a>高等排序算法</h1><p>归并排序见我的另一篇<a href="https://grant1499.github.io/2021/04/17/two-pointers%E6%80%9D%E6%83%B3%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/#more">文章</a>。</p>
<span id="more"></span>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>C++竞赛语法总结（九）</title>
    <url>/posts/cc84a5fd.html</url>
    <content><![CDATA[<h2 id="1-常用库函数"><a href="#1-常用库函数" class="headerlink" title="1.常用库函数"></a>1.常用库函数</h2><p>这些库函数大都在<code>&lt;algorithm&gt;</code>中。</p>
<span id="more"></span>

<h3 id="1-reverse-翻转"><a href="#1-reverse-翻转" class="headerlink" title="(1)  reverse 翻转"></a>(1)  reverse 翻转</h3><p>既可以用于一般的数组，也能够用于vector。</p>
<p>翻转一个vector：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">reverse(a.begin(), a.end());</span><br></pre></td></tr></table></figure>

<p>翻转一个数组，元素存放在下标1~n：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">reverse(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;)</span></span>;</span><br><span class="line">    reverse(a.begin(), a.end());<span class="comment">// 左闭右开</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x:a) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    reverse(b,b + <span class="number">5</span>);<span class="comment">// 左闭右开</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x:a) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-unique-去重"><a href="#2-unique-去重" class="headerlink" title="(2)  unique 去重"></a>(2)  unique 去重</h3><p>去除容器中相邻的重复元素。(<strong>必须保证重复元素是相邻排列的</strong>)</p>
<p>返回去重之后的尾迭代器（或指针），仍然为前闭后开，即这个迭代器是去重之后末尾元素的下一个位置。该函数常用于离散化，<strong>利用迭代器（或指针）的减法，可计算出去重后的元素个数</strong>。</p>
<p>注：数组去重之后，<strong>去重之后的多余元素并没有删除，而是放在后面</strong>。</p>
<p>把一个vector去重：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = unique(a.begin(), a.end()) – a.begin();</span><br></pre></td></tr></table></figure>

<p>把一个数组去重，元素存放在下标1~n：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = unique(a + <span class="number">1</span>, a + <span class="number">1</span> + n) – (a + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><strong>补充<code>vector::erase</code>：（左闭右开）</strong></p>
<p>从指定容器删除指定位置的元素或某段范围内的元素，vector::erase()方法有两种重载形式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">如下： <span class="function">iterator <span class="title">erase</span><span class="params">(  iterator _Where)</span></span>; <span class="function">iterator <span class="title">erase</span><span class="params">(  iterator _First,  iterator _Last)</span></span>; </span><br></pre></td></tr></table></figure>

<p>  如果是删除指定位置的元素时：返回值是一个迭代器，指向删除元素下一个元素 ；</p>
<p> 如果是删除某范围内的元素时：返回值也表示一个迭代器，指向最后一个删除元素的下一个元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> m = unique(a,a + <span class="number">7</span>) - a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i ++) <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">7</span>;i ++) <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 去重之后的多余元素并没有删除</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>&#125;)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> n = unique(b.begin(),b.end()) - b.begin();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">c</span><span class="params">(&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>&#125;)</span></span>;</span><br><span class="line">    c.erase(unique(c.begin(),c.end()),c.end());<span class="comment">// 常见的用法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: c) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-random-shuffle-随机打乱"><a href="#3-random-shuffle-随机打乱" class="headerlink" title="(3)  random_shuffle 随机打乱"></a>(3)  random_shuffle 随机打乱</h3><p>用法与reverse相同 ,参数与reverse一样。生成随机数排列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;)</span></span>;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    random_shuffle(a.begin(),a.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x:a) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-sort-非常非常重要"><a href="#4-sort-非常非常重要" class="headerlink" title="(4)  sort(非常非常重要)"></a>(4)  sort(非常非常重要)</h3><p>前两个参数与reverse完全一样。</p>
<p>对两个迭代器（或指针）指定的部分进行快速排序。可以在第三个参数传入定义大小比较的函数，或者重载“小于号”运算符。</p>
<p>把一个int数组（元素存放在下标1~n）从大到小排序，传入比较函数：</p>
<p> <code>int a[MAX_SIZE];</code></p>
<p><code>bool cmp(int a, int b) &#123;return a &gt; b;&#125;</code></p>
<p><code>sort(a + 1, a + 1 + n, cmp);</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><span class="comment">// a是否应该排在b的前面</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;<span class="comment">// 从大到小</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;)</span></span>;</span><br><span class="line">    sort(a.begin(),a.end());<span class="comment">// 从小到大</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x :a) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    sort(a.begin(),a.end(),greater&lt;<span class="keyword">int</span>&gt;());<span class="comment">// 从大到小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x :a) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    sort(a.begin(),a.end(),cmp);<span class="comment">// 根据cmp排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x :a) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结构体排序"><a href="#结构体排序" class="headerlink" title="结构体排序"></a>结构体排序</h4><p>solution 1:自定义比较函数cmp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rec</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">    &#125;a[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Rec a,Rec b)</span><span class="comment">// a是否应该排在b的前面</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;<span class="comment">// 从小到大</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i].x =-i;</span><br><span class="line">        a[i].y = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i ++) <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d) &quot;</span>,a[i].x,a[i].y);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    sort(a,a + <span class="number">5</span>,cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i ++) <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d) &quot;</span>,a[i].x,a[i].y);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>solution 2:把自定义的结构体vector排序，重载“小于号”运算符：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rec</span>&#123;</span> <span class="keyword">int</span> id, x, y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;rec&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> rec &amp;a, <span class="keyword">const</span> rec &amp;b) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> a.x &lt; b.x || a.x == b.x &amp;&amp; a.y &lt; b.y;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(a.begin(), a.end());</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rec</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Rec&amp;t) <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x &lt; t.x;<span class="comment">// 从小到大排序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;a[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i].x =-i;</span><br><span class="line">        a[i].y = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i ++) <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d) &quot;</span>,a[i].x,a[i].y);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    sort(a,a + <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i ++) <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d) &quot;</span>,a[i].x,a[i].y);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-lower-bound-upper-bound-二分"><a href="#5-lower-bound-upper-bound-二分" class="headerlink" title="(5)  lower_bound/upper_bound 二分"></a>(5)  lower_bound/upper_bound 二分</h3><p>二分的前提是<strong>数组或者结构体已经从小到排好序了</strong>。</p>
<p>lower_bound 的第三个参数传入一个元素x，在两个迭代器（指针）指定的部分上执行二分查找，返回指向第一个<strong>大于等于x的元素的位置</strong>的迭代器（指针）。</p>
<p>upper_bound 的用法和lower_bound大致相同，唯一的区别是<strong>查找第一个大于x的元素</strong>。当然，两个迭代器（指针）指定的部分应该是提前排好序的。</p>
<p>在有序int数组（元素存放在下标1~n）中查找大于等于x的最小整数的下标：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法1</span></span><br><span class="line"><span class="keyword">int</span>* l = lower_bound(a + <span class="number">1</span>, a + <span class="number">1</span> + n, x);</span><br><span class="line"><span class="keyword">int</span> t = l - a;</span><br><span class="line"><span class="comment">// 写法2</span></span><br><span class="line"><span class="keyword">int</span> l = lower_bound(a + <span class="number">1</span>, a + <span class="number">1</span> + n, x) - a;</span><br></pre></td></tr></table></figure>

<p>在有序<code>vector&lt;int&gt;</code> 中查找小于等于x的最大整数（假设一定存在）：</p>
<p><code>int y = *--upper_bound(a.begin(), a.end(), x);</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>* p = lower_bound(a,a + <span class="number">5</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span>* q = lower_bound(a,a + <span class="number">5</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">int</span> t1 = lower_bound(a,a + <span class="number">5</span>,<span class="number">6</span>) - a;<span class="comment">// 返回第一个&gt;=6的元素的下标</span></span><br><span class="line">    <span class="keyword">int</span> t2 = lower_bound(a,a + <span class="number">5</span>,<span class="number">7</span>) - a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; t2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; *q &lt;&lt;  <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;<span class="comment">// 去掉()也能初始化vector</span></span><br><span class="line">    <span class="keyword">int</span> t = upper_bound(b.begin(),b.end(),<span class="number">4</span>) - b.begin();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b[t] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-next-permutation-（全排列函数）"><a href="#6-next-permutation-（全排列函数）" class="headerlink" title="(6) next_permutation()（全排列函数）"></a>(6) next_permutation()（全排列函数）</h3><p>将当前排列更改为 <strong>全排列中的下一个排列</strong>。如果当前排列已经是 <strong>全排列中的最后一个排列</strong>（元素完全从大到小排列），函数返回 <code>false</code> 并将排列更改为 <strong>全排列中的第一个排列</strong>（元素完全从小到大排列）；否则，函数返回 <code>true</code>。<code>next_permutation(v.begin(), v.end())</code> 或 <code>next_permutation(v + begin, v + end)</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">next_permutation()将按字母表顺序生成给定序列的下一个较大的排列,直到整个序列为降序为止。</span></span><br><span class="line"><span class="comment">prev_permutation()与之相反,是生成给定序列的上一个较小的排列。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (next_permutation(num,num + <span class="number">5</span>)) &#123;</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : num) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; cnt;<span class="comment">// cnt == 5! == 120</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*1 2 3 5 4 </span></span><br><span class="line"><span class="comment">1 2 4 3 5</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">5 4 3 2 1</span></span><br><span class="line"><span class="comment">120*/</span></span><br></pre></td></tr></table></figure>

<h2 id="2-acwing-53-最小的k个数"><a href="#2-acwing-53-最小的k个数" class="headerlink" title="2.acwing.53.最小的k个数"></a>2.acwing.53.最小的k个数</h2><p>输入n个整数，找出其中最小的k个数。</p>
<p><strong>注意：</strong></p>
<ul>
<li>数据保证k一定小于等于输入数组的长度;</li>
<li>输出数组内元素请按从小到大顺序排序;</li>
</ul>
<p>样例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>] , k=<span class="number">4</span></span><br><span class="line"></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1,我的题解，利用优先队列（堆）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; p;<span class="comment">// 小根堆</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; input.size();i ++) p.push(input[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i ++) &#123;res.push_back(p.top());p.pop();&#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// solution 2,y总题解，练习sort</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        sort(input.begin(),input.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i ++) res.push_back(input[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-acwing-75-和为S的两个数字"><a href="#3-acwing-75-和为S的两个数字" class="headerlink" title="3.acwing.75.和为S的两个数字"></a>3.acwing.75.和为S的两个数字</h2><p>输入一个数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。</p>
<p>如果有多对数字的和等于s，输出任意一对即可。</p>
<p>你可以认为每组输入中都至少含有一组满足条件的输出。</p>
<p>样例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] , sum=<span class="number">7</span></span><br><span class="line"></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1，暴力枚举</span></span><br><span class="line"><span class="comment">//两个遍历数组的循环，所以时间复杂度是O(n^2)</span></span><br><span class="line"><span class="comment">//没有开辟与数组大小相关的空间，所以空间复杂度是O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findNumbersWithSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size();i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; nums.size();j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(nums[i]);</span><br><span class="line">                    res.push_back(nums[j]);</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// solution 2，y总题解，哈希表</span></span><br><span class="line"><span class="comment">//时间复杂度O(n)；开辟了数组大小的哈希表，所以空间复杂度是O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findNumbersWithSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(S.count(target-x)) <span class="keyword">return</span> &#123;x,target-x&#125;;</span><br><span class="line">            S.insert(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-acwing-51-数字排列"><a href="#4-acwing-51-数字排列" class="headerlink" title="4.acwing.51.数字排列"></a>4.acwing.51.数字排列</h2><p>有难度！！不会了！</p>
<p>输入一组数字（可能包含重复数字），输出其所有的排列方式。</p>
<p>样例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">      [</span><br><span class="line">        [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">        [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">        [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">        [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">        [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">        [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">      ]</span><br></pre></td></tr></table></figure>

<p><strong><code>next_permutation</code>全排列函数详解：</strong></p>
<ul>
<li><code>next_permutation</code>：将当前排列更改为 <strong>全排列中的下一个排列</strong>。如果当前排列已经是 <strong>全排列中的最后一个排列</strong>（元素完全从大到小排列），函数返回 <code>false</code> 并将排列更改为 <strong>全排列中的第一个排列</strong>（元素完全从小到大排列）；否则，函数返回 <code>true</code>。<code>next_permutation(v.begin(), v.end())</code> 或 <code>next_permutation(v + begin, v + end)</code>。</li>
<li>使用 <code>next_permutation</code> 生成 到 的全排列。例题：<a href="https://www.luogu.com.cn/problem/P1706">Luogu P1706 全排列问题</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> N = <span class="number">9</span>, a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (next_permutation(a, a + N));</span><br></pre></td></tr></table></figure>

<p><strong>题解：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1,STLnb!!!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permutation(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">do</span> res.push_back(nums);<span class="keyword">while</span> (next_permutation(nums.begin(),nums.end()));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5-acwing-26-二进制中1的个数"><a href="#5-acwing-26-二进制中1的个数" class="headerlink" title="5.acwing.26.二进制中1的个数"></a>5.acwing.26.二进制中1的个数</h2><p>输入一个32位整数，输出该数二进制表示中1的个数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1，我的题解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>;i &gt;= <span class="number">0</span>;i --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &gt;&gt; i &amp; <span class="number">1</span>) == <span class="number">1</span>) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// solution 2，y总题解，lowbit写法，更快一点</span></span><br><span class="line"><span class="comment">//lowbit(x) = x &amp; -x，取二进制最后一位1及以后的数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;n -= n &amp; -n; res++;&#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="6-acwing-862-三元组排序"><a href="#6-acwing-862-三元组排序" class="headerlink" title="6.acwing.862.三元组排序"></a>6.acwing.862.三元组排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1，我的题解，结构体普通做法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">float</span> b;</span><br><span class="line">    <span class="built_in">string</span> c;</span><br><span class="line">&#125;R[<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Rec x,Rec y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x.a &lt; y.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (N--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; R[i].a &gt;&gt; R[i].b &gt;&gt; R[i].c;</span><br><span class="line">		i ++;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(R,R+i,cmp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j ++)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;%d %.2f %s\n&quot;</span>,R[j].a,R[j].b,R[j].c.c_str());</span><br><span class="line">        <span class="comment">// 注意printf输出string得用string.c_str()</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// solution 2</span></span><br><span class="line"><span class="comment">//STL:vector 这里用了pair&lt;int, pair&lt;double, string &gt;&gt; 嵌套pair构成三元组</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="built_in">pair</span>&lt;<span class="keyword">double</span>, <span class="built_in">string</span> &gt;&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;PII&gt; ans;</span><br><span class="line"><span class="keyword">int</span> n, a;</span><br><span class="line"><span class="keyword">double</span> b;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">        ans.push_back(&#123;a, &#123;b, s&#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(ans.begin(), ans.end());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: ans)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %.2lf %s\n&quot;</span>,i.x, i.y.x, i.y.y.c_str());   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">作者：小张同学</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/9475/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class="line"><span class="comment">// solution 3,STL : map</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">double</span>, <span class="built_in">string</span>&gt; PII;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, PII&gt; ans;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    <span class="built_in">string</span> c;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        ans.insert(&#123;a, &#123;b, c&#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// map&lt;int, PII&gt;::iterator iter; 迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, PII&gt;::iterator iter = ans.begin(); iter != ans.end(); iter ++ )</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %.2f %s\n&quot;</span>, iter-&gt;x, iter-&gt;y.x, iter-&gt;y.y.c_str());  <span class="comment">//这里 iter -&gt; x/y 是map ，后面两个是pair ：PII.first/second</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">作者：小张同学</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/9475/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h2 id="7-acwing-20-用两个栈实现队列（剑指offer）"><a href="#7-acwing-20-用两个栈实现队列（剑指offer）" class="headerlink" title="7.acwing.20.用两个栈实现队列（剑指offer）"></a>7.acwing.20.用两个栈实现队列（剑指offer）</h2><p>请用栈实现一个队列，支持如下四种操作：</p>
<ul>
<li>push(x) – 将元素x插到队尾；</li>
<li>pop() – 将队首的元素弹出，并返回该元素；</li>
<li>peek() – 返回队首元素；</li>
<li>empty() – 返回队列是否为空；</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>你只能使用栈的标准操作：<code>push to top</code>，<code>peek/pop from top</code>, <code>size</code> 和 <code>is empty</code>；</li>
<li>如果你选择的编程语言没有栈的标准库，你可以使用list或者deque等模拟栈的操作；</li>
<li>输入数据保证合法，例如，在队列为空时，不会进行<code>pop</code>或者<code>peek</code>等操作；</li>
</ul>
<p>样例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MyQueue <span class="built_in">queue</span> = <span class="keyword">new</span> MyQueue();</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>.push(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">queue</span>.push(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">queue</span>.peek();  <span class="comment">// returns 1</span></span><br><span class="line"><span class="built_in">queue</span>.pop();   <span class="comment">// returns 1</span></span><br><span class="line"><span class="built_in">queue</span>.empty(); <span class="comment">// returns false</span></span><br></pre></td></tr></table></figure>

<p><strong>算法：</strong>(栈，队列) O(n)<br>这是一道基础题，只要把功能实现对就可以，不需要考虑运行效率。</p>
<p><strong>我们用两个栈来做，一个主栈，用来存储数据；一个辅助栈，用来当缓存</strong>。</p>
<ul>
<li><code>push(x)</code>，我们直接将x插入主栈中即可。</li>
<li><code>pop()</code>，此时我们需要弹出最先进入栈的元素，也就是栈底元素。我们可以先将所有元素从主栈中弹出，压入辅助栈中。则辅助栈的栈顶元素就是我们要弹出的元素，将其弹出即可。然后再将辅助栈中的元素全部弹出，压入主栈中。</li>
<li><code>peek()</code>，可以用和pop()操作类似的方式，得到最先压入栈的元素。</li>
<li><code>empty()</code>，直接判断主栈是否为空即可。<br>时间复杂度分析</li>
<li><code>push()</code>：O(1)；</li>
<li><code>pop()</code>: 每次需要将主栈元素全部弹出，再压入，所以需要 O(n)的时间；</li>
<li><code>peek()</code>：类似于pop()，需要 O(n) 的时间；</li>
<li><code>empty()</code>：O(1)；</li>
</ul>
<p>作者：yxc<br>链接：<a href="https://www.acwing.com/solution/content/725/">https://www.acwing.com/solution/content/725/</a><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1,s2;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyQueue() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s1.push(x);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (s1.size() &gt; <span class="number">1</span>) s2.push(s1.top()),s1.pop();<span class="comment">// 注意这里是逗号</span></span><br><span class="line">        <span class="keyword">int</span> t = s1.top();</span><br><span class="line">        s1.pop();</span><br><span class="line">        <span class="keyword">while</span> (s2.size()) s1.push(s2.top()),s2.pop();</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (s1.size() &gt; <span class="number">1</span>) s2.push(s1.top()),s1.pop();</span><br><span class="line">        <span class="keyword">int</span> t = s1.top();</span><br><span class="line">        <span class="keyword">while</span> (s2.size()) s1.push(s2.top()),s2.pop();</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Acwing：语法基础课系列正式完结！！！"><a href="#Acwing：语法基础课系列正式完结！！！" class="headerlink" title="Acwing：语法基础课系列正式完结！！！"></a>Acwing：语法基础课系列正式完结！！！</h1>]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>竞赛语法</tag>
        <tag>位运算</tag>
        <tag>库函数</tag>
        <tag>栈实现队列</tag>
      </tags>
  </entry>
  <entry>
    <title>C++竞赛语法总结（四）</title>
    <url>/posts/99b255e0.html</url>
    <content><![CDATA[<h4 id="1-acwing768-忽略大小写比较字符串大小"><a href="#1-acwing768-忽略大小写比较字符串大小" class="headerlink" title="1.acwing768.忽略大小写比较字符串大小"></a>1.acwing768.忽略大小写比较字符串大小</h4><p>一般我们用strcmp可比较两个字符串的大小，比较方法为对两个字符串从前往后逐个字符相比较（按ASCII码值大小比较），直到出现不同的字符或遇到’\0’为止。</p>
<span id="more"></span>

<p>如果全部字符都相同，则认为相同；如果出现不相同的字符，则以第一个不相同的字符的比较结果为准。</p>
<p>但在有些时候，我们比较字符串的大小时，希望忽略字母的大小，例如”Hello”和”hello”在忽略字母大小写时是相等的。</p>
<p>请写一个程序，实现对两个字符串进行忽略字母大小写的大小比较。</p>
<p> 输入格式</p>
<p>输入为两行，每行一个字符串，共两个字符串。注意字符串中可能包含空格。</p>
<p>数据保证每个字符串的长度都不超过80。</p>
<p> 输出格式</p>
<p>如果第一个字符串比第二个字符串小，输出一个字符”&lt;”。</p>
<p>如果第一个字符串比第二个字符串大，输出一个字符”&gt;”。</p>
<p>如果两个字符串相等，输出一个字符”=”。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自己写的题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a,b;</span><br><span class="line">    getline(<span class="built_in">cin</span>,a);</span><br><span class="line">    getline(<span class="built_in">cin</span>,b);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">3</span>] = &#123;<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;=&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;a[i] &amp;&amp; b[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = a[i] &lt; <span class="string">&#x27;a&#x27;</span>? a[i] + <span class="number">32</span>:a[i];</span><br><span class="line">        b[i] = b[i] &lt; <span class="string">&#x27;a&#x27;</span>? b[i] + <span class="number">32</span>:b[i];</span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[i]) k = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &gt; b[i]) &#123;k = <span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;k = <span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.size() &gt; b.size()) k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a.size() &lt; b.size()) k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; op[k];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 题解2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a,b;</span><br><span class="line">    getline(<span class="built_in">cin</span>,a);</span><br><span class="line">    getline(<span class="built_in">cin</span>,b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i ++)</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; a[i] &lt;= <span class="string">&#x27;Z&#x27;</span>) a[i] += <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.size(); i ++)</span><br><span class="line">        <span class="keyword">if</span> (b[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; b[i] &lt;= <span class="string">&#x27;Z&#x27;</span>) b[i] += <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    c = <span class="built_in">strcmp</span>(a.c_str(),b.c_str());</span><br><span class="line">    <span class="keyword">if</span>(c &lt; <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&lt;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;=&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(c &gt; <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">此题如果使用<span class="built_in">string</span>类型，也想用<span class="built_in">strcmp</span>比较大小，可以使用<span class="built_in">string</span>的成员函数c_str()把<span class="built_in">string</span>转换为<span class="keyword">const</span> <span class="keyword">char</span> *，然后比较。</span><br><span class="line">作者：paprika</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/12573/</span></span><br><span class="line">来源：AcWing</span><br></pre></td></tr></table></figure>

<h2 id="2-acwing-766-去掉多余的空格"><a href="#2-acwing-766-去掉多余的空格" class="headerlink" title="2.acwing.766.去掉多余的空格"></a>2.acwing.766.去掉多余的空格</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有想到好的思路</span></span><br><span class="line"><span class="comment">// y总简单题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s) <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">&#x27; &#x27;</span>;<span class="comment">// cin遇到空格停止</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// y总题解2、3，自己过滤多余的空格</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    getline(<span class="built_in">cin</span>,s);</span><br><span class="line">    <span class="built_in">string</span> r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>) r += s[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            r += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">int</span> j = i;<span class="comment">// 这三行代码是常用的算法，第一类双指针算法</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; s.size() &amp;&amp; s[j] == <span class="string">&#x27; &#x27;</span>) j++;</span><br><span class="line">            i = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将26,27,28,29改成 if(!i || s[i-1] != &#x27; &#x27;) r += s[i];也可以</span></span><br><span class="line"><span class="comment">// 加上!i避免i=0时索引越界</span></span><br><span class="line"><span class="comment">// 局部性判断方法</span></span><br></pre></td></tr></table></figure>

<h2 id="3-string"><a href="#3-string" class="headerlink" title="3.string!!!"></a>3.string!!!</h2><p>标准库类型string，非常强大，大部分场合可用string而不用char数组。</p>
<p>一般情况下，不超时的话用string，如果输入量比较大则使用字符串。</p>
<p><img src="/posts/99b255e0/image-20210116183048237.png" alt="image-20210116183048237"></p>
<p>string里有c_str()函数用于string转char数组。</p>
<p>使用方法为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,str.c_str());</span><br></pre></td></tr></table></figure>

<p>string.c_str()方法可以将string转换成char类型！！！（string为变量名）</p>
<p>puts() 也是一样，<code>puts(s.c_str());</code></p>
<p><strong>注意：不能使用scanf读取string类型变量！！！</strong></p>
<p><img src="/posts/99b255e0/image-20210117092853170.png" alt="image-20210117092853170"></p>
<p>empty函数：测试string是否为空（即长度是否为0），如果为空，输出1，否则输出0.这里的1,0代表真假。</p>
<p>size函数：求string长度，不像strlen函数会进行循环，它的时间复杂度是O(1)，很快。</p>
<p><img src="/posts/99b255e0/image-20210117093630721.png" alt="image-20210117093630721"></p>
<p><code>s4 = s1 + “asdafd” + ‘s’;// 这种也是支持的</code></p>
<p><img src="/posts/99b255e0/image-20210117094315743.png" alt="image-20210117094315743"></p>
<p><strong>注意：必须确保每个“+”的两侧至少有一个是string！！！</strong></p>
<p>上面s6正确是因为左边s1 + “,”已经变成了一个string，所以可以通过编译。</p>
<p>下面展示遍历string：</p>
<p><img src="/posts/99b255e0/image-20210117094823940.png" alt="image-20210117094823940"></p>
<p>注意：上面这种遍历相当于是把s中的每个字符复制给c，并不会修改原s中的字符！！但是下面加上了&amp;就可以进行修改，此时c完全等价于s中的字符，而且下面的效率更高一点！</p>
<h2 id="4-acwing770-单词替换"><a href="#4-acwing770-单词替换" class="headerlink" title="4.acwing770.单词替换"></a>4.acwing770.单词替换</h2><p> 输入格式</p>
<p>输入共3行。</p>
<p>第1行是包含多个单词的字符串 s;</p>
<p>第2行是待替换的单词a(长度不超过100);</p>
<p>第3行是a将被替换的单词b(长度不超过100)。</p>
<p>共一行，输出将s中所有单词a替换成b之后的字符串。</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">You want someone to help you</span><br><span class="line">You</span><br><span class="line">I</span><br></pre></td></tr></table></figure>

<p> 输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I want someone to help you</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1，y总解法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s,a,b;</span><br><span class="line">    getline(<span class="built_in">cin</span>,s);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="function"><span class="built_in">stringstream</span> <span class="title">ssin</span><span class="params">(s)</span></span>;<span class="comment">// ssin从string流中读取string，类似cin</span></span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">while</span> （(ssin &gt;&gt; str)&#123;</span><br><span class="line">     	<span class="keyword">if</span>(str == a) &#123;<span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// solution 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> a[<span class="number">10000</span>],b,d;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a[c])</span><br><span class="line">    &#123;</span><br><span class="line">        c++;</span><br><span class="line">        <span class="keyword">char</span> x=getchar();</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;b&gt;&gt;d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==b)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;d&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：SLL</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/12105/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h3 id="sstream讲解："><a href="#sstream讲解：" class="headerlink" title="sstream讲解："></a>sstream讲解：</h3><p>ssin用于从string字符串中提取出需要的信息，同样地有sscanf()函数。</p>
<p>大部分情况下还是用ssin，很少用到sscanf。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    getline(<span class="built_in">cin</span>,s);</span><br><span class="line">    <span class="function"><span class="built_in">stringstream</span> <span class="title">ssin</span><span class="params">(s)</span></span>;<span class="comment">// 把strnig初始化成string流</span></span><br><span class="line">    <span class="comment">// 用法类似cin</span></span><br><span class="line">    <span class="keyword">int</span> a,b;<span class="built_in">string</span> str;<span class="keyword">double</span> c;</span><br><span class="line">    ssin &gt;&gt; a &gt;&gt; str &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span> &lt;&lt;c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"># <span class="number">12</span> llx <span class="number">23</span> <span class="number">23.34</span>(输入)</span><br><span class="line"># (输出)</span><br><span class="line"><span class="number">12</span></span><br><span class="line">llx</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">23.34</span></span><br><span class="line"><span class="comment">// char[]字符串的类似用法    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">1000</span>];</span><br><span class="line">    fgets(s,<span class="number">1000</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">    <span class="built_in">sscanf</span>(s,<span class="string">&quot;%d%s%d%lf&quot;</span>,&amp;a,str,&amp;b,&amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%s\n%d\n%lf\n&quot;</span>,a,str,b,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-acwing-771-字符串中最长的连续出现的字符"><a href="#5-acwing-771-字符串中最长的连续出现的字符" class="headerlink" title="5.acwing.771.字符串中最长的连续出现的字符"></a>5.acwing.771.字符串中最长的连续出现的字符</h2><p>又不会了，字符串很多题都没有思路。</p>
<p>这题用到第一类双指针算法，前面已经提过！</p>
<p>求一个字符串中最长的连续出现的字符，输出该字符及其出现次数，字符串中无空白字符（空格、回车和tab），如果这样的字符不止一个，则输出第一个。</p>
<p>输入格式</p>
<p>第一行输入整数N，表示测试数据的组数。</p>
<p>每组数据占一行，包含一个不含空白字符的字符串，字符串长度不超过200。</p>
<p>输出格式</p>
<p>共一行，输出最长的连续出现的字符及其出现次数，中间用空格隔开。</p>
<p> 输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">aaaaabbbbbcccccccdddddddddd</span><br><span class="line">abcdefghigk</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d 10</span><br><span class="line">a 1</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">    <span class="keyword">while</span> (num--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;<span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;<span class="comment">// 第一类双指针算法</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt;s.size() &amp;&amp; s[i] == s[j]) j++;</span><br><span class="line">            <span class="comment">// 此时j是和s[i]不相等的第一个字符的下标</span></span><br><span class="line">            <span class="keyword">if</span> (j - i &gt; cnt) &#123;cnt = j-i;c = s[i];&#125;</span><br><span class="line">            i = j - <span class="number">1</span>;<span class="comment">// 特别注意是i-1，因为循环中有i++</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-acwing-774-最长单词"><a href="#6-acwing-774-最长单词" class="headerlink" title="6.acwing.774.最长单词"></a>6.acwing.774.最长单词</h2><p>一个以’.’结尾的简单英文句子，单词之间用空格分隔，没有缩写形式和其它特殊形式，求句子中的最长单词。</p>
<p>输入格式</p>
<p>输入这个简单英文句子，长度不超过500。</p>
<p> 输出格式</p>
<p>该句子中最长的单词。如果多于一个，则输出第一个。</p>
<p> 输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I am a student of Peking University.</span><br><span class="line">University</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1，自己的解法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> s[<span class="number">500</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>,p = <span class="number">0</span>,len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s[i]) i++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = s[j].size();</span><br><span class="line">        <span class="keyword">if</span> (j == i - <span class="number">1</span>) t -= <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span> (len &lt; t) &#123;len = t;p = j;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == i - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; s[p].size() - <span class="number">1</span>;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; s[p][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; s[p];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// solution 2，y总解法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res,str;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.back() == <span class="string">&#x27;.&#x27;</span>) str.pop_back();</span><br><span class="line">        <span class="comment">// str.back()函数返回string的最后一个字符</span></span><br><span class="line">        <span class="comment">// str.pop_back()去掉string的最后一个字符</span></span><br><span class="line">        <span class="keyword">if</span> (str.size() &gt; res.size()) res = str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// solution 3，双指针算法，字符串中的常用算法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    getline(<span class="built_in">cin</span>, a);</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>, tag_i, tag_j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; a.size() &amp;&amp; a[j] != <span class="string">&#x27; &#x27;</span>) j ++;</span><br><span class="line">        <span class="keyword">if</span>(max &lt; j - i)</span><br><span class="line">        &#123;</span><br><span class="line">            max = j - i + <span class="number">1</span>;</span><br><span class="line">            tag_i = i;</span><br><span class="line">            tag_j = j;</span><br><span class="line">        &#125;</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = tag_i; i &lt;= tag_j &amp;&amp; a[i] != <span class="string">&#x27;.&#x27;</span>; i ++) <span class="built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line">	<span class="comment">// 这里的max并不是单词最大长度，结果多输出了一个空格</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：Logic</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/11742/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h2 id="7-acwing-775-倒排单词"><a href="#7-acwing-775-倒排单词" class="headerlink" title="7.acwing.775.倒排单词"></a>7.acwing.775.倒排单词</h2><p>编写程序，读入一行英文(只包含字母和空格，单词间以单个空格分隔)，将所有单词的顺序倒排并输出，依然以单个空格分隔。</p>
<p>输入格式</p>
<p>输入为一个字符串（字符串长度至多为100）。</p>
<p>输出格式输出为按要求排序后的字符串。</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I am a student</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">student a am I</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str, res;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str)</span><br><span class="line">        res = str + <span class="string">&#x27; &#x27;</span> + res;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// solution 2，y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str[n]) n ++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i --) <span class="built_in">cout</span> &lt;&lt; str[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-acwing-776-字符串移位包含问题"><a href="#8-acwing-776-字符串移位包含问题" class="headerlink" title="8.acwing.776.字符串移位包含问题"></a>8.acwing.776.字符串移位包含问题</h2><p>对于一个字符串来说，定义一次循环移位操作为：将字符串的第一个字符移动到末尾形成新的字符串。</p>
<p>给定两个字符串s1和s2，要求判定其中一个字符串是否是另一字符串通过若干次循环移位后的新字符串的子串。</p>
<p>例如CDAA是由AABCD两次移位后产生的新串BCDAA的子串，而ABCD与ACBD则不能通过多次移位来得到其中一个字符串是新串的子串。</p>
<p> 输入格式</p>
<p>共一行，包含两个字符串，中间由单个空格隔开。</p>
<p>字符串只包含字母和数字，长度不超过30。</p>
<p> 输出格式</p>
<p>如果一个字符串是另一字符串通过若干次循环移位产生的新串的子串，则输出true，否则输出false。</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AABCD CDAA</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>

<p>难度：困难，不知道怎么判断子串。（y总：本章压轴题，最难的问题之一）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a,b;<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span> (a.size() &lt; b.size()) swap(a,b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; a.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a = a.substr(<span class="number">1</span>) + a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j + b.size() &lt;= a.size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>;k &lt; b.size();k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[j+k] != b[k])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == b.size())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-acwing-777-字符串乘方"><a href="#9-acwing-777-字符串乘方" class="headerlink" title="9.acwing.777.字符串乘方"></a>9.acwing.777.字符串乘方</h2><p>又不会了！困难题。</p>
<p>给定两个字符串a和b,我们定义a*b为他们的连接。</p>
<p>例如，如果a=”abc” 而b=”def”， 则a*b=”abcdef”。 </p>
<p>如果我们将连接考虑成乘法，一个非负整数的乘方将用一种通常的方式定义：</p>
<p>a$^0$=””(空字符串)，a$^{(n+1)}$=a∗(a$^n$)。</p>
<p>输入格式</p>
<p>输入包含多组测试样例，每组测试样例占一行。</p>
<p>每组样例包含一个字符串s，s的长度不超过100。</p>
<p>最后的测试样例后面将是一个点号作为一行。</p>
<p>输出格式</p>
<p>对于每一个s，你需要输出最大的n，使得存在一个字符串a，让s=ans=an。</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abcd</span><br><span class="line">aaaa</span><br><span class="line">ababab</span><br><span class="line">.</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">4</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; s,s != <span class="string">&quot;.&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = len; n;n--)<span class="comment">// n从大到小枚举，因为求最大的n值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (len % n == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> m = len / n;</span><br><span class="line">                <span class="built_in">string</span> str = s.substr(<span class="number">0</span>,m);</span><br><span class="line">                <span class="built_in">string</span> res;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) res += str;</span><br><span class="line">                <span class="keyword">if</span> (res == s)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-acwing-778-字符串最大跨距"><a href="#10-acwing-778-字符串最大跨距" class="headerlink" title="10.acwing.778.字符串最大跨距"></a>10.acwing.778.字符串最大跨距</h2><p>难度确实不小，又白给了:slightly_smiling_face:大概思路还是对的，具体代码细节不会了:cold_sweat:</p>
<p>有三个字符串S,S1,S2，其中，S长度不超过300，S1和S2的长度不超过10。</p>
<p>现在，我们想要检测S1和S2是否同时在S中出现，且S1位于S2的左边，并在S中互不交叉（即，S1的右边界点在S2的左边界点的左侧）。</p>
<p>计算满足上述条件的最大跨距（即，最大间隔距离：最右边的S2的起始点与最左边的S1的终止点之间的字符数目）。</p>
<p>如果没有满足条件的S1，S2存在，则输出-1。</p>
<p>例如，S = “abcd123ab888efghij45ef67kl”, S1=”ab”, S2=”ef”，其中，S1在S中出现了2次，S2也在S中出现了2次，最大跨距为：18。</p>
<p>输入格式</p>
<p>输入共一行，包含三个字符串S,S1,S2，字符串之间用逗号隔开。</p>
<p>数据保证三个字符串中不含空格和逗号。</p>
<p>输出格式</p>
<p>输出一个整数，表示最大跨距。</p>
<p>如果没有满足条件的S1和S2存在，则输出-1.</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abcd123ab888efghij45ef67kl,ab,ef</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">18</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s,s1,s2;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; c,c != <span class="string">&#x27;,&#x27;</span>) s += c;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; c,c != <span class="string">&#x27;,&#x27;</span>) s1 += c;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; c) s2 += c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s.size() &lt;= s1.size() || s.size() &lt;= s2.size()) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l + s1.size() &lt;= s.size())<span class="comment">// 这里用到的结构与上一题类似</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; s1.size())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s1[k] != s[l+k]) <span class="keyword">break</span>;</span><br><span class="line">                k ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == s1.size()) <span class="keyword">break</span>;</span><br><span class="line">            l ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> r = s.size() - s2.size();</span><br><span class="line">        <span class="keyword">while</span> (r &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; s2.size())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s2[k] != s[r+k]) <span class="keyword">break</span>;</span><br><span class="line">                k ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == s2.size()) <span class="keyword">break</span>;</span><br><span class="line">            r --;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        l += s1.size() <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,r - l <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>str.find()简介\</em></strong></p>
<p>查找第一次出现的目标字符串：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">&quot;de&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = s1.find(s2) ;   <span class="comment">//在S1中查找子串S2</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：如果查找成功则输出查找到的第一个位置，否则返回-1. </p>
<p><strong><em>查找从指定位置开始的第一次出现的目标字符串：</em></strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;csdtio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">&quot;de&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = s1.find(s2, <span class="number">2</span>) ;   <span class="comment">//从S1的第二个字符开始查找子串S2</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 2，使用了STL中的find函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> S,S1,S2;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a!=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>) S+=a;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>) S1+=a;</span><br><span class="line">            <span class="keyword">else</span> S2+=a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s,s1,s2;</span><br><span class="line">    s1=S.find(S1);</span><br><span class="line">    s2=S.rfind(S2);</span><br><span class="line">    <span class="keyword">if</span>(s1!=<span class="number">-1</span>&amp;&amp;s2!=<span class="number">-1</span>&amp;&amp;(s1+S1.length()<span class="number">-1</span>)&lt;s2)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s2-s1-S1.length()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;-1&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：Sir.Guo</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/7213/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>竞赛语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab快速入门笔记（配套代码）</title>
    <url>/posts/fcc74e6c.html</url>
    <content><![CDATA[<blockquote>
<p>本文参考自B站西电通院科协glanny的1小时matlab速成视频！</p>
</blockquote>
<p><a href="https://www.bilibili.com/video/BV1hE411Q7T4?from=search&seid=16973427387965814013">视频链接</a></p>
<span id="more"></span>

<h2 id="第1部分：变量定义和基本运算"><a href="#第1部分：变量定义和基本运算" class="headerlink" title="第1部分：变量定义和基本运算"></a>第1部分：变量定义和基本运算</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">% 建议有C语言或其他编程基础，了解线性代数和矩阵相关知识</span></span><br><span class="line"><span class="comment">% https://ww2.mathworks.cn/help/matlab/</span></span><br><span class="line"><span class="comment">% 加*为了解内容</span></span><br><span class="line"><span class="comment">% 生成矩阵</span></span><br><span class="line">    <span class="comment">% 直接法</span></span><br><span class="line">        a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line">    <span class="comment">% 冒号一维矩阵 a = 开始：步长：结束，步长为1可省略</span></span><br><span class="line">        b = <span class="number">1</span>:<span class="number">1</span>:<span class="number">10</span>;  <span class="comment">% 1,2,...10</span></span><br><span class="line">        b = <span class="number">1</span>:<span class="number">10</span>;  <span class="comment">%与上一个等价</span></span><br><span class="line">    <span class="comment">% 函数生成</span></span><br><span class="line">        <span class="comment">% linspace(开始，结束，元素个数)，等差生成指定元素数的一维矩阵，省略个数则生成100个</span></span><br><span class="line">            c = <span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">10</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="comment">% 特殊矩阵</span></span><br><span class="line">            e = <span class="built_in">eye</span>(<span class="number">4</span>);  <span class="comment">% eye(维数)单位阵</span></span><br><span class="line">            z = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">4</span>);  <span class="comment">% zeros(维数)全零阵</span></span><br><span class="line">            o = <span class="built_in">ones</span>(<span class="number">4</span>,<span class="number">1</span>);  <span class="comment">% ones(维数)全1阵</span></span><br><span class="line">            r = <span class="built_in">rand</span>(<span class="number">4</span>);  <span class="comment">% rand(维数)0~1分布随机阵</span></span><br><span class="line">            rn = <span class="built_in">randn</span>(<span class="number">4</span>);  <span class="comment">% randn(维数)0均值Gaussian分布随机阵</span></span><br><span class="line">                      </span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">% 矩阵运算</span></span><br><span class="line">    diag_a = <span class="built_in">diag</span>(a,<span class="number">1</span>);  <span class="comment">% diag(行向量，主对角线上方第k条斜线)用行向量生成对角阵</span></span><br><span class="line">    tril_a = <span class="built_in">tril</span>(a,<span class="number">1</span>);  <span class="comment">% tril(矩阵，主对角线上方第k条斜线)生成矩阵的下三角阵，triu上三角阵</span></span><br><span class="line">    <span class="comment">% 加、减、乘、乘方</span></span><br><span class="line">        a*a</span><br><span class="line">    <span class="comment">% 点运算</span></span><br><span class="line">        <span class="comment">% a.*b , a./b , a.\b , a.^b  对应元素的*,/,\,^运算</span></span><br><span class="line">        a.*a</span><br><span class="line">    <span class="comment">% 逆矩阵</span></span><br><span class="line">        pinv(a)  <span class="comment">% 伪逆矩阵，当a不是方阵，求广义逆矩阵；当a是可逆方阵，结果与逆矩阵相同</span></span><br><span class="line">    <span class="comment">% 特征值，特征向量</span></span><br><span class="line">        [v,D] = eig(a);  <span class="comment">% 输出v为特征向量，D为特征值对角阵</span></span><br><span class="line">    <span class="comment">% *行列式</span></span><br><span class="line">        det(a)</span><br><span class="line">    <span class="comment">% *秩</span></span><br><span class="line">        rank(a)</span><br><span class="line">    <span class="comment">% *伴随</span></span><br><span class="line">        <span class="built_in">compan</span>(b)</span><br><span class="line">        </span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">% 矩阵的修改</span></span><br><span class="line">    <span class="comment">%部分替换</span></span><br><span class="line">        chg_a = a;</span><br><span class="line">        chg_a(<span class="number">2</span>,<span class="number">3</span>) = <span class="number">4</span>;  <span class="comment">% (行，列)元素替换</span></span><br><span class="line">        chg_a(<span class="number">1</span>,:) = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>];  <span class="comment">% (行,:)替换行，为[]删除该行</span></span><br><span class="line">        chg_a(:,<span class="number">1</span>) = [];  <span class="comment">% (:,列)替换列，为[]删除该列</span></span><br><span class="line">    <span class="comment">% 转置</span></span><br><span class="line">        T_a = a&#x27;;</span><br><span class="line">    <span class="comment">% 指定维数拼接</span></span><br><span class="line">        c1_a = <span class="built_in">cat</span>(<span class="number">1</span>,a,a);  <span class="comment">% 垂直拼接</span></span><br><span class="line">        c2_a = <span class="built_in">cat</span>(<span class="number">2</span>,a,a);  <span class="comment">% 水平拼接</span></span><br><span class="line">    <span class="comment">% *变维</span></span><br><span class="line">        rs_a = <span class="built_in">reshape</span>(a,<span class="number">1</span>,<span class="number">9</span>);  <span class="comment">% 元素个数不变，矩阵变为m*n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">% 信息获取</span></span><br><span class="line">    <span class="comment">% 矩阵的行列数</span></span><br><span class="line">        [row_a, col_a] = <span class="built_in">size</span>(a);  <span class="comment">% [行数，列数]</span></span><br><span class="line">    <span class="comment">% 行列中最大的</span></span><br><span class="line">        len_a = <span class="built_in">length</span>(a);</span><br><span class="line">        </span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">% 多维数组</span></span><br><span class="line">    <span class="comment">% 创建</span></span><br><span class="line">        <span class="comment">% 直接法</span></span><br><span class="line">            mul_1(:,:,<span class="number">1</span>) = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">            mul_1(:,:,<span class="number">2</span>) = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">        <span class="comment">% *扩展法</span></span><br><span class="line">            mul_2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">            mul_2(:,:,<span class="number">2</span>) = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];  <span class="comment">% 若不赋值第一页，第一页全为0</span></span><br><span class="line">        <span class="comment">% cat法</span></span><br><span class="line">            mul_31 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">            mul_32 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">            mul_3 = <span class="built_in">cat</span>(<span class="number">3</span>,mul_31,mul_32);  <span class="comment">% 把a1a2按照“3”维连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">% *字符串</span></span><br><span class="line">    <span class="comment">% 创建</span></span><br><span class="line">        str0 = <span class="string">&#x27;hello world&#x27;</span>;  <span class="comment">% 单引号引起</span></span><br><span class="line">        str1 = <span class="string">&#x27;I&#x27;&#x27;m a student&#x27;</span>;  <span class="comment">% 字符串中单引号写两遍</span></span><br><span class="line">        str3 = [<span class="string">&#x27;I&#x27;&#x27;m&#x27;</span> <span class="string">&#x27;a&#x27;</span> <span class="string">&#x27;student&#x27;</span>];  <span class="comment">% 方括号链接多字符串</span></span><br><span class="line">        str4 = strcat(str0, str1);  <span class="comment">% strcat连接字符串函数</span></span><br><span class="line">        str5 = strvcat(str0, str1);  <span class="comment">% strvcat连接产生多行字符串</span></span><br><span class="line">        str6 = double(str0);  <span class="comment">% 取str0的ASCII值，也可用abs函数</span></span><br><span class="line">        str7 = char(str6);  <span class="comment">% 把ASCII转为字符串</span></span><br><span class="line">    <span class="comment">% 操作</span></span><br><span class="line">        <span class="comment">% 比较</span></span><br><span class="line">            strcmp(str0, str1);  <span class="comment">% 相等为1，不等为0</span></span><br><span class="line">            strncmp(str0, str1, <span class="number">3</span>);  <span class="comment">% 比较前3个是否相等(n)</span></span><br><span class="line">            strcmpi(str0, str1);  <span class="comment">% 忽略大小写比较(i)</span></span><br><span class="line">            strncmpi(str0, str1, <span class="number">3</span>);  <span class="comment">% 忽略大小写比较前3个是否相等</span></span><br><span class="line">        <span class="comment">% 查找替换</span></span><br><span class="line">            strfind(str0, str1);  <span class="comment">% 在str0找到str1的位置</span></span><br><span class="line">            strmatch(str1, str0);  <span class="comment">% 在str0字符串数组中找到str1开头的行数</span></span><br><span class="line">            strtok(str0);  <span class="comment">% 截取str0第一个分隔符（空格，tab，回车）前的部分</span></span><br><span class="line">            strrep(str0, str1, str2);  <span class="comment">% 在str0中用str2替换str1</span></span><br><span class="line">        <span class="comment">% 其他</span></span><br><span class="line">            upper(str0);  <span class="comment">% 转大写，lower转小写</span></span><br><span class="line">            strjust(str0, <span class="string">&#x27;right&#x27;</span>);  <span class="comment">% 将str0右对齐，left左对齐，center中间对齐</span></span><br><span class="line">            strtrim(str0);  <span class="comment">% 删除str0开头结尾空格</span></span><br><span class="line">            eval(str0);  <span class="comment">% 将str0作为代码执行</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">%转换</span></span><br><span class="line">    <span class="comment">% ___2___  --&gt;  如num2str，将数字转字符串； dec2hex，将十进制转十六进制</span></span><br><span class="line">    str_b = num2str(b);</span><br><span class="line">    <span class="comment">% abs，double取ASCII码；char把ASCII转字符串</span></span><br><span class="line">    abs_str = <span class="built_in">abs</span>(<span class="string">&#x27;aAaA&#x27;</span>);  </span><br></pre></td></tr></table></figure>

<h2 id="第2部分：程序结构"><a href="#第2部分：程序结构" class="headerlink" title="第2部分：程序结构"></a>第2部分：程序结构</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%%</span></span><br><span class="line">a = <span class="number">5</span>;</span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>]; y =[<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">%选择结构</span></span><br><span class="line">    <span class="comment">%if-elseif-else-end</span></span><br><span class="line">        <span class="keyword">if</span> a&gt;<span class="number">0</span></span><br><span class="line">            <span class="built_in">disp</span>(x);</span><br><span class="line">        <span class="keyword">elseif</span> a==<span class="number">0</span></span><br><span class="line">            <span class="built_in">disp</span>(a);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">disp</span>(a<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">%switch-case-otherwise-end</span></span><br><span class="line">        <span class="keyword">switch</span> a</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span></span><br><span class="line">                <span class="built_in">disp</span>(a);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span></span><br><span class="line">                <span class="built_in">disp</span>(a+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">otherwise</span></span><br><span class="line">                <span class="built_in">disp</span>(<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">%try-catch</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">            z = x*y;</span><br><span class="line">        <span class="keyword">catch</span></span><br><span class="line">            z = x.*y;  <span class="comment">% 若try出错，则执行</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">disp</span>(z);</span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">% 循环结构</span></span><br><span class="line">    <span class="comment">% for 循环变量=初值:步长:终值 - end</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">0</span>:<span class="number">1</span>:<span class="number">10</span>  <span class="comment">% 步长为负，则初值大于终值</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="built_in">i</span>);  <span class="comment">% 循环体内不可对循环变量做修改</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% while-end</span></span><br><span class="line">    <span class="keyword">while</span> a&gt;<span class="number">2</span></span><br><span class="line">        <span class="built_in">disp</span>(a);</span><br><span class="line">        a = a<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">%程序控制</span></span><br><span class="line">    <span class="comment">%continue 跳过当次循环剩下语句，进入下一循环</span></span><br><span class="line">    <span class="comment">%break 跳出当前循环</span></span><br><span class="line">    <span class="comment">%return 跳出程序并返回</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">%m文件</span></span><br><span class="line">    <span class="comment">%脚本文件：没有输入输出参数，执行后变量结果返回工作空间，可直接运行</span></span><br><span class="line">        <span class="comment">%以下是脚本文件，文件名假设为exp.m</span></span><br><span class="line">        <span class="comment">%**********************************************</span></span><br><span class="line">            clear</span><br><span class="line">            r = <span class="number">5</span>;</span><br><span class="line">            s = <span class="built_in">pi</span>*r*r;</span><br><span class="line">            p = <span class="number">2</span>*<span class="built_in">pi</span>*r;</span><br><span class="line">            <span class="built_in">disp</span>(s)</span><br><span class="line">            <span class="built_in">disp</span>(p)</span><br><span class="line">        <span class="comment">%**********************************************</span></span><br><span class="line">        <span class="comment">%以下是调用</span></span><br><span class="line">        <span class="comment">%**********************************************</span></span><br><span class="line">            <span class="built_in">exp</span></span><br><span class="line">        <span class="comment">%**********************************************</span></span><br><span class="line">    <span class="comment">%函数文件：以function开头，有输入输出，变量为局部变量不返回工作空间，需要调用</span></span><br><span class="line">        <span class="comment">%以下是函数文件</span></span><br><span class="line">        <span class="comment">%**********************************************</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="params">[s, p]</span> = <span class="title">circ</span><span class="params">(r)</span>  % 文件命名应与函数名一致，系统找文件名<span class="title">circ</span>.<span class="title">m</span></span></span><br><span class="line">            <span class="comment">%CIRC 计算圆面积和周长  % 简单说明</span></span><br><span class="line">            <span class="comment">%参数：输入参数r:圆半径；输出参数s:圆面积，p:周长  % 详细说明</span></span><br><span class="line">                s = <span class="built_in">pi</span>*r*r;</span><br><span class="line">                p = <span class="number">2</span>*<span class="built_in">pi</span>*r;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="comment">%**********************************************</span></span><br><span class="line">        <span class="comment">%以下是调用</span></span><br><span class="line">        <span class="comment">%**********************************************</span></span><br><span class="line">            [a, b] = circ(<span class="number">5</span>);  <span class="comment">% 返回为多个参数时，若写a = circ(5)则保留第一个返回值</span></span><br><span class="line">        <span class="comment">%**********************************************</span></span><br><span class="line">        <span class="comment">%*以下是带子函数的函数文件</span></span><br><span class="line">        <span class="comment">%**********************************************</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">key</span><span class="params">(w)</span>  % 主函数放第一个，函数名为<span class="title">key</span></span></span><br><span class="line">            <span class="keyword">if</span> w==<span class="number">0</span></span><br><span class="line">                y = type0(w);  <span class="comment">% 调用子函数type0</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                y = type1(w);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">y0</span> = <span class="title">type0</span><span class="params">(a)</span>  % 子函数，各子函数之间顺序无所谓</span></span><br><span class="line">            y0 = a+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">y1</span> = <span class="title">type1</span><span class="params">(a)</span></span></span><br><span class="line">            y1 = a+<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">%**********************************************</span></span><br><span class="line">        <span class="comment">%*函数输入输出参数可以不定</span></span><br><span class="line">        <span class="comment">%nargin：输入参数个数，nargout：输出参数个数</span></span><br><span class="line">        <span class="comment">%varargin：输入参数内容的元胞数组，varargout：输出参数</span></span><br><span class="line">        <span class="comment">%以下是函数文件</span></span><br><span class="line">        <span class="comment">%**********************************************</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">varargout</span> = <span class="title">idk</span><span class="params">(varargin)</span></span></span><br><span class="line">            x = <span class="built_in">length</span>(varargin);</span><br><span class="line">            varargout&#123;<span class="number">1</span>&#125; = x;</span><br><span class="line">            varargout&#123;<span class="number">2</span>&#125; = x+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">%**********************************************  </span></span><br></pre></td></tr></table></figure>

<h2 id="第3部分：图像绘制"><a href="#第3部分：图像绘制" class="headerlink" title="第3部分：图像绘制"></a>第3部分：图像绘制</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%%</span></span><br><span class="line">x = <span class="number">0</span>:<span class="number">0.1</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">y1 = <span class="built_in">sin</span>(x);</span><br><span class="line">y2 = <span class="built_in">cos</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">% 二维曲线绘制</span></span><br><span class="line">    <span class="comment">% 基本函数</span></span><br><span class="line">        <span class="comment">% plot(y)</span></span><br><span class="line">            <span class="comment">% y为向量</span></span><br><span class="line">                <span class="built_in">plot</span>(y1);  <span class="comment">% 纵坐标为y的值；横坐标自动为元素序号(角标+1)，此处为1~9</span></span><br><span class="line">            <span class="comment">% y为矩阵</span></span><br><span class="line">                <span class="built_in">figure</span>;  <span class="comment">% 开启新绘图窗口，下一次绘图在新窗口</span></span><br><span class="line">                y = [y1&#x27;, y2&#x27;];</span><br><span class="line">                <span class="built_in">plot</span>(y);  <span class="comment">% 当y为矩阵，按每一列画出曲线，颜色自动区分</span></span><br><span class="line">        <span class="comment">% plot(x, y)</span></span><br><span class="line">            <span class="comment">% xy为向量</span></span><br><span class="line">                <span class="built_in">plot</span>(x, y1);  <span class="comment">% 先绘制曲线</span></span><br><span class="line">        <span class="comment">% plot(x1, y1, x2, y2...)</span></span><br><span class="line">            <span class="built_in">plot</span>(x, y1, x, y2);  <span class="comment">% 在同一个窗口同一坐标轴绘制多条曲线</span></span><br><span class="line">    <span class="comment">% 线性图形格式设置</span></span><br><span class="line">        <span class="comment">% 线形颜色数据点</span></span><br><span class="line">            <span class="built_in">plot</span>(x, y1, <span class="string">&#x27;b:o&#x27;</span>);  <span class="comment">% 蓝色 点线 圆圈</span></span><br><span class="line">            <span class="comment">% b蓝 g绿 r红 c青 m紫 y黄 k黑 w白</span></span><br><span class="line">            <span class="comment">% -实线 :点线 --虚线 -.点画线</span></span><br><span class="line">            <span class="comment">% .实点 o圆圈 x叉 +十字 *星号 s方块 d钻石 v下三角 ^上三角 &lt;左三角 &gt;右三角 p五角星 h六角星</span></span><br><span class="line">        <span class="comment">% 坐标轴</span></span><br><span class="line">            <span class="built_in">plot</span>(x, y1);</span><br><span class="line">            axis([<span class="number">-1</span>*<span class="built_in">pi</span>, <span class="number">3</span>*<span class="built_in">pi</span>, <span class="number">-1.5</span>, <span class="number">1.5</span>]);  <span class="comment">% 规定横纵坐标范围</span></span><br><span class="line">    <span class="comment">% 图形修饰</span></span><br><span class="line">        <span class="comment">% 标题标签</span></span><br><span class="line">            title(<span class="string">&#x27;a title&#x27;</span>);  <span class="comment">% 图像标题</span></span><br><span class="line">            xlabel(<span class="string">&#x27;this is x&#x27;</span>);  <span class="comment">% x轴标记，同理还有ylabel，zlabel</span></span><br><span class="line">        <span class="comment">%图例设置</span></span><br><span class="line">            <span class="built_in">legend</span>(<span class="string">&#x27;hahaha&#x27;</span>, <span class="string">&#x27;location&#x27;</span>, <span class="string">&#x27;best&#x27;</span>);  <span class="comment">% str的顺序与绘图顺序一致; &#x27;best&#x27;指图例位置最佳化，还有其他位置</span></span><br><span class="line">        <span class="comment">%图形保持</span></span><br><span class="line">            <span class="built_in">plot</span>(x, y1);</span><br><span class="line">            <span class="built_in">hold</span> on;  <span class="comment">% 在原有窗口y1曲线上增加绘制下一个图形</span></span><br><span class="line">            <span class="built_in">plot</span>(x, y2);  <span class="comment">% y2在同一窗口内被绘制</span></span><br><span class="line">            <span class="built_in">hold</span> off;</span><br><span class="line">        <span class="comment">%分割绘制</span></span><br><span class="line">            subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>);  <span class="comment">% 分割成2x2区域，在第一块区域绘制下一个图形</span></span><br><span class="line">            <span class="built_in">plot</span>(x, y1);  <span class="comment">% y1被绘制在4块区域的第一块</span></span><br><span class="line">            subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>);  <span class="comment">% 分割方法相同，区域改变</span></span><br><span class="line">            <span class="built_in">plot</span>(x, y2);  <span class="comment">% y2在第二块区域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">%*二维特殊图形绘制</span></span><br><span class="line">    <span class="comment">%柱状图</span></span><br><span class="line">        bar(x, y, width, <span class="string">&#x27;参数&#x27;</span>);  <span class="comment">% x横坐标向量，m个元素; y为向量时，每个x画一竖条共m条，矩阵mxn时，每个x画n条;</span></span><br><span class="line">                                   <span class="comment">% width宽度默认0.8，超过1各条会重叠;</span></span><br><span class="line">                                   <span class="comment">% 参数有grouped分组式，stacked堆栈式; 默认grouped</span></span><br><span class="line">                                   <span class="comment">% bar垂直柱状图,barh水平柱状图,bar3三维柱状图,barh3水平三维柱状图(三维多一个参数detached, 且为默认)</span></span><br><span class="line">    <span class="comment">%饼形图</span></span><br><span class="line">        pie(x, explode, <span class="string">&#x27;lable&#x27;</span>);  <span class="comment">% x为向量显示每个元素占总和百分比, 为矩阵显示每个元素占所有总和百分比</span></span><br><span class="line">                                   <span class="comment">% explode向量与x同长度，为1表示该元素被分离突出显示，默认全0不分离</span></span><br><span class="line">                                   <span class="comment">% pie3绘制三维饼图</span></span><br><span class="line">    <span class="comment">%直方图</span></span><br><span class="line">        hist(y, n);  <span class="comment">% y为向量，把横坐标分为n段绘制</span></span><br><span class="line">        hist(y, x);  <span class="comment">% x为向量，用于指定每段中间值, 若取N = hist(y, x), N为每段元素个数</span></span><br><span class="line">    <span class="comment">%离散数据图</span></span><br><span class="line">        stairs(x, y, <span class="string">&#x27;b-o&#x27;</span>);  <span class="comment">% 阶梯图，参数同plot</span></span><br><span class="line">        stem(x, y, <span class="string">&#x27;fill&#x27;</span>);  <span class="comment">% 火柴杆图，参数fill是填充火柴杆，或定义线形</span></span><br><span class="line">        candle(HI, LO, CL, OP);  <span class="comment">% 蜡烛图:HI为最高价格向量,LO为最低价格向量,CL为收盘价格向量,OP为开盘价格向量</span></span><br><span class="line">    <span class="comment">%向量图</span></span><br><span class="line">        compass(u, v, <span class="string">&#x27;b-o&#x27;</span>);  <span class="comment">% 罗盘图横坐标u纵坐标v</span></span><br><span class="line">        compass(Z, <span class="string">&#x27;b-o&#x27;</span>);  <span class="comment">% 罗盘图复向量Z</span></span><br><span class="line">        feather(u, v, <span class="string">&#x27;b-o&#x27;</span>);  <span class="comment">% 羽毛图横坐标u纵坐标v</span></span><br><span class="line">        feather(Z, <span class="string">&#x27;b-o&#x27;</span>);  <span class="comment">% 羽毛图复向量Z</span></span><br><span class="line">        quiver(x, y, u, v);  <span class="comment">% 以(x, y)为起点(u, v)为终点向量场图</span></span><br><span class="line">    <span class="comment">%极坐标图</span></span><br><span class="line">        <span class="comment">% polar(theta, rho, &#x27;b-o&#x27;);  % 极角theta, 半径rho</span></span><br><span class="line">        theta = -<span class="built_in">pi</span>:<span class="number">0.01</span>:<span class="built_in">pi</span>;</span><br><span class="line">        rho = <span class="built_in">sin</span>(theta);</span><br><span class="line">        polar(theta, rho, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    <span class="comment">%对数坐标图</span></span><br><span class="line">        semilogx(x1, y1, <span class="string">&#x27;b-o&#x27;</span>);  <span class="comment">% 把x轴对数刻度表示, semilogy是y轴对数刻度表示，loglog是两个坐标都用对数表示</span></span><br><span class="line">    <span class="comment">%双纵坐标</span></span><br><span class="line">        plotyy(x1, y1, x2, y2, <span class="string">&#x27;fun1&#x27;</span>, <span class="string">&#x27;fun2&#x27;</span>);  <span class="comment">% fun规定了两条条线的绘制方式，如plot,semilogx,semilogy,loglog,stem等</span></span><br><span class="line">    <span class="comment">%函数绘图</span></span><br><span class="line">        f = <span class="string">&#x27;sin(2*x)&#x27;</span>;</span><br><span class="line">        ezplot(f, [<span class="number">0</span>, <span class="number">2</span>*<span class="built_in">pi</span>]);  <span class="comment">% 绘制f并规定横坐标范围，也有[xmin, xmax, ymin, ymax]</span></span><br><span class="line">        x = <span class="string">&#x27;2*cos(t)&#x27;</span>;</span><br><span class="line">        y = <span class="string">&#x27;4*sin(t)&#x27;</span>;</span><br><span class="line">        ezplot(x, y);  <span class="comment">% 绘制x(t),y(t)在[0, 2*pi]图像, 也可以在最后用[tmin, tmax]规定t的范围</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">%三维曲线曲面绘制</span></span><br><span class="line">    <span class="comment">%三维曲线</span></span><br><span class="line">        x = <span class="number">0</span>:<span class="number">0.1</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">        y = <span class="built_in">sin</span>(x); z = <span class="built_in">cos</span>(x);</span><br><span class="line">        <span class="built_in">plot3</span>(x, y, z, <span class="string">&#x27;b-*&#x27;</span>);</span><br><span class="line">    <span class="comment">%三维曲面</span></span><br><span class="line">        <span class="comment">%三维网格</span></span><br><span class="line">            x = <span class="number">-5</span>:<span class="number">0.1</span>:<span class="number">5</span>;  <span class="comment">% 规定了x轴采样点，也规定了x轴范围</span></span><br><span class="line">            y = <span class="number">-4</span>:<span class="number">0.1</span>:<span class="number">4</span>;  <span class="comment">% 规定了y轴采样点，也规定了y轴范围</span></span><br><span class="line">            [X, Y] = <span class="built_in">meshgrid</span>(x, y);  <span class="comment">% 得到了xoy面网格点</span></span><br><span class="line">            Z = X.^<span class="number">2</span>+Y.^<span class="number">2</span>;</span><br><span class="line">            mesh(X, Y, Z)  <span class="comment">% XY是meshgrid得到的网格点，Z是网格顶点，c是用色矩阵可省略</span></span><br><span class="line">        <span class="comment">%三维表面图</span></span><br><span class="line">            x = <span class="number">-5</span>:<span class="number">0.1</span>:<span class="number">5</span>;  </span><br><span class="line">            y = <span class="number">-4</span>:<span class="number">0.1</span>:<span class="number">4</span>;</span><br><span class="line">            [X, Y] = <span class="built_in">meshgrid</span>(x, y);</span><br><span class="line">            Z = X.^<span class="number">2</span>+Y.^<span class="number">2</span>;  <span class="comment">% 以上部分同上</span></span><br><span class="line">            surf(X, Y, Z)  <span class="comment">% 与上一个类似</span></span><br></pre></td></tr></table></figure>

<h2 id="第4部分：多项式"><a href="#第4部分：多项式" class="headerlink" title="第4部分：多项式"></a>第4部分：多项式</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">%多项式</span></span><br><span class="line">    <span class="comment">%创建</span></span><br><span class="line">        p = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];  <span class="comment">% 系数向量，按x降幂排列，最右边是常数</span></span><br><span class="line">        f1 = poly2str(p, <span class="string">&#x27;x&#x27;</span>);  <span class="comment">% 生成好看的字符串 f1 = x^3 + 2 x^2 + 3 x + 4，不被认可的运算式</span></span><br><span class="line">        f2 = poly2sym(p);  <span class="comment">% 生成可用的符号函数 f2 = x^3 + 2*x^2 + 3*x + 4</span></span><br><span class="line">    <span class="comment">%求值</span></span><br><span class="line">        x = <span class="number">4</span>;</span><br><span class="line">        y1 = polyval(p, x);  <span class="comment">% 代入求值；若x1为矩阵，则对每个值单独求值</span></span><br><span class="line">    <span class="comment">%求根</span></span><br><span class="line">        r = roots(p); <span class="comment">% p同上，由系数求根，结果为根植矩阵</span></span><br><span class="line">        p0 = poly(r);  <span class="comment">% 由根求系数，结果为系数矩阵</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">%数据插值</span></span><br><span class="line">    <span class="comment">%一维插值</span></span><br><span class="line">        <span class="comment">%yi = interp1(X, Y, xi, &#x27;method&#x27;)</span></span><br><span class="line">        X = [<span class="number">-3</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>];</span><br><span class="line">        Y = [<span class="number">9</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">9</span>];  <span class="comment">% XY为已知点横纵坐标向量</span></span><br><span class="line">        y2 = interp1(X, Y, <span class="number">2</span>);  <span class="comment">% 差值预估在x=2的y的值，x不能超过已知范围(此处x&lt;3)</span></span><br><span class="line">        y2m = interp1(X, Y, <span class="number">2</span>, <span class="string">&#x27;spline&#x27;</span>);  <span class="comment">% 用spline方法(三次样条)差值预估在x=2的y的值</span></span><br><span class="line">    <span class="comment">%二维插值</span></span><br><span class="line">        <span class="comment">%zi = interp1(X, Y, Z, xi, yi, &#x27;method&#x27;)</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">%%</span></span><br><span class="line">X = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>];</span><br><span class="line">A = [<span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>; <span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>; <span class="number">8</span>, <span class="number">4</span> ,<span class="number">6</span>];</span><br><span class="line">B = [<span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>; <span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>; <span class="number">8</span>, <span class="number">4</span> ,<span class="number">6</span>];</span><br><span class="line"><span class="comment">%数据统计</span></span><br><span class="line">    <span class="comment">%矩阵最大最小值</span></span><br><span class="line">        y = <span class="built_in">max</span>(X);  <span class="comment">% 求矩阵X的最大值，min最小值</span></span><br><span class="line">        [y, k] = <span class="built_in">max</span>(X);  <span class="comment">% 求最大值，k为该值的角标</span></span><br><span class="line">        [y, k] = <span class="built_in">max</span>(A, [], <span class="number">2</span>);  <span class="comment">% A是矩阵，&#x27;2&#x27;时返回y每一行最大元素构成的列向量，k元素所在列；&#x27;1&#x27;时与上述相同</span></span><br><span class="line">    <span class="comment">%均值和中值</span></span><br><span class="line">        y = <span class="built_in">mean</span>(X);  <span class="comment">% 均值</span></span><br><span class="line">        y = median(X);  <span class="comment">% 中值</span></span><br><span class="line">        y = <span class="built_in">mean</span>(A, <span class="number">2</span>);  <span class="comment">% &#x27;2&#x27;时返回y每一行均值构成的列向量；&#x27;1&#x27;时与上述相同</span></span><br><span class="line">        y = median(A, <span class="number">2</span>);  <span class="comment">% &#x27;2&#x27;时返回y每一行中值构成的列向量；&#x27;1&#x27;时与上述相同</span></span><br><span class="line">    <span class="comment">%排序</span></span><br><span class="line">        Y = <span class="built_in">sort</span>(A, <span class="number">1</span>, <span class="string">&#x27;ascend&#x27;</span>);  <span class="comment">% sort(矩阵, dim, &#x27;method&#x27;)dim为1按列排序，2按行排序；ascend升序，descend降序</span></span><br><span class="line">        [Y, I] = <span class="built_in">sort</span>(A, <span class="number">1</span>, <span class="string">&#x27;ascend&#x27;</span>);  <span class="comment">% I保留了元素之前在A的位置</span></span><br><span class="line">    <span class="comment">%求和求积累加累乘</span></span><br><span class="line">        y = sum(X);  <span class="comment">% 求和</span></span><br><span class="line">        y = prod(X);  <span class="comment">% 求积</span></span><br><span class="line">        y = cumsum(X);  <span class="comment">% 累加</span></span><br><span class="line">        y = cumprod(X);  <span class="comment">% 累乘</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">%*数值计算</span></span><br><span class="line">    <span class="comment">%最(极)值</span></span><br><span class="line">        <span class="comment">%多元函数在给定初值附近找最小值点</span></span><br><span class="line">        x = fminsearch(fun, x0);</span><br><span class="line">    <span class="comment">%函数零点</span></span><br><span class="line">        x = fzero(fun, x0);  <span class="comment">% 在给定初值x0附近找零点</span></span><br></pre></td></tr></table></figure>

<h2 id="第5部分：符号函数"><a href="#第5部分：符号函数" class="headerlink" title="第5部分：符号函数"></a>第5部分：符号函数</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">%符号对象创建</span></span><br><span class="line">    <span class="comment">%sym函数</span></span><br><span class="line">        p = <span class="built_in">sin</span>(<span class="built_in">pi</span>/<span class="number">3</span>);</span><br><span class="line">        P = sym(p, <span class="string">&#x27;r&#x27;</span>);  <span class="comment">% 用数值p创建符号常量P；&#x27;d&#x27;浮点数&#x27;f&#x27;有理分式的浮点数&#x27;e&#x27;有理数和误差&#x27;r&#x27;有理数</span></span><br><span class="line">    <span class="comment">%syms函数</span></span><br><span class="line">        syms x;  <span class="comment">% 声明符号变量</span></span><br><span class="line">        f = <span class="number">7</span>*x^<span class="number">2</span> + <span class="number">2</span>*x+<span class="number">9</span>;  <span class="comment">% 创建符号函数</span></span><br><span class="line">    <span class="comment">%符号运算</span></span><br><span class="line">        <span class="comment">% 加减乘除外</span></span><br><span class="line">        <span class="comment">% &#x27;转置 ； ==相等 ； ~=不等</span></span><br><span class="line">        <span class="comment">% sin, cos, tan; asin, acos, atan 三角反三角</span></span><br><span class="line">        <span class="comment">% sinh, cosh, tanh; asinh, acosh, atanh 双曲反双曲</span></span><br><span class="line">        <span class="comment">% conj复数共轭；real复数实部；imag复数虚部；abs复数模；angle复数幅角</span></span><br><span class="line">        <span class="comment">% diag矩阵对角；triu矩阵上三角；tril矩阵下三角；inv逆矩阵；det行列式；rank秩；poly特征多项式；</span></span><br><span class="line">        <span class="comment">% |----expm矩阵指数函数；eig矩阵特征值和特征向量；svd奇异值分解；</span></span><br><span class="line">    <span class="comment">%符号对象精度转换</span></span><br><span class="line">        digits;  <span class="comment">% 显示当前用于计算的精度</span></span><br><span class="line">        digits(<span class="number">16</span>);  <span class="comment">% 将计算精度改为16位，降低精度有时可以加快程序运算速度或减少空间占用</span></span><br><span class="line">        a16 = vpa(<span class="built_in">sqrt</span>(<span class="number">2</span>));  <span class="comment">% vpa括起的运算使sqrt(2)运算按照规定的精度执行</span></span><br><span class="line">        a8 = vpa(<span class="built_in">sqrt</span>(<span class="number">2</span>), <span class="number">8</span>);  <span class="comment">% 在vpa内控制精度，离开这一步精度恢复</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">%符号多项式函数运算</span></span><br><span class="line">    <span class="comment">%*符号表达形式与相互转化</span></span><br><span class="line">        <span class="comment">%多项式展开整理</span></span><br><span class="line">            g = expand(f);  <span class="comment">% 展开</span></span><br><span class="line">            h = collect(g);  <span class="comment">% 整理(默认按x整理)</span></span><br><span class="line">            h1 = collect(f, x);  <span class="comment">% 按x整理（降幂排列）</span></span><br><span class="line">        <span class="comment">%因式分解展开质因数</span></span><br><span class="line">            fac = <span class="built_in">factor</span>(h);  <span class="comment">% 因式分解</span></span><br><span class="line">            <span class="built_in">factor</span>(<span class="number">12</span>);  <span class="comment">% 对12分解质因数</span></span><br><span class="line">    <span class="comment">%符号多项式向量形式与计算</span></span><br><span class="line">        syms a b c;</span><br><span class="line">        n = [a, b, c];</span><br><span class="line">        roots(n);  <span class="comment">% 求符号多项式ax^2+bx+c的根</span></span><br><span class="line">        n = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">        roots(n);  <span class="comment">% 求符号多项式带入a=1, b=2, c=3的根</span></span><br><span class="line">    <span class="comment">%*反函数</span></span><br><span class="line">        fi = finverse(f, x);  <span class="comment">% 对f中的变量x求反函数</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">%符号微积分</span></span><br><span class="line">    <span class="comment">%函数的极限和级数运算</span></span><br><span class="line">        <span class="comment">% 常量a，b</span></span><br><span class="line">        <span class="comment">%极限</span></span><br><span class="line">            limit(f, x, <span class="number">4</span>);  <span class="comment">% 求f(x), x-&gt;4</span></span><br><span class="line">            limit(f, <span class="number">4</span>);  <span class="comment">% 默认变量-&gt;4</span></span><br><span class="line">            limit(f);  <span class="comment">% 默认变量-&gt;0</span></span><br><span class="line">            limit(f, x, <span class="number">4</span>, <span class="string">&#x27;right&#x27;</span>);  <span class="comment">% 求f(x), x-&gt;4+, &#x27;left&#x27; x-&gt;4-</span></span><br><span class="line">        <span class="comment">%*基本级数运算</span></span><br><span class="line">            <span class="comment">%求和</span></span><br><span class="line">                symsum(s, x, <span class="number">3</span>, <span class="number">5</span>);  <span class="comment">% 计算表达式s变量x从3到5的级数和，或symsum(s, x, [a b])或symsum(s, x, [a;b])</span></span><br><span class="line">                symsum(s, <span class="number">3</span>, <span class="number">5</span>);  <span class="comment">% 计算s默认变量从3到5的级数和</span></span><br><span class="line">                symsum(s);  <span class="comment">% 计算s默认变量从0到n-1的级数和</span></span><br><span class="line">            <span class="comment">%一维泰勒展开</span></span><br><span class="line">                taylor(f, x, <span class="number">4</span>);  <span class="comment">% f在x=4处展开为五阶泰勒级数</span></span><br><span class="line">                taylor(f, x);  <span class="comment">% f在x=0处展开为五阶泰勒级数</span></span><br><span class="line">                taylor(f);  <span class="comment">% f在默认变量=0处展开为五阶泰勒级数</span></span><br><span class="line">    <span class="comment">%符号微分</span></span><br><span class="line">        <span class="comment">%单变量求导（单变量偏导）</span></span><br><span class="line">            n = <span class="number">1</span>;  <span class="comment">% 常量n</span></span><br><span class="line">            fn = diff(f, x, n);  <span class="comment">% f对x的n阶导</span></span><br><span class="line">            f1 = diff(f, x);  <span class="comment">% f对x的1阶导</span></span><br><span class="line">            diff(f, n);  <span class="comment">% f对默认变量的n阶导</span></span><br><span class="line">            diff(f);  <span class="comment">% 默认变量1阶导</span></span><br><span class="line">        <span class="comment">%多元偏导</span></span><br><span class="line">            fxy = diff(f, x, y);  <span class="comment">% 先求x偏导，再求y偏导</span></span><br><span class="line">            fxyz = diff(f, x, y, z);  <span class="comment">% 先求x偏导，再求y偏导,再求z偏导</span></span><br><span class="line">    <span class="comment">%符号积分</span></span><br><span class="line">        <span class="comment">%积分命令</span></span><br><span class="line">            int(f, x, <span class="number">1</span>, <span class="number">2</span>);  <span class="comment">% 函数f变量x在1~2区间定积分</span></span><br><span class="line">            int(f, <span class="number">1</span>, <span class="number">2</span>);  <span class="comment">% 函数f默认变量在ab区间定积分</span></span><br><span class="line">            int(f, x);  <span class="comment">% 函数f变量x不定积分</span></span><br><span class="line">            int(f);  <span class="comment">% 函数f默认变量不定积分</span></span><br><span class="line">            <span class="comment">% 傅里叶，拉普拉斯，Z变换</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">%*符号方程求解</span></span><br><span class="line">    <span class="comment">%符号代数方程</span></span><br><span class="line">        <span class="comment">%一元方程</span></span><br><span class="line">            eqn1 = a*x==b;</span><br><span class="line">            S = solve(eqn1);  <span class="comment">% 返回eqn符号解</span></span><br><span class="line">        <span class="comment">%多元方程组</span></span><br><span class="line">            eqn21 = x-y==a;</span><br><span class="line">            eqn22 = <span class="number">2</span>*x+y==b;</span><br><span class="line">            [Sx, Sy] = solve(eqn21, eqn22, x, y);  <span class="comment">% [Svar1,...SvarN]=solve(eqn1,...eqnM, var1,...varN),MN不一定相等</span></span><br><span class="line">            [Sxn, Syn] = solve(eqn21, eqn22, x, y, <span class="string">&#x27;ReturnCondition&#x27;</span>, <span class="built_in">true</span>);  <span class="comment">% 加上参数ReturnCondition可返回通解及解的条件</span></span><br><span class="line">            <span class="comment">% 其他参数(参数加上true生效)</span></span><br><span class="line">                <span class="comment">% IgnoreProperty，忽略变量定义时一些假设</span></span><br><span class="line">                <span class="comment">% IgnoreAnalyticConstraints，忽略分析限制；</span></span><br><span class="line">                <span class="comment">% MaxDegree，大于3解显性解；</span></span><br><span class="line">                <span class="comment">% PrincipleValue，仅主值</span></span><br><span class="line">                <span class="comment">% Real，仅实数解</span></span><br><span class="line">        <span class="comment">%非线性fsolve</span></span><br><span class="line">            X = fsolve(fun, X0, optimset(option));  <span class="comment">% fun函数.m文件名；X0求根初值；option选项如(&#x27;Display&#x27;,&#x27;off&#x27;)不显示中间结果等</span></span><br></pre></td></tr></table></figure>
<p>作者：glanny</p>
<p><a href="https://www.bilibili.com/read/cv7966685?spm_id_from=333.788.b_636f6d6d656e74.6">原文地址</a></p>
<p>出处： bilibili</p>
]]></content>
      <categories>
        <category>Matlab</category>
      </categories>
      <tags>
        <tag>Matlab入门</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出计算机组成原理（四）</title>
    <url>/posts/496d4617.html</url>
    <content><![CDATA[<h2 id="在软硬件接口中，CPU-帮我们做了什么事？"><a href="#在软硬件接口中，CPU-帮我们做了什么事？" class="headerlink" title="在软硬件接口中，CPU 帮我们做了什么事？"></a>在软硬件接口中，CPU 帮我们做了什么事？</h2><p>我们前面，从<strong>硬件</strong>的角度来看，CPU 就是一个超大规模集成电路，通过电路实现了加法、乘法乃至各种各样的处理逻辑。</p>
<span id="more"></span>

<p>如果我们从<strong>软件</strong>工程师的角度来讲，CPU 就是一个执行各种计算机指令（Instruction Code）的逻辑机器。这里的<strong>计算机指令</strong>，就好比一门 CPU 能够听得懂的语言，我们也可以把它叫作机器语言（Machine Language）。</p>
<p>不同的 CPU 能够听懂的语言不太一样。比如，我们的个人电脑用的是 Intel 的 CPU，苹果手机用的是 ARM 的 CPU。这两者能听懂的语言就不太一样。类似这样两种 CPU 各自支持的语言，就是两组不同的<strong>计算机指令集</strong>，英文叫 Instruction Set。这里面的“Set”，其实就是数学上的集合，代表不同的单词、语法。</p>
<p>一个计算机程序，不可能只有一条指令，而是由成千上万条指令组成的。但是 CPU 里不能一直放着所有指令，所以计算机程序平时是存储在存储器中的。这种程序指令存储在存储器里面的计算机，我们就叫作<strong>存储程序型计算机</strong>（Stored-program Computer）。</p>
<h2 id="从编译到汇编，代码怎么变成机器码？"><a href="#从编译到汇编，代码怎么变成机器码？" class="headerlink" title="从编译到汇编，代码怎么变成机器码？"></a>从编译到汇编，代码怎么变成机器码？</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">  a = a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要让这段程序在一个 Linux 操作系统上跑起来，我们需要把整个程序翻译成一个<strong>汇编语言</strong>（ASM，Assembly Language）的程序，这个过程我们一般叫<strong>编译</strong>（Compile）成汇编代码。</p>
<p>针对汇编代码，我们可以再用汇编器（Assembler）翻译成机器码（Machine Code）。这些机器码由“0”和“1”组成的机器语言表示。这一条条<strong>机器码</strong>，就是一条条的<strong>计算机指令</strong>。这样一串串的 16 进制数字，就是我们 CPU 能够真正认识的计算机指令。</p>
<p>在一个 Linux 操作系统上，我们可以简单地使用 gcc 和 objdump 这样两条命令，把对应的汇编代码和机器码都打印出来。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -g -c test.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> objdump -d -M intel -S test.o</span></span><br></pre></td></tr></table></figure>

<p>可以看到，左侧有一堆数字，这些就是一条条机器码；右边有一系列的 push、mov、add、pop 等，这些就是对应的汇编代码。一行 C 语言代码，有时候只对应一条机器码和汇编代码，有时候则是对应多条机器码和汇编代码。<u>汇编代码和机器码之间是一一对应的</u>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test.o:     file format elf64-x86-64</span><br><span class="line">Disassembly of section .text:</span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   0:   55                      push   rbp</span><br><span class="line">   1:   48 89 e5                mov    rbp,rsp</span><br><span class="line">  int a = 1; </span><br><span class="line">   4:   c7 45 fc 01 00 00 00    mov    DWORD PTR [rbp-0x4],0x1</span><br><span class="line">  int b = 2;</span><br><span class="line">   b:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2</span><br><span class="line">  a = a + b;</span><br><span class="line">  12:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]</span><br><span class="line">  15:   01 45 fc                add    DWORD PTR [rbp-0x4],eax</span><br><span class="line">&#125;</span><br><span class="line">  18:   5d                      pop    rbp</span><br><span class="line">  19:   c3                      ret    </span><br></pre></td></tr></table></figure>

<p><strong>因为汇编代码其实就是“给程序员看的机器码”</strong>，也正因为这样，机器码和汇编代码是一一对应的。我们人类很容易记住 add、mov 这些用英文表示的指令，而 8b 45 f8 这样的指令，由于很难一下子看明白是在干什么，所以会非常难以记忆。</p>
<p>从高级语言到汇编代码，再到机器码，就是一个日常开发程序，最终变成了 CPU 可以执行的计算机指令的过程。</p>
<h2 id="解析指令和机器码"><a href="#解析指令和机器码" class="headerlink" title="解析指令和机器码"></a>解析指令和机器码</h2><p>一般来说，常见的指令可以分成五大类。</p>
<ul>
<li><p>第一类是算术类指令。我们的加减乘除，在 CPU 层面，都会变成一条条算术类指令。</p>
</li>
<li><p>第二类是数据传输类指令。给变量赋值、在内存里读写数据，用的都是数据传输类指令。</p>
</li>
<li><p>第三类是逻辑类指令。逻辑上的与或非，都是这一类指令。</p>
</li>
<li><p>第四类是条件分支类指令。日常我们写的“if/else”，其实都是条件分支类指令。</p>
</li>
<li><p>最后一类是无条件跳转指令。写一些大一点的程序，我们常常需要写一些函数或者方法。在调用函数的时候，其实就是发起了一个无条件跳转指令。你可能一下子记不住，或者对这些指令的含义还不能一下子掌握，这里我画了一个表格，给你举例子说明一下，帮你理解、记忆。</p>
</li>
</ul>
<p><img src="/posts/496d4617/image-20210322223752004.png" alt="image-20210322223752004"></p>
<p>下面我们来看看，汇编器是怎么把对应的汇编代码，翻译成为机器码的。</p>
<p>我们说过，不同的 CPU 有不同的指令集，也就对应着不同的汇编语言和不同的机器码。为了方便你快速理解这个机器码的计算方式，我们选用最简单的 MIPS 指令集，来看看机器码是如何生成的。</p>
<p>MIPS 的指令是一个 <strong>32 位</strong>的整数，高 6 位叫<strong>操作码</strong>（Opcode），也就是代表这条指令具体是一条什么样的指令，剩下的 26 位有三种格式，分别是 R、I 和 J。</p>
<p><strong>R 指令</strong>是一般用来做算术和逻辑操作，里面有读取和写入数据的寄存器的地址。如果是逻辑位移操作，后面还有位移操作的位移量，而最后的功能码，则是在前面的操作码不够的时候，扩展操作码表示对应的具体指令的。</p>
<p><strong>I 指令</strong>，则通常是用在数据传输、条件分支，以及在运算的时候使用的并非变量还是常数的时候。这个时候，没有了位移量和操作码，也没有了第三个寄存器，而是把这三部分直接合并成了一个地址值或者一个常数。</p>
<p><strong>J 指令</strong>就是一个跳转指令，高 6 位之外的 26 位都是一个跳转后的地址。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">add $t0,$s2,$s1</span><br></pre></td></tr></table></figure>

<p>我以一个简单的加法算术指令 add t0,s1, $s2, 为例，给你解释。为了方便，我们下面都用十进制来表示对应的代码。</p>
<p>对应的 MIPS 指令里 opcode 是 0，rs 代表第一个寄存器 s1 的地址是 17，rt 代表第二个寄存器 s2 的地址是 18，rd 代表目标的临时寄存器 t0 的地址，是 8。因为不是位移操作，所以位移量是 0。把这些数字拼在一起，就变成了一个 MIPS 的加法指令。</p>
<p>为了读起来方便，我们一般把对应的二进制数，用 16 进制表示出来。在这里，也就是 0X02324020。这个数字也就是这条指令对应的机器码。</p>
<blockquote>
<p>注：这里MIPS指令是一个32位的二进制数，对应的十六进制机器码就是8位。</p>
</blockquote>
<p><img src="/posts/496d4617/image-20210322224518788.png" alt="image-20210322224518788"></p>
<h2 id="CPU-是如何执行指令的？"><a href="#CPU-是如何执行指令的？" class="headerlink" title="CPU 是如何执行指令的？"></a>CPU 是如何执行指令的？</h2><p>对于我们这些做软件的程序员来说，我们只要知道，写好的代码变成了指令之后，是一条一条<strong>顺序</strong>执行的就可以了。</p>
<p>我们先不管几百亿的晶体管的背后是怎么通过电路运转起来的，<strong>逻辑上，我们可以认为，CPU 其实就是由一堆寄存器组成的。</strong>而寄存器就是 CPU 内部，由多个触发器（Flip-Flop）或者锁存器（Latches）组成的简单电路。</p>
<p>触发器和锁存器，其实就是两种不同原理的数字电路组成的逻辑门。这块内容并不是我们这节课的重点，所以你只要了解就好。如果想要深入学习的话，你可以学习数字电路的相关课程，这里我们不深入探讨。</p>
<p>好了，现在我们接着前面说。N 个触发器或者锁存器，就可以组成一个 N 位（Bit）的寄存器，能够保存 N 位的数据。比方说，我们用的 64 位 Intel 处理器，寄存器就是 64 位的。</p>
<p><img src="/posts/496d4617/image-20210328175418110.png" alt="image-20210328175418110"></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
</search>
