<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ STL与Java util对比</title>
    <url>/posts/4c2b5dfd.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="常用容器操作"><a href="#常用容器操作" class="headerlink" title="常用容器操作"></a>常用容器操作</h2><h3 id="1-vector-和-ArrayList"><a href="#1-vector-和-ArrayList" class="headerlink" title="1.vector 和 ArrayList"></a>1.vector 和 ArrayList</h3><span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a; - ArrayList&lt;Integer&gt; a = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">size() - size()  <span class="comment">// 返回元素个数</span></span><br><span class="line">empty() - isEmpty()  <span class="comment">// 返回是否为空</span></span><br><span class="line">clear() - clear  <span class="comment">// 清空</span></span><br><span class="line">front()/back() - get(<span class="number">0</span>)/get(a.size() - <span class="number">1</span>)</span><br><span class="line">push_back()/pop_back() - add()/remove(a.size() - <span class="number">1</span>)</span><br><span class="line">begin()/end() - iterator()</span><br><span class="line">[] - get()</span><br><span class="line">支持比较运算 - 不支持比较运算</span><br><span class="line">    </span><br><span class="line">ArrayList 的遍历：</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i++) a.get(i);</span><br><span class="line"></span><br><span class="line">Iterator&lt;Integer&gt; iterator = <span class="built_in">list</span>.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) iterator.next()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num : a) num;</span><br></pre></td></tr></table></figure>

<h3 id="2-pair-和-Pair（Java-需要-import-javafx-util-Pair-，目前-acwing-不支持）"><a href="#2-pair-和-Pair（Java-需要-import-javafx-util-Pair-，目前-acwing-不支持）" class="headerlink" title="2.pair 和 Pair（Java 需要 import javafx.util.Pair ，目前 acwing 不支持）"></a>2.pair 和 Pair（Java 需要 import javafx.util.Pair ，目前 acwing 不支持）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p = <span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">2</span>); - Pair&lt;Integer, Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">1</span>, <span class="number">2</span>); </span><br><span class="line">first - getKey() <span class="comment">// 第一个元素</span></span><br><span class="line">second - getValue() <span class="comment">// 第二个元素</span></span><br><span class="line">支持比较运算 - 不支持比较运算</span><br></pre></td></tr></table></figure>

<h3 id="3-string-和-String"><a href="#3-string-和-String" class="headerlink" title="3.string 和 String"></a>3.string 和 String</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> a = <span class="string">&quot;yxc&quot;</span>; - String b = <span class="string">&quot;hqh&quot;</span>;</span><br><span class="line">size()/length() - length()  <span class="comment">// 返回字符串长度</span></span><br><span class="line">empty()</span><br><span class="line">clear()</span><br><span class="line">substr(起始下标，(子串长度)) - substring(起始下标，(终止下标 + <span class="number">1</span>)) <span class="comment">// 返回子串</span></span><br><span class="line">c_str()  <span class="comment">// 返回字符串所在字符数组的起始地址</span></span><br><span class="line">支持加法运算 - 支持加法运算</span><br></pre></td></tr></table></figure>

<h3 id="4-queue-stack-deque-和-Deque-有两个实现类，一般使用-ArrayDeque"><a href="#4-queue-stack-deque-和-Deque-有两个实现类，一般使用-ArrayDeque" class="headerlink" title="4.queue, stack, deque 和 Deque (有两个实现类，一般使用 ArrayDeque)"></a>4.queue, stack, deque 和 Deque (有两个实现类，一般使用 ArrayDeque)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>, 队列</span><br><span class="line">   size() - size()</span><br><span class="line">   empty() - isEmpty()</span><br><span class="line">   push() - offer()  <span class="comment">// 向队尾插入一个元素</span></span><br><span class="line">   front() - peek()  <span class="comment">// 返回队头元素</span></span><br><span class="line">   back()  <span class="comment">// 返回队尾元素</span></span><br><span class="line">   pop() - poll()  <span class="comment">// 弹出队头元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>, 栈</span><br><span class="line">   size() - size()</span><br><span class="line">   empty() - isEmpty()</span><br><span class="line">   push() - push()  <span class="comment">// 向栈顶插入一个元素</span></span><br><span class="line">   top() - peek()  <span class="comment">// 返回栈顶元素</span></span><br><span class="line">   pop() - pop()  <span class="comment">// 弹出栈顶元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>, 双端队列</span><br><span class="line">   size() - size()</span><br><span class="line">   empty() - isEmpty()</span><br><span class="line">   clear() - clear()</span><br><span class="line">   front()/back() - getFirst()/getLast()</span><br><span class="line">   push_back()/pop_back() - offerLast()/pollLast()</span><br><span class="line">   push_front()/pop_front() - offerFirst()/pollFirst()</span><br><span class="line">   begin()/end() - iterator()</span><br><span class="line">   []</span><br></pre></td></tr></table></figure>

<h3 id="5-priority-queue-和-PriorityQueue"><a href="#5-priority-queue-和-PriorityQueue" class="headerlink" title="5.priority_queue 和 PriorityQueue"></a>5.priority_queue 和 PriorityQueue</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">默认是大根堆 - 默认是小根堆</span><br><span class="line">push() - offer()  <span class="comment">// 插入一个元素</span></span><br><span class="line">top() - peek()  <span class="comment">// 返回堆顶元素</span></span><br><span class="line">pop() - poll() <span class="comment">// 弹出堆顶元素</span></span><br><span class="line"></span><br><span class="line">PriorityQueue 定义成大根堆的方式：</span><br><span class="line">PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br></pre></td></tr></table></figure>

<h3 id="6-unordered-set-和-HashSet"><a href="#6-unordered-set-和-HashSet" class="headerlink" title="6.unordered_set 和 HashSet"></a>6.unordered_set 和 HashSet</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">size() - size()</span><br><span class="line">empty() - isEmpty()</span><br><span class="line">clear() - clear()</span><br><span class="line">insert() - add  <span class="comment">// 插入一个数</span></span><br><span class="line">find() - contains()  <span class="comment">// 查找一个数</span></span><br><span class="line">erase() - remove() <span class="comment">// 删除元素</span></span><br></pre></td></tr></table></figure>

<h3 id="7-unordered-map-和-HashMap"><a href="#7-unordered-map-和-HashMap" class="headerlink" title="7.unordered_map 和 HashMap"></a>7.unordered_map 和 HashMap</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">size() - size()</span><br><span class="line">empty() - isEmpty()</span><br><span class="line">clear() - clear()</span><br><span class="line">insert() - put() <span class="comment">// 插入的数是一个 pair</span></span><br><span class="line">find() - get(key) <span class="comment">// 查找一个 pair</span></span><br><span class="line">erase() - remove() <span class="comment">// 删除元素</span></span><br><span class="line">    - containsKey(key)/containsValue(value) <span class="comment">// 判断元素是否在集合中</span></span><br><span class="line">    - entrySet() <span class="comment">// 返回一个包含所有节点的集合</span></span><br><span class="line">    - keySet() <span class="comment">// 返回一个包含所有键的集合</span></span><br><span class="line">    - values() <span class="comment">// 返回一个包含所有值的集合</span></span><br><span class="line">    - getOrDefault(key, <span class="keyword">default</span> value) <span class="comment">// 返回指定 key 的 value，若 key 不存在 则返回 default value</span></span><br><span class="line">    - putIfAbsent(key, value) <span class="comment">// 如果集合中没有该 key 对应的节点，则插入</span></span><br></pre></td></tr></table></figure>

<p>作者：我要番茄锅<br>链接：<a href="https://www.acwing.com/blog/content/2180/">https://www.acwing.com/blog/content/2180/</a><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>Java util</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中algorithm头文件下的常用函数总结</title>
    <url>/posts/d38917ef.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这块内容在STL的文章中都已经介绍过了，但还是单独提下algorithm的内容。</p>
<p>参考自：<a href="https://blog.csdn.net/qq_39445165/article/details/94721121">https://blog.csdn.net/qq_39445165/article/details/94721121</a></p>
<p>详细内容可以参照《算法笔记》。</p>
<span id="more"></span>

<h2 id="①-max、min和abs函数，下面是具体的代码："><a href="#①-max、min和abs函数，下面是具体的代码：" class="headerlink" title="① max、min和abs函数，下面是具体的代码："></a>① max、min和abs函数，下面是具体的代码：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">-2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, max(x, y), min(x, y));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, <span class="built_in">abs</span>(x), <span class="built_in">abs</span>(y));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="②-swap函数，下面是具体的代码："><a href="#②-swap函数，下面是具体的代码：" class="headerlink" title="② swap函数，下面是具体的代码："></a>② swap函数，下面是具体的代码：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">-2</span>;</span><br><span class="line">	swap(x, y);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, x, y);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="③-reverse函数"><a href="#③-reverse函数" class="headerlink" title="③ reverse函数"></a>③ reverse函数</h2><p>reverse（it，it2）可以将数组指针在[it，it2）之间的元素或者容器的迭代器在[it，it2）范围内的元素进行翻转，具体的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>&#125;;</span><br><span class="line">	reverse(arr, arr + <span class="number">8</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="④-next-permutation函数"><a href="#④-next-permutation函数" class="headerlink" title="④ next_permutation函数"></a>④ next_permutation函数</h2><p>使用这个函数可以生成给定序列在全排列中的下一个排列，并且生成的排列是从小到大进行排序的，具体的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">	<span class="comment">//使用C++中的net_permutation函数生成数组的全排列</span></span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d%d%d%d\n&quot;</span>, arr[<span class="number">0</span>], arr[<span class="number">1</span>], arr[<span class="number">2</span>], arr[<span class="number">3</span>]);</span><br><span class="line">	&#125;<span class="keyword">while</span>(next_permutation(arr, arr + <span class="number">4</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="⑤-fill函数"><a href="#⑤-fill函数" class="headerlink" title="⑤ fill函数"></a>⑤ fill函数</h2><p>fill函数可以将数组或者是容器中的某一区间赋予某个相同的值，与memset函数不同的是，这里的赋值可以是数组类型对应范围中的任意值，具体的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>&#125;;</span><br><span class="line">	fill(arr, arr + <span class="number">8</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C++入门笔记（一）</title>
    <url>/posts/1eaad404.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-头文件的防卫式声明"><a href="#1-头文件的防卫式声明" class="headerlink" title="1.头文件的防卫式声明"></a>1.头文件的防卫式声明</h2><p><img src="/posts/1eaad404/image-20210201104338919.png" alt="image-20210201104338919"></p>
<p>写头文件时，非常建议按这种格式写防卫式声明。</p>
<span id="more"></span>

<h2 id="2-基本数据类型"><a href="#2-基本数据类型" class="headerlink" title="2.基本数据类型"></a>2.基本数据类型</h2><p>五种主要的数据类型如下：（其中bool是C语言所没有的）</p>
<p>其实还有别的。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>布尔型</td>
<td>bool</td>
</tr>
<tr>
<td>字符型</td>
<td>char</td>
</tr>
<tr>
<td>整型</td>
<td>int</td>
</tr>
<tr>
<td>浮点型</td>
<td>float</td>
</tr>
<tr>
<td>双浮点型</td>
<td>double</td>
</tr>
</tbody></table>
<p>一些基本类型可以使用一个或多个类型修饰符进行修饰：</p>
<ul>
<li><p>signed</p>
</li>
<li><p>unsigned</p>
</li>
<li><p>short</p>
</li>
<li><p>long</p>
</li>
<li><p>long long</p>
<p><img src="/posts/1eaad404/image-20210202171246995.png" alt="image-20210202171246995"></p>
</li>
</ul>
<p><strong>注意：</strong>不同系统会有所差异，一字节为 8 位。</p>
<p><strong>注意：</strong>long int 8 个字节，int 都是 4 个字节，早期的 C 编译器定义了 long int 占用 4 个字节，int 占用 2 个字节，新版的 C/C++ 标准兼容了早期的这一设定。</p>
<p>bool ： 1个字节 ： 取值范围（false和true，小写）</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>位</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>1 个字节</td>
<td>-128 到 127 或者 0 到 255</td>
</tr>
<tr>
<td>unsigned char</td>
<td>1 个字节</td>
<td>0 到 255</td>
</tr>
<tr>
<td>signed char</td>
<td>1 个字节</td>
<td>-128 到 127</td>
</tr>
<tr>
<td>int</td>
<td>4 个字节</td>
<td>-2147483648 到 2147483647</td>
</tr>
<tr>
<td>unsigned int</td>
<td>4 个字节</td>
<td>0 到 4294967295</td>
</tr>
<tr>
<td>signed int</td>
<td>4 个字节</td>
<td>-2147483648 到 2147483647</td>
</tr>
<tr>
<td>short int</td>
<td>2 个字节</td>
<td>-32768 到 32767</td>
</tr>
<tr>
<td>unsigned short int</td>
<td>2 个字节</td>
<td>0 到 65,535</td>
</tr>
<tr>
<td>signed short int</td>
<td>2 个字节</td>
<td>-32768 到 32767</td>
</tr>
<tr>
<td>long int</td>
<td>8 个字节</td>
<td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td>signed long int</td>
<td>8 个字节</td>
<td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td>unsigned long int</td>
<td>8 个字节</td>
<td>0 到 18,446,744,073,709,551,615</td>
</tr>
<tr>
<td>float</td>
<td>4 个字节</td>
<td>精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字)</td>
</tr>
<tr>
<td>double</td>
<td>8 个字节</td>
<td>双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字)</td>
</tr>
<tr>
<td>long double</td>
<td>16 个字节</td>
<td>长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。</td>
</tr>
<tr>
<td>wchar_t</td>
<td>2 或 4 个字节</td>
<td>1 个宽字符</td>
</tr>
</tbody></table>
<p><strong>注意：</strong>C++中有字符串常量，但是基本类型中却没有字符串变量。</p>
<p><img src="/posts/1eaad404/image-20210202172025668.png" alt="image-20210202172025668"></p>
<p><img src="/posts/1eaad404/image-20210202172115612.png" alt="image-20210202172115612"></p>
<h2 id="3-类型别名"><a href="#3-类型别名" class="headerlink" title="3.类型别名"></a>3.类型别名</h2><h3 id="typedef-声明"><a href="#typedef-声明" class="headerlink" title="typedef 声明"></a>typedef 声明</h3><p>您可以使用 <strong>typedef</strong> 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> type newname; </span><br></pre></td></tr></table></figure>

<p>例如，下面的语句会告诉编译器，feet 是 int 的另一个名称：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> feet;</span><br></pre></td></tr></table></figure>

<p>现在，下面的声明是完全合法的，它创建了一个整型变量 distance：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">feet distance;</span><br></pre></td></tr></table></figure>

<h3 id="using"><a href="#using" class="headerlink" title="using"></a>using</h3><p>语法格式：<code>using 新类型名 = 已有类型名;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Area = <span class="keyword">double</span>; <span class="comment">// 这和typename类似</span></span><br><span class="line">Area a = <span class="number">10.10</span>; <span class="comment">// Area相当于double</span></span><br></pre></td></tr></table></figure>

<h2 id="4-枚举类型"><a href="#4-枚举类型" class="headerlink" title="4.枚举类型"></a>4.枚举类型</h2><p>不限定作用域枚举类型。</p>
<p><img src="/posts/1eaad404/image-20210203121020706.png" alt="image-20210203121020706"></p>
<p>枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。</p>
<p>如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓”枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。</p>
<p>创建枚举，需要使用关键字 <strong>enum</strong>。枚举类型的一般形式为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> 枚举名&#123;</span> </span><br><span class="line">     标识符[=整型常数], </span><br><span class="line">     标识符[=整型常数], </span><br><span class="line">... </span><br><span class="line">    标识符[=整型常数]</span><br><span class="line">&#125; 枚举变量;</span><br></pre></td></tr></table></figure>

<p>如果枚举没有初始化, 即省掉”=整型常数”时, 则从第一个标识符开始。</p>
<p>例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 “blue”。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> &#123;</span> red, green, blue &#125; c;</span><br><span class="line">c = blue;</span><br></pre></td></tr></table></figure>

<p>默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，<strong>green</strong> 的值为 5。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> &#123;</span> red, green=<span class="number">5</span>, blue &#125;;</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>blue</strong> 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。</p>
<p><strong>注意</strong>：整数值不能直接赋值给枚举变量，如果需要将整数值赋值给枚举变量，应进行强制类型转换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">GameResult</span>&#123;</span>WIN,LOSE,TIE,CANCEL&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GameResult result;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">GameResult</span> <span class="title">omit</span> =</span> CANCEL; <span class="comment">// 这两种声明枚举变量的方式相同</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> count = WIN; count &lt;= CANCEL; count++)</span><br><span class="line">	&#123;</span><br><span class="line">		result = GameResult(count); <span class="comment">// 将int型变量count强制转换为GameResult</span></span><br><span class="line">        <span class="comment">// 等价于result = (GameResult)count;</span></span><br><span class="line">		<span class="keyword">if</span> (result == omit) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The game was cancelled&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The game was played&quot;</span>;</span><br><span class="line">			<span class="keyword">if</span> (result == WIN) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;and we won!&quot;</span>;</span><br><span class="line">			<span class="keyword">if</span> (result == LOSE) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;and we lost.&quot;</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment">The game was playedand we won!</span></span><br><span class="line"><span class="comment">The game was playedand we lost.</span></span><br><span class="line"><span class="comment">The game was played</span></span><br><span class="line"><span class="comment">The game was cancelled</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="5-auto类型与decltype类型"><a href="#5-auto类型与decltype类型" class="headerlink" title="5.auto类型与decltype类型"></a>5.auto类型与decltype类型</h2><p>当变量类型名称太长时，可以使用auto进行简化。</p>
<p><img src="/posts/1eaad404/image-20210203124857742.png" alt="image-20210203124857742"></p>
<p><img src="/posts/1eaad404/image-20210203125001245.png" alt="image-20210203125001245"></p>
<h2 id="6-const修饰变量称为符号常量"><a href="#6-const修饰变量称为符号常量" class="headerlink" title="6.const修饰变量称为符号常量"></a>6.const修饰变量称为符号常量</h2><p><img src="/posts/1eaad404/image-20210202173012524.png" alt="image-20210202173012524"></p>
<h2 id="7-sizeof运算符与位运算"><a href="#7-sizeof运算符与位运算" class="headerlink" title="7.sizeof运算符与位运算"></a>7.sizeof运算符与位运算</h2><p><strong>sizeof运算符</strong></p>
<p>语法格式：<code>sizeof(类型名)</code>或者<code>sizeof 表达式</code></p>
<p>结果值： 类型名或表达式的结果所占有的字节数。</p>
<p>例如：<code>sizeof(short)  sizeof x</code></p>
<p><strong>位运算</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>按位与（&amp;）</span><br><span class="line">运算规则：将两个运算量的每一个位进行逻辑与操作。</span><br><span class="line">    <span class="number">3</span> : <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">    <span class="number">5</span> : <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">________________________</span><br><span class="line"><span class="number">3</span> &amp; <span class="number">5</span> : <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">相同位的两个数字都为<span class="number">1</span>，则为<span class="number">1</span>；若有一个不为<span class="number">1</span>，则为<span class="number">0</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>按位或（|）</span><br><span class="line">运算规则：将两个运算量的每一个位进行逻辑或操作。</span><br><span class="line">    <span class="number">3</span> : <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">    <span class="number">5</span> : <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">________________________</span><br><span class="line"><span class="number">3</span> | <span class="number">5</span> : <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">相同位只要一个为<span class="number">1</span>即为<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>按位异或（^）</span><br><span class="line">运算规则：两个操作数进行异或，若对应位相同，该位为<span class="number">0</span>，否则为<span class="number">1</span>。</span><br><span class="line">        <span class="number">0</span> <span class="number">7</span> <span class="number">1</span> : <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">        <span class="number">0</span> <span class="number">5</span> <span class="number">2</span> : <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">_______________________________</span><br><span class="line"><span class="number">0</span> <span class="number">7</span> <span class="number">1</span> ^ <span class="number">0</span> <span class="number">5</span> <span class="number">2</span> : <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">相同位不同则为<span class="number">1</span>，相同则为<span class="number">0</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>按位取反 （~）</span><br><span class="line">运算规则：将一个二进制数按位取反。</span><br><span class="line"><span class="number">3</span> : <span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">~<span class="number">3</span>: <span class="number">1111</span> <span class="number">1100</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/1eaad404/image-20210203113233625.png" alt="image-20210203113233625"></p>
<p><img src="/posts/1eaad404/image-20210203113607711.png" alt="image-20210203113607711"></p>
<p><img src="/posts/1eaad404/image-20210203114610229.png" alt="image-20210203114610229"></p>
<p><img src="/posts/1eaad404/image-20210203114904249.png" alt="image-20210203114904249"></p>
<p><strong>移位运算：</strong></p>
<p>右移运算分为：逻辑右移和算术右移。</p>
<p>有符号数右移时，高位补符号位，如果是负数，补1，是整数则补0.</p>
<p>算术右移相当于除以2的效果；左移相当于乘以2的效果。</p>
<h2 id="8-运算符的优先级与结合性表"><a href="#8-运算符的优先级与结合性表" class="headerlink" title="8.运算符的优先级与结合性表"></a>8.运算符的优先级与结合性表</h2><p>不需要背，需要时查阅即可。</p>
<p><img src="/posts/1eaad404/image-20210203115510900.png" alt="image-20210203115510900"></p>
<h2 id="9-类型转换"><a href="#9-类型转换" class="headerlink" title="9.类型转换"></a>9.类型转换</h2><p><img src="/posts/1eaad404/image-20210203115727659.png" alt="image-20210203115727659"></p>
<p><img src="/posts/1eaad404/image-20210203115801913.png" alt="image-20210203115801913"></p>
<p><img src="/posts/1eaad404/image-20210203115952100.png" alt="image-20210203115952100"></p>
<p><strong>注意</strong>：<code>(int)a</code>和<code>int(a)</code>这两种方法都是等价的。</p>
<p><img src="/posts/1eaad404/image-20210203120004165.png" alt="image-20210203120004165"></p>
<h2 id="10-I-O流"><a href="#10-I-O流" class="headerlink" title="10.I/O流"></a>10.I/O流</h2><p>我们很少用到这种格式控制，可以用printf来代替格式化输出。</p>
<p><img src="/posts/1eaad404/image-20210203120254795.png" alt="image-20210203120254795"></p>
<h2 id="11-引用类型"><a href="#11-引用类型" class="headerlink" title="11.引用类型"></a>11.引用类型</h2><p>引用是一种特殊类型的变量，可以被认为是另一个变量的别名。</p>
<p>引用可以作为形参，实现形实结合。</p>
<p>引用是双向传递的！！</p>
<p><strong>注意两点：</strong></p>
<ul>
<li>声明一个引用时，必须同时对它进行初始化，使它指向一个已存在的对象；</li>
<li>一旦一个引用被初始化，就不能再指向其他对象。</li>
</ul>
<p><img src="/posts/1eaad404/image-20210203140838883.png" alt="image-20210203140838883"></p>
<h2 id="12-含有可变参数的函数"><a href="#12-含有可变参数的函数" class="headerlink" title="*12.含有可变参数的函数"></a>*12.含有可变参数的函数</h2><p><img src="/posts/1eaad404/image-20210203142030769.png" alt="image-20210203142030769"></p>
<p><img src="/posts/1eaad404/image-20210203142053872.png" alt="image-20210203142053872"></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++入门</tag>
      </tags>
  </entry>
  <entry>
    <title>C++入门笔记（七）</title>
    <url>/posts/c1f7bea.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-类类型与系统预定义类型之间的转换"><a href="#1-类类型与系统预定义类型之间的转换" class="headerlink" title="1.类类型与系统预定义类型之间的转换"></a>1.类类型与系统预定义类型之间的转换</h2><p>这个标题很教科书式，让人搞不懂，通俗的讲就是用户自己定义的类对象与内置的像int、double之类的数据之间的转换。</p>
<span id="more"></span>

<p>给出两篇参考文章：</p>
<ol>
<li><a href="https://blog.csdn.net/zhulinzhulinlin/article/details/80031029">https://blog.csdn.net/zhulinzhulinlin/article/details/80031029</a></li>
<li><a href="https://blog.csdn.net/SlowIsFastLemon/article/details/104250213">https://blog.csdn.net/SlowIsFastLemon/article/details/104250213</a></li>
</ol>
<h3 id="1-1转换构造函数-预定义类型转换成类类型"><a href="#1-1转换构造函数-预定义类型转换成类类型" class="headerlink" title="1.1转换构造函数:预定义类型转换成类类型"></a>1.1转换构造函数:预定义类型转换成类类型</h3><p>用转换构造函数可以将一个指定类型的数据转换为类的对象。但是不能反过来将一个类的对象转换为一个其他</p>
<p>类型的数据(例如将一个Complex类对象转换成double类型数据)。</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">double</span> real;</span><br><span class="line">        <span class="keyword">double</span> imag;</span><br><span class="line">        C() &#123;&#125;</span><br><span class="line">        C(<span class="keyword">double</span> i, <span class="keyword">double</span> r) &#123; real = i; imag = r; &#125;</span><br><span class="line">        C(<span class="keyword">double</span> r) &#123;<span class="comment">//转换构造函数</span></span><br><span class="line">            real = r; imag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        C <span class="keyword">operator</span> +(C &amp;c1)</span><br><span class="line">        &#123;</span><br><span class="line">            C tem;</span><br><span class="line">            tem.real = c1.real + <span class="keyword">this</span>-&gt;real;</span><br><span class="line">            tem.imag = c1.imag + <span class="keyword">this</span>-&gt;imag;</span><br><span class="line">            <span class="keyword">return</span> tem;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*friend C operator +(C &amp;c1, C&amp;c2)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            C tem;</span></span><br><span class="line"><span class="comment">            tem.real = c1.real + c2.real;</span></span><br><span class="line"><span class="comment">            tem.imag = c1.imag + c2.imag;</span></span><br><span class="line"><span class="comment">            return tem;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">C <span class="title">c1</span><span class="params">(<span class="number">1.1</span>, <span class="number">2.2</span>)</span></span>;</span><br><span class="line">    C c2,c3;</span><br><span class="line">    <span class="function">C <span class="title">c4</span><span class="params">(<span class="number">9.2</span>)</span></span>;</span><br><span class="line">    <span class="comment">//不同调用转换构造函数的方式</span></span><br><span class="line">    c2= C(<span class="number">2.3</span>) + c1;<span class="comment">//C（2.3）调用转换构造函数</span></span><br><span class="line">    c3 = <span class="number">4</span>;<span class="comment">//调用转换构造函数</span></span><br><span class="line">    <span class="comment">// C trans(int a)</span></span><br><span class="line">    <span class="comment">// &#123; return a&#125;</span></span><br><span class="line">    <span class="comment">//  该方式也调用转换构造函数 int-&gt;C </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//b = a + C(2.3);//出错，+重载函数必须为friend</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c1.real &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; c1.imag &lt;&lt; <span class="string">&quot;i&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C(2.1)和C c(2.1)两种方式都可以调用转换构造函数。第一种方式会生成一个临时对象。</p>
<ul>
<li>先声明一个类。</li>
<li>在类中定义一个<strong>只有一个参数</strong>的构造函数，参数是待转换类型的数据。</li>
<li>凡是需要将系统预定义的数据类型转换为类类型的都要用到转换构造函数。</li>
<li>其中要注意的是在C++的类中，用单个实参来调用的构造函数默认定义了从形参类型到该类类型的一个隐式转换。可以写一个类测试一下 如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        A()&#123;&#125;;</span><br><span class="line">        A(<span class="keyword">int</span> a) :a(a) &#123;&#125;</span><br><span class="line">    <span class="comment">//加上explicit关键字的可以防止类构造函数的隐式自动转换</span></span><br><span class="line">    <span class="comment">//那么下面test= 3会报错</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A test;</span><br><span class="line">    test= <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//执行test=3时跳转到A(int a) :a(a) &#123;&#125; ,将3-&gt;A类型</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; test.a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2explicit关键字"><a href="#1-2explicit关键字" class="headerlink" title="1.2explicit关键字"></a>1.2explicit关键字</h3><p>作用就是<strong>防止类构造函数的隐式自动转换</strong>。</p>
<ul>
<li><p>工程中通过explicit关键字杜绝编译器的转换尝试。</p>
</li>
<li><p>转换构造函数被explicit修饰时只能进行显示转换。</p>
<p><img src="/posts/c1f7bea/image-20210415111019594.png" alt="image-20210415111019594"></p>
</li>
</ul>
<p>explicit在下面两种情况下有效：</p>
<ul>
<li>类的构造函数只有一个参数时；</li>
<li>类的构造函数中除了第一个参数以外，其他参数都有默认值的时候。(第一个参数可以有默认值，也可以没有)</li>
</ul>
<p>google C++规范中也约定所有单参数的构造函数都必须是显示的，即使用explicit关键字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mValue;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test()</span><br><span class="line">    &#123;</span><br><span class="line">        mValue = <span class="number">0</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> i)</span><span class="comment">// 只能显式转换</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mValue = i;</span><br><span class="line">    &#125;   </span><br><span class="line">    Test <span class="keyword">operator</span> + (<span class="keyword">const</span> Test&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Test <span class="title">ret</span><span class="params">(mValue + p.mValue)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    Test t;    </span><br><span class="line">    t = <span class="keyword">static_cast</span>&lt;Test&gt;(<span class="number">5</span>);    <span class="comment">// t = Test(5);</span></span><br><span class="line">    </span><br><span class="line">    Test r;  </span><br><span class="line">    r = t + <span class="keyword">static_cast</span>&lt;Test&gt;(<span class="number">10</span>);   <span class="comment">// r = t + Test(10);</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r.value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3类型转换函数-类类型转换成其他类型（系统预定义类型）"><a href="#1-3类型转换函数-类类型转换成其他类型（系统预定义类型）" class="headerlink" title="1.3类型转换函数:类类型转换成其他类型（系统预定义类型）"></a>1.3类型转换函数:类类型转换成其他类型（系统预定义类型）</h3><p>作用：将一个类的对象转换为<strong>其他类型</strong>的数据。这里的其他类型不仅仅指系统预定义类型。</p>
<p>格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">operator</span> 目标类型()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> 目标类型的数据；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型转换函数<strong>没有返回类型</strong>，但是要return 目标类型的数据，<strong>没有参数</strong>，只能定义为类的成员函数。</p>
<p>这样做导致的结果是：类型转换函数看起来没有返回值类型，其实是隐式地指明了返回值类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        A() &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> a)</span> :<span class="title">a</span><span class="params">(a)</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span><span class="comment">//类型转换函数</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">test</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="comment">//用法1</span></span><br><span class="line">    <span class="keyword">int</span> d = test;</span><br><span class="line">    <span class="comment">//用法2</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">2</span> + <span class="keyword">int</span>(test);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>类型转换函数只能定义为成员函数，不能定义为友元函数</li>
<li>一个类可以定义多个类型转换函数，但是要避免二义性</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++入门</tag>
      </tags>
  </entry>
  <entry>
    <title>C++入门笔记（三）</title>
    <url>/posts/63a29b8e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-C-在非OOP方面的扩充"><a href="#1-C-在非OOP方面的扩充" class="headerlink" title="1.C++在非OOP方面的扩充"></a>1.C++在非OOP方面的扩充</h2><p><img src="/posts/63a29b8e/image-20210309223740177.png" alt="image-20210309223740177"></p>
<span id="more"></span>

<h2 id="2-函数重载回顾"><a href="#2-函数重载回顾" class="headerlink" title="2.函数重载回顾"></a>2.函数重载回顾</h2><p>注意：下图爆红代码，编译器无法正确匹配函数（存在多义性）。</p>
<p><img src="/posts/63a29b8e/image-20210309230013279.png" alt="image-20210309230013279"></p>
<p>正常运行。</p>
<p><img src="/posts/63a29b8e/image-20210309230508180.png" alt="image-20210309230508180"></p>
<h2 id="3-作用域运算符"><a href="#3-作用域运算符" class="headerlink" title="3.作用域运算符::"></a>3.作用域运算符<code>::</code></h2><p><img src="/posts/63a29b8e/image-20210309230703134.png" alt="image-20210309230703134"></p>
<h2 id="4-new和delete"><a href="#4-new和delete" class="headerlink" title="4.new和delete"></a>4.new和delete</h2><p><img src="/posts/63a29b8e/image-20210309230729654.png" alt="image-20210309230729654"></p>
<p>说明：这里p已经声明为int*指针，不需要特意强调new int，编译器会自动识别。</p>
<p><img src="/posts/63a29b8e/image-20210313184252878.png" alt="image-20210313184252878"></p>
<p>强调：</p>
<p>使用new可以动态开辟数组空间，但是必须提供数组每一维的大小，如：<code>int* p = new int[2][3][4]</code>；</p>
<p>new可以为简单变量初始化，如：<code>int* p = new int(5)</code>，但是不能对数组初始化；</p>
<p>使用delete释放动态数组空间，如：<code>delete []p</code>，不需要指出所删除数组的维数和大小。</p>
<h2 id="5-引用"><a href="#5-引用" class="headerlink" title="5.引用"></a>5.引用</h2><p>不允许建立void类型的引用，因为void本质上不是一个类型；</p>
<p>不能建立数组的引用，不能建立引用的引用。</p>
<p>demo1:</p>
<p><img src="/posts/63a29b8e/image-20210313185008444.png" alt="image-20210313185008444"></p>
<p>demo2:</p>
<p><img src="/posts/63a29b8e/image-20210313185039548.png" alt="image-20210313185039548"></p>
<h2 id="6-对象数组与数组指针"><a href="#6-对象数组与数组指针" class="headerlink" title="6.对象数组与数组指针"></a>6.对象数组与数组指针</h2><h3 id="对象数组及其初始化"><a href="#对象数组及其初始化" class="headerlink" title="对象数组及其初始化"></a>对象数组及其初始化</h3><p>demo1：</p>
<p><img src="/posts/63a29b8e/image-20210316203312632.png" alt="image-20210316203312632"></p>
<p>demo2：</p>
<p><img src="/posts/63a29b8e/image-20210316203415021.png" alt="image-20210316203415021"></p>
<p>demo3：</p>
<p><img src="/posts/63a29b8e/image-20210316203445931.png" alt="image-20210316203445931"></p>
<p>demo4：</p>
<p><img src="/posts/63a29b8e/image-20210316203536971.png" alt="image-20210316203536971"></p>
<h3 id="对象指针"><a href="#对象指针" class="headerlink" title="对象指针"></a>对象指针</h3><p><img src="/posts/63a29b8e/image-20210316203610938.png" alt="image-20210316203610938"></p>
<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>作用基本同Java的this（这里其实没必要加上）</p>
<p><img src="/posts/63a29b8e/image-20210316203645915.png" alt="image-20210316203645915"></p>
<h2 id="7-向函数传递对象"><a href="#7-向函数传递对象" class="headerlink" title="7.向函数传递对象"></a>7.向函数传递对象</h2><p><img src="/posts/63a29b8e/image-20210316203831986.png" alt="image-20210316203831986"></p>
<p><img src="/posts/63a29b8e/image-20210316203924539.png" alt="image-20210316203924539"></p>
<h2 id="8-构造函数与析构函数的执行次序"><a href="#8-构造函数与析构函数的执行次序" class="headerlink" title="8.构造函数与析构函数的执行次序"></a>8.构造函数与析构函数的执行次序</h2><ul>
<li><p>构造函数在对象被创建时调用，析构函数在对象被删除前调用。</p>
</li>
<li><p>后调用的对象先调用析构函数，与构造函数的执行顺序相反。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Point(<span class="keyword">int</span> xx = <span class="number">0</span>, <span class="keyword">int</span> yy = <span class="number">0</span>) &#123; <span class="comment">// 构造函数</span></span><br><span class="line">		x = xx;</span><br><span class="line">		y = yy;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line">	&#125;</span><br><span class="line">    ~Point();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line">Point::~Point()&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;this:%d\n&quot;</span>,<span class="keyword">this</span>-&gt;x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Point p1(1,1), p2(2,2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">this:2</span></span><br><span class="line"><span class="comment">this:1*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++入门</tag>
      </tags>
  </entry>
  <entry>
    <title>C++入门笔记（九）</title>
    <url>/posts/81b972f6.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-纯虚函数与抽象类"><a href="#1-纯虚函数与抽象类" class="headerlink" title="1.纯虚函数与抽象类"></a>1.纯虚函数与抽象类</h2><h3 id="1-1纯虚函数"><a href="#1-1纯虚函数" class="headerlink" title="1.1纯虚函数"></a>1.1纯虚函数</h3><p><strong>首先：强调一个概念</strong></p>
<p>定义一个函数为虚函数，不代表函数为不被实现的函数。</p>
<p>定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。</p>
<p>定义一个函数为纯虚函数，才代表函数没有被实现。</p>
<p>定义纯虚函数是为了<strong>实现一个接口</strong>，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。</p>
<span id="more"></span>

<p><img src="/posts/81b972f6/image-20210415131524794.png" alt="image-20210415131524794"></p>
<h3 id="1-2抽象类"><a href="#1-2抽象类" class="headerlink" title="1.2抽象类"></a>1.2抽象类</h3><p>类似Java中抽象方法与抽象类的区别，只是在基类中说明，具体实现交给派生类。</p>
<p><img src="/posts/81b972f6/image-20210415131904033.png" alt="image-20210415131904033"></p>
<p><img src="/posts/81b972f6/image-20210415131917288.png" alt="image-20210415131917288"></p>
<h3 id="1-3应用抽象类建立栈与队列"><a href="#1-3应用抽象类建立栈与队列" class="headerlink" title="1.3应用抽象类建立栈与队列"></a>1.3应用抽象类建立栈与队列</h3><p>两种类型的表(list)：栈与队列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span>&#123;</span> <span class="comment">// 声明一个抽象类</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">list</span>* head; <span class="comment">// 表头指针</span></span><br><span class="line">        <span class="built_in">list</span>* tail; <span class="comment">// 表尾指针</span></span><br><span class="line">        <span class="built_in">list</span>* next;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="built_in">list</span>()&#123;</span><br><span class="line">            head=tail=next=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">(<span class="keyword">int</span> i)</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">retrieve</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span>:</span><span class="keyword">public</span> <span class="built_in">list</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">store</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">retrieve</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queue::store</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; <span class="comment">// 定义虚函数</span></span><br><span class="line">    <span class="built_in">list</span>* item;</span><br><span class="line">    item = <span class="keyword">new</span> <span class="built_in">queue</span>;</span><br><span class="line">    <span class="keyword">if</span> (!item)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Allocation error\n&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    item-&gt;num = i;</span><br><span class="line">    <span class="keyword">if</span> (tail) tail-&gt;next = item;</span><br><span class="line">    tail = item;</span><br><span class="line">    item-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!head) head = tail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue::retrieve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">list</span>* p;</span><br><span class="line">    <span class="keyword">if</span> (!head)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;list empty\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i = head-&gt;num;</span><br><span class="line">    p = head;</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stack</span>:</span><span class="keyword">public</span> <span class="built_in">list</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">store</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">retrieve</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stack::store</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>* item;</span><br><span class="line">    item = <span class="keyword">new</span> <span class="built_in">stack</span>;</span><br><span class="line">    <span class="keyword">if</span> (!item)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Allocation error\n&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    item-&gt;num = i;</span><br><span class="line">    <span class="keyword">if</span> (head) item-&gt;next = head;</span><br><span class="line">    head = item;</span><br><span class="line">    <span class="keyword">if</span> (!tail) tail = head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack::retrieve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">list</span>* p;</span><br><span class="line">    <span class="keyword">if</span> (!head)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;list empty\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i = head-&gt;num;</span><br><span class="line">    p = head;</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>* p; <span class="comment">// 定义指向抽象类list的指针p</span></span><br><span class="line">    <span class="built_in">queue</span> q_ob;</span><br><span class="line">    p = &amp;q_ob; <span class="comment">// p指向queue对象q_ob</span></span><br><span class="line">    p-&gt;store(<span class="number">1</span>);</span><br><span class="line">    p-&gt;store(<span class="number">2</span>);</span><br><span class="line">    p-&gt;store(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;queue:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i ++) <span class="built_in">cout</span> &lt;&lt; p-&gt;retrieve();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">stack</span> s_ob;</span><br><span class="line">    p = &amp;s_ob;</span><br><span class="line">    p-&gt;store(<span class="number">1</span>);</span><br><span class="line">    p-&gt;store(<span class="number">2</span>);</span><br><span class="line">    p-&gt;store(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;stack:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i ++) <span class="built_in">cout</span> &lt;&lt; p-&gt;retrieve();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++入门</tag>
        <tag>抽象类</tag>
      </tags>
  </entry>
  <entry>
    <title>C++入门笔记（二）</title>
    <url>/posts/2ebc38dc.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-内联函数"><a href="#1-内联函数" class="headerlink" title="1.内联函数"></a>1.内联函数</h2><p>声明内联函数使用inline关键字。</p>
<p>编译时在调用处用函数体进行替换，这样可以节省参数传递，控制转移等开销。</p>
<span id="more"></span>

<p><img src="/posts/2ebc38dc/image-20210203143637716.png" alt="image-20210203143637716"></p>
<p><strong>强调：inline只是对编译器的建议，具体如何处理取决于编译器。</strong></p>
<p>没有用inline修饰的函数也可能被编译为内联。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.1415926535798954</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">calArea</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> PI * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> r = <span class="number">3.0</span>;</span><br><span class="line">	<span class="keyword">double</span> area = calArea(r);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; area &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-constexpr函数（C-11新特性）"><a href="#2-constexpr函数（C-11新特性）" class="headerlink" title="2.constexpr函数（C++11新特性）"></a>2.constexpr函数（C++11新特性）</h2><p>constexpr：也即常量表达式。</p>
<p>语法规定：constexpr修饰的函数在其所有参数都是constexpr时一定返回constexpr。</p>
<p>C++11规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mf=<span class="number">20</span>;		<span class="comment">//20是常量表达式</span></span><br><span class="line">constexper <span class="keyword">int</span> limit=mf+<span class="number">1</span>;	<span class="comment">//mf+1是常量表达式</span></span><br><span class="line">constxper <span class="keyword">int</span> sz=size();	<span class="comment">//只有当size是一个constxper函数时才是一条正确的声明语句</span></span><br></pre></td></tr></table></figure>

<p>不能用普通函数作为constexpr变量的初始值，只能用constexpr函数去初始化constexpr变量。这种函数足够简单，以使得编译时就可以计算其结果。</p>
<p><strong>一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型。</strong></p>
<p>constexpr函数是指能用于常量表达式的函数。该函数要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">new_sz</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> foo = new_sz();</span><br></pre></td></tr></table></figure>

<p>在对变量foo初始化时，编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数。</p>
<p>constexpr函数体内也可以包含其它语句，只要这些语句在运行时不执行任何操作就行。例如，constexpr函数中可以有空语句、类型别名以及using声明。</p>
<h2 id="3-函数重载（重要）"><a href="#3-函数重载（重要）" class="headerlink" title="3.函数重载（重要）"></a>3.函数重载（重要）</h2><p><img src="/posts/2ebc38dc/image-20210203145400561.png" alt="image-20210203145400561"></p>
<p><img src="/posts/2ebc38dc/image-20210203145500712.png" alt="image-20210203145500712"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumOfSquare</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a * a + b * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两个函数同名，只是参数类型和返回类型不同，功能类似</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sumOfSquare</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a * a + b * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m, n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; sumOfSquare(m, n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">double</span> x, y;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; sumOfSquare(x, y) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-OOP的几大基本特点"><a href="#4-OOP的几大基本特点" class="headerlink" title="4.OOP的几大基本特点"></a>4.OOP的几大基本特点</h2><h3 id="4-1抽象"><a href="#4-1抽象" class="headerlink" title="4.1抽象"></a>4.1抽象</h3><p><img src="/posts/2ebc38dc/image-20210203150448563.png" alt="image-20210203150448563"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span> : <span class="comment">// 类的外部访问接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span> newH,<span class="keyword">int</span> newM,<span class="keyword">int</span> newS)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showTime</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>: <span class="comment">// 数据隐藏在类的内部</span></span><br><span class="line">    <span class="keyword">int</span> hour,minute,second;</span><br><span class="line">&#125;; <span class="comment">// 记得末尾的;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2封装"><a href="#4-2封装" class="headerlink" title="4.2封装"></a>4.2封装</h3><p><img src="/posts/2ebc38dc/image-20210203150758714.png" alt="image-20210203150758714"></p>
<h3 id="4-3继承"><a href="#4-3继承" class="headerlink" title="4.3继承"></a>4.3继承</h3><p>在已有类的基础上，进行扩展形成新的类。</p>
<h3 id="4-4多态"><a href="#4-4多态" class="headerlink" title="4.4多态"></a>4.4多态</h3><p>同一名称，采用不同的功能来实现。</p>
<p>目的：达到行为的标识统一，减少程序中标识符的个数。</p>
<h2 id="5-类和对象的定义"><a href="#5-类和对象的定义" class="headerlink" title="5.类和对象的定义"></a>5.类和对象的定义</h2><p>定义类的对象，才可以通过对象使用类中定义的功能。</p>
<h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><p><img src="/posts/2ebc38dc/image-20210203151526209.png" alt="image-20210203151526209"></p>
<p>无论数据成员还是函数成员都可以分成以上三大类。</p>
<p>在类的定义中，不同属性的成员可以按任意顺序出现，修饰访问属性的关键字也可以多次出现。</p>
<p><strong>但是一个成员只能有一种访问属性。</strong></p>
<h3 id="公有类型成员"><a href="#公有类型成员" class="headerlink" title="公有类型成员"></a>公有类型成员</h3><p>在关键字public后面声明，他们是类与外部的接口，任何外部函数都可以访问公有型数据和函数。</p>
<h3 id="私有类型成员"><a href="#私有类型成员" class="headerlink" title="私有类型成员"></a>私有类型成员</h3><p>在关键字private后面声明，只允许本类中的函数访问，而类外部的任何函数都不能访问。</p>
<p>如果紧跟在类名称的后面声明私有成员，则关键字private可以省略。</p>
<h3 id="保护类型成员"><a href="#保护类型成员" class="headerlink" title="保护类型成员"></a>保护类型成员</h3><p>与private类似，具体差别详见后面。</p>
<h3 id="定义对象"><a href="#定义对象" class="headerlink" title="定义对象"></a>定义对象</h3><p>语法格式： 类名  对象名;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Clock myClock;</span><br></pre></td></tr></table></figure>

<h3 id="访问成员"><a href="#访问成员" class="headerlink" title="访问成员"></a>访问成员</h3><p>类中成员之间可以直接使用，成员名互相访问。</p>
<p>从类外访问成员使用“对象名.成员名”方式来访问public成员。</p>
<h3 id="类的成员函数"><a href="#类的成员函数" class="headerlink" title="类的成员函数"></a>类的成员函数</h3><p>在类的成员函数中，可以访问到类的全部成员。</p>
<p><img src="/posts/2ebc38dc/image-20210203154639070.png" alt="image-20210203154639070"></p>
<p><img src="/posts/2ebc38dc/image-20210203154703412.png" alt="image-20210203154703412"></p>
<p>与普通函数不同的是，实现成员函数时要指明类的名称。可以在类的内部或者外部实现。</p>
<p>成员函数可以定义在类定义内部，或者单独使用<strong>范围解析运算符 ::</strong> 来定义。在类定义中定义的成员函数把函数声明为<strong>内联</strong>的，即便没有使用 inline 标识符。所以您可以按照如下方式定义 <code>getVolume()</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">double</span> length;      <span class="comment">// 长度</span></span><br><span class="line">      <span class="keyword">double</span> breadth;     <span class="comment">// 宽度</span></span><br><span class="line">      <span class="keyword">double</span> height;      <span class="comment">// 高度</span></span><br><span class="line">   </span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getVolume</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>您也可以在类的外部使用<strong>范围解析运算符 ::</strong> 定义该函数，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Box::getVolume</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span> newH = <span class="number">0</span>, <span class="keyword">int</span> newM = <span class="number">0</span>, <span class="keyword">int</span> newS = <span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showTime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">	<span class="keyword">int</span> hour, minute, second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clock::setTime</span><span class="params">(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS)</span> </span>&#123;</span><br><span class="line">	hour = newH;</span><br><span class="line">	minute = newM;</span><br><span class="line">	second = newS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clock::showTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; hour &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; minute &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Clock myClock;<span class="comment">// 定义对象</span></span><br><span class="line">	myClock.setTime(<span class="number">8</span>, <span class="number">30</span>, <span class="number">30</span>);<span class="comment">// 使用对象</span></span><br><span class="line">	myClock.showTime();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-构造函数"><a href="#6-构造函数" class="headerlink" title="6.构造函数"></a>6.构造函数</h2><p>构造函数时是类中的特殊成员函数，用于描述初始化算法。</p>
<p><strong>构造函数的作用就是在对象被创建时利用特定的值构造对象，将对象初始化为一个特定的状态。</strong></p>
<p><strong>与一般函数的重要区别</strong>：函数名与类名相同，不能定义返回值类型，没有return语句。</p>
<p><img src="/posts/2ebc38dc/image-20210204210411325.png" alt="image-20210204210411325"></p>
<p><img src="/posts/2ebc38dc/image-20210204210603157.png" alt="image-20210204210603157"></p>
<p>如果类中没有写构造函数，编译器会自动生成一个隐含的默认构造函数，该构造函数的参数列表和函数体皆为空。</p>
<p><img src="/posts/2ebc38dc/image-20210204211618472.png" alt="image-20210204211618472"></p>
<p><img src="/posts/2ebc38dc/image-20210204211726359.png" alt="image-20210204211726359"></p>
<h3 id="构造函数初始化列表"><a href="#构造函数初始化列表" class="headerlink" title="构造函数初始化列表"></a><strong>构造函数初始化列表</strong></h3><p>构造函数初始化列表以一个冒号开始，接着是以逗号分隔的数据成员列表，每个数据成员后面跟一个放在括号中的初始化式。</p>
<p><strong>对于const修饰的数据成员和引用类型的数据成员，不允许直接用赋值语句赋值</strong>，只能通过构造函数的初始化列表进行初始化。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">float</span> b;</span><br><span class="line">    <span class="comment">//构造函数初始化列表</span></span><br><span class="line">    CExample(): a(<span class="number">0</span>),b(<span class="number">8.8</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="comment">//构造函数内部赋值</span></span><br><span class="line">    CExample()</span><br><span class="line">    &#123;</span><br><span class="line">        a=<span class="number">0</span>;</span><br><span class="line">        b=<span class="number">8.8</span>;</span><br><span class="line">    &#125;<span class="comment">// 两个构造函数的结果是一样的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example 1</span></span><br><span class="line"><span class="comment">// 类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Clock(<span class="keyword">int</span> newH,<span class="keyword">int</span> newM,<span class="keyword">int</span> newS);<span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span> newH,<span class="keyword">int</span> newM,<span class="keyword">int</span> newS)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showTime</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> hour,minute,second;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 构造函数的实现1,初始化列表</span></span><br><span class="line">Clock::Clock(<span class="keyword">int</span> newH,<span class="keyword">int</span> newM,<span class="keyword">int</span> newS):</span><br><span class="line">hour(newH),minute(newM),second(newS)&#123;</span><br><span class="line">    <span class="comment">// 将newH赋值给hour初始化，等价于在函数体中对应赋值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造函数的实现2,一般方式，等价的</span></span><br><span class="line"><span class="comment">//Clock::Clock(int newH,int newM,int newS)&#123;</span></span><br><span class="line"><span class="comment">//    hour = newH;minute = newM;second = newS;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Clock <span class="title">c</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    c.showTime();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Clock(<span class="keyword">int</span> newH,<span class="keyword">int</span> newM,<span class="keyword">int</span> newS);</span><br><span class="line">    Clock();<span class="comment">// 默认构造函数，经验告诉我们最好加上</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span> newH,<span class="keyword">int</span> newM,<span class="keyword">int</span> newS)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showTime</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> hour,minute,second;</span><br><span class="line">&#125;;</span><br><span class="line">Clock::Clock():hour(<span class="number">0</span>),minute(<span class="number">0</span>),second(<span class="number">0</span>)&#123;&#125;<span class="comment">// 默认构造函数的实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Clock <span class="title">c1</span><span class="params">(<span class="number">8</span>,<span class="number">10</span>,<span class="number">0</span>)</span></span>;<span class="comment">// 调用有参数的构造函数</span></span><br><span class="line">    Clock c2;<span class="comment">// 调用无参数的构造函数</span></span><br><span class="line">    c1.showTime();</span><br><span class="line">    c2.showTime();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a><strong>委托构造函数</strong></h3><p>作用：省事，方便修改。在类的继承中会用到，子类的构造函数调用父类的构造函数。</p>
<p><img src="/posts/2ebc38dc/image-20210204220622695.png" alt="image-20210204220622695"></p>
<h3 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h3><p>系统会自动生成一个默认的复制构造函数，复制出完全相同的新对象。</p>
<p><img src="/posts/2ebc38dc/image-20210204221028604-1617715750285.png" alt="image-20210204221028604"></p>
<p>我们只能使用这里的引用进行复制，而不让它对指向的对象进行修改。</p>
<p>这样既能传参又能保证安全性。</p>
<p><img src="/posts/2ebc38dc/image-20210204221610258.png" alt="image-20210204221610258"></p>
<p><img src="/posts/2ebc38dc/image-20210204221758899.png" alt="image-20210204221758899"></p>
<p><img src="/posts/2ebc38dc/image-20210204222349707.png" alt="image-20210204222349707"></p>
<p>有点小难呢，举个栗子吧：</p>
<p><strong>调用复制构造函数的三种情况：</strong></p>
<p>（1）用类的一个对象去初始化另一个对象；</p>
<p>（2）如果函数的形参是类的对象，调用函数时，进行形参和实参的结合；</p>
<p>（3）如果函数的返回值是类的对象，函数执行完成返回调用者。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Point(<span class="keyword">int</span> xx = <span class="number">0</span>, <span class="keyword">int</span> yy = <span class="number">0</span>) &#123; <span class="comment">// 构造函数</span></span><br><span class="line">		x = xx;</span><br><span class="line">		y = yy;</span><br><span class="line">	&#125;</span><br><span class="line">	Point(<span class="keyword">const</span> Point&amp; p);<span class="comment">// 复制构造函数</span></span><br><span class="line">    <span class="comment">// 注意用const修饰，避免修改原对象</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point::Point(<span class="keyword">const</span> Point&amp; p) &#123;</span><br><span class="line">	x = p.x;</span><br><span class="line">	y = p.y;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Calling the copy constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; p.getX() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Point a;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Point a;<span class="comment">// 对象a</span></span><br><span class="line">	<span class="function">Point <span class="title">b</span><span class="params">(a)</span></span>;<span class="comment">// 情况1，用a初始化b，第一次调用复制构造函数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; b.getX() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	fun1(b);<span class="comment">// 情况2，对象b作为fun1的实参，第二次调用复制构造函数</span></span><br><span class="line">	b = fun2();<span class="comment">//  情况3，函数的返回值是类对象，第三次调用复制构造函数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; b.getX() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>情况3下，a是fun2()的局部对象，离开建立它的函数fun2后就消亡了，编译器在处理这种情况时会创建一个无名临时变量，生存期在<code>b = fun2();</code>中。</p>
<h2 id="7-析构函数"><a href="#7-析构函数" class="headerlink" title="7.析构函数"></a>7.析构函数</h2><p>它完成对象被删除前的一些清理工作。</p>
<p>如果程序中未声明析构函数，编译器会自动产生一个默认的构造函数，函数体为空。</p>
<p>它的名称由类名前加“~”构成，<strong>没有参数和返回值</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Point(<span class="keyword">int</span> xx = <span class="number">0</span>, <span class="keyword">int</span> yy = <span class="number">0</span>) &#123; <span class="comment">// 构造函数</span></span><br><span class="line">		x = xx;</span><br><span class="line">		y = yy;</span><br><span class="line">	&#125;</span><br><span class="line">    ~Point(); </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line">Point::~Point()&#123;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++入门</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>C++入门笔记（五）</title>
    <url>/posts/bb1147ac.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1常类型"><a href="#1常类型" class="headerlink" title="1常类型"></a>1常类型</h2><span id="more"></span>

<h3 id="1-1常引用"><a href="#1-1常引用" class="headerlink" title="1.1常引用"></a>1.1常引用</h3><p><img src="/posts/bb1147ac/image-20210326195826852.png" alt="image-20210326195826852"></p>
<p>如果用常引用作为形参，便不会修改实参。</p>
<h3 id="1-2常对象"><a href="#1-2常对象" class="headerlink" title="1.2常对象"></a>1.2常对象</h3><p><img src="/posts/bb1147ac/image-20210326203559729.png" alt="image-20210326203559729"></p>
<p><img src="/posts/bb1147ac/image-20210326203730026.png" alt="image-20210326203730026"></p>
<h3 id="1-3常对象成员"><a href="#1-3常对象成员" class="headerlink" title="1.3常对象成员"></a>1.3常对象成员</h3><h4 id="1-3-1常数据成员"><a href="#1-3-1常数据成员" class="headerlink" title="1.3.1常数据成员"></a>1.3.1常数据成员</h4><p><img src="/posts/bb1147ac/image-20210326203907290.png" alt="image-20210326203907290"></p>
<p>如果在一个类中声明了常数据成员，那么构造函数就只能通过成员初始化列表对该数据成员进行初始化，而其他任何函数都不能对该成员赋值。</p>
<p>一旦对常数据成员初始化后，它的值就不能改了。</p>
<h4 id="1-3-2常成员函数"><a href="#1-3-2常成员函数" class="headerlink" title="1.3.2常成员函数"></a>1.3.2常成员函数</h4><p><img src="/posts/bb1147ac/image-20210326204233223.png" alt="image-20210326204233223"></p>
<p>常成员函数的一个例子：库函数sort的重载cmp函数应该写出常成员函数。</p>
<p><img src="/posts/bb1147ac/image-20210326204455146.png" alt="image-20210326204455146"></p>
<p>常成员函数不能更新对象的数据成员，也不能调用该类中的普通成员函数，这就保证它就一定不会更新数据成员的值。</p>
<p><img src="/posts/bb1147ac/image-20210518090614849.png" alt="image-20210518090614849"></p>
<p><img src="/posts/bb1147ac/image-20210326204642137.png" alt="image-20210326204642137"></p>
<h2 id="2派生类与继承"><a href="#2派生类与继承" class="headerlink" title="2派生类与继承"></a>2派生类与继承</h2><p><img src="/posts/bb1147ac/image-20210326220105829.png" alt="image-20210326220105829"></p>
<p><strong>示例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; age &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; sex &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		<span class="built_in">string</span> name;</span><br><span class="line">		<span class="keyword">int</span> age;</span><br><span class="line">		<span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span> <span class="keyword">public</span> Person&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; department &lt;&lt; salary&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="built_in">string</span> department;</span><br><span class="line">		<span class="keyword">float</span> salary;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>protected关键字修饰保护数据成员，可以被本类的成员函数访问，也可以被本类的派生类的成员函数访问，类以外的任何访问都是非法的，它是半隐藏的。</p>
<p>Employee类（派生类，子类）继承了Person类（基类，父类），public代表公有继承。</p>
<p>如果不显式地给出继承方式，则默认为私有方式继承。</p>
<p><img src="/posts/bb1147ac/image-20210326205705011.png" alt="image-20210326205705011"></p>
<p>派生类把基类的全部成员（除构造函数和析构函数之外）接收过来。</p>
<p>调整从基类接收来的成员：</p>
<ul>
<li>一方面改变基类成员在派生类中的访问属性，主要通过派生类声明时的继承方式来控制；</li>
<li>另一方面对基类的成员进行重定义，在派生类中声明一个与基类成员同名的成员，这时会覆盖基类的成员。</li>
</ul>
<h3 id="2-1基类成员在派生类中的访问属性"><a href="#2-1基类成员在派生类中的访问属性" class="headerlink" title="2.1基类成员在派生类中的访问属性"></a><strong>2.1基类成员在派生类中的访问属性</strong></h3><p><img src="/posts/bb1147ac/image-20210326212627017.png" alt="image-20210326212627017"></p>
<h3 id="2-2派生类对基类成员的访问规则"><a href="#2-2派生类对基类成员的访问规则" class="headerlink" title="2.2派生类对基类成员的访问规则"></a><strong>2.2派生类对基类成员的访问规则</strong></h3><p>派生类对基类的访问形式主要有两种：</p>
<ul>
<li>内部访问：派生类中新增的成员函数对于基类继承来的成员的访问；</li>
<li>对象访问：在派生类外部，通过对象进行访问。</li>
</ul>
<h4 id="2-2-1私有继承的访问规则"><a href="#2-2-1私有继承的访问规则" class="headerlink" title="2.2.1私有继承的访问规则"></a>2.2.1私有继承的访问规则</h4><p><img src="/posts/bb1147ac/image-20210326214408609.png" alt="image-20210326214408609"></p>
<h4 id="2-2-2公有继承的访问规则"><a href="#2-2-2公有继承的访问规则" class="headerlink" title="2.2.2公有继承的访问规则"></a>2.2.2公有继承的访问规则</h4><p><img src="/posts/bb1147ac/image-20210326214426371.png" alt="image-20210326214426371"></p>
<h4 id="2-2-3保护继承的访问规则"><a href="#2-2-3保护继承的访问规则" class="headerlink" title="2.2.3保护继承的访问规则"></a>2.2.3保护继承的访问规则</h4><p><img src="/posts/bb1147ac/image-20210326214439701.png" alt="image-20210326214439701"></p>
<h3 id="2-3派生类构造和析构函数"><a href="#2-3派生类构造和析构函数" class="headerlink" title="2.3派生类构造和析构函数"></a>2.3派生类构造和析构函数</h3><p>创建对象：先执行基类构造函数，再执行派生类的构造函数；</p>
<p>销毁对象：先执行派生类的析构函数，再执行基类的析构函数。</p>
<p><img src="/posts/bb1147ac/image-20210326214829763.png" alt="image-20210326214829763"></p>
<p><img src="/posts/bb1147ac/image-20210326214944702.png" alt="image-20210326214944702"></p>
<h3 id="3多重继承"><a href="#3多重继承" class="headerlink" title="3多重继承"></a>3多重继承</h3><p><img src="/posts/bb1147ac/image-20210326215234476.png" alt="image-20210326215234476"></p>
<p><strong>多重继承的构造函数</strong></p>
<p><img src="/posts/bb1147ac/image-20210326215339284.png" alt="image-20210326215339284"></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++入门</tag>
      </tags>
  </entry>
  <entry>
    <title>C++入门笔记（八）</title>
    <url>/posts/fb7453a9.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-虚函数"><a href="#1-虚函数" class="headerlink" title="1.虚函数"></a>1.虚函数</h2><p>参考文章：<a href="https://www.jianshu.com/p/d07e0ac0ba3c?from=singlemessage">https://www.jianshu.com/p/d07e0ac0ba3c?from=singlemessage</a></p>
<p>在基类中，虚函数被virtual关键字修饰，并在派生类中重新被定义。</p>
<p>作用：允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类的同名函数。</p>
<p>虚函数与Java中的覆盖同属于运行（动态）多态。</p>
<span id="more"></span>

<p>与Java中的覆盖类似，在派生类重新定义时，函数原型（函数类型、函数名、参数个数和类型顺序），都必须与基类中的原型完全相同。</p>
<p>当一个成员函数被定义为虚函数之后，其派生类中符合虚函数特点的同名函数会自动成为虚函数，所以在派生类中重新定义虚函数时，virtual可以写或不写，但为了阅读方便，最好每一层都加上。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// 基类 Father</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Father::display()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在函数中调用了，子类覆盖基类的函数display()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fatherShowDisplay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类Son</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span><span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重写基类中的display()函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Son::display()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Son son;                    <span class="comment">// 子类对象</span></span><br><span class="line">    son.fatherShowDisplay();    <span class="comment">// 通过基类中未被覆盖的函数，想调用子类中覆盖的display函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与Java类似，如果父类中有m1，m2两个方法。子类覆盖了m2方法。那么如果调用m1，则m1中调用的m2会是子类中定义的m2。</p>
<p>虚函数必须是成员函数，且不能是友元函数或静态函数，因为它的调用依赖特定的对象来决定。</p>
<p><strong>通过对象名和点运算调用是静态联编，只有通过基类指针的方式才是运行多态。</strong></p>
<p><img src="/posts/fb7453a9/image-20210415115503800.png" alt="image-20210415115503800"></p>
<p>注意：上图不是虚函数，下图才是，两个对比来看。</p>
<p><img src="/posts/fb7453a9/image-20210415115608054.png" alt="image-20210415115608054"></p>
<p>对比上面两张图，一个定义虚函数，一个没有，很容易就理解虚函数的作用。</p>
<p>下图也是，左边定义了虚函数，右边没有定义。</p>
<p><img src="/posts/fb7453a9/image-20210415115650383.png" alt="image-20210415115650383"></p>
<p><img src="/posts/fb7453a9/image-20210415115658294.png" alt="image-20210415115658294"></p>
<p><img src="/posts/fb7453a9/image-20210415115705660.png" alt="image-20210415115705660"></p>
<h2 id="2-虚析构函数"><a href="#2-虚析构函数" class="headerlink" title="2.虚析构函数"></a>2.虚析构函数</h2><p><img src="/posts/fb7453a9/image-20210415124307380.png" alt="image-20210415124307380"></p>
<p>注意上图第二个例子，delete时只调用B的析构函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ~B()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;call ~B()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> B&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ~D()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;call ~D()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    D obj;</span><br><span class="line">    <span class="comment">/*call ~D()</span></span><br><span class="line"><span class="comment">	call ~B()*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先调用派生类的析构函数，再调用基类的析构函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ~B()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;call ~B()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> B&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ~D()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;call ~D()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B* p;</span><br><span class="line">    p = <span class="keyword">new</span> D; <span class="comment">// 基类指针p指向无名派生类对象</span></span><br><span class="line">    <span class="keyword">delete</span> p; <span class="comment">// 撤销无名对象，释放动态空间</span></span><br><span class="line">    <span class="comment">//call ~B()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/fb7453a9/image-20210415125758286.png" alt="image-20210415125758286"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~B()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;call ~B()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> B&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ~D()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;call ~D()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B* p;</span><br><span class="line">    p = <span class="keyword">new</span> D; <span class="comment">// 基类指针p指向无名派生类对象</span></span><br><span class="line">    <span class="keyword">delete</span> p; <span class="comment">// 撤销无名对象，释放动态空间</span></span><br><span class="line">    <span class="comment">/*call ~D()</span></span><br><span class="line"><span class="comment">    call ~B()*/</span></span><br><span class="line">    <span class="comment">// 通过虚析构函数实现了动态多态</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/fb7453a9/image-20210415130027582.png" alt="image-20210415130027582"></p>
<h2 id="3-虚函数与重载函数的关系"><a href="#3-虚函数与重载函数的关系" class="headerlink" title="3.虚函数与重载函数的关系"></a>3.虚函数与重载函数的关系</h2><p><img src="/posts/fb7453a9/image-20210415130603412.png" alt="image-20210415130603412"></p>
<p><img src="/posts/fb7453a9/image-20210415130624719.png" alt="image-20210415130624719"></p>
<h2 id="4-虚函数与多重继承"><a href="#4-虚函数与多重继承" class="headerlink" title="4.虚函数与多重继承"></a>4.虚函数与多重继承</h2><p><img src="/posts/fb7453a9/image-20210415130918576.png" alt="image-20210415130918576"></p>
<p><img src="/posts/fb7453a9/image-20210415131012252.png" alt="image-20210415131012252"></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++入门</tag>
        <tag>虚函数</tag>
      </tags>
  </entry>
  <entry>
    <title>C++入门笔记（六）</title>
    <url>/posts/de1f0c75.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-虚基类"><a href="#1-虚基类" class="headerlink" title="1.虚基类"></a>1.虚基类</h2><p>在多条继承路径上有一个公共的基类,在这些路径中的某几条汇合处，这个公共的基类就会产生多个实例(或多个副本)，若只想保存这个基类的一个实例，<strong>可以将这个公共基类说明为虚基类</strong>。</p>
<span id="more"></span>

<p><img src="/posts/de1f0c75/image-20210404174942521.png" alt="image-20210404174942521"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base0</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Base0(<span class="keyword">int</span> var):var0(var)&#123;&#125;</span><br><span class="line">        <span class="keyword">int</span> var0;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">fun0</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Member of Base0&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> Base0&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Base1(<span class="keyword">int</span> var):Base0(var)&#123;&#125;</span><br><span class="line">        <span class="keyword">int</span> var1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> Base0&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Base2(<span class="keyword">int</span> var):Base0(var)&#123;&#125;</span><br><span class="line">        <span class="keyword">int</span> var2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base1,<span class="keyword">public</span> Base2&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 需要给最远的基类Base0传参</span></span><br><span class="line">        Derived(<span class="keyword">int</span> var):Base0(var),Base1(var),Base2(var)&#123;&#125;</span><br><span class="line">        <span class="keyword">int</span> var;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Member of Derived&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    d.var0 = <span class="number">2</span>; <span class="comment">// 直接访问虚基类的数据成员</span></span><br><span class="line">    d.fun0(); <span class="comment">// 直接访问虚基类的函数成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建立对象时，<strong>由最远的派生类的构造函数调用虚基类的构造函数进行初始化。该派生类的其他基类对虚基类的构造函数的调用都自动忽略。</strong></p>
<p><strong>构造函数调用顺序</strong></p>
<ul>
<li><p>先调用虚基类的构造函数，再调用非虚基类的构造函数，最后调用派生类的构造函数</p>
</li>
<li><p>对于多个虚基类或非虚基类，先左后右，自上而下</p>
</li>
</ul>
<h2 id="2-基类与派生类对象之间的赋值兼容关系"><a href="#2-基类与派生类对象之间的赋值兼容关系" class="headerlink" title="2.基类与派生类对象之间的赋值兼容关系"></a>2.基类与派生类对象之间的赋值兼容关系</h2><p><strong>在需要基类对象的任何地方，都可以使用公有派生类的对象来替代。</strong></p>
<ol>
<li>派生类的对象可以隐含（自动）转换为基类对象</li>
<li>派生类的对象可以初始化基类的引用</li>
<li>派生类的指针可以隐含转换为基类的指针</li>
<li>若函数的形参是基类对象或基类对象的引用，在调用函数时可以用派生类对象作为实参</li>
</ol>
<p>在替代之后，派生类对象就可以作为基类对象使用，但只能使用从基类继承的成员。</p>
<p><img src="/posts/de1f0c75/image-20210404190957863.png" alt="image-20210404190957863"></p>
<h2 id="3-多态性"><a href="#3-多态性" class="headerlink" title="3.多态性"></a>3.多态性</h2><h3 id="3-1多态的分类"><a href="#3-1多态的分类" class="headerlink" title="3.1多态的分类"></a>3.1多态的分类</h3><p>C++里的多态包括了静态多态和动态多态。</p>
<p><img src="/posts/de1f0c75/image-20210404191316120.png" alt="image-20210404191316120"></p>
<p><img src="/posts/de1f0c75/image-20210404191332961.png" alt="image-20210404191332961"></p>
<h3 id="3-2运算符重载（重要）"><a href="#3-2运算符重载（重要）" class="headerlink" title="3.2运算符重载（重要）"></a>3.2运算符重载（重要）</h3><p>运算符重载通过创建<u>运算符重载函数</u>来实现，包括：类外的普通函数、类的成员函数和友元函数。</p>
<p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Box <span class="keyword">operator</span>+(<span class="keyword">const</span> Box&amp;);</span><br></pre></td></tr></table></figure>

<p>声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Box <span class="keyword">operator</span>+(<span class="keyword">const</span> Box&amp;, <span class="keyword">const</span> Box&amp;);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作为类成员函数的运算符重载函数</span></span><br><span class="line"><span class="comment">// 重载 + 运算符，用于把两个 Box 对象相加</span></span><br><span class="line">Box <span class="keyword">operator</span>+(<span class="keyword">const</span> Box&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    Box box;</span><br><span class="line">    box.length = <span class="keyword">this</span>-&gt;length + b.length;</span><br><span class="line">    box.breadth = <span class="keyword">this</span>-&gt;breadth + b.breadth;</span><br><span class="line">    box.height = <span class="keyword">this</span>-&gt;height + b.height;</span><br><span class="line">    <span class="keyword">return</span> box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把两个对象相加，得到 Box3</span></span><br><span class="line">Box3 = Box1 + Box2;</span><br></pre></td></tr></table></figure>

<h4 id="可重载运算符-不可重载运算符"><a href="#可重载运算符-不可重载运算符" class="headerlink" title="可重载运算符/不可重载运算符"></a>可重载运算符/不可重载运算符</h4><p>下面是可重载的运算符列表：</p>
<table>
<thead>
<tr>
<th>双目算术运算符</th>
<th>+ (加)，-(减)，*(乘)，/(除)，% (取模)</th>
</tr>
</thead>
<tbody><tr>
<td>关系运算符</td>
<td>==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于)，&lt;=(小于等于)，&gt;=(大于等于)</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>||(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)</td>
</tr>
<tr>
<td>单目运算符</td>
<td>+ (正)，-(负)，*(指针)，&amp;(取地址)</td>
</tr>
<tr>
<td>自增自减运算符</td>
<td>++(自增)，–(自减)</td>
</tr>
<tr>
<td>位运算符</td>
<td>| (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>=, +=, -=, *=, /= , % = , &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;=</td>
</tr>
<tr>
<td>空间申请与释放</td>
<td>new, delete, new[ ] , delete[]</td>
</tr>
<tr>
<td>其他运算符</td>
<td><code>()</code>(函数调用)，<code>-&gt;</code>(成员访问)，<code>,</code>(逗号)，<code>[]</code>(下标)</td>
</tr>
</tbody></table>
<p>下面是不可重载的运算符列表：</p>
<ul>
<li><code>.</code>：成员访问运算符</li>
<li><code>.*</code>,<code> -&gt;*</code>：成员指针访问运算符</li>
<li><code>::</code>：域运算符</li>
<li><code>sizeof</code>：长度运算符</li>
<li><code>?:</code>：条件运算符</li>
<li><code>#</code>： 预处理符号</li>
</ul>
<p>补充：</p>
<p><img src="/posts/de1f0c75/image-20210412125715522.png" alt="image-20210412125715522"></p>
<p><img src="/posts/de1f0c75/image-20210412125814210.png" alt="image-20210412125814210"></p>
<p><img src="/posts/de1f0c75/image-20210412125906936.png" alt="image-20210412125906936"></p>
<h4 id="对于-和-的重载"><a href="#对于-和-的重载" class="headerlink" title="对于++和- -的重载"></a>对于++和- -的重载</h4><p>前缀形式重载调用 Check operator ++ () ，后缀形式重载调用 operator ++ (int)。</p>
<p>后缀形式中的int形参不起任何作用，只是为了区分前置和后置++或- -。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重载前缀递增运算符（ ++ ）</span></span><br><span class="line">Time <span class="keyword">operator</span>++ ()  </span><br><span class="line">&#123;</span><br><span class="line">    ++minutes;          <span class="comment">// 对象加 1</span></span><br><span class="line">    <span class="keyword">if</span>(minutes &gt;= <span class="number">60</span>)  </span><br><span class="line">    &#123;</span><br><span class="line">        ++hours;</span><br><span class="line">        minutes -= <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Time(hours, minutes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载后缀递增运算符（ ++ ）</span></span><br><span class="line">Time <span class="keyword">operator</span>++( <span class="keyword">int</span> )         </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 保存原始值</span></span><br><span class="line">    <span class="function">Time <span class="title">T</span><span class="params">(hours, minutes)</span></span>;</span><br><span class="line">    <span class="comment">// 对象加 1</span></span><br><span class="line">    ++minutes;                    </span><br><span class="line">    <span class="keyword">if</span>(minutes &gt;= <span class="number">60</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ++hours;</span><br><span class="line">        minutes -= <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回旧的原始值</span></span><br><span class="line">    <span class="keyword">return</span> T; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/de1f0c75/image-20210518092650383.png" alt="image-20210518092650383"></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++入门</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title>C++入门笔记（十一）</title>
    <url>/posts/cbdb2df7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-异常处理"><a href="#1-异常处理" class="headerlink" title="1.异常处理"></a>1.异常处理</h2><p>C++处理异常的机制由：检查、抛出和捕获组成，与其他语言类似。</p>
<p>分别由3种语句完成：try、throw、和catch。</p>
<span id="more"></span>

<p><img src="/posts/cbdb2df7/image-20210416223423799.png" alt="image-20210416223423799"></p>
<p><img src="/posts/cbdb2df7/image-20210416223434097.png" alt="image-20210416223434097"></p>
<p>异常处理的例子：</p>
<p><img src="/posts/cbdb2df7/image-20210416223616929.png" alt="image-20210416223616929"> <img src="/posts/cbdb2df7/image-20210416223812578.png" alt="image-20210416223812578"></p>
<h2 id="2-C-为什么要建立自己的I-O系统"><a href="#2-C-为什么要建立自己的I-O系统" class="headerlink" title="2.C++为什么要建立自己的I/O系统"></a>2.C++为什么要建立自己的I/O系统</h2><p><img src="/posts/cbdb2df7/image-20210428132831602.png" alt="image-20210428132831602"></p>
<p><img src="/posts/cbdb2df7/image-20210428132843718.png" alt="image-20210428132843718"></p>
<h2 id="3-C-的输入输出流"><a href="#3-C-的输入输出流" class="headerlink" title="3.C++的输入输出流"></a>3.C++的输入输出流</h2><p>在C++中,<strong>“流”指的是数据从一个源流到一个目的的抽象</strong>,它负责在数据的生产者(源)和数据的消费者(目的)</p>
<p>之间建立联系,并管理数据的流动。</p>
<p>从流中提取数据称为输入操作；向流中添加数据称为输出操作。</p>
<p>C++编译系统带有一个<strong>I/O流类库</strong>。在I/O流类库中包含许多用于输入输出的类,称为流类。用流类定义的对象称</p>
<p>为<strong>流对象</strong>。</p>
<p><img src="/posts/cbdb2df7/image-20210428133057533.png" alt="image-20210428133057533"></p>
<p>I/O流类库中包含了许多用于输入输出操作的类,</p>
<p> ios是抽象基类,输入流类istream和输出流类ostream是通过单继承从基类ios派生而来的,</p>
<p>输入输出流类iostream是通过多继承从类istream和ostream派生而来的。</p>
<p><img src="/posts/cbdb2df7/image-20210428133204523.png" alt="image-20210428133204523"></p>
<ul>
<li>标准输入流 (流对象) cin</li>
<li>标准输出流(流对象) cout</li>
<li>非缓冲型的标准出错流 (流对象) cerr（简单了解）</li>
<li>缓冲型的标准出错流 (流对象) clog（简单了解）</li>
</ul>
<p><img src="/posts/cbdb2df7/image-20210428133318072.png" alt="image-20210428133318072"></p>
<h2 id="4-输入输出流的成员函数"><a href="#4-输入输出流的成员函数" class="headerlink" title="4.输入输出流的成员函数"></a>4.输入输出流的成员函数</h2><p><img src="/posts/cbdb2df7/image-20210428133504829.png" alt="image-20210428133504829"></p>
<p><img src="/posts/cbdb2df7/image-20210428133515520.png" alt="image-20210428133515520"></p>
<p><img src="/posts/cbdb2df7/image-20210428133527883.png" alt="image-20210428133527883"></p>
<p><img src="/posts/cbdb2df7/image-20210428133559247.png" alt="image-20210428133559247"></p>
<p><img src="/posts/cbdb2df7/image-20210428133616059.png" alt="image-20210428133616059"></p>
<p><img src="/posts/cbdb2df7/image-20210428133630746.png" alt="image-20210428133630746"></p>
<p><img src="/posts/cbdb2df7/image-20210428133645045.png" alt="image-20210428133645045"></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++入门</tag>
        <tag>异常</tag>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title>C++入门笔记（十二）</title>
    <url>/posts/fbcdc12f.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-输入输出运算符的实现原理"><a href="#1-输入输出运算符的实现原理" class="headerlink" title="1.输入输出运算符的实现原理"></a>1.输入输出运算符的实现原理</h2><p><strong>对输入输出运算符的重载是关键知识点。</strong></p>
<span id="more"></span>

<p><img src="/posts/fbcdc12f/image-20210428134441249.png" alt="image-20210428134441249"></p>
<p><img src="/posts/fbcdc12f/image-20210428134501051.png" alt="image-20210428134501051"></p>
<p><img src="/posts/fbcdc12f/image-20210428134708619.png" alt="image-20210428134708619"></p>
<p><img src="/posts/fbcdc12f/image-20210428134723588.png" alt="image-20210428134723588"></p>
<h2 id="2-预定义的操纵符输入输出格式控制"><a href="#2-预定义的操纵符输入输出格式控制" class="headerlink" title="2.预定义的操纵符输入输出格式控制"></a>2.预定义的操纵符输入输出格式控制</h2><p>除了操纵符，还有<strong>流成员函数</strong>可以控制输入输出格式，这里就不说了。</p>
<p>有关C++输入输出的完整内容可以参考<a href="https://www.runoob.com/cplusplus/cpp-basic-input-output.html">菜鸟教程</a>。</p>
<p><img src="/posts/fbcdc12f/image-20210428140029182.png" alt="image-20210428140029182"></p>
<p><img src="/posts/fbcdc12f/image-20210428140136067.png" alt="image-20210428140136067"></p>
<p><img src="/posts/fbcdc12f/image-20210428140208904.png" alt="image-20210428140208904"></p>
<p><img src="/posts/fbcdc12f/image-20210428140236225.png" alt="image-20210428140236225"></p>
<h2 id="3-自定义操纵符输入输出格式控制"><a href="#3-自定义操纵符输入输出格式控制" class="headerlink" title="3.自定义操纵符输入输出格式控制"></a>3.自定义操纵符输入输出格式控制</h2><p><img src="/posts/fbcdc12f/image-20210428135006688.png" alt="image-20210428135006688"></p>
<p><img src="/posts/fbcdc12f/image-20210428135030374.png" alt="image-20210428135030374"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入流操纵符函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">istream&amp; <span class="title">input</span><span class="params">(istream&amp; in)</span></span>&#123;</span><br><span class="line">    in &gt;&gt; hex;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter number using hex format:&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; input &gt;&gt; i;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hex:&quot;</span> &lt;&lt; hex &lt;&lt; i &lt;&lt; <span class="string">&quot;-----dec:&quot;</span> &lt;&lt; dec &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Enter number using hex format:23ae</span></span><br><span class="line"><span class="comment">hex:23ae-----dec:9134*/</span></span><br></pre></td></tr></table></figure>

<h2 id="4-重载输入输出运算符"><a href="#4-重载输入输出运算符" class="headerlink" title="4.重载输入输出运算符"></a>4.重载输入输出运算符</h2><p>注意：</p>
<p><strong>重载输入输出运算符不能是所操作类的成员函数，但可以是该类的友元函数或普通函数。</strong><img src="/posts/fbcdc12f/image-20210428141954272.png" alt="image-20210428141954272"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重载插入运算符</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coord</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Coord(<span class="keyword">int</span> i = <span class="number">0</span>,<span class="keyword">int</span> j = <span class="number">0</span>)&#123;</span><br><span class="line">        x = i,y = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; stream,Coord&amp; ob);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; stream,Coord&amp; ob)&#123;</span><br><span class="line">    stream &lt;&lt; ob.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; ob.y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Coord a(55,56),b(100,200);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/fbcdc12f/image-20210428142554403.png" alt="image-20210428142554403"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// // 重载插入与提取运算符</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Three_d</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Three_d(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)&#123;</span><br><span class="line">        x = a,y = b,z = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; output,Three_d ob);</span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt; (istream&amp; input,Three_d&amp; ob);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; output,Three_d ob)&#123;</span><br><span class="line">    output &lt;&lt; ob.x &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    output &lt;&lt; ob.y &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    output &lt;&lt; ob.z &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt; (istream&amp; input,Three_d&amp; ob)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter x,y,z value:&quot;</span>;</span><br><span class="line">    input &gt;&gt; ob.x;</span><br><span class="line">    input &gt;&gt; ob.y;</span><br><span class="line">    input &gt;&gt; ob.z;</span><br><span class="line">    <span class="keyword">return</span> input;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Three_d <span class="title">obj</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; obj;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; obj;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-文件的输入输出"><a href="#5-文件的输入输出" class="headerlink" title="5.文件的输入输出"></a>5.文件的输入输出</h2><p>文件的两种形式：</p>
<p><img src="/posts/fbcdc12f/image-20210428143750640.png" alt="image-20210428143750640"></p>
<p>为什么文本形式会多一个字节？</p>
<p>因为要做一些转码处理，换行转为回车换行。</p>
<p><img src="/posts/fbcdc12f/image-20210428144315193.png" alt="image-20210428144315193"></p>
<p><img src="/posts/fbcdc12f/image-20210428144339078.png" alt="image-20210428144339078"></p>
<p><img src="/posts/fbcdc12f/image-20210428144432437.png" alt="image-20210428144432437"></p>
<p><img src="/posts/fbcdc12f/image-20210428144447690.png" alt="image-20210428144447690"></p>
<p><img src="/posts/fbcdc12f/image-20210428144508143.png" alt="image-20210428144508143"></p>
<p>文件的关闭：<code>out.close();</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 写文件与读文件</span></span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;f2.txt&quot;</span>)</span></span>;<span class="comment">// 不存在会新建</span></span><br><span class="line">    <span class="keyword">if</span> (!fout)&#123; <span class="comment">// 文件打开失败时fout返回0</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cannot open output file\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fout &lt;&lt; <span class="number">10</span> &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt;hex&lt;&lt;<span class="number">100</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    fout.close();</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">&quot;f2.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!fin)&#123; <span class="comment">// 文件打开失败时fin返回0</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cannot open input file\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">80</span>];</span><br><span class="line">    <span class="keyword">while</span> (fin)&#123;</span><br><span class="line">        fin.getline(str,<span class="number">80</span>);<span class="comment">// 读入信息赋值给str</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fin.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">10 64\n*/</span></span><br></pre></td></tr></table></figure>

<p>提一点，C++的多行注释最好写成<code>/**/</code>，而不要写成<code>//</code>。在某种情况下，注释会与“/”产生一些奇怪的BUG。</p>
<h2 id="6-命名空间"><a href="#6-命名空间" class="headerlink" title="6.命名空间"></a>6.命名空间</h2><p>也就是namespace。</p>
<p><img src="/posts/fbcdc12f/image-20210428150001654.png" alt="image-20210428150001654"></p>
<p><img src="/posts/fbcdc12f/image-20210428150013044.png" alt="image-20210428150013044"></p>
<p><img src="/posts/fbcdc12f/image-20210428150026666.png" alt="image-20210428150026666"></p>
<p><img src="/posts/fbcdc12f/image-20210428150050936.png" alt="image-20210428150050936"></p>
<p><img src="/posts/fbcdc12f/image-20210428150114048.png" alt="image-20210428150114048"></p>
<h2 id="7-补充"><a href="#7-补充" class="headerlink" title="7.补充"></a>7.补充</h2><p>C++入门笔记系列就到这结束了！</p>
<p>大佬两万字总结《C++ Primer》要点：<a href="https://mp.weixin.qq.com/s/05IdvsA3NtOJwheu1ljqSQ">https://mp.weixin.qq.com/s/05IdvsA3NtOJwheu1ljqSQ</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++入门</tag>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title>C++入门笔记（十）</title>
    <url>/posts/48b5732.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-什么是模板"><a href="#1-什么是模板" class="headerlink" title="1.什么是模板"></a>1.什么是模板</h2><p><img src="/posts/48b5732/image-20210416202641797.png" alt="image-20210416202641797"></p>
<span id="more"></span>

<p>为什么要使用模板？</p>
<p>因为使用重载还是有重复代码，使用模板可以写一个通用的函数适用多种不同的数据类型。</p>
<p><img src="/posts/48b5732/image-20210416213008855.png" alt="image-20210416213008855"></p>
<h2 id="2-函数模板与模板函数"><a href="#2-函数模板与模板函数" class="headerlink" title="2.函数模板与模板函数"></a>2.函数模板与模板函数</h2><p><strong>函数模板</strong>就是建立一个通用函数，其函数返回类型和形参类型不具体指定，用一个虚拟类型来代表。</p>
<p>在调用函数时系统会根据实参的类型（模板实参）来取代模板中的虚拟类型从而实现不同的函数功能。</p>
<p><img src="/posts/48b5732/image-20210416213921364.png" alt="image-20210416213921364"></p>
<p>使用函数模板时必须将类型参数实例化，类型参数前要加上关键字typename或者class，推荐加上typename，class容易与类搞混。</p>
<p><strong>typename后面的类型参数必须实例化。</strong></p>
<p><img src="/posts/48b5732/image-20210416215058349.png" alt="image-20210416215058349"></p>
<p><img src="/posts/48b5732/image-20210416215118498.png" alt="image-20210416215118498"></p>
<p><strong>实际上函数模板提供了一类函数的抽象，它经过实例化而生成的具体函数成为模板函数。</strong></p>
<p><img src="/posts/48b5732/image-20210416215300861.png" alt="image-20210416215300861"></p>
<p>定义两种类型参数的函数模板：</p>
<p><img src="/posts/48b5732/image-20210416215736766.png" alt="image-20210416215736766"></p>
<p>注意点：</p>
<p><img src="/posts/48b5732/image-20210416215654841.png" alt="image-20210416215654841"></p>
<p>重载的函数模板例子：</p>
<p><img src="/posts/48b5732/image-20210416215918724.png" alt="image-20210416215918724"></p>
<p>函数模板与同名的非模板函数也能重载。</p>
<p>这时的调用顺序是：先寻找一个参数完全匹配的非模板函数，找到了就调用它，否则寻找一个匹配的函数模板，实例化产生模板函数，调用它。</p>
<p><img src="/posts/48b5732/image-20210416220231627.png" alt="image-20210416220231627"></p>
<h2 id="3-类模板与模板类"><a href="#3-类模板与模板类" class="headerlink" title="3.类模板与模板类"></a>3.类模板与模板类</h2><p><strong>类模板</strong>就是建立一个通用类，其数据成员、成员函数的返回类型和形参类型不具体指定，用一个虚拟类型来代表。使用类模板定义对象时，系统会根据实参的类型来取代模板中的虚拟类型从而实现了不同类的功能。</p>
<p><img src="/posts/48b5732/image-20210416220749449.png" alt="image-20210416220749449"></p>
<p>还是建议使用typename关键字。</p>
<p><img src="/posts/48b5732/image-20210416222050662.png" alt="image-20210416222050662"></p>
<p><img src="/posts/48b5732/image-20210416222039232.png" alt="image-20210416222039232"></p>
<p><img src="/posts/48b5732/image-20210416222122639.png" alt="image-20210416222122639"></p>
<p>用数组实现的栈的例子：</p>
<p><img src="/posts/48b5732/image-20210416222507375.png" alt="image-20210416222507375"></p>
<p>含有两个类型参数的模板类的例子：</p>
<p><img src="/posts/48b5732/image-20210416222605659.png" alt="image-20210416222605659"></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++入门</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>C++入门笔记（四）</title>
    <url>/posts/d48f82eb.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-静态成员"><a href="#1-静态成员" class="headerlink" title="1.静态成员"></a>1.静态成员</h2><h3 id="1-1静态数据成员"><a href="#1-1静态数据成员" class="headerlink" title="1.1静态数据成员"></a>1.1静态数据成员</h3><p>在某些情况下，我们需要在类中使用作用类似全局变量的变量，这时会用到静态数据成员。</p>
<p>静态数据成员类似于Java中的类变量（静态变量），随类一起加载。</p>
<span id="more"></span>

<p>OOP中有着”类属性“的概念。<strong>也就是说，如果某个属性为整个类所共有，不属于任何一个具体的对象，则采用static关键字修饰。</strong></p>
<p>静态成员在每一个类只有一个副本，有该类的所有对象共同维护和使用，从而实现同一类不同对象的数据共享。</p>
<ul>
<li>如何初始化静态数据成员？</li>
</ul>
<p>它的初始化应在类外单独进行，而且应在定义对象之前。一般在main函数之前和定义对象之后初始化。</p>
<p>语法：<code>int Student::count = 0;</code> –&gt; 数据类型   类名：：静态数据成员名   =   初始值；</p>
<ul>
<li>如何访问静态数据成员？</li>
</ul>
<p>1.类名：：静态数据成员名</p>
<p>2.对象名.静态数据成员名</p>
<p>3.对象指针-&gt;静态数据成员名</p>
<p>注意：私有静态数据成员不能在类外直接访问，必须通过公有的（静态）成员函数访问。</p>
<p><strong>示例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Student()&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入学生的学号、姓名、成绩：\n&quot;</span>;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; id &gt;&gt; name &gt;&gt; score;</span><br><span class="line">			stuNum ++;</span><br><span class="line">			sumScore += score;</span><br><span class="line">			averScore = sumScore/stuNum;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">showIfmation</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; id +<span class="string">&quot; &quot;</span>+name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showsumScore</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; stuNum&lt;&lt;<span class="string">&quot;个学生的总分为:&quot;</span>&lt;&lt;sumScore &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showaverScore</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; stuNum&lt;&lt;<span class="string">&quot;个学生的平均为:&quot;</span>&lt;&lt;averScore &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		~Student()&#123;</span><br><span class="line">			stuNum--;</span><br><span class="line">			sumScore -= score;</span><br><span class="line">			averScore = sumScore/stuNum;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="built_in">string</span> name,id;</span><br><span class="line">		<span class="keyword">double</span> score; </span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">int</span> stuNum;</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">double</span> sumScore,averScore;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 静态数据成员初始化 </span></span><br><span class="line"><span class="keyword">int</span> Student::stuNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> Student::sumScore = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">double</span> Student::averScore = <span class="number">0.0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Student s1,s2,s3;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;学生信息为：\n&quot;</span>;</span><br><span class="line">	s1.showIfmation();</span><br><span class="line">	s2.showIfmation();</span><br><span class="line">	s3.showIfmation();</span><br><span class="line">	Student::showsumScore();</span><br><span class="line">	s1.showsumScore();<span class="comment">// 两种访问静态数据成员方式</span></span><br><span class="line">	Student::showaverScore();</span><br><span class="line">	s3.showaverScore();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2静态成员函数"><a href="#1-2静态成员函数" class="headerlink" title="1.2静态成员函数"></a>1.2静态成员函数</h3><p><img src="/posts/d48f82eb/image-20210326185129994.png" alt="image-20210326185129994"></p>
<p><strong>示例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Cat(<span class="keyword">double</span> w);</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">total_disp</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">double</span> weight;</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">double</span> total_weight;</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">double</span> total_number;</span><br><span class="line">&#125;;</span><br><span class="line">Cat::Cat(<span class="keyword">double</span> w)&#123;</span><br><span class="line">	weight = w;</span><br><span class="line">	total_weight += w;</span><br><span class="line">	total_number ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cat::display</span><span class="params">()</span></span>&#123; <span class="comment">// 定义静态成员函数不需要加上static</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;This cat&#x27;s weight is:&quot;</span> &lt;&lt; weight &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cat::total_disp</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;total_number is:&quot;</span>&lt;&lt;total_number&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;total_weight is:&quot;</span>&lt;&lt;total_weight&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> Cat::total_weight = <span class="number">0</span>; <span class="comment">// 静态数据成员初始化</span></span><br><span class="line"><span class="keyword">double</span> Cat::total_number = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Cat w1(0.5),w2(0.6);</span><br><span class="line">	w1.display();</span><br><span class="line">	w2.display();</span><br><span class="line">	Cat::total_disp();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>补充说明</strong></p>
<ol>
<li>一般情形，用于访问静态数据成员；</li>
<li>私有静态成员函数不能做类外的函数和对象访问；</li>
<li>使用静态成员函数的一个原因是，可以用在建立对象之前调用它，已处理静态数据成员；</li>
<li>编译系统将静态成员函数限定为内部链接，与其他文件中的同名函数不会冲突；</li>
<li>静态成员函数与非静态成员函数的重要区别：前者没有this指针，而后者有this指针。</li>
</ol>
<h2 id="2友元函数"><a href="#2友元函数" class="headerlink" title="2友元函数"></a>2友元函数</h2><p>类的主要特点之一就是隐藏和封装。C++中的友元为数据隐藏这堵不透明的墙开了一个小洞，也就是一扇通向私有（保护）成员的后门。</p>
<p><img src="/posts/d48f82eb/image-20210326193745049.png" alt="image-20210326193745049"></p>
<p>友元函数不是当前类的成员函数，但它可以访问该类所有成员。</p>
<p><strong>示例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Girl(<span class="built_in">string</span> n,<span class="keyword">int</span> d):</span><br><span class="line">		name(n),age(d)&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">disp</span><span class="params">(Girl&amp;)</span></span>;<span class="comment">// 声明友元函数</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="built_in">string</span> name;</span><br><span class="line">		<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disp</span><span class="params">(Girl&amp; x)</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;girl&#x27;s name is:&quot;</span> &lt;&lt; x.name &lt;&lt; <span class="string">&quot;,age is:&quot;</span> &lt;&lt; x.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Girl <span class="title">g</span><span class="params">(<span class="string">&quot;xiaoli&quot;</span>,<span class="number">18</span>)</span></span>;</span><br><span class="line">	disp(g);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>补充说明</strong></p>
<ol>
<li>在类的外部定义友元函数时，不必像成员函数那样加上<code>类名::</code>；</li>
<li>友元函数不是类的成员，<strong>不能直接访问对象的数据成员</strong>，也不能通过this指针访问，它必须通过作为入口参数传递进来的对象名（或对象指针、引用）来访问该对象的数据成员；</li>
</ol>
<h2 id="3类的组合"><a href="#3类的组合" class="headerlink" title="3类的组合"></a>3类的组合</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Score</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Score(<span class="keyword">double</span> c = <span class="number">0</span>,<span class="keyword">double</span> m = <span class="number">0</span>,<span class="keyword">double</span> e = <span class="number">0</span>);</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">double</span> chinese,math,english;</span><br><span class="line">&#125;;</span><br><span class="line">Score::Score(<span class="keyword">double</span> c,<span class="keyword">double</span> m,<span class="keyword">double</span> e):</span><br><span class="line">	chinese(c),math(m),english(e)&#123;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Score::show</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;chinese:&quot;</span>&lt;&lt;chinese &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;math:&quot;</span>&lt;&lt;math &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;english:&quot;</span>&lt;&lt;english&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Student(<span class="built_in">string</span> n,<span class="built_in">string</span> i,<span class="keyword">double</span> a,<span class="keyword">double</span> b,<span class="keyword">double</span> c);</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="built_in">string</span> name,id;</span><br><span class="line">		Score s;</span><br><span class="line">&#125;;</span><br><span class="line">Student::Student(<span class="built_in">string</span> n,<span class="built_in">string</span> i,<span class="keyword">double</span> a,<span class="keyword">double</span> b,<span class="keyword">double</span> c):</span><br><span class="line">	name(n),id(i),s(a,b,c)&#123; <span class="comment">// 注意这里的初始化列表</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::show</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;id:&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	s.show();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Student <span class="title">s1</span><span class="params">(<span class="string">&quot;小明&quot;</span>,<span class="string">&quot;1001&quot;</span>,<span class="number">97</span>,<span class="number">78</span>,<span class="number">81</span>)</span></span>;</span><br><span class="line">	s1.show();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用构造函数时：先对内部嵌套对象按照声明顺序调用，最后调用类的构造函数；</p>
<p>调用析构函数时：与构造函数顺序相反。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++入门</tag>
      </tags>
  </entry>
  <entry>
    <title>C++的输入输出速度比较</title>
    <url>/posts/48fab36.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>下面对C++中的一些常用输入输出方式速度进行比较。</p>
<span id="more"></span>

<p>众所周知，使用printf/scanf的速度会比cin/cout快上不少。</p>
<p>关于输出换行（回车）的几种方式：</p>
<p>1.cout &lt;&lt; endl;</p>
<p>2.puts(“”);</p>
<p>3.printf(“\n”);</p>
<p>4.putchar(10);</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1290ms</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 19ms</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 10ms</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 10ms</span></span><br></pre></td></tr></table></figure>

<p>结论：</p>
<p><code>printf(&quot;\n&quot;);</code>和<code>putchar(10);</code>最快，两者差距不大；</p>
<p><code>puts(&quot;&quot;);</code>比上面的稍慢；</p>
<p><code>cout &lt;&lt; endl;</code>最慢，用时较长。</p>
<p>据大佬总结的endl的好处：</p>
<ul>
<li>endl好处是能一直刷新流，因为要刷新适合一些交互题；</li>
<li>而且如果是大工程，endl更容易方便debug</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++竞赛语法总结（一）</title>
    <url>/posts/5397030f.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="0-C-语法知识长文总结"><a href="#0-C-语法知识长文总结" class="headerlink" title="0.C++语法知识长文总结"></a>0.C++语法知识长文总结</h2><p><a href="https://www.acwing.com/solution/content/44372/">https://www.acwing.com/solution/content/44372/</a></p>
<h2 id="1-acwing656-钞票和硬币"><a href="#1-acwing656-钞票和硬币" class="headerlink" title="1.acwing656.钞票和硬币"></a>1.acwing656.钞票和硬币</h2><p>读取一个带有两个小数位的浮点数，这代表货币价值。</p>
<p>在此之后，将该值分解为多种钞票与硬币的和，每种面值的钞票和硬币使用数量不限，要求使用的钞票和硬币的数量尽可能少。</p>
<span id="more"></span>

<p>钞票的面值是100,50,20,10,5,2。</p>
<p>硬币的面值是1,0.50,0.25,0.10,0.05和0.01。</p>
<p>输入格式</p>
<p>输入一个浮点数N。</p>
<p>输出格式</p>
<p>参照输出样例，输出每种面值的钞票和硬币的需求数量。</p>
<p>数据范围</p>
<p>0≤N≤1000000.00</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">576.73</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">NOTAS:</span><br><span class="line"><span class="number">5</span> nota(s) de R$ <span class="number">100.00</span></span><br><span class="line"><span class="number">1</span> nota(s) de R$ <span class="number">50.00</span></span><br><span class="line"><span class="number">1</span> nota(s) de R$ <span class="number">20.00</span></span><br><span class="line"><span class="number">0</span> nota(s) de R$ <span class="number">10.00</span></span><br><span class="line"><span class="number">1</span> nota(s) de R$ <span class="number">5.00</span></span><br><span class="line"><span class="number">0</span> nota(s) de R$ <span class="number">2.00</span></span><br><span class="line">MOEDAS:</span><br><span class="line"><span class="number">1</span> moeda(s) de R$ <span class="number">1.00</span></span><br><span class="line"><span class="number">1</span> moeda(s) de R$ <span class="number">0.50</span></span><br><span class="line"><span class="number">0</span> moeda(s) de R$ <span class="number">0.25</span></span><br><span class="line"><span class="number">2</span> moeda(s) de R$ <span class="number">0.10</span></span><br><span class="line"><span class="number">0</span> moeda(s) de R$ <span class="number">0.05</span></span><br><span class="line"><span class="number">3</span> moeda(s) de R$ <span class="number">0.01</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取一个浮点数，表示货币价值，将他分解为多种钞票和硬币的和，尽可能少的钞票和硬币数量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,c;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;b);</span><br><span class="line">    a = (<span class="keyword">int</span>)b;</span><br><span class="line">    c = <span class="number">100</span>*b - <span class="number">100</span>*a;<span class="comment">// 注意这里</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NOTAS:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d nota(s) de R$ 100.00\n&quot;</span>,a/<span class="number">100</span>);</span><br><span class="line">    a %= <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d nota(s) de R$ 50.00\n&quot;</span>,a/<span class="number">50</span>);</span><br><span class="line">    a %= <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d nota(s) de R$ 20.00\n&quot;</span>,a/<span class="number">20</span>);</span><br><span class="line">    a %= <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d nota(s) de R$ 10.00\n&quot;</span>,a/<span class="number">10</span>);</span><br><span class="line">    a %= <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d nota(s) de R$ 5.00\n&quot;</span>,a/<span class="number">5</span>);</span><br><span class="line">    a %= <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d nota(s) de R$ 2.00\n&quot;</span>,a/<span class="number">2</span>);</span><br><span class="line">    a %= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MOEDAS:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d moeda(s) de R$ 1.00\n&quot;</span>,a/<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d moeda(s) de R$ 0.50\n&quot;</span>,c/<span class="number">50</span>);</span><br><span class="line">    c %= <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d moeda(s) de R$ 0.25\n&quot;</span>,c/<span class="number">25</span>);</span><br><span class="line">    c %= <span class="number">25</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d moeda(s) de R$ 0.10\n&quot;</span>,c/<span class="number">10</span>);</span><br><span class="line">    c %= <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d moeda(s) de R$ 0.05\n&quot;</span>,c/<span class="number">5</span>);</span><br><span class="line">    c %= <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d moeda(s) de R$ 0.01&quot;</span>,c/<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-acwing610-工资和奖金"><a href="#2-acwing610-工资和奖金" class="headerlink" title="2.acwing610.工资和奖金"></a>2.acwing610.工资和奖金</h2><p>请你编写一个程序，给定你一个销售人员的名字，底薪以及月销售额。</p>
<p>请你计算他的月收入是多少。</p>
<p>已知月收入等于底薪加15%的月销售额。</p>
<p>所有数据保留两位小数。</p>
<p>输入格式</p>
<p>输入第一行包含一个由大写字母构成的长度不超过10的字符串，表示销售人员的名字。</p>
<p>第二行包含一个浮点数，表示该人员的底薪。</p>
<p>第三行包含一个浮点数，表示该人员的月销售额。</p>
<p>输出格式</p>
<p>输出格式为“TOTAL = R$ X”，X为该人员月收入。</p>
<p>数据范围</p>
<p>0≤底薪，月销售额≤10000.00</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JOAO</span><br><span class="line">500.00</span><br><span class="line">1230.30</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TOTAL &#x3D; R$ 684.54</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重点在读取字符串的区别</span></span><br><span class="line"><span class="comment">// solution 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a,b;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s %lf %lf&quot;</span>,s,&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TOTAL = R$ %.2lf&quot;</span>,a+<span class="number">0.15</span>*b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//solution 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TOTAL = R$ %.2lf&quot;</span>,x+<span class="number">0.15</span>*y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-解题新思路"><a href="#3-解题新思路" class="headerlink" title="3.解题新思路"></a>3.解题新思路</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换a和b,c的值使a,b,c按从大到小排列</span></span><br><span class="line"><span class="comment">// solution 1</span></span><br><span class="line"><span class="keyword">if</span> (a &lt; b)</span><br><span class="line">    &#123;</span><br><span class="line">        t = a;a = b;b = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; c)</span><br><span class="line">    &#123;</span><br><span class="line">        t = b;b = c;c = t;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">        &#123;</span><br><span class="line">            t = a;a = b;b = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// solution 2</span></span><br><span class="line">&lt;algorithm&gt;</span><br><span class="line"><span class="keyword">if</span> (a &lt; b) swap(a,b);</span><br><span class="line"><span class="keyword">if</span> (a &lt; c) swap(a,c);</span><br><span class="line"><span class="keyword">if</span> (b &lt; c) swap(b,c);</span><br></pre></td></tr></table></figure>

<h2 id="4-acwing668-游戏时间2"><a href="#4-acwing668-游戏时间2" class="headerlink" title="4.acwing668.游戏时间2"></a>4.acwing668.游戏时间2</h2><p>读取四个整数A,B,C,D，用来表示游戏的开始时间和结束时间。</p>
<p>其中A和B为开始时刻的小时和分钟数，C和D为结束时刻的小时和分钟数。</p>
<p>请你计算游戏的持续时间。</p>
<p>比赛最短持续1分钟，最长持续24小时。</p>
<p>输入格式</p>
<p>共一行，包含四个整数A,B,C,D。</p>
<p>输出格式</p>
<p>输出格式为“O JOGO DUROU X HORA(S) E Y MINUTO(S)”，表示游戏共持续了X小时Y分钟。</p>
<p>数据范围</p>
<p>0≤A,C≤23<br>        0≤B,D≤59</p>
<p>输入样例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 8 9 10</span><br></pre></td></tr></table></figure>

<p>输出样例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O JOGO DUROU 2 HORA(S) E 2 MINUTO(S)</span><br></pre></td></tr></table></figure>

<p>输入样例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 7 7 7</span><br></pre></td></tr></table></figure>

<p>输出样例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O JOGO DUROU 24 HORA(S) E 0 MINUTO(S)</span><br></pre></td></tr></table></figure>

<p>输入样例3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 10 8 9</span><br></pre></td></tr></table></figure>

<p>输出样例3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O JOGO DUROU 0 HORA(S) E 59 MINUTO(S)</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取游戏的开始和结束小时和分钟数，估算持续时间</span></span><br><span class="line"><span class="comment">//注意一些样例的特殊性</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c,d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line">    b+=a*<span class="number">60</span>,d+=c*<span class="number">60</span>;</span><br><span class="line">    a=(d-b+<span class="number">24</span>*<span class="number">60</span>)%(<span class="number">24</span>*<span class="number">60</span>); </span><br><span class="line">    a=(a)?(a):(<span class="number">24</span>*<span class="number">60</span>);<span class="comment">// 当a=0时，a变成24*60，处理特殊样例</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;O JOGO DUROU %d HORA(S) E %d MINUTO(S)\n&quot;</span>,a/<span class="number">60</span>,a%<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-acwing663-简单排序"><a href="#5-acwing663-简单排序" class="headerlink" title="5.acwing663.简单排序"></a>5.acwing663.简单排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入三个数对他们升序排列每行输出一个数，接着一个空行，按原顺序每行输出一个数</span></span><br><span class="line"><span class="comment">// solution 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">    x=max(a,max(b,c));</span><br><span class="line">    y=min(a,min(b,c));</span><br><span class="line">    z=a+b+c-x-y;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;z&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// solution 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c,t,d,e,f;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    d = a;e = b;f = c;</span><br><span class="line">    <span class="keyword">if</span> (a&lt;b)</span><br><span class="line">    &#123;</span><br><span class="line">        t = a;a = b;b = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b&lt;c)</span><br><span class="line">    &#123;</span><br><span class="line">        t = b;b = c;c = t;</span><br><span class="line">        <span class="keyword">if</span> (a&lt;b)</span><br><span class="line">        &#123;</span><br><span class="line">            t = a;a = b;b = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d\n%d\n\n&quot;</span>,c,b,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d\n%d\n&quot;</span>,d,e,f);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// solution 2</span></span><br><span class="line">&lt;algorithm&gt;</span><br><span class="line"><span class="keyword">if</span> (a &lt; b) swap(a,b);</span><br><span class="line"><span class="keyword">if</span> (a &lt; c) swap(a,c);</span><br><span class="line"><span class="keyword">if</span> (b &lt; c) swap(b,c);</span><br></pre></td></tr></table></figure>

<h2 id="6-acwing714-连续奇数和1"><a href="#6-acwing714-连续奇数和1" class="headerlink" title="6.acwing714.连续奇数和1"></a>6.acwing714.连续奇数和1</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给定两整数x和y，输出他们之间（不包括x，y）的所有奇数和</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y,sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) swap(x,y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x + <span class="number">1</span>;i &lt; y;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i%<span class="number">2</span>) sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意：-1%2 = -1,-3%2 = -1,-2%2 = 0</span></span><br></pre></td></tr></table></figure>

<h2 id="7-acwing721-递增序列"><a href="#7-acwing721-递增序列" class="headerlink" title="7.acwing721.递增序列"></a>7.acwing721.递增序列</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取一系列的整数X，对于每个X，输出一个1,2,…,X的序列</span></span><br><span class="line"><span class="comment">//其中最后一个为0，其他的均为正整数,对于最后一行的整数0，不作任何处理</span></span><br><span class="line"><span class="comment">//solution 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; x,x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= x;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//solution 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);<span class="comment">// 输出字符串，遇&#x27;\0&#x27;停止，自动加换行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//~scanf(&quot;%d&quot;,&amp;n)等价于scanf(&quot;%d&quot;,&amp;n) != -1(EOF)</span></span><br></pre></td></tr></table></figure>

<h2 id="8-acwing710-六个奇数"><a href="#8-acwing710-六个奇数" class="headerlink" title="8.acwing710.六个奇数"></a>8.acwing710.六个奇数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取一个整数X，输出X之后的6个奇数，如果X也是奇数，那么它也算作6个奇数之一</span></span><br><span class="line"><span class="comment">//每个数占一行</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x, j = <span class="number">0</span>; j &lt; <span class="number">6</span>; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            j ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-acwing719-连续奇数和2"><a href="#9-acwing719-连续奇数和2" class="headerlink" title="9.acwing719.连续奇数和2"></a>9.acwing719.连续奇数和2</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入N对整数对X,Y，对于每对X,Y，请你求出它们之间（不包括X和Y）的所有奇数的和</span></span><br><span class="line"><span class="comment">//solution 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) swap(x,y);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x + <span class="number">1</span>;i &lt; y;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>) sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//solution 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> x,y,ans,t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=(x&lt;y?x:y)+<span class="number">1</span>;i&lt;(x&gt;y?x:y);i++) <span class="keyword">if</span>(i&amp;<span class="number">1</span>) ans+=i;</span><br><span class="line">        <span class="comment">//i&amp;1 用于判断奇偶，为真是奇数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-acwing717-简单斐波那契"><a href="#10-acwing717-简单斐波那契" class="headerlink" title="10.acwing717.简单斐波那契"></a>10.acwing717.简单斐波那契</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下数列0 1 1 2 3 5 8 13 21 …被称为斐波纳契数列</span></span><br><span class="line"><span class="comment">//在一行中输出斐波那契数列的前N项，数字之间用空格隔开</span></span><br><span class="line"><span class="comment">//solution 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>,b = <span class="number">1</span>,c = a + b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;0 &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;1 &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,c);</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">            c = a+b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//better edition</span></span><br><span class="line"><span class="comment">//solution 2 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,a,b=<span class="number">1</span>,c;<span class="comment">// 这里a自动初始化为0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a);</span><br><span class="line">        c=a+b;</span><br><span class="line">        a=b,b=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>竞赛语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++抽象类与模板类的应用</title>
    <url>/posts/633af201.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-抽象类的应用"><a href="#1-抽象类的应用" class="headerlink" title="1.抽象类的应用"></a>1.抽象类的应用</h2><p><img src="/posts/633af201/image-20210421233258943.png" alt="image-20210421233258943"></p>
<span id="more"></span>

<p>C++程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _USE_MATH_DEFINES <span class="comment">// 使用M_PI </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="title">calcSurface</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="title">calcVolume</span><span class="params">()</span> </span>= <span class="number">0</span>;	</span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sphere</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Sphere(<span class="keyword">double</span> _r):r(_r)&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcSurface</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">4</span>*M_PI*r*r;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcVolume</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">4</span>*r*r*r*M_PI/<span class="number">3</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">double</span> r;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cylinder</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Cylinder(<span class="keyword">int</span> _r,<span class="keyword">int</span> _h):r(_r),h(_h)&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcSurface</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> r*r*<span class="number">2</span>*M_PI+<span class="number">2</span>*M_PI*r*h;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcVolume</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> r*r*M_PI*h;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">double</span> r;</span><br><span class="line">		<span class="keyword">double</span> h;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cube</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Cube(<span class="keyword">double</span> _a):a(_a)&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcSurface</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">6</span>*a*a;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcVolume</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> a*a*a;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">double</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Sphere <span class="title">s</span><span class="params">(<span class="number">4.5</span>)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Surface:&quot;</span>&lt;&lt;s.calcSurface();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;, Volume:&quot;</span>&lt;&lt;s.calcVolume()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;---------------------------------\n&quot;</span>;</span><br><span class="line">	<span class="function">Cylinder <span class="title">c1</span><span class="params">(<span class="number">4.3</span>,<span class="number">1.2</span>)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Surface:&quot;</span>&lt;&lt;c1.calcSurface();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;, Volume:&quot;</span>&lt;&lt;c1.calcVolume()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;---------------------------------\n&quot;</span>;</span><br><span class="line">	<span class="function">Cube <span class="title">c2</span><span class="params">(<span class="number">9.0</span>)</span></span>;<span class="comment">// 用指针来调用函数，才是动态多态，待修改</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Surface:&quot;</span>&lt;&lt;c2.calcSurface();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;, Volume:&quot;</span>&lt;&lt;c2.calcVolume()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-模板类的应用"><a href="#2-模板类的应用" class="headerlink" title="2.模板类的应用"></a>2.模板类的应用</h2><p><img src="/posts/633af201/image-20210421233409708.png" alt="image-20210421233409708"></p>
<p>C++程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Set</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Set() &#123;</span><br><span class="line">        t[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Set(T num[N]) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(t, num, <span class="keyword">sizeof</span>(T) * N);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++, size++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[i] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;有%d个元素：&quot;</span>, size);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) <span class="built_in">cout</span> &lt;&lt; t[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Set <span class="keyword">operator</span>+(Set &amp;s);</span><br><span class="line">    Set <span class="keyword">operator</span>-(Set &amp;s);</span><br><span class="line">    Set <span class="keyword">operator</span>*(Set &amp;s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T t[N];</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Set&lt;T&gt; Set&lt;T&gt;::<span class="keyword">operator</span>+(Set&lt;T&gt; &amp;s) &#123;</span><br><span class="line">    Set&lt;T&gt; temp;</span><br><span class="line">    <span class="built_in">memcpy</span>(temp.t, t, <span class="keyword">sizeof</span>(T) * size);</span><br><span class="line">    <span class="keyword">int</span> k = size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.t[i] == temp.t[j]) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">false</span>) temp.t[k++] = s.t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    temp.size = k;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Set&lt;T&gt; Set&lt;T&gt;::<span class="keyword">operator</span>-(Set&lt;T&gt; &amp;s) &#123;</span><br><span class="line">    Set&lt;T&gt; temp;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.size; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[i] == s.t[j]) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">false</span>) temp.t[k++] = t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    temp.size = k;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Set&lt;T&gt; Set&lt;T&gt;::<span class="keyword">operator</span>*(Set&lt;T&gt; &amp;s) &#123;</span><br><span class="line">    Set&lt;T&gt; temp;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.size; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[i] == s.t[j]) temp.t[k++] = s.t[j];</span><br><span class="line">        &#125;</span><br><span class="line">    temp.size = k;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[N] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> b[N] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    Set&lt;int&gt; A(a), B(b), C, D, E;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A:&quot;</span>;</span><br><span class="line">    A.show();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B:&quot;</span>;</span><br><span class="line">    B.show();</span><br><span class="line">    C = A + B; <span class="comment">// 并</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A和B的并集:&quot;</span>;</span><br><span class="line">    C.show();</span><br><span class="line">    D = A * B; <span class="comment">// 交</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A和B的交集:&quot;</span>;</span><br><span class="line">    D.show();</span><br><span class="line">    E = A - B; <span class="comment">// 差</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A和B的差集:&quot;</span>;</span><br><span class="line">    E.show();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>抽象类</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>C++竞赛语法总结（七）</title>
    <url>/posts/4122ace1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-acwing-66-两个链表的第一个公共结点"><a href="#1-acwing-66-两个链表的第一个公共结点" class="headerlink" title="1.acwing.66.两个链表的第一个公共结点"></a>1.acwing.66.两个链表的第一个公共结点</h2><p><u>这几道链表题大多来自《剑指offer》，都不太会啊！</u></p>
<p>输入两个链表，找出它们的第一个公共结点。</p>
<p>当不存在公共结点时，返回空结点。</p>
<span id="more"></span>

<p>样例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给出两个链表如下所示：</span><br><span class="line">A：        a1 → a2</span><br><span class="line">                   ↘</span><br><span class="line">                     c1 → c2 → c3</span><br><span class="line">                   ↗            </span><br><span class="line">B:     b1 → b2 → b3</span><br><span class="line"></span><br><span class="line">输出第一个公共结点c1</span><br></pre></td></tr></table></figure>

<p><img src="/posts/4122ace1/image-20210213203133692.png" alt="image-20210213203133692"></p>
<p><img src="/posts/4122ace1/image-20210213203516385.png" alt="image-20210213203516385"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">findFirstCommonNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* p = headA;ListNode* q = headB;</span><br><span class="line">        <span class="keyword">while</span> (p != q) <span class="comment">// 直到p，q走到公共结点或同时为空时跳出</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p) p = p-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> p = headB;</span><br><span class="line">            <span class="keyword">if</span> (q) q = q-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> q = headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-acwing-29-删除链表中的重复结点"><a href="#2-acwing-29-删除链表中的重复结点" class="headerlink" title="2.acwing.29.删除链表中的重复结点"></a>2.acwing.29.删除链表中的重复结点</h2><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留。</p>
<p>样例11</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</span><br><span class="line"></span><br><span class="line">输出：1-&gt;2-&gt;5</span><br></pre></td></tr></table></figure>

<p>样例2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;1-&gt;1-&gt;2-&gt;3</span><br><span class="line"></span><br><span class="line">输出：2-&gt;3</span><br></pre></td></tr></table></figure>

<p><strong>算法：(线性扫描) O(n)</strong><br>为了方便处理边界情况，我们定义一个虚拟元素 dummy指向链表头节点。<br>然后从前往后扫描整个链表，每次扫描元素相同的一段，如果这段中的元素个数多于1个，则将整段元素直接删除。</p>
<p><strong>时间复杂度</strong><br>整个链表只扫描一遍，所以时间复杂度是 O(n)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);<span class="comment">// 定义虚拟头结点避免特判第一个结点被删除的情况</span></span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* p = dummy;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> q = p-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (q-&gt;next &amp;&amp; p-&gt;next-&gt;val == q-&gt;next-&gt;val) q = q-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;next == q) p = q;</span><br><span class="line">            <span class="keyword">else</span> p-&gt;next = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-C-STL容器"><a href="#3-C-STL容器" class="headerlink" title="3.C++ STL容器"></a>3.C++ STL容器</h2><p>STL是提高C++编写效率的一个利器。                                                                                                            ——yxc</p>
<p>最后两章要背的东西比较多！</p>
<h3 id="3-1-include-lt-vector-gt"><a href="#3-1-include-lt-vector-gt" class="headerlink" title="3.1 #include &lt;vector&gt;"></a>3.1 <code>#include &lt;vector&gt;</code></h3><p>vector是<strong>变长数组，支持随机访问，不支持在任意位置O(1)插入</strong>。为了保证效率，元素的增删一般应该在末尾进行。 </p>
<h4 id="3-1-1-声明"><a href="#3-1-1-声明" class="headerlink" title="3.1.1  声明"></a>3.1.1  声明</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;    头文件</span></span></span><br><span class="line"></span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;       相当于一个长度动态变化的<span class="keyword">int</span>数组</span><br><span class="line"></span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b[<span class="number">233</span>];   相当于第一维长<span class="number">233</span>，第二位长度动态变化的<span class="keyword">int</span>数组</span><br><span class="line"></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">rec</span>&#123;</span>…&#125;;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">vector</span>&lt;rec&gt; c;       自定义的结构体类型也可以保存在<span class="built_in">vector</span>中</span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-size-empty"><a href="#3-1-2-size-empty" class="headerlink" title="3.1.2 size/empty"></a>3.1.2 size/empty</h4><p>size函数返回vector的实际长度（包含的元素个数），empty函数返回一个bool类型，表明vector是否为空，为空返回true，否则返回false。二者的时间复杂度都是O(1)。</p>
<p><strong>所有的STL容器都支持这两个方法，含义也相同</strong>，之后我们就不再重复给出。 </p>
<h4 id="3-1-3-clear"><a href="#3-1-3-clear" class="headerlink" title="3.1.3 clear"></a>3.1.3 clear</h4><p>​       clear函数把vector清空。 </p>
<h4 id="3-1-4-迭代器-iterator"><a href="#3-1-4-迭代器-iterator" class="headerlink" title="3.1.4 迭代器(iterator)"></a>3.1.4 迭代器(iterator)</h4><p>​       <strong>迭代器就像STL容器的“指针”</strong>，可以用星号“*”操作符解除引用。</p>
<p>​       一个保存int的vector的迭代器声明方法为：</p>
<p>​       <code>vector&lt;int&gt;::iterator it;</code></p>
<p>vector的迭代器是“随机访问迭代器”，可以把vector的迭代器与一个整数相加减，其行为和指针的移动类似。可以把vector的两个迭代器相减，其结果也和指针相减类似，得到两个迭代器对应下标之间的距离。 </p>
<h4 id="3-1-5-begin-end–-begin-end"><a href="#3-1-5-begin-end–-begin-end" class="headerlink" title="3.1.5 begin/end–[begin,end)"></a>3.1.5 begin/end–[begin,end)</h4><p>begin函数返回指向vector中第一个元素的迭代器。例如a是一个非空的vector，则<code>*a.begin()</code>与a[0]的作用相同。</p>
<p><strong>所有的容器都可以视作一个“前闭后开”的结构</strong>，end函数返回vector的尾部，即第n个元素再往后的“边界”。<code>*a.end()</code>与a[n]都是越界访问，其中n=<code>a.size()</code>。</p>
<p>下面两份代码都遍历了<code>vector&lt;int&gt; a</code>，并输出它的所有元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> I = <span class="number">0</span>; I &lt; a.size(); I ++) <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = a.begin(); it != a.end(); it ++) <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-6-front-back"><a href="#3-1-6-front-back" class="headerlink" title="3.1.6 front/back"></a>3.1.6 front/back</h4><p>​       front函数返回vector的第一个元素，等价于<code>*a.begin()</code> 和 a[0]。</p>
<p>​       back函数返回vector的最后一个元素，等价于<code>*==a.end()</code> 和 <code>a[a.size() – 1]</code>。 </p>
<h4 id="3-1-7-push-back-和-pop-back"><a href="#3-1-7-push-back-和-pop-back" class="headerlink" title="3.1.7  push_back() 和 pop_back()"></a>3.1.7  push_back() 和 pop_back()</h4><p><code>a.push_back(x)</code> 把元素x插入到vector a的尾部。</p>
<p><u>在数组结尾插入时间复杂度是O(1)，在数组开头插入时间复杂度是O(n)。</u></p>
<p> <code>b.pop_back()</code> 删除vector a的最后一个元素。</p>
<h4 id="3-1-8-实例"><a href="#3-1-8-实例" class="headerlink" title="3.1.8 实例"></a>3.1.8 实例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.front() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; *a.begin() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 3种等价写法</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.back() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a[a.size()<span class="number">-1</span>] &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// a.end()在最后一个元素之后的位置，索引会越界</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3种迭代vector的方法</span></span><br><span class="line">    <span class="comment">// solution 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; a.size();i ++) <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// solution 2，迭代器用到较少，太麻烦，只是介绍语法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = a.begin();it != a.end();it ++) <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="comment">// for (auto it = ...)简化</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// solution 3，常用</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : a) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">   	a.push_back(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x:a) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 1 2 3 4</span></span><br><span class="line">    </span><br><span class="line">    a.pop_back();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x:a) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 1 2 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-include-lt-queue-gt"><a href="#3-2-include-lt-queue-gt" class="headerlink" title="3.2 #include &lt;queue&gt; "></a>3.2 <code>#include &lt;queue&gt; </code></h3><p>头文件queue主要包括循环队列queue和优先队列priority_queue两个容器。 </p>
<p>没有clear函数。</p>
<p><strong>先进先出(FIFO)，队头插入，队尾删除。</strong></p>
<p>优先队列：</p>
<ul>
<li>定义大根堆时结构体要重载小于号&lt;；</li>
<li>定义小根堆时结构体要重载大于号&gt;；</li>
</ul>
<h4 id="3-2-1-声明"><a href="#3-2-1-声明" class="headerlink" title="3.2.1 声明"></a>3.2.1 声明</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">rec</span>&#123;</span>…&#125;; <span class="built_in">queue</span>&lt;rec&gt; q;    <span class="comment">//在优先队列中，结构体rec中必须定义小于号</span></span><br><span class="line"></span><br><span class="line">       <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; q;    <span class="comment">// 大根堆，每次返回最大值</span></span><br><span class="line"></span><br><span class="line">       <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;   <span class="comment">// 小根堆，每次返回最小值</span></span><br><span class="line"></span><br><span class="line">       <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;<span class="comment">// pair是二元组</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-循环队列-queue"><a href="#3-2-2-循环队列-queue" class="headerlink" title="3.2.2 循环队列 queue"></a>3.2.2 循环队列 queue</h4><p>​       push 从队尾插入</p>
<p>​       pop 从队头弹出</p>
<p>​       front 返回队头元素</p>
<p>​       back 返回队尾元素 </p>
<h4 id="3-2-3-优先队列-priority-queue"><a href="#3-2-3-优先队列-priority-queue" class="headerlink" title="3.2.3 优先队列 priority_queue"></a>3.2.3 优先队列 priority_queue</h4><p>​       push 把元素插入堆</p>
<p>​       pop 删除堆顶元素</p>
<p>​       top 查询堆顶元素（最大值）</p>
<h4 id="3-2-4-实例"><a href="#3-2-4-实例" class="headerlink" title="3.2.4 实例"></a>3.2.4 实例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    a.push(<span class="number">1</span>);<span class="comment">// 从队尾插入</span></span><br><span class="line">    a.push(<span class="number">2</span>);</span><br><span class="line">    a.push(<span class="number">3</span>);</span><br><span class="line">    a.pop();<span class="comment">// 弹出队头元素1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.front() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 返回队头2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.back() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 返回队尾3</span></span><br><span class="line">    a = <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;();<span class="comment">// 重新初始化以清空队列</span></span><br><span class="line">    <span class="comment">// 因为队列，栈容器没有clear函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">double</span>&gt; q;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; b;<span class="comment">// 大根堆</span></span><br><span class="line">    b.push(<span class="number">2</span>);</span><br><span class="line">    b.push(<span class="number">4</span>);</span><br><span class="line">    b.push(<span class="number">8</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b.top() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 取最大值8</span></span><br><span class="line">    b.pop();<span class="comment">// 删除最大值，无返回值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b.top() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; x;<span class="comment">// 小根堆</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Rec</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Rec&amp; t) <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a &lt; t.a;<span class="comment">// 没有重载&quot;&lt;&quot;时插入元素会报错</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;Rec&gt; s;<span class="comment">// 大根堆重载&lt;</span></span><br><span class="line">    s.push(&#123;<span class="number">1</span>,<span class="number">2</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Res</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>&gt; (<span class="keyword">const</span> Res&amp; t) <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a &gt; t.a;<span class="comment">// 没有重载&quot;&gt;&quot;时插入元素会报错</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;Res,<span class="built_in">vector</span>&lt;Res&gt;,greater&lt;Res&gt;&gt; n;<span class="comment">// 小根堆重载&gt;</span></span><br><span class="line">    n.push(&#123;<span class="number">1</span>,<span class="number">2</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;Rec&gt; v;</span><br><span class="line">    v.push(&#123;<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-include-lt-stack-gt"><a href="#3-3-include-lt-stack-gt" class="headerlink" title="3.3 #include &lt;stack&gt;"></a>3.3 <code>#include &lt;stack&gt;</code></h3><p>头文件stack包含栈。声明和前面的容器类似。</p>
<p>没有clear函数。</p>
<p><strong>先进后出(FILO)，栈顶插入，栈顶删除</strong></p>
<p>push 向栈顶插入</p>
<p>pop 弹出栈顶元素</p>
<p>top 取栈顶元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    stk.push(<span class="number">1</span>);</span><br><span class="line">    stk.push(<span class="number">8</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stk.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    stk.pop();</span><br><span class="line">    stk.push(<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stk.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">12*/</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-include-lt-deque-gt"><a href="#3-4-include-lt-deque-gt" class="headerlink" title="3.4 #include &lt;deque&gt;"></a>3.4 <code>#include &lt;deque&gt;</code></h3><p>双端队列deque是一个支持在两端高效插入或删除元素的连续线性存储空间。它就像是vector和queue的结合。<strong>与vector相比，deque在头部增删元素仅需要O(1)的时间；与queue相比，deque像数组一样支持随机访问。运行效率会比stack和vector慢。</strong></p>
<p>[] 随机访问</p>
<p>begin/end，返回deque的头/尾迭代器，<strong>左闭右开</strong></p>
<p>front/back 队头/队尾元素</p>
<p>push_back 从队尾入队</p>
<p>push_front 从队头入队</p>
<p>pop_back 从队尾出队</p>
<p>pop_front 从队头出队</p>
<p>clear 清空队列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    a.push_back(<span class="number">1</span>),a.push_front(<span class="number">2</span>);</span><br><span class="line">    a.push_back(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *a.begin() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; *a.end() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.front() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    a.pop_back(),a.pop_front();</span><br><span class="line">    a.clear();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">2 17367376</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">2 3*/</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>竞赛语法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>C++竞赛语法总结（三）</title>
    <url>/posts/2e9f4c85.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-scanf-函数"><a href="#1-scanf-函数" class="headerlink" title="1.scanf()函数"></a>1.scanf()函数</h2><p><strong>scanf()函数接收输入数据时，遇以下情况结束一个数据的输入：</strong> </p>
<p>① 遇空格、“回车”、“跳格”键。<br>        ② 遇宽度结束。<br>        ③ 遇非法输入。</p>
<p><strong>cin遇到空格或者回车也会结束读取！！！</strong></p>
<p><strong>scanf接收包含空格的字符串</strong></p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">80</span>]; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入：I love you!<br>        输出：I<br>        原因：scanf遇空格结束读取。</p>
<h2 id="2-ASCII码"><a href="#2-ASCII码" class="headerlink" title="2.ASCII码"></a>2.ASCII码</h2><p>每个常用字符都对应一个-128~127的数字，二者之间可以相互转化。</p>
<table>
<thead>
<tr>
<th>ASCII码</th>
<th>字符</th>
</tr>
</thead>
<tbody><tr>
<td>48</td>
<td>‘0’</td>
</tr>
<tr>
<td>65</td>
<td>‘A’</td>
</tr>
<tr>
<td>97</td>
<td>‘a’</td>
</tr>
</tbody></table>
<h2 id="3-字符数组"><a href="#3-字符数组" class="headerlink" title="3.字符数组"></a>3.字符数组</h2><h3 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h3><p>字符串就是字符数组加上==结束符’\0’==。没有’\0’不算字符串，只是普通的字符数组。</p>
<p>可以使用字符串来初始化字符数组，但此时要注意，每个字符串结尾会暗含一个’\0’字符，因此字符数组的长度至少要比字符串的长度多1！</p>
<p><img src="/posts/2e9f4c85/image-20210101141628559.png" alt="image-20210101141628559"></p>
<p>这里第二、三种初始化方式是等价的。</p>
<h3 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 输入：abc</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出：</span></span><br><span class="line"><span class="comment">    abc</span></span><br><span class="line"><span class="comment">    a </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 这样就可以让读取的字符串的数组从1开始</span></span><br><span class="line"><span class="comment">// 使用scanf函数有同样的效果,scanf(&quot;%s&quot;,s + 1)</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3"><a href="#3-3" class="headerlink" title="3.3"></a>3.3</h3><h4 id="3-3-1"><a href="#3-3-1" class="headerlink" title="3.3.1"></a>3.3.1</h4><p>读入一行字符串（包括空格），可以使用gets函数，但由于它不安全，已经被淘汰。</p>
<h4 id="3-3-2"><a href="#3-3-2" class="headerlink" title="3.3.2"></a>3.3.2</h4><p>现在使用fgets函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line">fgets(s,<span class="number">100</span>,<span class="built_in">stdin</span>);</span><br></pre></td></tr></table></figure>

<p>原型  <code>char *  fgets(char * s, int n,FILE *stream);</code></p>
<p>  参数：</p>
<p>​     s: 字符型指针，指向存储读入数据的缓冲区的地址。</p>
<p>​     n: 从流中读入n-1个字符</p>
<p>​     stream ： 指向读取的流。</p>
<p>  返回值：</p>
<ol>
<li>​     当n&lt;=0 时返回NULL，即空指针。</li>
<li>​     当n=1 时，返回空串””。</li>
<li>​     如果读入成功，则返回缓冲区的地址。</li>
<li>​     如果读入错误或遇到文件结尾(EOF)，则返回NULL。</li>
</ol>
<h4 id="3-3-3"><a href="#3-3-3" class="headerlink" title="3.3.3"></a>3.3.3</h4><p>在用fgets(..)读入数据时，先定义一个字符数组或字符指针，如果定义了字符指针 ，那么一定要初始化。</p>
<p>​    example:</p>
<p>​       char s[100]; //可以。</p>
<p>​       char *s;  //不可以，因为只是声明了一个指针。但并没有为它分配内存缓冲区。</p>
<p>​       所以，如果要用指针，则  <code>char *s=(char*)malloc(100*sizeof(char));</code> 为其分配内存空间,c++中用<code>char *s=new char [100];</code>    如果未分配内存空间，编译时不会检查出问题，但运行时会出现未知错误。。</p>
<h4 id="3-3-4"><a href="#3-3-4" class="headerlink" title="3.3.4"></a>3.3.4</h4><p>fgets(…)读入文本行时的两种情况。</p>
<p>​     1.   如果n大于一行的字符串长度，那么当读到字符串末尾的换行符时，fgets(..)会返回。并且在s的最后插入字符串结束标志’\0’。 而s缓冲区剩余的位置不会再填充。</p>
<p>​      example：</p>
<p>​       123abc</p>
<p>​       fgets(s,10,fp);</p>
<p>​       此时，读入七个字符，123abc\n,实际上还有最后的’\0’,所以，strlen(s)=7; 如果要去除末尾的\n，s[strlen(s)-1]=’\0’;便可。</p>
<p>​     2.   如果n小于等于一行的字符串的长度，那么读入n-1个字符，此时并没有读入\n因为并没有到行尾 ，同样在最后会插入’\0’.</p>
<p>​     example:</p>
<p>​      123abc</p>
<p>​      char  s[5];</p>
<p>​      fgets(s,5,fp);</p>
<p>​      这时读入4个字符，123a,并没有换行符，所以strlen(s)=4.</p>
<h3 id="3-4"><a href="#3-4" class="headerlink" title="3.4"></a>3.4</h3><p>用getline函数来读取字符串中的空格。（定义在头文件中）</p>
<p>getline 函数如下所示：</p>
<p>getline(cin, inputLine);</p>
<p>其中 cin 是正在读取的输入流，而 inputLine 是接收输入字符串的 string 变量的名称。</p>
<p>注意：第二个参数不能是字符数组，必须是string变量！！<u>它将继续读取，直到它读取至最大指定的字符数，或直到按下了回车键。</u></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="built_in">string</span> city;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Please enter your name: &quot;</span>;</span><br><span class="line">getline(<span class="built_in">cin</span>, name);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter the city you live in: &quot;</span>;</span><br><span class="line">getline(<span class="built_in">cin</span>, city);<span class="comment">// 上一次用户输入的&#x27;\n&#x27;被去除了，没有读入city</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, &quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You live in &quot;</span> &lt;&lt; city &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出如下</span></span><br><span class="line">Please enter your name: John Doe</span><br><span class="line">Enter the city you live in: Chicago</span><br><span class="line">Hello, John Doe</span><br><span class="line">You live in Chicago</span><br></pre></td></tr></table></figure>

<p>补充：getline()中读入结束的回车后，结束符不放入缓存区，会将读入的\n直接去除，下一个输入前，缓冲区为空，并不会因为回车留下\n。而cin的结束后，以及getchar()此类的读入结束后,按下回车或者使用空格读入下一个，此时按下的回车或空格会还在缓存区,继续用getline()就会出现前面所提到的情况。</p>
<p>scanf函数并不会清空缓冲区回车！！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用scanf过滤空格</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">30</span>],c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;\n%c&quot;</span>,&amp;c);</span><br></pre></td></tr></table></figure>

<h3 id="3-5"><a href="#3-5" class="headerlink" title="3.5"></a>3.5</h3><p>cin.getline函数。</p>
<p>与 getline 一样，cin.getline 允许读取包含空格的字符串。它将继续读取，直到它读取至最大指定的字符数，或直到按下了回车键。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">cin</span>.getline(s,<span class="number">100</span>);<span class="comment">// 最多读取99个字符，最后一个位置放&#x27;\0&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-6"><a href="#3-6" class="headerlink" title="3.6"></a>3.6</h3><p>puts函数。（引入)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> name[] = <span class="string">&quot;asaf&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,name);</span><br><span class="line"><span class="built_in">puts</span>(name);<span class="comment">// 两者是完全等价的</span></span><br></pre></td></tr></table></figure>

<h2 id="4-字符数组常用操作"><a href="#4-字符数组常用操作" class="headerlink" title="4.字符数组常用操作"></a>4.字符数组常用操作</h2><p>下面几个函数需要引入头文件:</p>
<p><code>#include &lt;string.h&gt;</code>  或者也可以</p>
<p>(1)  strlen(str)，求字符串的长度，注意：不包括最后的’\0’</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自己实现代码</span></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;s[i];i++) len++;<span class="comment">// 用s[i]作为判断条件，因为&#x27;\0&#x27;代表停止</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>(2)  strcmp(a, b)，比较两个字符串的大小，a &lt; b 返回-1，a == b 返回0，a &gt; b返回1。这里的比较方式是字典序！</p>
<p>(3)  strcpy(a, b)，将字符串b复制给从a开始的字符数组。</p>
<h2 id="5-acwing772-只出现一次的字符"><a href="#5-acwing772-只出现一次的字符" class="headerlink" title="5.acwing772.只出现一次的字符"></a>5.acwing772.只出现一次的字符</h2><p><img src="/posts/2e9f4c85/image-20210101155001628.png" alt="image-20210101155001628"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 巧妙的做法</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;<span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">    <span class="keyword">int</span> s[<span class="number">300</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> &amp;c : str) s[c]++;<span class="comment">// 遍历string</span></span><br><span class="line">    <span class="keyword">char</span> p = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> &amp;c: str)<span class="comment">// 注意这里还是遍历str，不是s</span></span><br><span class="line">        <span class="comment">// 因为题目要求第一个出现的满足要求的字符</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[c] == <span class="number">1</span>) &#123;p = c;<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">-1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;no&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-acwing763-循环相克令"><a href="#6-acwing763-循环相克令" class="headerlink" title="6.acwing763.循环相克令"></a>6.acwing763.循环相克令</h2><p><img src="/posts/2e9f4c85/image-20210101170937824.png" alt="image-20210101170937824"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原解法，太过低效，直接暴力枚举</span></span><br><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">// 这行代码最后紧跟着include</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">&quot;Hunter&quot;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">&quot;Bear&quot;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> a,b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">int</span> x = get(a),y = get(b);</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="built_in">puts</span>(<span class="string">&quot;Tie&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((y+<span class="number">1</span>)%<span class="number">3</span> == x) <span class="built_in">puts</span>(<span class="string">&quot;Player1&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Player2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 巧妙的解题思路，利用字母的长度之差，读题能力实在佩服</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> x, y;</span><br><span class="line">    <span class="keyword">while</span> (n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">int</span> a = x.size(), b = y.size();</span><br><span class="line">        <span class="keyword">if</span> (a - b == <span class="number">-1</span> || a - b == <span class="number">-2</span> || a - b == <span class="number">3</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Player1&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a == b)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Tie&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Player2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：黄</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/15253/</span></span><br><span class="line">来源：AcWing</span><br></pre></td></tr></table></figure>

<h2 id="7-acwing765-字符串加空格"><a href="#7-acwing765-字符串加空格" class="headerlink" title="7.acwing765.字符串加空格"></a>7.acwing765.字符串加空格</h2><p>给定一个字符串，在字符串的每个字符之间都加一个空格。</p>
<p>输出修改后的新字符串。</p>
<p>输入格式<br>共一行，包含一个字符串。注意字符串中可能包含空格。</p>
<p>输出格式<br>输出增加空格后的字符串。</p>
<p>数据范围<br>1≤字符串长度≤100</p>
<p>样例<br>输入样例：<br><code>test case</code><br>输出样例：<br><code>t e s t   c a s e</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历字符串的非常巧妙的做法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    getline(<span class="built_in">cin</span>, a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> &amp;c : a) <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 遍历字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-acwing773-字符串插入"><a href="#8-acwing773-字符串插入" class="headerlink" title="8.acwing773.字符串插入"></a>8.acwing773.字符串插入</h2><p>有两个不包含空白字符的字符串str和substr，str的字符个数不超过10，substr的字符个数为3（字符个数不包括字符串结尾处的’\0’。）</p>
<p>将substr插入到str中ASCII码最大的那个字符后面，若有多个最大则只考虑第一个。</p>
<p>输入格式</p>
<p>输入包括若干行，每一行为一组测试数据，格式为</p>
<p>str substr</p>
<p> 输出格式</p>
<p>对于每一组测试数据，输出插入之后的字符串。</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abcab eee</span><br><span class="line">12343 555</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abceeeab</span><br><span class="line">12345553</span><br></pre></td></tr></table></figure>

<p>关于substr的说明：</p>
<ol start="0">
<li><p>用途：一种构造string的方法</p>
</li>
<li><p>形式：s.substr(pos, n)</p>
</li>
<li><p>解释：返回一个string，包含s中从pos开始的n个字符的拷贝（pos的默认值是0，n的默认值是s.size() - pos，即不加参数会默认拷贝整个s）<br>当只有一个数字pos表示从下标为pos开始一直到结尾</p>
</li>
<li><p>补充：若pos的值超过了string的大小，则substr函数会抛出一个out_of_range异常；若pos+n的值超过了string的大小，则substr会调整n的值，只拷贝到string的末尾</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">string</span> s = <span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.substr(<span class="number">0</span>,<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span> &lt;&lt; s.substr(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 第一个参数代表下标，第二个参数代表长度（可以不加）</span></span><br><span class="line"><span class="comment">/*    输出如下</span></span><br><span class="line"><span class="comment"> 012</span></span><br><span class="line"><span class="comment">3456789</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原解法TLE了，超时，写错了</span></span><br><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> a,b;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; a.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[p]) p = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a.substr(<span class="number">0</span>,p + <span class="number">1</span>) + b + a.substr(p + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 题解2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">11</span>], substr[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s %s&quot;</span>, str, substr) != EOF)&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = str[<span class="number">0</span>], res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] &gt; cnt) cnt = str[i], res = i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == cnt) <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= res; i ++)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; str[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(substr); i++)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; substr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = res + <span class="number">1</span>; i &lt; <span class="built_in">strlen</span>(str); i++)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; str[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：zhiling</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/2913/</span></span><br><span class="line">来源：AcWing</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>竞赛语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++竞赛语法总结（二）</title>
    <url>/posts/6381efd7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-acwing725-完全数"><a href="#1-acwing725-完全数" class="headerlink" title="1.acwing725.完全数"></a>1.acwing725.完全数</h2><p>一个整数，除了本身以外的其他所有约数的和如果等于该数，那么我们就称这个整数为完全数。</p>
<p>例如，6就是一个完全数，因为它的除了本身以外的其他约数的和为 1+2+3 = 6。</p>
<p>现在，给定你N个整数，请你依次判断这些数是否是完全数。</p>
<p>每个测试用例输出一个结果，每个结果占一行。</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意这样时间复杂度太大，会超时</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">while</span> (n--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x,sum = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; x;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (x%i == <span class="number">0</span>) sum += i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (sum == x) <span class="built_in">printf</span>(<span class="string">&quot;%d is perfect\n&quot;</span>,x);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d is not perfect\n&quot;</span>,x);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化版本</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">while</span> (n--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x,sum = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i*i &lt;= x;i++)<span class="comment">// 减少循环次数</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (x%i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; x) sum += i;</span><br><span class="line">                <span class="keyword">if</span> (i != x/i &amp;&amp; x/i &lt; x) sum += x/i; <span class="comment">// 关键步骤</span></span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (sum == x) <span class="built_in">printf</span>(<span class="string">&quot;%d is perfect\n&quot;</span>,x);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d is not perfect\n&quot;</span>,x);</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特别解法"><a href="#特别解法" class="headerlink" title="特别解法"></a>特别解法</h3><p>有点数学基础的人都应该知道100000000内的完全数没有几个……</p>
<p>数学部分<br>100000000100000000内的完全数有6,28,496,8128,335503366,28,496,8128,33550336.所以说多背一点数字是很有用的</p>
<p>既然这道题可以直接O(1)O(1)解决,我们不妨来说一下完全数的各种性质以备于各种毒瘤的算法竞赛.</p>
<p>完全数比较重要的几个性质<br>(也是我只知道的几个性质)</p>
<p>所有完全数都是三角形数<br>目前截止发现的所有完全数都以66或2828结尾<br>到现在为止,数学家们一共发现了4848个完全数,且4848个完全数全部是偶数<br>如果有人们没有找到的奇完全数,则它一定可以写成12p+112p+1或36p+936p+9的形式,而且pp是素数<br>奇完全数一定大于1030010300<br>完全数的约数的倒数之和为调和数<br>完全数可以表示成连续奇数的立方和<br>完全数可以表示成22的连续自然数的次幂之和,且这些自然数的数量必定是素数<br>完全数计算法<br>若2p−1是素数(亦称其为梅森素数),则2p−1∗(2p−1)是完全数.</p>
<p>时间复杂度<br>这里数据小了一点,对于每个数据时间复杂度为O(1)O(1).<br>数据再大我都不怕,反正现在找到48个不如个map然后映射一个布尔类不就好了!</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">6</span> || n == <span class="number">28</span> || n == <span class="number">496</span> || n == <span class="number">8128</span> || n == <span class="number">33550336</span>)  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; is perfect&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; is not perfect&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-错误小提示"><a href="#2-错误小提示" class="headerlink" title="2.错误小提示"></a>2.错误小提示</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误写法，第二句不会执行，很容易犯错</span></span><br><span class="line"><span class="keyword">if</span> (...) xxx; xxx;</span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="number">1.</span><span class="keyword">if</span> (...) &#123;xxx; xxx;&#125;</span><br><span class="line"><span class="number">2.</span><span class="keyword">if</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">    xxx; xxx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3.</span><span class="keyword">if</span>() xxx,xxx;</span><br></pre></td></tr></table></figure>

<h2 id="3-acwing727-菱形"><a href="#3-acwing727-菱形" class="headerlink" title="3.acwing727.菱形"></a>3.acwing727.菱形</h2><p><img src="/posts/6381efd7/image-20201230171526383-1610606143859.png" alt="image-20201230171526383"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">abs</span>(i-n/<span class="number">2</span>) + <span class="built_in">abs</span>(j-n/<span class="number">2</span>) &lt;= n/<span class="number">2</span>)<span class="comment">// abs函数求绝对值</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);<span class="comment">// 漏掉这里就只能打印右半边图形</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致思路：来自于y总讲解。根据图形特点，这是一个正方形中的菱形，离正方形中心的曼哈顿距离&lt;= n/2的点打印*，其他点打印空格。</p>
<p>例如在平面上，坐标(x1,y1)的i点与坐标(x2,y2)的j点的曼哈顿距离为：</p>
<p><code>d(i,j)=|X1-X2|+|Y1-Y2|.</code></p>
<h2 id="4-高精度浮点数运算问题"><a href="#4-高精度浮点数运算问题" class="headerlink" title="4.高精度浮点数运算问题"></a>4.高精度浮点数运算问题</h2><p>如果进行了一系列对浮点数的运算，精度可能变得不准确，这时运算之前、之后的浮点数可能不相等，但实际上是相等的，只是因为精度丢失。看例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">sqrt</span>(<span class="number">3</span>) * <span class="built_in">sqrt</span>(<span class="number">3</span>) != <span class="number">3</span>) <span class="built_in">puts</span>(<span class="string">&quot;!!!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>结果我们会发现显示！！！，说明精度丢失了，但实际结果应该相等。</p>
<p>解决方案如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当两个浮点数相差足够小时，我们可以认为他们相等</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(<span class="built_in">sqrt</span>(<span class="number">3</span>) * <span class="built_in">sqrt</span>(<span class="number">3</span>) - <span class="number">3</span>) &lt; eps) <span class="built_in">puts</span>(<span class="string">&quot;相等&quot;</span>);</span><br><span class="line"><span class="comment">// double fabs(double x)，fabs用于求绝对值</span></span><br></pre></td></tr></table></figure>

<p>这时我们便会发现显示相等了。</p>
<h2 id="5-数组的初始化"><a href="#5-数组的初始化" class="headerlink" title="5.数组的初始化"></a>5.数组的初始化</h2><p>注意一下：</p>
<p><img src="/posts/6381efd7/image-20201230191009315.png" alt="image-20201230191009315"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将数组全部初始化为0的写法</span></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">// 很常用</span></span><br></pre></td></tr></table></figure>

<p>切记：定义在函数内部（包括main函数）的数组，如果不初始化，则是随机的。</p>
<p>知识点：放在函数内部的数组空间存放在栈里，如果栈的空间不够，则可能会出现段错误。</p>
<p>但放在函数外部的数组空间存放在堆里，只要不超过内存限制，可以定的比较大。比如可以放main函数之外。</p>
<p>定义在函数外部的数组，如果不初始化，则是全部默认为0的。</p>
<p>这就是局部变量和全局变量的区别。</p>
<p>注意数组下标越界的问题，会导致段错误！</p>
<h2 id="6-练习题-旋转数组"><a href="#6-练习题-旋转数组" class="headerlink" title="6.练习题.旋转数组"></a>6.练习题.旋转数组</h2><p>输入一个n，再输入n个整数。将这个数组顺时针旋转k(k &lt;= n)次，最后将结果输出。</p>
<p>相关题目：<a href="https://www.acwing.com/problem/content/description/818/">acwing.816. 数组翻转</a>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般做法，有两重循环</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (k--)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> t = a[n<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-2</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i+<span class="number">1</span>] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	a[<span class="number">0</span>] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/6381efd7/image-20201230194748915.png" alt="image-20201230194748915"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更巧妙的做法，只有一重循环</span></span><br><span class="line"><span class="comment">//reverse函数用于反转在[first,last)范围内的顺序（包括first指向的元素，不包括last指向的元素），reverse函数没有返回值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">reverse(a,a + n);<span class="comment">// 翻转a[0]到a[n-1]的n个数</span></span><br><span class="line">reverse(a,a + k);<span class="comment">// 翻转a[0]到a[k-1]的k个数</span></span><br><span class="line">reverse(a + k,a + n);</span><br></pre></td></tr></table></figure>

<p><u>注意：reverse函数的参数是左闭右开的。</u></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//演示reverse函数</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,b[<span class="number">3</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">	reverse(a,a+<span class="number">1</span>);<span class="comment">// 翻转1个数</span></span><br><span class="line">	reverse(b,b+<span class="number">2</span>);<span class="comment">// 翻转2个数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++) <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++) <span class="built_in">cout</span> &lt;&lt; b[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出如下</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">    </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="7-acwing743-数组中的行"><a href="#7-acwing743-数组中的行" class="headerlink" title="7.acwing743.数组中的行"></a>7.acwing743.数组中的行</h2><p>输入一个二维数组<code>M[12][12]</code>，根据输入的要求，求出二维数组中某一行的元素的平均值或元素的和。</p>
<p> <strong>输入格式</strong></p>
<p>第一行输入整数L，表示所求的具体行数（行数从0开始计数）。</p>
<p>第二行包含一个大写字母，若为’S’，则表示需要求出第 L 行的元素的和，若为’M’，则表示需要求出第 L 行的元素的平均值。</p>
<p>接下来12行，每行包含12个用空格隔开的浮点数，表示这个二维数组，其中第 i+1 行的第 j+1 个数表示数组元素<code>M[i][j]</code>。输出一个数，表示所求的平均数或元素的和的值，保留一位小数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">char</span> op;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; op;</span><br><span class="line">    <span class="keyword">double</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">12</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> a;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">            <span class="keyword">if</span>(i==l) s+=a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,op==<span class="string">&#x27;S&#x27;</span> ? s : s/<span class="number">12</span>);<span class="comment">//简化操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-acwing749-数组的上方区域"><a href="#8-acwing749-数组的上方区域" class="headerlink" title="8.acwing749.数组的上方区域"></a>8.acwing749.数组的上方区域</h2><p><img src="/posts/6381efd7/image-20201230222858583.png" alt="image-20201230222858583"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">    <span class="keyword">double</span> a,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">12</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;i&amp;&amp;i+j&lt;<span class="number">11</span>)res+=a;<span class="comment">//关键是找到绿色方块的分布规律，两块区域的交集</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,c==<span class="string">&#x27;S&#x27;</span>?res:res/<span class="number">30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-acwing753-平方矩阵-I"><a href="#9-acwing753-平方矩阵-I" class="headerlink" title="9.acwing753.平方矩阵 I"></a>9.acwing753.平方矩阵 I</h2><p><img src="/posts/6381efd7/image-20201230225943900.png" alt="image-20201230225943900"></p>
<p><img src="/posts/6381efd7/image-20201230230029361.png" alt="image-20201230230029361"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这题不会做，困难</span></span><br><span class="line"><span class="comment">// 主要思路就是求到上下左右四条边的最小值，找到规律就不难</span></span><br><span class="line"><span class="comment">// y总解法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,up,down,left,right;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n,n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                up = i;down = n-i+<span class="number">1</span>;left = j;right = n-j+<span class="number">1</span>;<span class="comment">// 这四个变量还可以省略</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; min(min(up,down),min(left,right)) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-acwing756-蛇形矩阵"><a href="#10-acwing756-蛇形矩阵" class="headerlink" title="10.acwing756.蛇形矩阵"></a>10.acwing756.蛇形矩阵</h2><p><img src="/posts/6381efd7/image-20201231183222306.png" alt="image-20201231183222306"><img src="/posts/6381efd7/image-20210101111311064.png" alt="image-20210101111311064"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 来自于微软面试题，尝试写了一小段，没完成</span></span><br><span class="line"><span class="comment">// 有一定难度</span></span><br><span class="line"><span class="comment">// y总解题思路</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res[<span class="number">100</span>][<span class="number">100</span>];<span class="comment">// 小细节，定义为全局变量默认初始化为0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dy[] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;<span class="comment">// 定义横纵坐标偏移量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>,y = <span class="number">0</span>,d = <span class="number">0</span>,k = <span class="number">1</span>;k &lt;= n*m;k++)</span><br><span class="line">        <span class="comment">// d用于确定前进方向，开始时向右走</span></span><br><span class="line">    &#123;</span><br><span class="line">        res[x][y] = k;</span><br><span class="line">        <span class="keyword">int</span> a = x + dx[d],b = y + dy[d];</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m || res[a][b])</span><br><span class="line">        <span class="comment">// 判断是否出界，或者已经遍历过，未遍历过res[a][b] == 0</span></span><br><span class="line">        <span class="comment">// 符合条件则将方向顺时针旋转90度</span></span><br><span class="line">        &#123;</span><br><span class="line">            d = (d + <span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">            a = x + dx[d],b = y + dy[d];</span><br><span class="line">        &#125;</span><br><span class="line">        x = a,y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; res[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题解2，紫书</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">150</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));<span class="comment">// 初始化数组a为0</span></span><br><span class="line">    <span class="comment">// 作用是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;       <span class="comment">//初始坐标坐标，（0,0） </span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;            <span class="comment">//初始化第一个数 </span></span><br><span class="line">    a[x][y] = cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cnt &lt; n * m ) </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">//用下一笔的位置来判断</span></span><br><span class="line">        <span class="comment">//向右， 符合条件，则填入下一笔。____提前预判  </span></span><br><span class="line">        <span class="keyword">while</span> (y + <span class="number">1</span> &lt; m &amp;&amp; !a[x][y + <span class="number">1</span>]) a[x][ ++ y] = ++ cnt;</span><br><span class="line">        <span class="comment">//向下 </span></span><br><span class="line">        <span class="keyword">while</span> (x + <span class="number">1</span> &lt; n &amp;&amp; !a[x + <span class="number">1</span>][y]) a[ ++ x][y] = ++ cnt;</span><br><span class="line">        <span class="comment">//向左</span></span><br><span class="line">        <span class="keyword">while</span> (y - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !a[x][y - <span class="number">1</span>]) a[x][ -- y] = ++ cnt;</span><br><span class="line">        <span class="comment">//向上</span></span><br><span class="line">        <span class="keyword">while</span> (x - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !a[x - <span class="number">1</span>][y]) a[ -- x][y] = ++ cnt;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; a[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：大锤</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/12905/</span></span><br><span class="line">来源：AcWing</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>竞赛语法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>C++竞赛语法总结（五）</title>
    <url>/posts/f62c90a7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-acwing-779-最长公共字符串后缀"><a href="#1-acwing-779-最长公共字符串后缀" class="headerlink" title="1.acwing.779.最长公共字符串后缀"></a>1.acwing.779.最长公共字符串后缀</h2><p><strong>注：字符串这一章知识点比较多，有点难，要经常复习消化。</strong></p>
<p>输入格式</p>
<p>由若干组输入组成。</p>
<p>每组输入的第一行是一个整数N。</p>
<p>N为0时表示输入结束，否则后面会继续有N行输入，每行是一个字符串（字符串内不含空白符）。</p>
<p>每个字符串的长度不超过200。</p>
<p>输出格式</p>
<p>共一行，为N个字符串的最长公共后缀（可能为空）。</p>
<span id="more"></span>

<p>数据范围</p>
<p>1≤N≤200</p>
<p>输入样例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line">baba</span><br><span class="line">aba</span><br><span class="line">cba</span><br><span class="line"><span class="number">2</span></span><br><span class="line">aa</span><br><span class="line">cc</span><br><span class="line"><span class="number">2</span></span><br><span class="line">aa</span><br><span class="line">a</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ba</span><br><span class="line"></span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解，通过循环枚举后缀长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">210</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">string</span> str[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n,n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; str[i];</span><br><span class="line">            <span class="keyword">if</span> (len &gt; str[i].size()) len = str[i].size();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> success = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">bool</span> is_same = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= len;j ++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (str[<span class="number">0</span>][str[<span class="number">0</span>].size() - j] != str[i][str[i].size() - j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        is_same = <span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!is_same)</span><br><span class="line">                &#123;</span><br><span class="line">                    success = <span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (success) <span class="keyword">break</span>;</span><br><span class="line">            len --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; str[<span class="number">0</span>].substr(str[<span class="number">0</span>].size() - len) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-static静态关键字修饰变量"><a href="#2-static静态关键字修饰变量" class="headerlink" title="2.static静态关键字修饰变量"></a>2.static静态关键字修饰变量</h2><h3 id="2-1-修饰局部变量"><a href="#2-1-修饰局部变量" class="headerlink" title="2.1 修饰局部变量"></a>2.1 修饰局部变量</h3><p>用于函数内部修饰变量。<strong>相当于在函数内部开了一个只有该函数能用的全局变量。</strong></p>
<p>调用堆空间，和全局变量有相同之处，未初始化时默认为0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>; <span class="comment">// note:1</span></span><br><span class="line">	<span class="comment">//int i = 1;  // note:2</span></span><br><span class="line">	i += <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们总结一下，静态局部变量的特点（括号内为note:2,也就是局部变量的对比）：</p>
<p>（1）该变量在全局数据区分配内存(局部变量在栈区分配内存);<br>        （2）静态局部变量在程序执行到该对象的声明处时被首次初始化，<strong>即以后的函数调用不再进行初始化</strong>(局部变量每次函数调用都会被初始化);<br>        （3）静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0(局部变量不会被初始化);<br>        （4）它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，也就是不能在函数体外面使用它(局部变量在栈区，在函数结束后立即释放内存);</p>
<h3 id="2-2-修饰全局变量"><a href="#2-2-修饰全局变量" class="headerlink" title="2.2 修饰全局变量"></a>2.2 修饰全局变量</h3><p>定义在函数体之外，用于修饰全局变量，表示该变量只在本文件可见。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;  <span class="comment">//note:3</span></span><br><span class="line"><span class="comment">//int i = 1;  //note:4</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i += <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上我们就可以得出静态全局变量的特点：</p>
<p>静态全局变量不能被其它文件所用(全局变量可以);<br>其它文件中可以定义相同名字的变量，不会发生冲突(自然了，因为static隔离了文件，其它文件使用相同的名字的变量，也跟它没关系了);</p>
<h3 id="2-3-修饰函数"><a href="#2-3-修饰函数" class="headerlink" title="2.3 修饰函数"></a>2.3 修饰函数</h3><p>表明该函数只在同一文件中调用。</p>
<p>其它文件中可以定义相同名字的函数，不会发生冲突;</p>
<h2 id="3-函数引用"><a href="#3-函数引用" class="headerlink" title="3.函数引用"></a>3.函数引用</h2><p>当函数的形参为引用类型时，对形参的修改会影响实参的值。使用引用的作用：避免拷贝、让函数返回额外信息。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> &amp;x,&amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x = <span class="number">10</span>;y = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) <span class="keyword">return</span> x; <span class="comment">// 修改形参会影响实参的值</span></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max(a,b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// input:3 4</span></span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment">20</span></span><br><span class="line"><span class="comment">10 20</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="4-函数的参数"><a href="#4-函数的参数" class="headerlink" title="4.函数的参数"></a>4.函数的参数</h2><h3 id="4-1-数组参数"><a href="#4-1-数组参数" class="headerlink" title="4.1 数组参数"></a>4.1 数组参数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明、定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> a[])</span> <span class="comment">// 一维数组可省略</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> a[][<span class="number">4</span>])</span> <span class="comment">// 二维数组可省略第一个参数，第二个不可以</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> a[][<span class="number">4</span>][<span class="number">3</span>][<span class="number">4</span>])</span> <span class="comment">// 多维数组可省略第一个参数，后面的多不可以</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 调用函数</span></span></span><br><span class="line"><span class="function"><span class="title">output</span><span class="params">(a)</span></span>; <span class="comment">// 注意不要写成a[]或a[][4]这种形式</span></span><br></pre></td></tr></table></figure>

<p>数组的传递是引用传递，对形参的修改会影响实参的值。</p>
<h3 id="4-2-默认参数"><a href="#4-2-默认参数" class="headerlink" title="4.2 默认参数"></a>4.2 默认参数</h3><p>默认参数只能放在位置参数的后面，允许有多个默认参数和全部是默认参数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo(<span class="number">5</span>);<span class="comment">// 不加参数则执行默认参数</span></span><br><span class="line">    foo(<span class="number">5</span>,<span class="number">3</span>);<span class="comment">// 加了参数则按照加的参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment">5 10</span></span><br><span class="line"><span class="comment">5 3*/</span></span><br></pre></td></tr></table></figure>

<h2 id="5-acwing-817-数组去重"><a href="#5-acwing-817-数组去重" class="headerlink" title="5.acwing.817.数组去重"></a>5.acwing.817.数组去重</h2><p>给定一个长度为n的数组a，请你编写一个函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_unique_count</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>;  <span class="comment">// 返回数组前n个数中的不同数的个数</span></span><br></pre></td></tr></table></figure>

<p>输入格式</p>
<p>第一行包含一个整数n。</p>
<p>第二行包含n个整数，表示数组a。</p>
<p>输出格式</p>
<p>共一行，包含一个整数表示数组中不同数的个数。</p>
<p>数据范围</p>
<p>1≤n≤1000</p>
<p>输入样例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我的暴力做法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1001</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_unique_count</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[a[i]] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i]) cnt ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> a[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; get_unique_count(a,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unique</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> is_exist = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (a[j] == a[i])</span><br><span class="line">            &#123;</span><br><span class="line">                is_exist = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (!is_exist) cnt ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; unique(a, n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/activity/content/code/content/275258/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h2 id="6-acwing-818-数组排序"><a href="#6-acwing-818-数组排序" class="headerlink" title="6.acwing.818.数组排序"></a>6.acwing.818.数组排序</h2><p>给定一个长度为n的数组a以及两个整数 l 和 r，请你编写一个函数，<code>void sort(int a[], int l, int r)</code>，将a[l] ~ a[r]从小到大排序。</p>
<p>输出排好序的数组a。</p>
<p>输入格式<br>第一行包含三个整数n，l，r。</p>
<p>第二行包含n个整数，表示数组a。</p>
<p>输出格式<br>共一行，包含n个整数，表示排序完成后的数组a。</p>
<p>数据范围<br>0≤l≤r&lt;n≤1000<br>输入样例：<br>5 2 4<br>4 5 1 3 2<br>输出样例：<br>4 5 1 2 3</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// select sort,最简单的排序，y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l;i &lt;= r;i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt;= r;j ++)</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[i]) swap(a[j],a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,l,r;<span class="keyword">int</span> a[<span class="number">1001</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    sort(a,l,r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// bubble sort,参考的这位dalao的做法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l;i &lt; r;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = l;j &lt; r -i + l;j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t = a[j];</span><br><span class="line">                a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,l,r;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">1001</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;n;i ++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    sort(a,l,r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">作者：Struggle</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/13638/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h2 id="7-acwing-821-跳台阶"><a href="#7-acwing-821-跳台阶" class="headerlink" title="7.acwing.821.跳台阶"></a>7.acwing.821.跳台阶</h2><p>这题并不难，只是没有认真思考。</p>
<p><strong>蓝鲸dalao题解</strong></p>
<p>题目描述<br>一个楼梯共有n级台阶，每次可以走一级或者两级，问从第0级台阶走到第n级台阶一共有多少种方案。</p>
<p>输入格式<br>共一行，包含一个整数n。</p>
<p>输出格式<br>共一行，包含一个整数，表示方案数。</p>
<p>数据范围<br>1≤n≤15</p>
<p>样例<br>输入样例：<br>5<br>输出样例：<br>8<br>解题思路<br>先自己手动列举一下，</p>
<table>
<thead>
<tr>
<th>台阶/级</th>
<th>步数/步</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>5</td>
<td>8</td>
</tr>
<tr>
<td>6</td>
<td>13</td>
</tr>
</tbody></table>
<p>根据以上列举，不难发现，这TM就是一斐波那契数列！</p>
<p><strong>算法1</strong><br>递归<br>说人话就是到这一级的步数等于到上一级的方案数和上上级的方案数，<br>而第一级台阶方案数为1，第二级台阶方案数为2，后面的步骤就是有手就行了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">C++ 代码</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dg</span><span class="params">(<span class="keyword">int</span> dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep == <span class="number">1</span>)  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (dep == <span class="number">2</span>)  <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">//终止条件</span></span><br><span class="line">    <span class="keyword">return</span> dg(dep - <span class="number">1</span>) + dg(dep - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dg(n)); <span class="comment">//用递归</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法2</strong><br>for循环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">C++代码</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">15</span>; i++) <span class="comment">//不要管他丫的，一共就15个，肝就对了</span></span><br><span class="line">        a[i] = a[i - <span class="number">1</span>] + a[i - <span class="number">2</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：蓝鲸</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/11022/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p><strong>y总题解</strong></p>
<p>先画出递归搜索树：（枚举n=5的所有情况）</p>
<p><img src="/posts/f62c90a7/image-20210207141503611.png" alt="image-20210207141503611"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == n) ans ++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        f(k + <span class="number">1</span>);</span><br><span class="line">        f(k + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    f(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-acwing-823-排列"><a href="#8-acwing-823-排列" class="headerlink" title="8.acwing.823.排列"></a>8.acwing.823.排列</h2><p><strong>有点难度！要逐步分析！用VScode单步调试分析，画递归搜索树分析！！！</strong></p>
<p>给定一个整数n，将数字1~n排成一排，将会有很多种排列方法。</p>
<p>现在，请你按照字典序将所有的排列方法输出。</p>
<p>输入格式</p>
<p>共一行，包含一个整数n。</p>
<p>输出格式</p>
<p>按字典序输出所有排列方案，每个方案占一行。</p>
<p>数据范围</p>
<p>1≤n≤9</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">2 1 3</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure>

<p>首先画出<strong>深度遍历搜索树</strong>！！！用到深度遍历的思想。</p>
<p><img src="/posts/f62c90a7/image-20210207183231960.png" alt="image-20210207183231960"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> nums[],<span class="keyword">bool</span> st[])</span><span class="comment">// u是填充的位数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="built_in">cout</span> &lt;&lt; nums[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">            <span class="keyword">if</span> (!st[i])</span><br><span class="line">            &#123;</span><br><span class="line">                st[i] = <span class="literal">true</span>;</span><br><span class="line">                nums[u] = i;</span><br><span class="line">                dfs(u + <span class="number">1</span>,nums,st);</span><br><span class="line">                st[i] = <span class="literal">false</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> nums[N];</span><br><span class="line">    <span class="keyword">bool</span> st[N] = &#123;<span class="number">0</span>&#125;;<span class="comment">// 初始化为false</span></span><br><span class="line">    dfs(<span class="number">1</span>,nums,st);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意：当输入输出比较多时，用scanf和printf会快很多</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>竞赛语法</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>C++竞赛语法总结（六）</title>
    <url>/posts/9322db7e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>类可以将变量、数组和函数完美地打包在一起。</p>
<p>​                                                            ——yxc</p>
<h2 id="1-类"><a href="#1-类" class="headerlink" title="1.类"></a>1.类</h2><p>类中的变量和函数被统一称为类的成员变量。</p>
<p>private后面的内容是私有成员变量，在类的外部不能访问；public后面的内容是公有成员变量，在类的外部可以访问。</p>
<span id="more"></span>

<h2 id="2-结构体与类的唯一区别"><a href="#2-结构体与类的唯一区别" class="headerlink" title="2.结构体与类的唯一区别"></a>2.结构体与类的唯一区别</h2><p>结构体和类的作用是一样的。不同点在于类默认是private，结构体默认是public。</p>
<p>习惯上把结构较为简单的函数较少的代码定义成<strong>结构体</strong>，较为复杂的麻烦的代码定义成<strong>类</strong>。</p>
<p>成员变量在<strong>使用初始化列表</strong>初始化时，与构造函数中初始化成员列表的<strong>顺序无关</strong>，只与定义成员变量的顺序有关。因为成员变量的初始化次序是根据变量在内存中次序有关，而内存中的排列顺序早在编译期就根据变量的定义次序决定了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> age,height;</span><br><span class="line">        <span class="keyword">double</span> money;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, &quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">get_age</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add_money</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            money += x;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">string</span> books[<span class="number">100</span>];</span><br><span class="line">&#125;d,Persons[<span class="number">100</span>]; <span class="comment">//! 一定记得加分号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person C;</span><br><span class="line">    Person Per[<span class="number">120</span>];</span><br><span class="line">    C.name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">    <span class="comment">//C.age = 18;// 私有成员不可访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age,height;<span class="comment">// 不加默认是public</span></span><br><span class="line">    <span class="keyword">double</span> money;</span><br><span class="line">    Person ()&#123;&#125;</span><br><span class="line">    Person(<span class="keyword">int</span> _age,<span class="keyword">int</span> _height):age(_age),height(_height) &#123;&#125;</span><br><span class="line">    Person(<span class="keyword">int</span> _age,<span class="keyword">int</span> _height,<span class="keyword">double</span> _money):age(_age),height(_height),money(_money) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Person b;<span class="comment">// 定义在函数体外默认初始化为0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p ;</span><br><span class="line">    Person c = &#123;<span class="number">18</span>,<span class="number">180</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p.money &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b.money &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c.money &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 一些编译器输出0，一些输出随机值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7.90505e-323 随机值</span></span><br><span class="line"><span class="comment">0 默认初始化为0</span></span><br><span class="line"><span class="comment">1.43279e-322 随机值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译器关于构造函数使用与变量初始化相同的规则来初始化数据成员。对象a在函数体外定义，其int、double类型数据成员被初始为0；对象b在函数体内定义，构造函数不会对其进行初始化（符合内置类型变量初始化规则），其中存放的都是随机值。</p>
<h2 id="3-指针与引用-回顾指针的用法"><a href="#3-指针与引用-回顾指针的用法" class="headerlink" title="3.指针与引用(回顾指针的用法)"></a>3.指针与引用(回顾指针的用法)</h2><h3 id="指针即地址"><a href="#指针即地址" class="headerlink" title="指针即地址"></a><strong>指针即地址</strong></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> a,b;<span class="comment">// 堆空间，地址从小到大</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>,d;<span class="comment">// 栈空间，地址从大到小</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0x407030</span></span><br><span class="line"><span class="comment">0x407031</span></span><br><span class="line"><span class="comment">0x61fe1f</span></span><br><span class="line"><span class="comment">0x61fe1e</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span>* p = &amp;a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;before:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    *p = <span class="number">12</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;after:&quot;</span> &lt;&lt; a &lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">before:10 10</span></span><br><span class="line"><span class="comment">after:12 12</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>指针指向存放变量的值的地址。因此我们可以通过指针来修改变量的值。</p>
<p>这类似于我们通过数组下标来修改数组中的值。</p>
<p>数组名是一种特殊的指针。指针可以做运算：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i ++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;a[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0x61fe00</span></span><br><span class="line"><span class="comment">0x61fe00</span></span><br><span class="line"><span class="comment">0x61fe04</span></span><br><span class="line"><span class="comment">0x61fe08</span></span><br><span class="line"><span class="comment">0x61fe0c</span></span><br><span class="line"><span class="comment">0x61fe10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* p = a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *(p + <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0x61fe00</span></span><br><span class="line"><span class="comment">0x61fe04</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a><strong>引用</strong></h3><p>引用和指针类似，相当于给变量起了个别名。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span>* p = &amp;a;</span><br><span class="line">    <span class="keyword">int</span>&amp; p = a;<span class="comment">// C++的简化写法，引用（别名）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-链表"><a href="#4-链表" class="headerlink" title="4.链表"></a>4.链表</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node* next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> _val) : val(_val),next(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node node = Node(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 写法一，定义Node型变量，值是1</span></span><br><span class="line">    Node* p = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 写法二，定义Node型变量，返回值是Node的地址，p是指针</span></span><br><span class="line">    <span class="comment">// new Node(1);返回的是Node*</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如图：</p>
<p><img src="/posts/9322db7e/image-20210208135341530.png" alt="image-20210208135341530"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node* next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> _val) : val(_val),next(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> q = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">auto</span> o = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    p-&gt;next = q;</span><br><span class="line">    q-&gt;next = o;<span class="comment">// 构造链表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历单链表</span></span><br><span class="line">    Node* head = p;<span class="comment">// 头结点存放第一个结点的地址，也即头结点指向第一个结点</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;before:\t&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node* i = head;i;i = i-&gt;next) <span class="comment">// 循环结束条件等价于i != NULL </span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 头插法添加结点</span></span><br><span class="line">    Node* u = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">    u-&gt;next = head;</span><br><span class="line">    head = u;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;after:\t&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node* i = head;i;i = i-&gt;next) <span class="comment">// 循环结束条件等价于i != NULL </span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//删除结点</span></span><br><span class="line">    head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment">before: </span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">after:</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>链表的头结点（head）：<strong>大部分情况下指的是第一个结点的地址。而不是它的值</strong>。记牢！</p>
<p><img src="/posts/9322db7e/image-20210208143505731.png" alt="image-20210208143505731"></p>
<h2 id="5-acwing-21-斐波那契数列"><a href="#5-acwing-21-斐波那契数列" class="headerlink" title="5.acwing.21.斐波那契数列"></a>5.acwing.21.斐波那契数列</h2><p>输入一个整数 n ，求斐波那契数列的第 n 项。</p>
<p>假定从0开始，第0项为0。(n&lt;=39)（0,1,1,2，…)</p>
<p>样例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入整数 n&#x3D;5 </span><br><span class="line"></span><br><span class="line">返回 5</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>) + Fibonacci(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="6-acwing-84-求1-2-3-…-n"><a href="#6-acwing-84-求1-2-3-…-n" class="headerlink" title="6.acwing.84.求1 + 2 + 3 + … + n"></a>6.acwing.84.求1 + 2 + 3 + … + n</h2><p>求1+2+…+n,要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1,y总题解，利用短路</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> res = n;</span><br><span class="line">            n &gt; <span class="number">0</span> &amp;&amp; (res += getSum(n<span class="number">-1</span>));<span class="comment">//利用短路运算终止递归，因为不能用if</span></span><br><span class="line">            <span class="comment">// 如果改成n &gt;= 0则到getSum(-1)才停止，比真实值少1</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// solution 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a[n][n+<span class="number">1</span>]; <span class="comment">// 变相求前n项和</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">sizeof</span>(a)&gt;&gt;<span class="number">1</span>;<span class="comment">// &gt;&gt;1 右移相当于除以2，因为不能用除法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="7-acwing-87-把字符串转换成整数"><a href="#7-acwing-87-把字符串转换成整数" class="headerlink" title="7.acwing.87.把字符串转换成整数"></a>7.acwing.87.把字符串转换成整数</h2><p>请你写一个函数StrToInt，实现把字符串转换成整数这个功能。</p>
<p>当然，不能使用atoi或者其他类似的库函数。</p>
<p>样例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;123&quot;</span><br><span class="line"></span><br><span class="line">输出：123</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>:</p>
<p>你的函数应满足下列条件：</p>
<ol>
<li>忽略所有行首空格，找到第一个非空格字符，可以是 ‘+/−’ 表示是正数或者负数，紧随其后找到最长的一串连续数字，将其解析成一个整数；</li>
<li>整数后可能有任意非数字字符，请将其忽略；</li>
<li>如果整数长度为0，则返回0；</li>
<li>如果整数大于INT_MAX(2^31 − 1)，请返回INT_MAX；如果整数小于INT_MIN(−2^31) ，请返回INT_MIN；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1,我的题解，非常复杂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">0</span>;<span class="keyword">long</span> <span class="keyword">long</span> n = <span class="number">0</span>;<span class="keyword">int</span> num[<span class="number">40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> &amp;c:str)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> ) &#123;sign = <span class="number">1</span>;<span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) &#123;sign = <span class="number">-1</span>;<span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sign != <span class="number">0</span>|| (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                    &#123;num[i] = c <span class="number">-48</span>;i ++;&#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c != <span class="string">&#x27; &#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; !sign) sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            n += (<span class="keyword">long</span> <span class="keyword">long</span>)num[j]*<span class="built_in">pow</span>(<span class="number">10</span>,i<span class="number">-1</span>-j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sign *n &gt; <span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>)<span class="number">-1</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sign *n &lt; <span class="number">-1</span>*<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>)) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> sign * n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// solution 2,y总题解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; str.size() &amp;&amp; str[k] == <span class="string">&#x27; &#x27;</span>) k ++;<span class="comment">// 过滤空格</span></span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> minus = <span class="number">1</span>;<span class="comment">// 符号位</span></span><br><span class="line">            <span class="keyword">if</span> (k &lt; str.size())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (str[k] == <span class="string">&#x27;-&#x27;</span>) &#123;minus = <span class="number">-1</span>;k ++;&#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (str[k] == <span class="string">&#x27;+&#x27;</span>) k ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; str.size() &amp;&amp; str[k] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; str[k] &gt;= <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res = res * <span class="number">10</span> + str[k] - <span class="string">&#x27;0&#x27;</span>;<span class="comment">// 这个思路特别好，可以不用数组存放</span></span><br><span class="line">                <span class="keyword">if</span> (res &gt; <span class="number">1e11</span>) <span class="keyword">break</span>;<span class="comment">// 数据太大就直接跳出来</span></span><br><span class="line">                k ++;</span><br><span class="line">            &#125;</span><br><span class="line">            res *= minus;</span><br><span class="line">            <span class="keyword">if</span> (res &gt; INT_MAX) res = INT_MAX;</span><br><span class="line">            <span class="keyword">if</span> (res &lt; INT_MIN) res = INT_MIN;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="8-acWing-28-在O-1-时间删除链表结点"><a href="#8-acWing-28-在O-1-时间删除链表结点" class="headerlink" title="8.acWing 28. 在O(1)时间删除链表结点"></a>8.acWing 28. 在O(1)时间删除链表结点</h2><p><u>tips：链表题多画图，方便思考，空想还是有难度的！</u></p>
<p>给定单向链表的一个节点指针，定义一个函数在O(1)时间删除该结点。</p>
<p>假设链表一定存在，并且该节点一定不是尾节点。</p>
<p>样例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：链表 <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">6</span>-&gt;<span class="number">8</span></span><br><span class="line">      删掉节点：第<span class="number">2</span>个节点即<span class="number">6</span>（头节点为第<span class="number">0</span>个节点）</span><br><span class="line"></span><br><span class="line">输出：新链表 <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">8</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1,y总题解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;<span class="comment">// 将待删除结点伪装成它的下一个结点</span></span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;<span class="comment">// 删除它的后一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// solution 2,y总题解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        *(node) = *(node-&gt;next);<span class="comment">// 结构体整体赋值，相当于往前推进一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="9-acwing-36-合并两个排序的链表"><a href="#9-acwing-36-合并两个排序的链表" class="headerlink" title="9.acwing.36.合并两个排序的链表"></a>9.acwing.36.合并两个排序的链表</h2><p>输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。</p>
<p>样例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;3-&gt;5 , 2-&gt;4-&gt;5</span><br><span class="line"></span><br><span class="line">输出：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;5</span><br></pre></td></tr></table></figure>

<p><strong>算法：(二路归并) O(n)</strong><br>    新建头部的保护结点dummy，设置cur指针指向dummy。<br>若当前l1指针指向的结点的值val比l2指针指向的结点的值val小，则令cur的next指针指向l1，且l1后移；否则指向l2，且l2后移。<br>    然后cur指针按照上一部设置好的位置后移。<br>    循环以上步骤直到l1或l2为空。<br>    将剩余的l1或l2接到cur指针后边。<br><strong>时间复杂度</strong><br>两个链表各遍历一次，所以时间复杂度为O(n)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1 -&gt; val &lt; l2 -&gt; val) &#123;</span><br><span class="line">                cur -&gt; next = l1;</span><br><span class="line">                l1 = l1 -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cur -&gt; next = l2;</span><br><span class="line">                l2 = l2 -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur -&gt; next = (l1 != <span class="literal">NULL</span> ? l1 : l2);</span><br><span class="line">        <span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="10-acwing-35-反转链表"><a href="#10-acwing-35-反转链表" class="headerlink" title="10.acwing.35.反转链表"></a>10.acwing.35.反转链表</h2><p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。</p>
<p><strong>思考题：</strong></p>
<ul>
<li>请同时实现迭代版本和递归版本。</li>
</ul>
<p>样例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line"></span><br><span class="line">输出:5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<p>作者：yxc<br>        链接：<a href="https://www.acwing.com/solution/content/743/">https://www.acwing.com/solution/content/743/</a><br>        来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p><strong>算法1：(链表操作，迭代) O(n)</strong></p>
<p>迭代也就是循环的意思。</p>
<p>翻转即将所有节点的next指针指向前驱节点。<br>由于是单链表，我们在迭代时不能直接找到前驱节点，所以我们需要一个额外的指针保存前驱节点。同时在改变当前节点的next指针前，不要忘记保存它的后继节点。</p>
<ul>
<li>空间复杂度分析：遍历时只有3个额外变量，所以额外的空间复杂度是 O(1)。</li>
<li>时间复杂度分析：只遍历一次链表，时间复杂度是 O(n)。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        ListNode* q = p-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (q)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* o = q-&gt;next;</span><br><span class="line">            q-&gt;next = p;</span><br><span class="line">            p = q,q = o;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;<span class="comment">// 一定注意这里不能忘</span></span><br><span class="line">        <span class="comment">// nullptr和0，NULL等价</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// solution 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">            ListNode *prev = <span class="literal">nullptr</span>;<span class="comment">// 这里不用考虑上面的初始头结点指空</span></span><br><span class="line">            ListNode *cur = head;</span><br><span class="line">            <span class="keyword">while</span> (cur)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode *next = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = prev;</span><br><span class="line">                prev = cur, cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> prev;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>算法2:(链表操作，递归) O(n)</strong><br>首先我们先考虑 reverseList 函数能做什么，它可以翻转一个链表，并返回新链表的头节点，也就是原链表的尾节点。<br>所以我们可以先递归处理 <code>reverseList(head-&gt;next)</code>，这样我们可以将以<code>head-&gt;next</code>为头节点的链表翻转，并得到原链表的尾节点tail，此时<code>head-&gt;next</code>是新链表的尾节点，我们令它的next指针指向head，并将<code>head-&gt;next</code>指向空即可将整个链表翻转，<strong>且新链表的头节点是tail</strong>。</p>
<ul>
<li>空间复杂度分析：总共递归 n 层，系统栈的空间复杂度是 O(n)，所以总共需要额外 O(n) 的空间。</li>
<li>时间复杂度分析：链表中每个节点只被遍历一次，所以时间复杂度是 O(n)。</li>
</ul>
<p><img src="/posts/9322db7e/image-20210213200327031.png" alt="来自一位xjj的javascript讲解"></p>
<p><img src="/posts/9322db7e/image-20210213201614715.png" alt="image-20210213201614715"></p>
<p>​                                                      <strong>head是每一层函数的返回值res。</strong></p>
<p>讲解链接：<a href="https://www.bilibili.com/video/av83907207?t=1">https://www.bilibili.com/video/av83907207?t=1</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;<span class="comment">// 递归最小一层返回head</span></span><br><span class="line">            ListNode *tail = reverseList(head-&gt;next);</span><br><span class="line">            head-&gt;next-&gt;next = head;</span><br><span class="line">            head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> tail;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>竞赛语法</tag>
        <tag>链表</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>CLion配置使用教程</title>
    <url>/posts/9869850b.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="CLion配置使用教程"><a href="#CLion配置使用教程" class="headerlink" title="CLion配置使用教程"></a>CLion配置使用教程</h2><p>参考下载安装教程：<a href="https://www.jb51.net/article/193508.htm">https://www.jb51.net/article/193508.htm</a></p>
<p>最好不要下载最新的，破解可能失效，然后跟着教程来就行了。</p>
<span id="more"></span>

<p>下面讲一下会遇到的问题（坑）：</p>
<p>配置MinGW时可能会出现如下警告。</p>
<p><img src="/posts/9869850b/image-20210418122025803.png" alt="image-20210418122025803"></p>
<p>我们点击More，可以看到类似下图的错误：</p>
<p><img src="/posts/9869850b/image-20210418122124086.png" alt="image-20210418122124086"></p>
<p>解决方案请参照<a href="https://zhuanlan.zhihu.com/p/43680621">这里</a></p>
<p>有的人内容可能不是完全一样（没有乱码，都是英文，其他一致）：如果上面的方案不行，再接着往下看</p>
<p>参照这篇<a href="https://www.pianshen.com/article/33861131114/">文章</a>，我花了大半天时间才找到这个非常有效的解决方案，我们根据提示，在D盘下新建一个CLion文件夹（或者你找别的路径也行），对照下图修改这四个部分。</p>
<p><img src="/posts/9869850b/image-20210418122720065.png" alt="image-20210418122720065"></p>
<p>然后打开CLion，新建工程，点击 help – edit custom vm options</p>
<p>在后面加上一行 <code>-Djava.io.tmpdir=d:/CLion/Temp</code></p>
<p>这下再重新执行CMakelist就行了，运行main.cpp会顺利看到hello，world就成功了。</p>
<p>有人可能还会出现头文件下方红线提示找不到的情况，可能是因为你CMake的路径改成了下载的CMake了，</p>
<p>再按照下图改回MinGW默认的就不会报错了。</p>
<p><img src="/posts/9869850b/image-20210418123300435.png" alt="image-20210418123300435"></p>
<p>最后就可以放心的使用CLion了！</p>
<p><img src="/posts/9869850b/image-20210418123416782.png" alt="image-20210418123416782"></p>
<p><strong>补充关于CLion的多文件编译：</strong></p>
<p>CLion默认一个项目之下只能有一个带main函数的源文件。</p>
<p>我们可以通过修改CMakeList文件来分别编译一个项目下的多个带main函数的源文件。</p>
<p>参考自：<a href="https://zhuanlan.zhihu.com/p/124284203%E3%80%82">https://zhuanlan.zhihu.com/p/124284203。</a></p>
<p>这里我们采用安装插件的方式来实现，如果不能在CLion中在线下载安装插件，可以直接在官网中下载，然后通过本地安装插件。</p>
<p>官网插件下载链接：<a href="https://plugins.jetbrains.com/">https://plugins.jetbrains.com/</a></p>
<p><img src="/posts/9869850b/image-20210419133730396.png" alt="image-20210419133730396"></p>
<p>安装插件之后就可以编写代码了。</p>
<p>这里有两段测试程序，main.cpp和test.cpp。</p>
<p>分别在cpp文件下单击右键：</p>
<p><img src="/posts/9869850b/image-20210419133920525.png" alt="image-20210419133920525"></p>
<p>这时会发现CMakeList文件中多了一行代码add_executable(main main.cpp)。（其实可以不用插件手动添加）</p>
<p>要运行单个文件，只要选择对应的文件即可，然后点击’Run’按钮。</p>
<p><img src="/posts/9869850b/image-20210419134154418.png" alt="image-20210419134154418"></p>
<p>现在你已经成功掌握了CLion的基本用法了！</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>CLion</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS学习笔记（一）</title>
    <url>/posts/8165435b.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-什么是CSS？"><a href="#1-什么是CSS？" class="headerlink" title="1.什么是CSS？"></a>1.什么是CSS？</h2><p>HTML+CSS+JavaScript</p>
<p>结构+表现+交互</p>
<ol>
<li>CSS最重要的部分就是<strong>选择器（重点+难点）</strong>；</li>
<li>美化网页（文字，阴影，超链接，列表，渐变…）；</li>
<li>盒子模型；</li>
<li>浮动；</li>
<li>定位。</li>
</ol>
<span id="more"></span>

<p>推荐前端学习网站：w3cschool和菜鸟教程。</p>
<p>前端和Java程序员一个很重要的区别就是：CSS。</p>
<p>作为Java程序员只要<strong>重点掌握选择器</strong>就行。</p>
<hr>
<p>CSS 是层叠样式表 ( Cascading Style Sheets ) 的简称。</p>
<p> 是用来表现HTML或XML的标记语言。</p>
<p>是由W3C的CSS工作组发布推荐和维护的。</p>
<p>CSS核心：表现层（<strong>美化网页</strong>）</p>
<p>字体，颜色，边距，高度，宽度，背景图片，网页定位，网页浮动…</p>
<p>CSS发展史：</p>
<p>CSS1.0 –&gt;</p>
<p> CSS2.0 –&gt; DIV（块）+ CSS，HTML与CSS结构分离的思想，网页变得简单，SEO</p>
<p> CSS2.1 –&gt; 浮动，定位</p>
<p> CSS3.0 圆角，阴影，动画</p>
<h2 id="2-CSS程序"><a href="#2-CSS程序" class="headerlink" title="2.CSS程序"></a>2.CSS程序</h2><p>以后尽量都保持这样的练习格式：</p>
<p><img src="/posts/8165435b/image-20210510193319750.png" alt="image-20210510193319750"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.html--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--规范，尽量在head中写CSS代码</span></span><br><span class="line"><span class="comment">    语法：</span></span><br><span class="line"><span class="comment">        选择器&#123;</span></span><br><span class="line"><span class="comment">            声明1;</span></span><br><span class="line"><span class="comment">            声明2;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--在html的style属性中写css代码--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">h1</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">color</span>: brown;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>html与css分离：建议使用这种格式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.html--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--规范，尽量在head中写CSS代码</span></span><br><span class="line"><span class="comment">    语法：</span></span><br><span class="line"><span class="comment">        选择器&#123;</span></span><br><span class="line"><span class="comment">            声明1;</span></span><br><span class="line"><span class="comment">            声明2;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引用css代码--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*这是CSS注释，html也行</span></span><br><span class="line"><span class="comment">style.css*/</span></span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: brown;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>css的优势：</p>
<ol>
<li>内容和表现分离</li>
<li>网页结构表现统一，可以实现复用</li>
<li>样式丰富</li>
<li>利用SEO，容易被搜索引擎收录</li>
</ol>
<h2 id="3-CSS的三种导入方式"><a href="#3-CSS的三种导入方式" class="headerlink" title="3.CSS的三种导入方式"></a>3.CSS的三种导入方式</h2><ol>
<li>行内样式</li>
<li>内部样式</li>
<li>外部样式</li>
</ol>
<p>优先级：就近原则。(覆盖原则)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="comment">/*内部样式*/</span></span></span><br><span class="line"><span class="css">        <span class="selector-tag">h1</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">color</span>: aqua;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    /*外部样式*/</span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--行内样式：在标签元素中编写style属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>;&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>拓展：外部样式的两种写法，仅作为了解内容</p>
<ul>
<li><p>链接式：</p>
<p>  html标签，只能用于html源码</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">/*外部样式*/</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/style.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>导入式：一般不使用</p>
<p>  CSS2.1特有，必须放入style标签</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="keyword">@import</span> url(<span class="string">&quot;css/style.css&quot;</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Java世界第一<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="4-选择器"><a href="#4-选择器" class="headerlink" title="4.选择器"></a>4.选择器</h2><blockquote>
<p>作用：选择页面上的某一个或者某一类元素</p>
</blockquote>
<h3 id="4-1基本选择器（必须掌握）"><a href="#4-1基本选择器（必须掌握）" class="headerlink" title="4.1基本选择器（必须掌握）"></a>4.1基本选择器（必须掌握）</h3><ol>
<li>标签选择器：选择一类标签，<code>标签&#123;&#125;</code></li>
<li>类选择器 class：选择所有class属性的标签，可跨标签，<code>.类名&#123;&#125;</code></li>
<li>id选择器：id名字不能以数字开头，ID 属性只能在每个 HTML 文档中出现一次，<code>#id名&#123;&#125;</code></li>
<li><strong>固定的</strong>优先级：行内样式 &gt; id选择器 &gt; class选择器 &gt; 标签选择器</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">/*标签选择器*/</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="comment">/*标签选择器，会选择页面上所有带这个标签的元素*/</span></span></span><br><span class="line"><span class="css">        <span class="comment">/*两个h1标签都会改变*/</span></span></span><br><span class="line"><span class="css">        <span class="selector-tag">h1</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">color</span>: darkgrey;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: crimson;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">23px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>学习使我快乐<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>疯狂卷起来<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>一日不学心慌张<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">/*类选择器*/</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        /*类选择器，&quot;.class的名称&#123;&#125;&quot;</span><br><span class="line">        好处：可以让多个标签归类，是同一个class，可以复用</span><br><span class="line">        */</span><br><span class="line">        .learn&#123;</span><br><span class="line"><span class="css">            <span class="attribute">color</span>: crimson;</span></span><br><span class="line">        &#125;</span><br><span class="line">        .juan&#123;</span><br><span class="line"><span class="css">            <span class="attribute">color</span>: <span class="number">#24c497</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;learn&quot;</span>&gt;</span>学习使我快乐<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;juan&quot;</span>&gt;</span>疯狂卷起来<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;learn&quot;</span>&gt;</span>一日不学心慌张<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">/*id选择器*/</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        /*id选择器 : id必须保证全局唯一！</span><br><span class="line">        #id名称&#123;&#125;</span><br><span class="line">         */</span><br><span class="line">        #learn&#123;</span><br><span class="line"><span class="css">            <span class="attribute">color</span>: <span class="number">#24c497</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">        .juan&#123;</span><br><span class="line"><span class="css">            <span class="attribute">color</span>:darkorange;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-tag">h1</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">color</span>: blue;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;learn&quot;</span>&gt;</span>学习使我快乐<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;juan&quot;</span>&gt;</span>疯狂卷起来<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;learn&quot;</span>&gt;</span>一日不学心慌张<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>C++竞赛语法总结（八）</title>
    <url>/posts/b64984a2.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>(续上文)</p>
<hr>
<h3 id="3-5-include-lt-set-gt"><a href="#3-5-include-lt-set-gt" class="headerlink" title="3.5 #include &lt;set&gt; "></a>3.5 <code>#include &lt;set&gt; </code></h3><p>头文件set主要包括set和multiset两个容器，分别是“有序集合”和“有序多重集合”，<strong>即前者的元素不能重复，而后者可以包含若干个相等的元素</strong>。set和multiset的内部实现是一棵红黑树，它们支持的函数基本相同。 </p>
<span id="more"></span>

<h4 id="3-5-1-声明"><a href="#3-5-1-声明" class="headerlink" title="3.5.1 声明"></a>3.5.1 声明</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rec</span>&#123;</span>…&#125;; <span class="built_in">set</span>&lt;rec&gt; s;   <span class="comment">// 结构体rec中必须定义小于号</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">double</span>&gt; s;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-2-size-empty-clear"><a href="#3-5-2-size-empty-clear" class="headerlink" title="3.5.2 size/empty/clear"></a>3.5.2 size/empty/clear</h4><p>​    与vector类似 </p>
<h4 id="3-5-3-迭代器"><a href="#3-5-3-迭代器" class="headerlink" title="3.5.3 迭代器"></a>3.5.3 迭代器</h4><p>set和multiset的迭代器称为“双向访问迭代器”，不*<em>支持“随机访问”，支持星号(</em>)解除引用，仅支持”++”和–“两个与算术相关的操作**。</p>
<p>设it是一个迭代器，例如<code>set&lt;int&gt;::iterator it;</code></p>
<p>若把<code>it++</code>，则it会指向“下一个”元素。这里的“下一个”元素是指在元素从小到大排序的结果中，排在it下一名的元素。同理，若把<code>it--</code>，则it将会指向排在“上一个”的元素。</p>
<h4 id="3-5-4-begin-end"><a href="#3-5-4-begin-end" class="headerlink" title="3.5.4 begin/end"></a>3.5.4 begin/end</h4><ul>
<li>返回集合的首、尾迭代器，时间复杂度均为O(1)。</li>
<li>s.begin() 是指向集合中最小元素的迭代器。</li>
<li>s.end() 是指向集合中最大元素的下一个位置的迭代器。<strong>换言之，就像vector一样，是一个“前闭后开”的形式</strong>。<strong>因此–s.end()是指向集合中最大元素的迭代器</strong>。</li>
</ul>
<h4 id="3-5-6-insert"><a href="#3-5-6-insert" class="headerlink" title="3.5.6 insert"></a>3.5.6 insert</h4><ul>
<li>s.insert(x)把一个元素x插入到集合s中，时间复杂度为O($logn$)。</li>
<li>在set中，若元素已存在，则不会重复插入该元素，对集合的状态无影响。</li>
</ul>
<h4 id="3-5-7-find"><a href="#3-5-7-find" class="headerlink" title="3.5.7 find"></a>3.5.7 find</h4><p>s.find(x) 在集合s中查找等于x的元素，并返回指向该元素的迭代器。若不存在，则返回s.end()。时间复杂度为O($logn$)。</p>
<h4 id="3-5-8-lower-bound-upper-bound"><a href="#3-5-8-lower-bound-upper-bound" class="headerlink" title="3.5.8 lower_bound/upper_bound"></a>3.5.8 lower_bound/upper_bound</h4><ul>
<li>这两个函数的用法与find类似，但查找的条件略有不同，时间复杂度为 O($logn$)。</li>
<li>s.lower_bound(x) 查找大于等于x的元素中最小的一个，并返回指向该元素的迭代器。</li>
<li>s.upper_bound(x) 查找大于x的元素中最小的一个，并返回指向该元素的迭代器。</li>
</ul>
<h4 id="3-5-9-erase"><a href="#3-5-9-erase" class="headerlink" title="3.5.9 erase"></a>3.5.9 erase</h4><ul>
<li>设it是一个迭代器，s.erase(it) 从s中删除迭代器it指向的元素，时间复杂度为O$logn$)</li>
<li>设x是一个元素，s.erase(x) 从s中删除所有等于x的元素，时间复杂度为O(k+$logn$)，其中k是被删除的元素个数。 </li>
</ul>
<h4 id="3-5-10-count"><a href="#3-5-10-count" class="headerlink" title="3.5.10 count"></a>3.5.10 count</h4><p>​       s.count(x) 返回集合s中等于x的元素个数，时间复杂度为 O(k +$logn$)，其中k为元素x的个数。</p>
<h4 id="3-5-11-实例"><a href="#3-5-11-实例" class="headerlink" title="3.5.11 实例"></a>3.5.11 实例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; a;<span class="comment">// 不能包含重复元素，否则会忽略操作</span></span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; b;<span class="comment">// 可以包含重复元素</span></span><br><span class="line">    <span class="comment">// set中需要作比较，所以必须重载</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Rec</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Rec&amp; t) <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x &lt; t.x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">set</span>&lt;Rec&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = a.begin();</span><br><span class="line">    it ++, it --;</span><br><span class="line">    ++ it, -- it;</span><br><span class="line">    a.end();</span><br><span class="line"></span><br><span class="line">    a.insert(x);</span><br><span class="line">    <span class="keyword">if</span> (a.find(x) == a.end()) <span class="comment">// 判断x在a中是否存在</span></span><br><span class="line">    a.lower_bound(x);<span class="comment">// 找到大于等于x的最小元素的迭代器</span></span><br><span class="line">    a.upper_bound(x);<span class="comment">// 找到大于x的最小元素的迭代器，很容易犯错</span></span><br><span class="line">    a.count(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-include-lt-map-gt"><a href="#3-6-include-lt-map-gt" class="headerlink" title="3.6 #include &lt;map&gt;"></a>3.6 <code>#include &lt;map&gt;</code></h3><p>map容器是一个键值对key-value的映射，其内部实现是一棵以key为关键码的红黑树。Map的key和value可以是任意类型，其中key必须定义小于号运算符。</p>
<h4 id="3-6-1-声明"><a href="#3-6-1-声明" class="headerlink" title="3.6.1 声明"></a>3.6.1 声明</h4><p>​       <code>map&lt;key_type, value_type&gt; name;</code></p>
<p>​       例如：</p>
<p>​       <code>map&lt;long, long, bool&gt; vis;</code></p>
<p>​       <code>map&lt;string, int&gt; hash;</code></p>
<p>​       <code>map&lt;pair&lt;int, int&gt;, vector&lt;int&gt;&gt; test;</code></p>
<h4 id="3-6-2"><a href="#3-6-2" class="headerlink" title="3.6.2"></a>3.6.2</h4><p>​    size/empty/clear/begin/end均与set类似。 </p>
<h4 id="3-6-3-Insert-erase"><a href="#3-6-3-Insert-erase" class="headerlink" title="3.6.3 Insert/erase"></a>3.6.3 Insert/erase</h4><p>​       与set类似，但其参数均是<code>pair&lt;key_type, value_type&gt;</code>。</p>
<h4 id="3-6-4-find"><a href="#3-6-4-find" class="headerlink" title="3.6.4 find"></a>3.6.4 find</h4><p>​       h.find(x) 在变量名为h的map中查找key为x的二元组。</p>
<h4 id="3-6-5-操作符"><a href="#3-6-5-操作符" class="headerlink" title="3.6.5  []操作符"></a>3.6.5  []操作符</h4><p>​       h[key] 返回key映射的value的引用，时间复杂度为O(logn)。</p>
<p>[]操作符是map最吸引人的地方。我们可以很方便地通过h[key]来得到key对应的value，还可以对h[key]进行赋值操作，改变key对应的value。</p>
<h4 id="3-6-6-实例"><a href="#3-6-6-实例" class="headerlink" title="3.6.6 实例"></a>3.6.6 实例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; a;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">10000</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[<span class="number">10000</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; b,c;</span><br><span class="line">    b[<span class="string">&quot;yxc&quot;</span>] = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    c[<span class="string">&quot;llx&quot;</span>] = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b[<span class="string">&quot;yxc&quot;</span>].size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c[<span class="string">&quot;llx&quot;</span>][<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    b.insert(&#123;<span class="string">&quot;as&quot;</span>,&#123;&#125;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">&quot;as&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (b.find(str) == b.end()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-7-补充的几个STL"><a href="#3-7-补充的几个STL" class="headerlink" title="3.7 补充的几个STL"></a>3.7 补充的几个STL</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; S;<span class="comment">// 底层由哈希表实现，不能存储重复元素</span></span><br><span class="line">    <span class="comment">/* 与set的区别：</span></span><br><span class="line"><span class="comment">    1.比set少了lower_bound/upper_bound，因为是无序的</span></span><br><span class="line"><span class="comment">    2.主要操作复杂度是O(1)，而set是O(logn)，相对效率更高</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">unordered_multiset</span>&lt;<span class="keyword">int</span>&gt; b;<span class="comment">// 可以存储重复元素</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; c;<span class="comment">// 哈希表，与map几乎完全一样</span></span><br><span class="line">    <span class="comment">// 效率更高，都是O(1)，而map是O(logn)，但不支持二分</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bitset</span>&lt;1000&gt; a,t;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    a.<span class="built_in">set</span>(<span class="number">3</span>);<span class="comment">// 把a[3]设为1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[<span class="number">3</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    a.reset(<span class="number">3</span>);<span class="comment">// 把a[3]设为0</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[<span class="number">3</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-8-二元组-pair"><a href="#3-8-二元组-pair" class="headerlink" title="3.8 二元组(pair)"></a>3.8 二元组(pair)</h3><p>pair是将2个数据组合成一组数据，当需要这样的需求时就可以使用pair，如stl中的map就是将key和value放在一起来保存。另一个应用是，当一个函数需要返回2个数据的时候，可以选择pair。 </p>
<p>pair的实现是一个结构体，主要的两个成员变量是first second 因为是使用struct不是class，所以可以直接使用pair的成员变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt; a,b;</span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p;</span><br><span class="line">    a = &#123;<span class="number">3</span>,<span class="string">&quot;yxc&quot;</span>&#125;;<span class="comment">// C++99不支持这种赋值</span></span><br><span class="line">    a = <span class="built_in">make_pair</span>(<span class="number">4</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// pair支持a &gt;= b,a &lt;= b,a == b,a != b等比较运算</span></span><br><span class="line">    <span class="comment">// 先比较first，再比较second</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c,d;</span><br><span class="line">    <span class="comment">// if(c == d)，vector也支持按字典序进行比较，先比较数组第一个位置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-位运算与常见库函数"><a href="#4-位运算与常见库函数" class="headerlink" title="4.位运算与常见库函数"></a>4.位运算与常见库函数</h2><p>C++帮我们实现好了很多有用的函数，我们要避免重复造轮子。                                                               ——yxc</p>
<h3 id="4-1-位运算"><a href="#4-1-位运算" class="headerlink" title="4.1 位运算"></a>4.1 位运算</h3><p>其实是数学上的概念。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>运算</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>与(AND)</td>
</tr>
<tr>
<td>|</td>
<td>或(OR)</td>
</tr>
<tr>
<td><strong>~</strong></td>
<td>非(NOT)</td>
</tr>
<tr>
<td>^</td>
<td>异或(XOR)（不进位的加）</td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>右移</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>左移</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>&amp;<span class="number">0</span> = <span class="number">0</span>, <span class="number">0</span>&amp;<span class="number">1</span> = <span class="number">0</span>, <span class="number">1</span>&amp;<span class="number">0</span> = <span class="number">0</span>, <span class="number">1</span>&amp;<span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0</span>|<span class="number">0</span> = <span class="number">0</span>, <span class="number">1</span>|<span class="number">0</span> = <span class="number">1</span>, <span class="number">0</span>|<span class="number">1</span> = <span class="number">1</span>, <span class="number">1</span>|<span class="number">1</span> = <span class="number">1</span></span><br><span class="line">~<span class="number">0</span> = <span class="number">1</span>, ~<span class="number">1</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span>^<span class="number">0</span> = <span class="number">0</span>, <span class="number">1</span>^<span class="number">1</span> = <span class="number">0</span>, <span class="number">1</span>^<span class="number">0</span> = <span class="number">1</span>, <span class="number">0</span>^<span class="number">1</span> = <span class="number">1</span> </span><br></pre></td></tr></table></figure>

<p>总之,在C中,左移是逻辑/算术左移(两者完全相同),右移是算术右移,会保持符号位不变.实际应用中可以根据情况用左/右移做快速的乘/除运算,这样会比循环效率高很多.</p>
<p><strong>常用操作：</strong></p>
<p>(1)  <strong>求x的第k位数字 x &gt;&gt; k &amp; 1</strong></p>
<p>(2)  <strong>lowbit(x) = x &amp; -x=x &amp; (~x + 1)，返回x的最后一位1及以后的数</strong></p>
<p>比如12（10）二进制表示为 1100（2），<code>lowbit(12) == 100（2）== 4（10）</code>。</p>
<p>(3) 我们可以直观的发现，如果是一个偶数^1,那么答案是偶数+1.如果是一个奇数^1,那么答案是奇数-1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>,b = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (a^b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    a = <span class="number">13</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (a &gt;&gt; <span class="number">2</span> &amp; <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>;i &gt;= <span class="number">0</span>;i --) <span class="built_in">cout</span> &lt;&lt; (a &gt;&gt; i &amp; <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">2345256</span>;</span><br><span class="line">    <span class="keyword">int</span> d = -c;</span><br><span class="line">    <span class="keyword">int</span> e = ~c + <span class="number">1</span>;<span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-acwing-67-数字在排序数组中出现的次数"><a href="#5-acwing-67-数字在排序数组中出现的次数" class="headerlink" title="5.acwing.67.数字在排序数组中出现的次数"></a>5.acwing.67.数字在排序数组中出现的次数</h2><p>题目描述<br>求一个排好序的数组中k的个数。例如输入排序数组[1, 2, 3, 3, 3, 3, 4, 5]和数字3，由于3在这个数组中出现了4次，因此输出4。</p>
<p>解题思路<br>目的是练习stl和常用的库函数</p>
<h3 id="题解一："><a href="#题解一：" class="headerlink" title="题解一："></a>题解一：</h3><p>使用有序多重集合multiset</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : nums) s.insert(x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.count(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="题解二："><a href="#题解二：" class="headerlink" title="题解二："></a>题解二：</h3><p>遍历vector，计数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : nums)</span><br><span class="line">            <span class="keyword">if</span>(x == k)</span><br><span class="line">                cnt++;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="题解三："><a href="#题解三：" class="headerlink" title="题解三："></a>题解三：</h3><p>二分做法，使用lower_bound和upper_bound,指针运算得出次数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> l = lower_bound(nums.begin(), nums.end(), k);<span class="comment">//第一个大于等于x的数的地址</span></span><br><span class="line">        <span class="keyword">auto</span> r = upper_bound(nums.begin(), nums.end(), k);<span class="comment">//第一个大于x的数的地址</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> r - l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>作者：醉生梦死<br>链接：<a href="https://www.acwing.com/solution/content/16094/">https://www.acwing.com/solution/content/16094/</a><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="关于vector中的lower-bound和upper-bound"><a href="#关于vector中的lower-bound和upper-bound" class="headerlink" title="关于vector中的lower_bound和upper_bound"></a>关于vector中的lower_bound和upper_bound</h3><h4 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h4><p>比较的“首”地址+ 一个数组元素的地址（对应的这个数组里边任意一个元素的地址，表示这个二分里边的比较的”结尾’地址）+ 你要二分查找的那个数。</p>
<p>一个数组元素的地址（或者数组名来表示这个数组的首地址，用来表示这个数组的开头比较的元素的地址，不一定要是首地址，只是用于比较的“首”地址）+ 一个数组元素的地址（对应的这个数组里边任意一个元素的地址，表示这个二分里边的比较的”结尾’地址）+ 你要二分查找的那个数。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lower_bound(r[x].begin(),r[x].end(),l)</span><br><span class="line">upper_bound(r[x].begin(),r[x].end(),R)</span><br></pre></td></tr></table></figure>

<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p><strong>lower_bound</strong></p>
<p><strong>返回第一个大于等于x的数的地址</strong></p>
<p><strong>upper_bound</strong></p>
<p><strong>返回第一个大于x的数的地址</strong></p>
<h2 id="6-acwing-68-数组中唯一只出现一次的数字"><a href="#6-acwing-68-数组中唯一只出现一次的数字" class="headerlink" title="6.acwing.68.数组中唯一只出现一次的数字"></a>6.acwing.68.数组中唯一只出现一次的数字</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1，我的题解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMissingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; nums.size();i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>  (nums[i] != i) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// solution 2，y总题解，利用哈希表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMissingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i &lt;= nums.size();i ++) S.insert(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x :nums) S.erase(x);</span><br><span class="line">        <span class="keyword">return</span> *S.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="7-acwing-32-调整数组顺序使奇数位于偶数前面"><a href="#7-acwing-32-调整数组顺序使奇数位于偶数前面" class="headerlink" title="7.acwing.32. 调整数组顺序使奇数位于偶数前面"></a>7.acwing.32. 调整数组顺序使奇数位于偶数前面</h2><p>主要是不会交换vector元素的位置。思路还是知道的（双指针）。不要用迭代器做！</p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序。</p>
<p>使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分。</p>
<p>样例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p><strong>算法</strong><br><strong>(双指针扫描) O(n)</strong><br>用两个指针分别从首尾开始，往中间扫描。扫描时保证第一个指针前面的数都是奇数，第二个指针后面的数都是偶数。</p>
<p>每次迭代时需要进行的操作：</p>
<p>第一个指针一直往后走，直到遇到第一个偶数为止；<br>第二个指针一直往前走，直到遇到第一个奇数为止；<br>交换两个指针指向的位置上的数，再进入下一层迭代，直到两个指针相遇为止；<br><strong>时间复杂度</strong><br>当两个指针相遇时，走过的总路程长度是 n，所以时间复杂度是 $O(n)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="built_in">array</span>.size() - <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">             <span class="keyword">while</span> (l &lt; r &amp;&amp; <span class="built_in">array</span>[l] % <span class="number">2</span> == <span class="number">1</span>) l ++ ;</span><br><span class="line">             <span class="keyword">while</span> (l &lt; r &amp;&amp; <span class="built_in">array</span>[r] % <span class="number">2</span> == <span class="number">0</span>) r -- ;</span><br><span class="line">             <span class="keyword">if</span> (l &lt; r) swap(<span class="built_in">array</span>[l], <span class="built_in">array</span>[r]);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="8-acwing-17-从尾到头打印链表"><a href="#8-acwing-17-从尾到头打印链表" class="headerlink" title="8.acwing.17.从尾到头打印链表"></a>8.acwing.17.从尾到头打印链表</h2><p>输入一个链表的头结点，按照 <strong>从尾到头</strong> 的顺序返回节点的值。</p>
<p>返回的结果用数组存储。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1，我的题解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printListReversingly</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">        <span class="keyword">for</span> (ListNode* p = head;p != <span class="literal">NULL</span>;p = p-&gt;next) a.push_back(p-&gt;val);</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>,k = a.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; k)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(a[j],a[k]);</span><br><span class="line">            j++,k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// solution 2,递归 vector 打印</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printListReversingly</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span> vi;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            vi =printListReversingly(head-&gt;next);</span><br><span class="line">            vi.push_back(head-&gt;val);</span><br><span class="line">            <span class="keyword">return</span> vi;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">作者：雪山肥鱼</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/9900/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class="line"><span class="comment">// solution 3,y总题解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printListReversingly</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.push_back(head-&gt;val);</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(temp.begin(),temp.end());<span class="comment">// reverse vector</span></span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>竞赛语法</tag>
        <tag>位运算</tag>
        <tag>库函数</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS学习笔记（三）</title>
    <url>/posts/fc6d0cd1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="5-CSS字体样式"><a href="#5-CSS字体样式" class="headerlink" title="5.CSS字体样式"></a>5.CSS字体样式</h2><p>span标签：用span套起来重点要突出的字。（约定俗成）</p>
<span id="more"></span>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        #title1&#123;</span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">40px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">欢迎学习<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;title1&quot;</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">span</span>&gt;</span>/*修改字体样式*/</span><br><span class="line">&lt;/body<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">body</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-family</span>: Consolas,宋体;<span class="comment">/*字体种类*/</span></span></span><br><span class="line"><span class="css">            <span class="comment">/*分别设置中英文字体*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">color</span>: darkorange;<span class="comment">/*字体颜色*/</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-tag">h1</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">50px</span>;<span class="comment">/*字体大小*/</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        .p1&#123;</span><br><span class="line"><span class="css">            <span class="attribute">font-weight</span>: bolder;<span class="comment">/*字体粗细*/</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>林清玄散文<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>You did not come,</span><br><span class="line">    　　And marching Time drew on, and wore me numb.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>少年时代读到苏轼的一阕词，非常喜欢，到现在还能背诵：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">p</span>&gt;</span>西雨斜风作小寒，淡烟疏柳媚晴滩。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">p</span>&gt;</span>入淮清洛渐漫漫，雪沫乳花浮午盏。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">p</span>&gt;</span>蓼茸蒿笋试春盘，人间有味是清欢。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">p</span>&gt;</span>这阕词，苏东坡在旁边写着“元丰七年十一月二十四日，从泗州刘倩叔游南山”，原来是苏轼和朋友到郊外去玩，在南山里喝了浮着雪沫乳花的小酒，配着春日山野里的蓼菜、茼蒿、新笋，以及野草的嫩芽等等，然后自己赞叹着“人间有味是清欢!”<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>字体样式：</p>
<p>种类、颜色、大小、粗细、风格（斜体等）。</p>
<p>1.分开写</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">body</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-family</span>: Consolas,宋体;<span class="comment">/*字体种类*/</span></span></span><br><span class="line"><span class="css">            <span class="comment">/*分别设置中英文字体*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">color</span>: darkorange;<span class="comment">/*字体颜色*/</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-tag">h1</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">50px</span>;<span class="comment">/*字体大小*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">opacity</span>: <span class="number">0.5</span>;<span class="comment">/*透明度*/</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        .p1&#123;</span><br><span class="line"><span class="css">            <span class="attribute">font-weight</span>: bolder;<span class="comment">/*字体粗细*/</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>林清玄散文<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>You did not come,</span><br><span class="line">    　　And marching Time drew on, and wore me numb.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>少年时代读到苏轼的一阕词，非常喜欢，到现在还能背诵：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">p</span>&gt;</span>这阕词，苏东坡xxx<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.合起来写</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="comment">/*风格 粗细 大小 种类*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">font</span>: oblique bolder <span class="number">14px</span> <span class="string">&quot;楷体&quot;</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>少年时代读到苏轼的一阕词，非常喜欢，到现在还能背诵：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-CSS文本样式"><a href="#6-CSS文本样式" class="headerlink" title="6.CSS文本样式"></a>6.CSS文本样式</h2><p>颜色、对齐方式、首行缩进、行高、下划线。</p>
<p><img src="/posts/fc6d0cd1/image-20210527170235077.png" alt="image-20210527170235077"></p>
<p>加粗的是重点。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        /*颜色：1.单词 2.RGB，十六进制,0~F 3.RGBA，多一个透明度</span><br><span class="line"><span class="css">        <span class="number">4</span><span class="selector-class">.rgb</span>(<span class="selector-tag">a</span>,<span class="selector-tag">b</span>,c) <span class="number">0</span>~<span class="number">255</span> <span class="number">5</span><span class="selector-class">.rgba</span>(<span class="selector-tag">a</span>,<span class="selector-tag">b</span>,c,d)*/</span></span><br><span class="line"><span class="css">        <span class="selector-tag">h1</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="comment">/*color: red;*/</span></span></span><br><span class="line"><span class="css">            <span class="comment">/*color: #00FF00;!*绿色*!*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>,<span class="number">0.8</span>);</span></span><br><span class="line"><span class="css">            <span class="attribute">text-align</span>: center;<span class="comment">/*文本居中:center,left,right*/</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        .p1&#123;</span><br><span class="line"><span class="css">            <span class="comment">/*em比px大得多*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">text-indent</span>: <span class="number">2em</span>;<span class="comment">/*段落首行缩进2字符*/</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        .p3&#123;</span><br><span class="line"><span class="css">            <span class="comment">/*行高的块的高度（height）一致，就可以上下居中*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: blue;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">line-height</span>: <span class="number">100px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.l1</span>&#123;<span class="comment">/*下划线*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">text-decoration</span>: underline;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.l2</span>&#123;<span class="comment">/*中划线*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">text-decoration</span>: line-through;</span></span><br><span class="line"><span class="css">            <span class="comment">/*上划线*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">text-decoration</span>: overline;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-tag">a</span>&#123;<span class="comment">/*超链接去下划线*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">text-decoration</span>: none;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>asd<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>林清玄散文<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>少年时代读到苏轼的一阕词，非常喜欢，到现在还能背诵：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>西雨斜风作小寒，淡烟疏柳媚晴滩。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;p3&quot;</span>&gt;</span>入淮清洛渐漫漫，雪沫乳花浮午盏。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;l1&quot;</span>&gt;</span>12314<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;l2&quot;</span>&gt;</span>12314<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="7-超链接伪类"><a href="#7-超链接伪类" class="headerlink" title="7.超链接伪类"></a>7.超链接伪类</h2><p>补充相对路径小知识：</p>
<p>上一级目录表示：../</p>
<p>上上级：../../</p>
<p>上上上级：../../../</p>
<p>以此类推。</p>
<hr>
<p>鼠标悬浮的状态（记住这个就行）<strong>a:hover</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="comment">/*默认颜色*/</span></span></span><br><span class="line"><span class="css">        <span class="selector-tag">a</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">text-decoration</span>: none;</span></span><br><span class="line"><span class="css">            <span class="attribute">color</span>: <span class="number">#000000</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="comment">/*鼠标悬浮的状态（记住这个就行）*/</span></span></span><br><span class="line"><span class="css">        <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">color</span>: orange;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">30px</span>;<span class="comment">/*放大效果*/</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="comment">/*鼠标按住未释放的状态*/</span></span></span><br><span class="line"><span class="css">        <span class="selector-tag">a</span><span class="selector-pseudo">:active</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">color</span>: green;</span></span><br><span class="line">        &#125;</span><br><span class="line">        #price&#123;</span><br><span class="line"><span class="css">            <span class="attribute">text-shadow</span>: blue;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../resources/image/a.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>码出高效：Java开发手册<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>作者：孤尽老师<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;price&quot;</span>&gt;</span></span><br><span class="line">    ￥99元</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="/posts/fc6d0cd1/image-20210527174927700.png" alt="image-20210527174927700"></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS学习笔记（二）</title>
    <url>/posts/b173af83.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>续CSS学习笔记（一）。</p>
</blockquote>
<h3 id="4-2高级选择器（现查现用）"><a href="#4-2高级选择器（现查现用）" class="headerlink" title="4.2高级选择器（现查现用）"></a>4.2高级选择器（现查现用）</h3><h4 id="4-2-1层次选择器"><a href="#4-2-1层次选择器" class="headerlink" title="4.2.1层次选择器"></a>4.2.1层次选择器</h4><p>先设计网页框架。</p>
<span id="more"></span>

<p><img src="/posts/b173af83/image-20210510210715099.png" alt="image-20210510210715099"></p>
<ol>
<li><p>后代选择器：在某个元素的后面   祖父  父亲 儿子  孙子</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#24c497</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子选择器：只有一代，儿子</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&gt;<span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#f39cff</span>;</span><br><span class="line">    <span class="comment">/*p1 p2 p3变色*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>相邻兄弟选择器：同辈<br>”弟弟“选择器</p>
</li>
</ol>
<p>只有一个相邻兄弟，向下</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.active</span>+<span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#f39cff</span>;</span><br><span class="line">    <span class="comment">/*p2会变色*/</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;p class=&quot;active&quot;&gt;p1&lt;/p&gt;</span><br><span class="line">&lt;<span class="selector-tag">p</span>&gt;p2&lt;/<span class="selector-tag">p</span>&gt;</span><br></pre></td></tr></table></figure>


<ol start="4">
<li><p>通用”弟弟“选择器</p>
<p> 当前选中元素向下的所有兄弟元素</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.active</span>~<span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#f39cff</span>;</span><br><span class="line">    <span class="comment">/*p2 p3 p7 p8变色*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="comment">/*后代选择器*/</span></span></span><br><span class="line"><span class="css">        <span class="comment">/*body p&#123;*/</span></span></span><br><span class="line"><span class="css">        <span class="comment">/*    background: #24c497;*/</span></span></span><br><span class="line"><span class="css">        <span class="comment">/*&#125;*/</span></span></span><br><span class="line"><span class="css">        <span class="comment">/*子选择器*/</span></span></span><br><span class="line"><span class="css">        <span class="comment">/*body&gt;p&#123;*/</span></span></span><br><span class="line"><span class="css">        <span class="comment">/*    background: #f39cff;*/</span></span></span><br><span class="line"><span class="css">        <span class="comment">/*&#125;*/</span></span></span><br><span class="line">        /*兄弟选择器</span><br><span class="line">        只有一个，向下</span><br><span class="line">        */</span><br><span class="line"><span class="css">        <span class="comment">/*.active+p&#123;*/</span></span></span><br><span class="line"><span class="css">        <span class="comment">/*    background: #f39cff;*/</span></span></span><br><span class="line"><span class="css">        <span class="comment">/*&#125;*/</span></span></span><br><span class="line"><span class="css">        <span class="comment">/*通用选择器*/</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.active</span>~<span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: <span class="number">#f39cff</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;active&quot;</span>&gt;</span>p1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>p4<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>p5<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>p6<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p7<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p8<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="4-2-2结构伪类选择器"><a href="#4-2-2结构伪类选择器" class="headerlink" title="4.2.2结构伪类选择器"></a>4.2.2结构伪类选择器</h4><p>我们直接从例子上手：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;结构伪类选择器&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--避免使用class和id选择器--&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        <span class="comment">/*ul的第一个子元素*/</span></span><br><span class="line">        <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:first</span>-child&#123;</span><br><span class="line">            <span class="attribute">background</span>: <span class="number">#f39cff</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*ul的最后一个子元素*/</span></span><br><span class="line">        <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span>&#123;</span><br><span class="line">            <span class="attribute">background</span>: <span class="number">#24c497</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*选中p1：定位到父元素，选择当前第一个子元素</span></span><br><span class="line"><span class="comment">        选择当前p元素的父元素的第n个子元素，并且这个元素也是p元素才行</span></span><br><span class="line"><span class="comment">        比如p的父元素是body，body的第1个子元素是h1，不生效，是p1，生效</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="selector-tag">p</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="attribute">background</span>: darkorange;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*选中当前元素的父元素中第n个类型为p的元素</span></span><br><span class="line"><span class="comment">        注意与上面的区别</span></span><br><span class="line"><span class="comment">        上面按顺序选择，这里按类型选择</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="selector-tag">p</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="attribute">background</span>:firebrick;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">h1</span>&gt;<span class="selector-tag">h1</span>&lt;/<span class="selector-tag">h1</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">p</span>&gt;p1&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">p</span>&gt;p2&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">p</span>&gt;p3&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">ul</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">li</span>&gt;li1&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">li</span>&gt;li2&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">li</span>&gt;li3&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">ul</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">html</span>&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/b173af83/image-20210517142007383.png" alt="image-20210517142007383"></p>
<p>再把h1注释掉，试试：</p>
<p><img src="/posts/b173af83/image-20210517142047182.png" alt="image-20210517142047182"></p>
<h4 id="4-2-3属性选择器（常用）"><a href="#4-2-3属性选择器（常用）" class="headerlink" title="4.2.3属性选择器（常用）"></a>4.2.3属性选择器（常用）</h4><p>把id和class选择器结合使用。</p>
<p>使用语法</p>
<p>1.属性名<br>        2.属性名=属性值 =是绝对等于，*=是包含这个元素，^=以这个开头，$=以这个结尾</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>结构伪类选择器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.demo</span> <span class="selector-tag">a</span>&#123;</span></span><br><span class="line">            /*</span><br><span class="line">            作为演示，不需要记住</span><br><span class="line">             */</span><br><span class="line"><span class="css">            <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: darkorange;</span></span><br><span class="line"><span class="css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">            <span class="attribute">text-decoration</span>: none;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">font</span>: bold <span class="number">20px</span>/<span class="number">50px</span> Arial;</span></span><br><span class="line">        &#125;</span><br><span class="line">        /*选择存在id属性的元素，正则表达式</span><br><span class="line">        1.属性名</span><br><span class="line">        2.属性名=属性值 =是绝对等于，*=是包含这个元素，^=以这个开头，$=以这个结尾</span><br><span class="line">         */</span><br><span class="line"><span class="css">        <span class="comment">/*a[id]&#123;*/</span></span></span><br><span class="line"><span class="css">        <span class="comment">/*    background: #f39cff;*/</span></span></span><br><span class="line"><span class="css">        <span class="comment">/*&#125;*/</span></span></span><br><span class="line"><span class="css">        <span class="selector-tag">a</span><span class="selector-attr">[id=first]</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: <span class="number">#f39cff</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-tag">a</span><span class="selector-attr">[class *= last]</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: <span class="number">#24c497</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="comment">/*选择href中以images开头的元素*/</span></span></span><br><span class="line"><span class="css">        <span class="selector-tag">a</span><span class="selector-attr">[href ^= images]</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: yellow;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        1包含多个class--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item first&quot;</span> <span class="attr">id</span>=<span class="string">&quot;first&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item first&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">title</span>=<span class="string">&quot;test&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;images/123.html&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;images/12.pdf&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;../images/1.txt&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item last&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>DP背包问题详解</title>
    <url>/posts/141c4cb6.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><p>所有背包问题的视频讲解参照：<a href="https://www.bilibili.com/video/av33930433/">y总2018年视频</a></p>
<p>主要背包问题模板整理：<a href="https://www.acwing.com/blog/content/228/">https://www.acwing.com/blog/content/228/</a></p>
<p>八类背包问题笔记整理：<a href="https://valen.blog.csdn.net/article/details/87878853?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1">点这里</a></p>
<p>OI-wiki背包问题简单总结：<a href="https://oi-wiki.org/dp/knapsack/">https://oi-wiki.org/dp/knapsack/</a></p>
<p>本文仅介绍主要的四个背包问题，不会全部介绍背包九讲。</p>
<span id="more"></span>

<p><img src="/posts/141c4cb6/image-20210519192928293.png" alt="image-20210519192928293"></p>
<h2 id="1-01背包问题"><a href="#1-01背包问题" class="headerlink" title="1.01背包问题"></a>1.01背包问题</h2><p>特点：每件物品最多只能用一次。</p>
<p>蓝桥杯系列文章已有相关题解。</p>
<p>请参考这篇文章：<a href="https://www.grantdrew.top/posts/a75e4e46.html">https://www.grantdrew.top/posts/a75e4e46.html</a></p>
<h2 id="2-完全背包问题"><a href="#2-完全背包问题" class="headerlink" title="2.完全背包问题"></a>2.完全背包问题</h2><p>特点：每件物品有无限个。</p>
<h3 id="acwing-3-完全背包问题"><a href="#acwing-3-完全背包问题" class="headerlink" title="acwing.3.完全背包问题"></a>acwing.3.完全背包问题</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。</span><br><span class="line">第 i 种物品的体积是 vi，价值是 wi。</span><br><span class="line">求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</span><br><span class="line">输出最大价值。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</span><br><span class="line">接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 种物品的体积和价值。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示最大价值。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">0</span>&lt;N,V≤<span class="number">1000</span></span><br><span class="line"><span class="number">0</span>&lt;vi,wi≤<span class="number">1000</span></span><br><span class="line">输入样例</span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>参考题解：<a href="https://www.acwing.com/solution/content/10454/">https://www.acwing.com/solution/content/10454/</a></p>
<p>y氏DP分析法：</p>
<p><img src="/posts/141c4cb6/image-20210519202245762.png" alt="image-20210519202245762"></p>
<p>三重循环（朴素）做法：数据加强后TLE，重在理解写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="comment">// 注意:TLE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="keyword">int</span> v[N],w[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i从1开始枚举，j从0开始枚举</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= m;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k*v[i]&lt;=j;k++)</span><br><span class="line">                dp[i][j] = max(dp[i][j],dp[i<span class="number">-1</span>][j-k*v[i]] + k*w[i]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化：</p>
<p>时间复杂度：O(n*m)。</p>
<p>减少一重循环。</p>
<p><img src="/posts/141c4cb6/image-20210520175203903.png" alt="image-20210520175203903"></p>
<p>对比01背包问题的状态转移方程是：<code>f[i][j] = max(f[i-1][j],f[i-1][j-v[i]]+w[i])</code></p>
<p>我们很容易发现，01背包和完全背包的区别就在于第二项的第一维，前者是i-1，而后者是i。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="keyword">int</span> v[N],w[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= m;j++)&#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j];<span class="comment">// 特判第一种情况</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v[i]) dp[i][j] = max(dp[i][j],dp[i][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为和01背包代码很相像，我们很容易想到进一步优化。</p>
<p>这里先介绍降低第一维度的题解，在01背包中没有提到过。</p>
<p>就是将第一个维度直接&amp;1，那么数据就会保存在<code>dp[0][x]</code>和<code>dp[1][x]</code>中。只要用到<code>dp[2][N]</code>这么大的数组就足够了。</p>
<p>我们还可以再优化，边读入变处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][N];</span><br><span class="line"><span class="keyword">int</span> v,w;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= m;j++)&#123;</span><br><span class="line">            dp[i&amp;<span class="number">1</span>][j] = dp[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v) dp[i&amp;<span class="number">1</span>][j] = max(dp[i&amp;<span class="number">1</span>][j],dp[i&amp;<span class="number">1</span>][j-v] + w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n&amp;<span class="number">1</span>][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是类似01背包的更优化的滚动数组。</p>
<p>利用滚动数组优化成一维：</p>
<p>由于完全背包用到的<code>dp[i][j-v[i]]</code>是第i（即本次）次的结果，不像01背包一样用到的是上一次的结果，所以可以直接正向枚举。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"><span class="keyword">int</span> v[N],w[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = v[i];j &lt;= m;j++)&#123;</span><br><span class="line">            dp[j] = max(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-多重背包问题"><a href="#3-多重背包问题" class="headerlink" title="3.多重背包问题"></a>3.多重背包问题</h2><p>特点：每件物品有给定个数（有限个）。</p>
<h3 id="acwing-4-多重背包问题-I"><a href="#acwing-4-多重背包问题-I" class="headerlink" title="acwing.4.多重背包问题 I"></a>acwing.4.多重背包问题 I</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">有 N 种物品和一个容量是 V 的背包。</span><br><span class="line">第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。</span><br><span class="line">求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。</span><br><span class="line">输出最大价值。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</span><br><span class="line">接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示最大价值。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">0</span>&lt;N,V≤<span class="number">100</span></span><br><span class="line"><span class="number">0</span>&lt;vi,wi,si≤<span class="number">100</span></span><br><span class="line">输入样例</span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>根据y氏DP分析法，参照上面的完全背包问题，很容易想到朴素做法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="keyword">int</span> v[N],w[N],s[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= m;j++)&#123;</span><br><span class="line">            <span class="comment">// 比完全背包多一个物品件数限制</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= s[i] &amp;&amp; j &gt;= k*v[i];k++) dp[i][j] = max(dp[i][j],dp[i<span class="number">-1</span>][j-k*v[i]] + k*w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这题数据范围比较小，所以三重循环也能过。</p>
<h3 id="acwing-5-多重背包问题-II"><a href="#acwing-5-多重背包问题-II" class="headerlink" title="acwing.5. 多重背包问题 II"></a>acwing.5. 多重背包问题 II</h3><p>数据范围</p>
<p>0&lt;N≤1000</p>
<p>0&lt;V≤2000</p>
<p>0&lt;vi,wi,si≤2000</p>
<p>数据范围比上一题加强了。</p>
<p>非优化写法时间复杂度O(n^3) 接近 1e9，必超时。</p>
<p>那么需要优化解题思路了，我们是否可以尝试类似完全背包的二重优化呢？</p>
<p><img src="/posts/141c4cb6/image-20210520205800390.png" alt="image-20210520205800390"></p>
<p>由上图的两个式子，我们发现并不能推导出一个递推式。</p>
<p> 再考虑其他的思路：</p>
<p>二进制优化！</p>
<p>我们知道任意一个实数可以由二进制数来表示，也就是2^0~2^k其中一项或几项的和。</p>
<p>下面给出两个例子：</p>
<p>假设对于一个物品，它有s=1023件。</p>
<p>那么我们可以用10组数字1,2,4,8,…,512来表示0到1023中的任意一个数字。</p>
<p>简单证明一下：</p>
<p>1可以表示出0和1；再加上2可以表示出2和3，一共是0到3；再加上4可以表示出4到7，一共是0到7；</p>
<p>以此类推，1到512可以表示出0到1023中的任意一个数字。</p>
<p>修改一下条件，s=200件。</p>
<p>那么我们可以用1,2,4,8,…,64,73来表示出0到200中的任意一个数字。</p>
<p>简单证明一下：</p>
<p>由上一个例子不难得出1,2,4,8,…,64可以表示出0到64*2-1，也就是0到127，再加上73，就能表示73到200，</p>
<p>合起来就能表示出0到200中的任意一个数字。</p>
<p>最后将s看成一个变量，看看如何处理：</p>
<p>如果<code>s &gt; 2^(k+1) - 1</code>，显然有<code>c &lt; 2^(k+1)</code>。</p>
<p><img src="/posts/141c4cb6/image-20210520215137628.png" alt="image-20210520215137628"></p>
<p>由1,2,4,8,…,2^k可以组合出0到2^(k+1) -1，</p>
<p>再补上c，就能组合出c到s（<code>s = 2^(k+1) -1 + c</code>），</p>
<p>最后再来判断两个区间是不是能完整地拼凑出区间[0,s]。</p>
<p>如果<code>c &gt; 2^(k+1)</code>，则区间存在缝隙，又上面得到<code>c &lt; 2^(k+1)</code>，所以区间[0,s]必然能完整拼凑。</p>
<p>时间复杂度为：<code>O(n*v*logs)</code>。</p>
<p>s件物品可以拆分成logs个小组求解01背包问题。</p>
<p>总之，每一小组有选和不选两种情况，这里有点像蓝桥杯”费解的开关”问题。</p>
<p>二进制优化思维就是：现在给出一堆苹果和10个箱子，选出n个苹果。将这一堆苹果分别按照</p>
<p>1,2,4,8,16,…..512分到10个箱子里，那么由于任何一个数字x ∈[1,1024]</p>
<p>都可以从这10个箱子里的苹果数量表示出来，但是这样选择的次数就是 ≤10次 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// N的上限是n*logS == 1000*log2000</span></span><br><span class="line"><span class="comment">// M表示背包物品总体积不超过2010</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">12000</span>,M = <span class="number">2010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> v[N],w[N];</span><br><span class="line"><span class="keyword">int</span> dp[M];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;<span class="comment">// 重新分组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,s;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt;= s)&#123;</span><br><span class="line">            cnt++;<span class="comment">//组别先增加，下标从1开始</span></span><br><span class="line">            v[cnt] = a*k;<span class="comment">//整体体积</span></span><br><span class="line">            w[cnt] = b*k;<span class="comment">// 整体价值</span></span><br><span class="line">            s -= k;</span><br><span class="line">            k *= <span class="number">2</span>;<span class="comment">// k = 1,2,4,8,...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理最后的剩余一组</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            v[cnt] = a*s;</span><br><span class="line">            w[cnt] = b*s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n = cnt;<span class="comment">//枚举次数由个数变成重新划分的组别数</span></span><br><span class="line">	<span class="comment">// 求解优化后的01背包问题</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m;j &gt;= v[i];j--)</span><br><span class="line">            dp[j] = max(dp[j],dp[j-v[i]] + w[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建议选一组数据手动模拟一下，会对二进制优化过程更清楚。</p>
<p>比如初始s=10，进入while循环，s,10-1=9，k=2；第二次，s=9-2=7，k=4；第三次，s=7-4=3，k=8；退出循</p>
<p>环，s有剩余，最后一组是3。</p>
<h2 id="4-分组背包问题"><a href="#4-分组背包问题" class="headerlink" title="4.分组背包问题"></a>4.分组背包问题</h2><p>特点：每组物品只能选一个。</p>
<h3 id="acwing-9-分组背包问题"><a href="#acwing-9-分组背包问题" class="headerlink" title="acwing.9. 分组背包问题"></a>acwing.9. 分组背包问题</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">有 N 组物品和一个容量是 V 的背包。</span><br><span class="line">每组物品有若干个，同一组内的物品最多只能选一个。</span><br><span class="line">每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。</span><br><span class="line">求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</span><br><span class="line">输出最大价值。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。</span><br><span class="line">接下来有 N 组数据：</span><br><span class="line">每组数据第一行有一个整数 Si，表示第 i 个物品组的物品数量；</span><br><span class="line">每组数据接下来有 Si 行，每行有两个整数 vij,wij，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值；</span><br><span class="line">    </span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示最大价值。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">0</span>&lt;N,V≤<span class="number">100</span></span><br><span class="line"><span class="number">0</span>&lt;Si≤<span class="number">100</span></span><br><span class="line"><span class="number">0</span>&lt;vij,wij≤<span class="number">100</span></span><br><span class="line">输入样例</span><br><span class="line"><span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>根据y氏DP分析法：</p>
<p>分析思路和前面的01背包问题有相似之处。</p>
<p>对于每一组中的每个物品，只有选和不选两种状态。</p>
<p>相当于在01背包问题中多加了一个维度。</p>
<p><img src="/posts/141c4cb6/image-20210521090754467.png" alt="image-20210521090754467"></p>
<p>二维朴素做法：01背包问题其实可以看成是每一组只有1件物品的分组背包问题。</p>
<p>这里和01背包的区别就在于：01背包max的第一项是<code>dp[i-1][j]</code>，而分组背包max的第一项是<code>dp[i][j]</code>，</p>
<p>因为01背包每组只有1件物品，而分组背包每组有多件物品，需要每次更新最大值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="keyword">int</span> v[N][N],w[N][N],s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; s[i];j++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= m;j++)&#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j];<span class="comment">// 不选</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; s[i];k++)&#123;<span class="comment">// 选第k件</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= v[i][k]) dp[i][j] = max(dp[i][j],dp[i<span class="number">-1</span>][j-v[i][k]] + w[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似01背包的滚动数组优化做法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> v[N][N],w[N][N],s[N];</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; s[i];j++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="comment">// 逆序枚举j</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m;j &gt;= <span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; s[i];k++)&#123;</span><br><span class="line">               <span class="comment">// if判断不能放在for的条件判断里面，相当于break</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= v[i][k]) dp[j] = max(dp[j],dp[j-v[i][k]] + w[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
        <tag>DP</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML学习笔记（一）</title>
    <url>/posts/8b5222e1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-HTML简介"><a href="#1-HTML简介" class="headerlink" title="1.HTML简介"></a>1.HTML简介</h2><p><strong>超文本标记语言</strong>（Hyper Text Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。</p>
<p>2014年10月由<strong>万维网联盟</strong>（W3C）完成标准制定。</p>
<span id="more"></span>

<p>推荐实战训练巩固知识：<a href="https://www.w3cschool.cn/codecamp/list?pename=html5_and_css_camp">https://www.w3cschool.cn/codecamp/list?pename=html5_and_css_camp</a></p>
<p>web英语教程推荐：<a href="https://www.bilibili.com/video/BV17b41137yx?p=2&amp;share_source=copy_web">https://www.bilibili.com/video/BV17b41137yx?p=2&amp;share_source=copy_web</a></p>
<p><img src="/posts/8b5222e1/image-20210504193312259.png" alt="image-20210504193312259"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第一个网页--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 告诉浏览器使用说明规范--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 显示内容必须包含在html标签之内--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--网页头部--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--meta描述性标签，描述网站信息--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--一般用来做SEO--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;一起学Java&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;来这里学Java&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--title网页标题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">hello,world!</span><br><span class="line"><span class="comment">&lt;!--body代表网页主题--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-网页基本标签"><a href="#2-网页基本标签" class="headerlink" title="2.网页基本标签"></a>2.网页基本标签</h2><p>一个网页必不可少的三个标签就是：html、head和body标签。</p>
<p><img src="/posts/8b5222e1/image-20210504200453609.png" alt="image-20210504200453609"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>基本标签学习<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--标题标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>一级标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>二级标签<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>三级标签<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--段落标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是    一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这  还    是 一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--水平线标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--换行标签，间距比上面p标签小，自闭合--&gt;</span></span><br><span class="line">这是    一个段落。<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">这  还    是 一个段落。<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--斜体与粗体--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>字体样式标签<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">粗体：<span class="tag">&lt;<span class="name">strong</span>&gt;</span>I love Java<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">斜体：<span class="tag">&lt;<span class="name">em</span>&gt;</span>I love C++<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>特殊符号<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--空    格，实际只有一个空格--&gt;</span></span><br><span class="line">空     格</span><br><span class="line">空<span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>格</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">大于号：<span class="symbol">&amp;gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">小于号：<span class="symbol">&amp;lt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">版权符号：<span class="symbol">&amp;copy;</span>版权所有</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;down&quot;</span>&gt;</span>底部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/8b5222e1/image-20210504201252485.png" alt="image-20210504201252485"></p>
<h3 id="图像标签"><a href="#图像标签" class="headerlink" title="图像标签"></a>图像标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>图像<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--img标签学习</span></span><br><span class="line"><span class="comment">src: 图片地址,相对（推荐使用）、绝对路径</span></span><br><span class="line"><span class="comment"> ../  上一级目录</span></span><br><span class="line"><span class="comment">alt: 图片名字</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">src和alt必填</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../resources/image/miku.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;初音未来&quot;</span> <span class="attr">title</span>=<span class="string">&quot;悬停文字&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;800&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="链接标签"><a href="#链接标签" class="headerlink" title="链接标签"></a>链接标签</h3><p><img src="/posts/8b5222e1/image-20210504202647535.png" alt="image-20210504202647535"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>链接<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--a标签</span></span><br><span class="line"><span class="comment">href : 必填，表示要跳转到哪个网页</span></span><br><span class="line"><span class="comment">target : 表示窗口在哪里打开</span></span><br><span class="line"><span class="comment"> _blank : 在新标签中打开链接</span></span><br><span class="line"><span class="comment"> _self : 在自己网页打开</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--使用name作为标记--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;top&quot;</span>&gt;</span>顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;图像.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>点击查看初音未来<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.w3cschool.cn/html5/html5-intro.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_self&quot;</span>&gt;</span>点击学习html<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--点击图像跳转--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.w3cschool.cn/html5/html5-intro.html&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../resources/image/miku.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;初音未来&quot;</span> <span class="attr">title</span>=<span class="string">&quot;悬停文字&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;800&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--文字填充--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">默认情况下，链接将以以下形式出现在浏览器中：</span><br><span class="line"></span><br><span class="line">一个未访问过的链接显示为蓝色字体并带有下划线。</span><br><span class="line">访问过的链接显示为紫色并带有下划线。</span><br><span class="line">点击链接时，链接显示为红色并带有下划线。</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">默认情况下，链接将以以下形式出现在浏览器中：</span><br><span class="line"></span><br><span class="line">一个未访问过的链接显示为蓝色字体并带有下划线。</span><br><span class="line">访问过的链接显示为紫色并带有下划线。</span><br><span class="line">点击链接时，链接显示为红色并带有下划线。</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">默认情况下，链接将以以下形式出现在浏览器中：</span><br><span class="line"></span><br><span class="line">一个未访问过的链接显示为蓝色字体并带有下划线。</span><br><span class="line">访问过的链接显示为紫色并带有下划线。</span><br><span class="line">点击链接时，链接显示为红色并带有下划线。</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--锚链接</span></span><br><span class="line"><span class="comment">1.需要一个锚标记</span></span><br><span class="line"><span class="comment">2.跳转到标记</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#top&quot;</span>&gt;</span>回到顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;基本标签学习.html#down&quot;</span>&gt;</span>跳转底部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--功能性链接</span></span><br><span class="line"><span class="comment">邮件链接 ： mailto:</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:2478881580@q.com&quot;</span>&gt;</span>点击联系我<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML学习笔记（三）</title>
    <url>/posts/f65a6d6b.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-页面结构分析"><a href="#1-页面结构分析" class="headerlink" title="1.页面结构分析"></a>1.页面结构分析</h2><p><img src="/posts/f65a6d6b/image-20210504222223240.png" alt="image-20210504222223240"></p>
<span id="more"></span>

<p>HTML <div> 标签，常用于组合块级元素，以便通过 CSS 来对这些元素进行格式化。</div></p>
<p>上图的标签也就是div标签的语义化标签，只是换个名字。</p>
<p>头部、脚部和导航比较重要。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>页面结构分析<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>网页头部<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>网页主体<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>网页脚部<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-iframe内联框架"><a href="#2-iframe内联框架" class="headerlink" title="2.iframe内联框架"></a>2.iframe内联框架</h2><p><img src="/posts/f65a6d6b/image-20210504223521277.png" alt="image-20210504223521277"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>内联框架<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--内联框架</span></span><br><span class="line"><span class="comment">src: 地址</span></span><br><span class="line"><span class="comment">w-h：宽-高度</span></span><br><span class="line"><span class="comment">name：标识名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://www.baidu.com/&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">&quot;hello&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">width</span>=<span class="string">&quot;1200px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;800px&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;媒体元素.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;hello&quot;</span>&gt;</span>点击跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-表单语法"><a href="#3-表单语法" class="headerlink" title="3.表单语法"></a>3.表单语法</h2><p><img src="/posts/f65a6d6b/image-20210504224535465.png" alt="image-20210504224535465"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>表单学习<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--表单form</span></span><br><span class="line"><span class="comment">action: 表单提交的位置，可以是网站，也可以是一个请求处理地址</span></span><br><span class="line"><span class="comment">method：post，get 提交方式</span></span><br><span class="line"><span class="comment">get方式：可以在提交位置的url看到提交信息，不安全，高效</span></span><br><span class="line"><span class="comment">post方式：比较安全，传输大文件，可以在F12看到密码等信息</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;表格.html&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--文本输入框：input type=&quot;text&quot;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>名字：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--密码框：input type=&quot;password&quot;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--提交和重置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>post方式：在填写注册信息时，打开F12，查看network–&gt;Headers.</p>
<p><img src="/posts/f65a6d6b/image-20210504230152083.png" alt="image-20210504230152083"></p>
<p><img src="/posts/f65a6d6b/image-20210510134343566.png" alt="image-20210510134343566"></p>
<p>name属性是必填的！！！</p>
<h2 id="4-更多表单语法"><a href="#4-更多表单语法" class="headerlink" title="4.更多表单语法"></a>4.更多表单语法</h2><p>单选框、多选框、按钮、下拉框、文本域、文件域、邮箱验证、url验证、数字验证、滑块、搜索框。</p>
<p>如果使用get方式，name对应的value可以在URL中看到。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>表单学习<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--表单form</span></span><br><span class="line"><span class="comment">action: 表单提交的位置，可以是网站，也可以是一个请求处理地址</span></span><br><span class="line"><span class="comment">method：post，get 提交方式</span></span><br><span class="line"><span class="comment">get方式：可以在提交位置的url看到提交信息，不安全，高效</span></span><br><span class="line"><span class="comment">post方法：比较安全，传输大文件</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;表格.html&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--文本输入框：input type=&quot;text&quot;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--value=&quot;Java is best&quot;  默认初始值</span></span><br><span class="line"><span class="comment">maxlength=&quot;8&quot;  最长能写几个字符</span></span><br><span class="line"><span class="comment">size=&quot;30&quot;  文本框的长度</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>名字：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Java is best&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;8&quot;</span> <span class="attr">size</span>=<span class="string">&quot;30&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--密码框：input type=&quot;password&quot;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>性别：</span><br><span class="line"><span class="comment">&lt;!--单选框：radio</span></span><br><span class="line"><span class="comment">checked表示默认值--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--两个name属性一致才能进行唯一的选择</span></span><br><span class="line"><span class="comment">value：单选框的值</span></span><br><span class="line"><span class="comment">name：表示组名。同组只能选一个--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;boy&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">checked</span>/&gt;</span>男</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;girl&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span>/&gt;</span>女</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--多选框 checkbox</span></span><br><span class="line"><span class="comment">checked表示默认值</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>爱好：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sleep&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">checked</span>&gt;</span>睡觉</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;basketball&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span>篮球</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;soccer&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span>足球</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;art&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span>艺术</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--button 普通按钮</span></span><br><span class="line"><span class="comment">image 图片按钮</span></span><br><span class="line"><span class="comment">submit 提交按钮</span></span><br><span class="line"><span class="comment">reset 重置按钮</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">name</span>=<span class="string">&quot;btn1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;懂的都懂&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;image&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../resources/image/miku.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50&quot;</span> <span class="attr">height</span>=<span class="string">&quot;80&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--下拉框和列表框select</span></span><br><span class="line"><span class="comment">selected表示默认值</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>国家：</span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;country&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;CN&quot;</span>&gt;</span>中国<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;US&quot;</span> <span class="attr">selected</span>&gt;</span>美国<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;UK&quot;</span>&gt;</span>英国<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;FRC&quot;</span>&gt;</span>法国<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 文本域 textarea</span></span><br><span class="line"><span class="comment"> cols=&quot;30&quot; 30列</span></span><br><span class="line"><span class="comment"> rows=&quot;10&quot; 10行--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>反馈：</span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;feedback&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span>&gt;</span>提交反馈<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  文件域input file</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;files&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;文件&quot;</span> <span class="attr">name</span>=<span class="string">&quot;upload&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    邮件验证email</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>邮箱：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    url验证url</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>URL：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;url&quot;</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    数字验证number</span></span><br><span class="line"><span class="comment">最大值、最小值、步长--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>商品数量：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">name</span>=<span class="string">&quot;num&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span> <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">step</span>=<span class="string">&quot;10&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    滑块range</span></span><br><span class="line"><span class="comment">最大值、最小值、步长--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>音量：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;range&quot;</span> <span class="attr">name</span>=<span class="string">&quot;voice&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span> <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">step</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    搜索框search</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>搜索：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;search&quot;</span> <span class="attr">name</span>=<span class="string">&quot;search&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--提交和重置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;清空表单&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML学习笔记（二）</title>
    <url>/posts/bb44ce39.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-行内元素和块元素"><a href="#1-行内元素和块元素" class="headerlink" title="1.行内元素和块元素"></a>1.行内元素和块元素</h2><p><img src="/posts/bb44ce39/image-20210504213328956.png" alt="image-20210504213328956"></p>
<span id="more"></span>

<h2 id="2-列表"><a href="#2-列表" class="headerlink" title="2.列表"></a>2.列表</h2><ul>
<li>有序列表</li>
<li>无序列表</li>
<li>自定义列表</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>列表学习<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--有序列表 orderlist</span></span><br><span class="line"><span class="comment">按123排序</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>C++<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>C<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>PHP<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Go<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--无序列表 unorderlist</span></span><br><span class="line"><span class="comment">按圆点分隔</span></span><br><span class="line"><span class="comment">应用：导航栏，侧边栏</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>C++<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>C<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--自定义列表</span></span><br><span class="line"><span class="comment">dl : 标签</span></span><br><span class="line"><span class="comment">dt : 列表名称</span></span><br><span class="line"><span class="comment">dd : 列表内容</span></span><br><span class="line"><span class="comment">应用：一些网站的底部</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Language<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>C++<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Cities<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>西安<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>合肥<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-表格"><a href="#3-表格" class="headerlink" title="3.表格"></a>3.表格</h2><p><img src="/posts/bb44ce39/image-20210504214925816.png" alt="image-20210504214925816"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>表格<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--表格table</span></span><br><span class="line"><span class="comment">行：tr</span></span><br><span class="line"><span class="comment">列：td</span></span><br><span class="line"><span class="comment">border:添加边框</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1px&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--跨列colspan--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span>1-1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;td&gt;1-2&lt;/td&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;td&gt;1-3&lt;/td&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--跨行rowspan--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2-1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>2-2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2-3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3-1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;td&gt;3-2&lt;/td&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3-3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-视频和音频"><a href="#4-视频和音频" class="headerlink" title="4.视频和音频"></a>4.视频和音频</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>媒体元素<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--视频</span></span><br><span class="line"><span class="comment">src：路径</span></span><br><span class="line"><span class="comment">controls：视频控制条，不加看不到视频</span></span><br><span class="line"><span class="comment">autoplay：自动播放，chrome现在好像不行，其他浏览器可以</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;video src=&quot;../resources/video/girlbythesea.mp4&quot; controls autoplay&gt;&lt;/video&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;../resources/audio/music.mp3&quot;</span> <span class="attr">controls</span> <span class="attr">autoplay</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML学习笔记（四）</title>
    <url>/posts/4177740e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-表单的应用"><a href="#1-表单的应用" class="headerlink" title="1.表单的应用"></a>1.表单的应用</h2><ol>
<li>隐藏域</li>
<li>只读</li>
<li>禁用</li>
</ol>
<span id="more"></span>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--只读 readonly--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>名字：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;admin&quot;</span> <span class="attr">readonly</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--禁用 disabled--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;boy&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">disabled</span>/&gt;</span>男</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--隐藏 hidden密码框并设定value的默认值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span> <span class="attr">hidden</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--增强鼠标可用性--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--拓展内容--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;mark&quot;</span>&gt;</span>点击有惊喜<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;mark&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--id可以放在你想放的位置--&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-表单的初级验证"><a href="#2-表单的初级验证" class="headerlink" title="2.表单的初级验证"></a>2.表单的初级验证</h2><p><img src="/posts/4177740e/image-20210510151322788.png" alt="image-20210510151322788"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">palceholder用在输入框中，提示信息</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>名字：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入用户名&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">required要求输入非空，用在输入框中</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>反馈：</span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;feedback&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span> <span class="attr">required</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">pattern正则表达式</span><br><span class="line">直接百度搜索CV就行</span><br><span class="line">别人写好的可以直接用</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>自定义邮箱：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;diymail&quot;</span> <span class="attr">pattern</span>=<span class="string">&quot;^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>HTML简单入门系列到这里正式结束！！！</p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的内存分配机制</title>
    <url>/posts/e1b970b9.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Java-中的内存区域"><a href="#Java-中的内存区域" class="headerlink" title="Java 中的内存区域"></a>Java 中的内存区域</h2><p>Java 中的内存主要分为内存堆，方法栈和方法区。当然还有一些别的内存，比如PC寄存器，和 CPU 的 PC 寄存器一样，作用是指向下一个要执行的指令，但是我们写 Java 程序的没关系，一般不需要管。下面我们就说说内存堆，方法栈和方法区。</p>
<span id="more"></span>

<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p><strong>方法区是一块连续的内存，存放的是Class文件加载到Java虚拟机内部之后的数据。</strong>表现在我们写程序的地方，方法区里的东西，也就是我们里面说的Class类的实例。方法区里的东西，包含类中的变量的定义，静态变量的值和定义，方法（所有方法，不管是静态还是非静态）的字节码等数据。我们可以通过每个类的Class实例来获取这些数据，还记得反射吗？</p>
<p>所以方法区里的数据是相对来说静止的。因为一个类一旦加载进来，就不会变了。唯一会变的可能就是静态变量的值了吧。</p>
<p>所以说，一个类无论创建多少个实例，它都不会增加方法区占用的内存。<strong>因为方法区就好想一个模版，模子，印章，不因为复制出来多少个实例而变大或者变小。</strong></p>
<h2 id="内存堆（Heap）"><a href="#内存堆（Heap）" class="headerlink" title="内存堆（Heap）"></a>内存堆（Heap）</h2><p>好，接着是内存堆。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">其实方法区也是一个堆。什么是堆呢？堆的英文名字叫做heap。是数据结构里一种标准的结构。</span><br><span class="line"></span><br><span class="line">和链表（List），Map，队列（Queue）是一样的。</span><br><span class="line"></span><br><span class="line">Java的内存堆，就是把一块连续的内存，按照堆这种数据结构组织起来。</span><br><span class="line"></span><br><span class="line">堆的结构如其名。可以简单的认为就是一堆东西，下面大上面小。就好像一堆麦子什么的。树（Tree）这个数据结构就是堆的一种。</span><br></pre></td></tr></table></figure>

<p>这里我们不去扯这些数据结构的东西。从帮助我们理解Java内存堆的作用的角度，我们可以再简化一点。可以认为Java内存堆就是一卷纸带，纸带上印着一个个大小相同的格子，比如一厘米一个格子（一个格子代表一个字节），每个格子都有一个编号（也就是内存地址）。</p>
<p>那么，我们写程序 new 一个类的对象，就是在这卷纸带上扯一段纸带，用来存放这个类的成员变量等数据。然后返回的就是这个这段纸带的开始第一个字节的地址。</p>
<p>比如说，<code>A a = new A();</code> 这段代码。new A()就是按照A占用的内存大小扯一段纸带，然后返回这段纸带的地址。紧接着把这个地址赋值给引用a。</p>
<p>这里补充一个知识点，一个对象占用的内存，是固定的。</p>
<p>先说数组，每种数据类型的数据，占用的内存大小是固定的，数组的长度也是创建的时候就确定的，所以一个数组，占用的内存就是数据类型大小 x 数组长度。当然，还有多位数组，但是我们说过，多维数组里，出了最低的一个维，其余的都是引用而已，指向低一个维度的数组对象引用。所以无论是多少维的数组，占用的内存都是一样的。</p>
<p>再说普通的类的对象。讲方法区的时候说过，方法字节码的数据，静态数据，变量定义等数据都在方法区里。那么一个对象占用的额外的数据，其实也就是成员变量。一个类里有几个成员变量是固定的。如果一个类就一个long，一个int，一个String引用，一个类A的引用，那么一个类应该占用多少内存呢？long 8 + int 4 + 引用 4 * 2 = 20个字节。当然每个对象还有一些额外的内存占用，这个所有的对象都是一样的，我们按下不表。可能还有一个问题没相同，就是那俩引用类型。这里我们要理解，String和类A的引用，其实是个引用，而不是对象本身。比如说类A的引用这个成员变量，这个引用可以指向A类的实例，A类的实例占用多少内存，这包含这个引用的对象没关系。当然A类的实例也可以是null，但是null也占内存。<strong>总言之，一个类的对象占用多少内存是固定的。</strong></p>
<p><strong>总结一下，堆就是给对象分配内存。堆里的数据可以通过内存地址访问。</strong>视频课里，我们说内存堆是挂满小本子的公告板，其实也是一个意思，小本子就是一段纸带，公告板的意思就是，这个纸带有地址，能根据地址访问。</p>
<h2 id="方法栈（Stack）"><a href="#方法栈（Stack）" class="headerlink" title="方法栈（Stack）"></a>方法栈（Stack）</h2><p>好，说完了内存堆，剩下就是执行代码了。执行方法需要的内存，都是在栈里分配的。栈，就是stack，是一种先进后出的数据结构。就好像摞盘子一样，最先摞的最后拿出来，最后摞的最先拿出来。</p>
<p>执行方法需要什么内存呢？参数和局部变量。每次执行一个方法，都要为这个方法的执行创建其中定义的参数和局部变量。</p>
<p>那么这里我们再来想通一个事情。那就是每次执行一个方法，占用的内存都是一样的。因为一个方法的参数和定义的局部变量的数量是一样的。可能有一个疑问就是，循环中定义的局部变量怎么办？其实细想，循环中定义的变量，其实是被重用的。一个for循环，里面定义了一个 int 变量。无论循环多少次，新的循环开始的时候，就可以重用之前定义的变量占用的内存，因为一个循环一旦结束，它占用的内存就没用了，可以被下次循环重新使用。</p>
<p>Stack的这个先进后出的特性，和方法调用时一样的。比如m1方法调用m2方法，m2方法调用m3方法，那么过程会是这样的。</p>
<ul>
<li>先调用m1，根据m1的代码，确定m1执行的时候需要多少内存，在栈上分配相应大小的内存供m1执行使用，同时将分配的内存进栈；</li>
<li>执行过程中调用了m2，同样的过程，在栈上分配m2需要的内存，然后内存进栈；</li>
<li>执行m2的时候，m2调用m3，还是分配m3需要的内存，然后内存进栈。</li>
<li>好了，m3执行完毕，释放m3占用的内存（内存出栈），然后是m2继续执行，执行完毕内存释放，最后是m1执行，执行完毕内存释放</li>
</ul>
<p>那么，如何访问栈上内存呢？既然每个方法执行需要的内存都是固定的，那么在分配的这一截内存上，每个变量的地址都是固定的。正所谓冥冥中自有定数，正是此意。所以这个和堆上的内存是不一样的。堆上的内存需要根据引用，找到堆上对应的对象，然后每个成员变量对应的内存地址，也都是冥冥中自有定数了。</p>
<p>参考文章：<a href="https://time.geekbang.org/course/intro/181">Java入门课程配套FAQ</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java知识详解</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中继承与组合的区别</title>
    <url>/posts/def2ac9d.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>组合和继承，是拿到一个问题，设计相应的Java类的时候，不得不面对的来自灵魂的拷问。</p>
<p>“XX到底是YY的一种，还是只是组合了YY？”，”手机到底是手电筒的一种，还是组合了一个可以当手电的闪光灯？”</p>
<span id="more"></span>

<h2 id="is-a与has-a关系"><a href="#is-a与has-a关系" class="headerlink" title="is-a与has-a关系"></a>is-a与has-a关系</h2><p>is-a( 是 “a”  小明是人类)表示的是属于得关系。比如兔子属于一种动物（继承关系）。</p>
<p>has-a( 有 “a”  汽车有轮胎) 表示组合，包含关系。比如兔子包含有腿，头等组件；就不能说兔子腿是属于一种兔子（不能说是继承关系）</p>
<h2 id="继承与组合的区别"><a href="#继承与组合的区别" class="headerlink" title="继承与组合的区别"></a>继承与组合的区别</h2><p>继承，其实表达的是一种”is-a”的关系，也就是说，在你用类构造的世界中，”子类是父类的一种特殊类别”。</p>
<p>组合，在类中创建另一个类的对象，来进行各种操作。</p>
<p>继承不是组合，继承也不只是为了能简单的拿来父类的属性和方法。如果仅仅如此，原封不动的拿来主义，组合也能做到。</p>
<p>继承也不是通过组合的方式来实现的。**和组合相比，继承更像是”融合”**。</p>
<p>所谓融合，即合二为一，可以互相影响。父类影响子类没问题，子类怎么影响父类呢？如何限制手机一次只能最多买五个？</p>
<h2 id="我们为什么需要使用继承？"><a href="#我们为什么需要使用继承？" class="headerlink" title="我们为什么需要使用继承？"></a>我们为什么需要使用继承？</h2><p>如果使用<strong>组合</strong>，对于作为属性的类对象，我们无法修改其方法。有时候是因为没有权限，有时候是因为我们的习惯：我们不该为了一个类去修改作为其属性的另一个类的方法。<strong>对于组合这种方式，我们只有使用的权限，而没有修改的权限。</strong>也就是说组合很难做到上面提到的限制手机买5个。</p>
<p>而对于<strong>继承</strong>，因为有<strong>覆写</strong>的存在，因此，虽然某个方法属于父类，但如果子类想要拥有区别于父类的属于自己的独特的方法，那么可以使用<strong>覆写机制</strong>。<strong>所以，对于继承这种方式，我们不仅可以使用，还可以修改。</strong></p>
<p>继承之于组合特殊的一点在于，它能够进行覆写，对继承自父类的方法不满足就可以修改。<strong>而在Java中，组合是没有覆盖的，覆盖只在继承中存在。</strong></p>
<p>即组合，我们从其他类简单地拿来了属性和方法；而继承，我们不仅仅从其他类拿来了属性和方法，我们还可以修改拿来的方法。</p>
<p>组合让两个类相对保持自己的独立性，而继承则让两个类相互渗透，因为继承更确切地说是子类和父类的融合。<br>类存在的目的是封装，而继承在某种程度上破坏了这种封装，让两个类紧紧耦合在了一起。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java知识详解</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的对象与对象引用</title>
    <url>/posts/c24ed739.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="对象和对象引用的区别"><a href="#对象和对象引用的区别" class="headerlink" title="对象和对象引用的区别"></a>对象和对象引用的区别</h2><p>不理解的话建议参考</p>
<ol>
<li>书籍：《Java核心技术：卷I》（第11版）—&gt; 4.2.1 对象与对象变量</li>
<li> 博客：CSDN博主「技术小栈」的原创文章<a href="https://blog.csdn.net/qq_26805137/article/details/52945688">原文链接</a></li>
</ol>
<span id="more"></span>

<p>首先举个例子：<code>Demo demo=new Demo();</code></p>
<p>  这一条语句，其实包括了四个动作：<br>                1）右边的“new Demo”，是以Demo类为模板，在堆空间里创建一个Demo对象。<strong>这条语句的返回值是对Demo对象的一个引用。</strong><br>                2）末尾的()意味着，在对象创建后，立即调用Demo类的构造函数，对刚生成的对象进行初始化。<br>                3）左边的“Demo demo”创建了一个Demo类引用变量，它存放在栈空间中。也就是用来指向Demo对象的对象引用。 这里的demo，我们也可以称之为对象变量。<br>                4）“=”操作符使对象引用指向刚创建的那个Demo对象。</p>
<p>当然这条语句我们也可以写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Demo demo;<span class="comment">//创建对象引用</span></span><br><span class="line">demo=<span class="comment">/*将对象引用指向对象*/</span><span class="keyword">new</span> Demo();<span class="comment">//创建对象</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/c24ed739/image-20210403090745364.png" alt="image-20210403090745364"></p>
<h2 id="对象引用与对象之间的关系"><a href="#对象引用与对象之间的关系" class="headerlink" title="对象引用与对象之间的关系"></a>对象引用与对象之间的关系</h2><p> 1）从对象引用出发:</p>
<p> 一个对象引用可以指向一个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Demo demo；<span class="comment">//一个对象引用</span></span><br><span class="line">demo=<span class="keyword">new</span> Demo();<span class="comment">//一个对象引用指向一个对象</span></span><br></pre></td></tr></table></figure>

<p> 也可以不指向对象。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Demo demo;<span class="comment">//创建对象引用，但是没有指向对象</span></span><br></pre></td></tr></table></figure>

<p> 2）从对象出发：</p>
<p>​       一个对象可以被一个对象引用引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Demo demo;<span class="comment">//创建对象引用</span></span><br><span class="line">demo=<span class="keyword">new</span> Demo();<span class="comment">//创建对象，并被一个对象引用指向</span></span><br></pre></td></tr></table></figure>

<p>  也可以被多个对象引用同时引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Demo demo1，demo2，demo3;<span class="comment">//创建多个对象引用</span></span><br><span class="line">demo1=<span class="keyword">new</span> Demo();</span><br><span class="line">demo2=demo1;<span class="comment">// 它们地址相同，指向同一个对象</span></span><br><span class="line">demo3=demo2;<span class="comment">//创建对象，并被多个对象引用指向</span></span><br></pre></td></tr></table></figure>

<h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><p><img src="/posts/c24ed739/image-20210403091943631.png" alt="image-20210403091943631"></p>
<p><img src="/posts/c24ed739/image-20210403092008411.png" alt="image-20210403092008411"></p>
<p><img src="/posts/c24ed739/image-20210403092458600.png" alt="image-20210403092458600"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java知识详解</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（一）</title>
    <url>/posts/b67a5797.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-java简介"><a href="#1-java简介" class="headerlink" title="1.java简介"></a>1.java简介</h2><p>本教程推荐配合大佬<a href="https://www.cnblogs.com/vccyb/tag/%E5%8C%85%E5%AD%90%E5%AD%A6%E7%B3%BB%E5%88%97/">笔记</a>食用！</p>
<p>B站视频倍速播放：F12–&gt;console–&gt;输入：document.querySelector(‘video’).playbackRate = 2.5，控制倍速。</p>
<p>随着Java的发展，SUN给Java又分出了三个不同版本：</p>
<ul>
<li>Java SE：Standard Edition</li>
<li>Java EE：Enterprise Edition</li>
<li>Java ME：Micro Edition</li>
</ul>
<span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌───────────────────────────┐</span><br><span class="line">│Java EE                    │</span><br><span class="line">│    ┌────────────────────┐ │</span><br><span class="line">│    │Java SE             │ │</span><br><span class="line">│    │    ┌─────────────┐ │ │</span><br><span class="line">│    │    │   Java ME   │ │ │</span><br><span class="line">│    │    └─────────────┘ │ │</span><br><span class="line">│    └────────────────────┘ │</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure>

<ul>
<li>JDK：Java Development Kit（java开发工具包）</li>
<li>JRE：Java Runtime Environment(Java运行环境)</li>
<li>简单而言，使用JDK的开发工具完成的java程序，交给JRE去运行。</li>
</ul>
<p>简单地说，JRE就是运行Java字节码的虚拟机。但是，如果只有Java源码，要编译成Java字节码，就需要JDK，因为JDK除了包含JRE，还提供了编译器、调试器等开发工具。</p>
<p>JDK:<strong>JRE + 开发工具集</strong>（编译器(Javac) + 其他工具）；JRE:<strong>Java虚拟机(JVM) + Java类库</strong> + 其他。</p>
<p>二者关系如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> ┌─    ┌──────────────────────────────────┐</span><br><span class="line"> │     │     Compiler, debugger, etc.     │</span><br><span class="line"> │     └──────────────────────────────────┘</span><br><span class="line">JDK ┌─ ┌──────────────────────────────────┐</span><br><span class="line"> │  │  │                                  │</span><br><span class="line"> │ JRE │      JVM + Runtime Library       │</span><br><span class="line"> │  │  │                                  │</span><br><span class="line"> └─ └─ └──────────────────────────────────┘</span><br><span class="line">       ┌───────┐┌───────┐┌───────┐┌───────┐</span><br><span class="line">       │Windows││ Linux ││ macOS ││others │</span><br><span class="line">       └───────┘└───────┘└───────┘└───────┘</span><br></pre></td></tr></table></figure>

<ul>
<li>java：这个可执行程序其实就是JVM，运行Java程序，就是启动JVM，然后让JVM执行指定的编译后的代码；</li>
<li>javac：这是Java的编译器，它用于把Java源码文件（以<code>.java</code>后缀结尾）编译为Java字节码文件（以<code>.class</code>后缀结尾）；</li>
<li>jar：用于把一组<code>.class</code>文件打包成一个<code>.jar</code>文件，便于发布；</li>
<li>javadoc：用于从Java源码中自动提取注释并生成文档；</li>
<li>jdb：Java调试器，用于开发阶段的运行调试。</li>
</ul>
<p>如果遇到编码问题，我们可以使用 <strong>-encoding</strong> 选项设置 <strong>utf-8</strong> 来编译：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javac -encoding UTF-8 HelloWorld.java </span><br><span class="line">java HelloWorld </span><br></pre></td></tr></table></figure>



<h2 id="2-Java与C-的区别"><a href="#2-Java与C-的区别" class="headerlink" title="2.Java与C++的区别"></a>2.Java与C++的区别</h2><p>我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来！</p>
<ul>
<li>都是面向对象的语言，都支持封装、继承和多态</li>
<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li>
<li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存</li>
<li><strong>在 C 语言中，字符串或字符数组最后都会有一个额外的字符<code>&#39;\0&#39;</code>来表示结束。但是，Java 语言中没有结束符这一概念。</strong> 这是一个值得深度思考的问题，具体原因推荐看这篇文章： <a href="https://blog.csdn.net/sszgg2006/article/details/49148189">https://blog.csdn.net/sszgg2006/article/details/49148189</a></li>
</ul>
<h2 id="3-java语言编译-compile-与解释并存"><a href="#3-java语言编译-compile-与解释并存" class="headerlink" title="3.java语言编译(compile)与解释并存"></a>3.java语言编译(compile)与解释并存</h2><p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 <u>Java 程序要经过先编译，后解释两个步骤</u>，由 Java 编写的程序需要先<strong>经过编译步骤，生成字节码</strong>（*.class 文件），这种字节码必须<strong>由 Java 解释器来解释执行</strong>。因此，我们可以认为 Java 语言编译与解释并存。</p>
<h2 id="4-字符型常量和字符串常量的区别"><a href="#4-字符型常量和字符串常量的区别" class="headerlink" title="4.字符型常量和字符串常量的区别"></a>4.字符型常量和字符串常量的区别</h2><ol>
<li><p>形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的 0 个或若干个字符</p>
</li>
<li><p>含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</p>
</li>
<li><p>占内存大小 字符常量只占 2 个字节; 字符串常量占若干个字节 (<strong>注意： char 在 Java 中占两个字节</strong>),</p>
<blockquote>
<p>字符封装类 <code>Character</code> 有一个成员常量 <code>Character.SIZE</code> 值为 16,单位是<code>bits</code>,该值除以 8(<code>1byte=8bits</code>)后就可以得到 2 个字节</p>
</blockquote>
</li>
</ol>
<h2 id="5-Java注释"><a href="#5-Java注释" class="headerlink" title="5.Java注释"></a>5.Java注释</h2><p>主要分为三种：单行、多行和文档注释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">   <span class="comment">/** 这是第一个Java程序</span></span><br><span class="line"><span class="comment">    * 它将输出 Hello World</span></span><br><span class="line"><span class="comment">    * 这是一个文档的示例</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       <span class="comment">// 这是单行注释的示例</span></span><br><span class="line">       <span class="comment">/* </span></span><br><span class="line"><span class="comment">       多行注释</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       System.out.println(<span class="string">&quot;Hello World&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-Java关键字"><a href="#6-Java关键字" class="headerlink" title="6.Java关键字"></a>6.Java关键字</h2><table>
<thead>
<tr>
<th>访问控制</th>
<th>private</th>
<th>protected</th>
<th>public</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>类，方法和变量修饰符</td>
<td>abstract</td>
<td>class</td>
<td>extends</td>
<td>final</td>
<td>implements</td>
<td>interface</td>
<td>native</td>
</tr>
<tr>
<td></td>
<td>new</td>
<td>static</td>
<td>strictfp</td>
<td>synchronized</td>
<td>transient</td>
<td>volatile</td>
<td></td>
</tr>
<tr>
<td>程序控制</td>
<td>break</td>
<td>continue</td>
<td>return</td>
<td>do</td>
<td>while</td>
<td>if</td>
<td>else</td>
</tr>
<tr>
<td></td>
<td>for</td>
<td>instanceof</td>
<td>switch</td>
<td>case</td>
<td>default</td>
<td></td>
<td></td>
</tr>
<tr>
<td>错误处理</td>
<td>try</td>
<td>catch</td>
<td>throw</td>
<td>throws</td>
<td>finally</td>
<td></td>
<td></td>
</tr>
<tr>
<td>包相关</td>
<td>import</td>
<td>package</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>基本类型</td>
<td>boolean</td>
<td>byte</td>
<td>char</td>
<td>double</td>
<td>float</td>
<td>int</td>
<td>long</td>
</tr>
<tr>
<td></td>
<td>short</td>
<td>null</td>
<td>true</td>
<td>false</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>变量引用</td>
<td>super</td>
<td>this</td>
<td>void</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>保留字</td>
<td>goto</td>
<td>const</td>
<td>null</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="7-java语法规范"><a href="#7-java语法规范" class="headerlink" title="7.java语法规范"></a>7.java语法规范</h2><p>编写 Java 程序时，应注意以下几点：</p>
<ul>
<li><strong>大小写敏感</strong>：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。</li>
<li><strong>类名</strong>：（class）对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 <strong>MyFirstJavaClass</strong> 。</li>
<li><strong>方法名</strong>：（method）所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。</li>
<li><strong>源文件名</strong>：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 <strong>.java</strong>。（如果文件名和类名不相同则会导致编译错误）。</li>
<li><strong>主方法入口</strong>：所有的 Java 程序由 <strong>public static void main(String[] args)</strong> 方法开始执行。</li>
</ul>
<p>像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：</p>
<ol>
<li>访问控制修饰符 : default, public , protected, private</li>
<li>非访问控制修饰符 : final, abstract, static, synchronized</li>
</ol>
<ul>
<li><p><strong>标识符命名规范</strong>：</p>
<p>所有的标识符都应该以英文字母、$、或者_开始。</p>
<p>首字符之后可以是英文字母、$_或者数字`的任意组合。</p>
<p><img src="/posts/b67a5797/image-20210210101349712.png" alt="image-20210210101349712"></p>
</li>
</ul>
<p><strong>小结</strong></p>
<p>一个Java源码只能定义一个<code>public</code>类型的class，并且class名称和文件名要完全一致；</p>
<p>但是可以定义多个class（类）;</p>
<p>使用<code>javac</code>可以将<code>.java</code>源码编译成<code>.class</code>字节码；（JVM运行字节码）</p>
<p>使用<code>java</code>可以运行一个已编译的Java程序，参数是类名。</p>
<h2 id="8-java变量与数据类型"><a href="#8-java变量与数据类型" class="headerlink" title="8.java变量与数据类型"></a>8.java变量与数据类型</h2><p>Java变量就好像一个容器，可以保存程序在运行过程中的值，它在声明的时候会定义对应的数据类型（Java分为两种数据类型：基本数据类型和引用数据类型）。变量按作用域的范围又可分为三种类型：<strong>局部变量，成员变量和静态变量</strong>。</p>
<p>Java中并没有全局变量的概念，这与C/C++不同！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Variable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> allClicks = <span class="number">0</span>;<span class="comment">// 类变量，静态变量</span></span><br><span class="line">    String s = <span class="string">&quot;helloworld&quot;</span>;<span class="comment">// 实例变量，成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">// 局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="8-1-主要分类"><a href="#8-1-主要分类" class="headerlink" title="8.1 主要分类"></a>8.1 主要分类</h5><p><img src="/posts/b67a5797/image-20210210102225703.png" alt="image-20210210102225703"></p>
<p>八大基本数据类型</p>
<ul>
<li>1字节 的是 byte 、boolean</li>
<li>2字节 的是 short 、<strong>char</strong>（Java采用<strong>Unicode编码</strong>）</li>
<li>4字节 的是 int （范围约21亿=2$^{31}$）、float</li>
<li>8字节 的是 long 、double</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> num1 = <span class="number">30L</span>;</span><br><span class="line"><span class="keyword">long</span> num1 = <span class="number">30l</span>;<span class="comment">// 两者等价</span></span><br><span class="line"><span class="keyword">float</span> num2 = <span class="number">23.1F</span>;</span><br><span class="line"><span class="keyword">float</span> num2 = <span class="number">23.1f</span>;<span class="comment">// 两者等价</span></span><br><span class="line"><span class="keyword">double</span> = <span class="number">23.23453456</span>;<span class="comment">// double不需要后缀，Java中的小数默认为double型</span></span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">Srting s = <span class="string">&quot;ABC&quot;</span>;<span class="comment">// 注意：String是一个类，不是关键字，不属于基本数据类型</span></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>

<h5 id="8-2-局部变量"><a href="#8-2-局部变量" class="headerlink" title="8.2 局部变量"></a>8.2 局部变量</h5><p>声明局部变量时的注意事项：</p>
<ul>
<li>局部变量声明在方法，构造方法或语句块中。</li>
<li>局部变量在方法，构造方法，或者语句块被执行的时候创建，当其执行完成后，将会被销毁。</li>
<li>访问修饰符不能用于局部变量。</li>
<li>局部变量只在声明它的方法，构造方法或语句块中可见。</li>
<li>局部变量是在栈上分配的。</li>
<li>局部变量没有默认值，所以局部变量被声明后，<strong>必须经过初始化，才可以使用</strong>。</li>
</ul>
<h5 id="8-3-成员变量"><a href="#8-3-成员变量" class="headerlink" title="8.3 成员变量"></a>8.3 成员变量</h5><p>在类内部但在方法体外声明的变量称为成员变量，或者实例变量。之所以称为实例变量，是因为该变量只能通过类的实例（对象）来访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 文档注释：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 微信搜「沉默王二」，回复关键字 PDF</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceVariable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">88</span>;<span class="comment">// data是成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InstanceVariable iv = <span class="keyword">new</span> InstanceVariable();</span><br><span class="line">        System.out.println(iv.data); <span class="comment">// 88</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以是一个变量，它是一个引用类型的变量。<code>new</code>关键字可以创建一个类的实例（也称为对象），通过“ =”操作符赋值给iv这个变量，iv就成了这个对象的引用，通过<code>iv.data</code>就可以访问成员变量了。</p>
<p>声明成员变量时的注意事项：</p>
<ul>
<li>成员变量声明在一个类中，但在方法，构造方法和语句块之外。</li>
<li>当一个对象被实例化之后，每个成员变量的值就跟着确定。</li>
<li>成员变量在对象创造的时候创造，在对象被销毁的时候销毁。</li>
<li>成员变量的值应该至少被一个方法，构造方法或语句块引用，以便外部能够通过这些方式获取实例变量信息。</li>
<li>成员变量可以声明在使用前或使用后。</li>
<li>访问修饰符可以修饰成员变量。</li>
<li>一般情况下应该把成员变量设为所有权。通过使用访问修饰符可以使成员变量对子类可见；成员变量具有唯一值。数值型成员变量对于类中的方法，构造方法或语句块是可见的。变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定。</li>
</ul>
<h2 id="9-位运算"><a href="#9-位运算" class="headerlink" title="9.位运算"></a>9.位运算</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;&gt;：符号位不动，其余位右移，符号位后边正数补<span class="number">0</span>，负数补<span class="number">1</span>。又称带符号右移</span><br><span class="line">&gt;&gt;&gt;：符号位一起右移，左边补<span class="number">0</span>，又称无符号右移</span><br><span class="line">&lt;&lt;：左移，右边补<span class="number">0</span>。左移没有带符号位一说，因为符号位在最左侧</span><br></pre></td></tr></table></figure>

<h2 id="10-关于cmd中文乱码的解决方案"><a href="#10-关于cmd中文乱码的解决方案" class="headerlink" title="10.关于cmd中文乱码的解决方案"></a>10.关于cmd中文乱码的解决方案</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">F:\Java_VScode&gt;javac -encoding utf-8 Calculation.java # 加上一个编码参数</span><br><span class="line">F:\Java_VScode&gt;java Calculation</span><br><span class="line">2 7</span><br><span class="line">最大公约数：1</span><br></pre></td></tr></table></figure>

<p>文件是以UTF-8的形式保存的。</p>
<p>这样做保证javac和java的字符集统一为UTF-8，就不会出现中文乱码。</p>
<p>在VScode通过右键code-Runner编译时发现这样做还是乱码。</p>
<p><img src="/posts/b67a5797/image-20210723082254496.png" alt="image-20210723082254496"></p>
<p>需要修改powershell的编码格式为UTF-8，才能保证格式统一。</p>
<p>还是通过main方法上面的run来运行。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（七）</title>
    <url>/posts/a4cff879.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-方法和属性的可见性修饰符"><a href="#1-方法和属性的可见性修饰符" class="headerlink" title="1.方法和属性的可见性修饰符"></a>1.方法和属性的可见性修饰符</h2><span id="more"></span>

<p><img src="/posts/a4cff879/image-20210403114450929.png" alt="image-20210403114450929"></p>
<ul>
<li><p>非公共的类，不能在包外被使用。</p>
</li>
<li><p>public的方法类似一种约定，既然外面的代码可以使用，就意味着不能乱改。比如签名不能改之类的。</p>
</li>
<li><p>对于private的方法，因为类外面调不到，所以无论怎么改，也不会影响（直接影响）类外面的代码。</p>
</li>
<li><p>有些时候，会把所有的构造方法都定义成private的，然后使用静态方法调用构造方法，这样的好处是可以通过代码，检查每个属性值是否合法。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MerchandiseV2 <span class="title">createMerchandise</span><span class="params">(String name, String id, <span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">double</span> soldPrice, <span class="keyword">double</span> purchasePrice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (soldPrice &lt; <span class="number">0</span> || purchasePrice &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MerchandiseV2(name, id, count, soldPrice, purchasePrice);<span class="comment">// 合法则调用构造器</span></span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>访问控制修饰符</th>
<th>本类内部</th>
<th>同包</th>
<th>不同包子类</th>
<th>同一工程</th>
</tr>
</thead>
<tbody><tr>
<td>Public</td>
<td>可以</td>
<td>可以</td>
<td>可以</td>
<td>可以</td>
</tr>
<tr>
<td>Protected</td>
<td>可以</td>
<td>可以</td>
<td>可以</td>
<td></td>
</tr>
<tr>
<td>默认（default）</td>
<td>可以</td>
<td>可以</td>
<td></td>
<td></td>
</tr>
<tr>
<td>private</td>
<td>可以</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="2-Math类"><a href="#2-Math类" class="headerlink" title="2.Math类"></a>2.Math类</h2><p>Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。</p>
<p>Math类中的方法都是静态的，所以不需要实例化对象。</p>
<p>它没有成员变量，是一个工具类，只提供一些方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.abs(-<span class="number">10</span>) <span class="comment">// 绝对值</span></span><br><span class="line">Math.sqrt(X)<span class="comment">//计算平方根</span></span><br><span class="line">Math.cbrt(X)<span class="comment">//计算立方根</span></span><br><span class="line">Math.pow(a, b)<span class="comment">//计算a的b次方</span></span><br><span class="line">Math.max( <span class="number">1</span>,<span class="number">2</span> );<span class="comment">//计算最大值</span></span><br><span class="line">Math.min( <span class="number">3</span>,<span class="number">4</span> );<span class="comment">//计算最小值</span></span><br><span class="line">Math.ceil(X) <span class="comment">//接近此数的大的整数的值 3.1-&gt;4</span></span><br><span class="line">Math.floor(X) <span class="comment">//接近此数的小的整数的值 3.1-&gt;3</span></span><br><span class="line">Math.random() <span class="comment">//[0,1)</span></span><br><span class="line">Math.round(X) <span class="comment">//round 四舍五入，float时返回int值，double时返回long值</span></span><br><span class="line">   </span><br><span class="line">Math.random(); <span class="comment">// 0.53907... 每次都不一样，返回值是double</span></span><br><span class="line"><span class="comment">//前面我们使用的Math.random()实际上内部调用了Random类</span></span><br><span class="line"><span class="comment">//random在java.util包里</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Math.random());</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//nextInt的返回值竟然有正数有负数哦！随机生成一个int值</span></span><br><span class="line">            System.out.println(Math.abs(random.nextInt()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Math.round(-<span class="number">9.2</span>));</span><br><span class="line">        System.out.println(Math.round(-<span class="number">9.5</span>));</span><br><span class="line">        System.out.println(Math.round(-<span class="number">9.8</span>));</span><br><span class="line">        System.out.println(Math.round(<span class="number">9.2</span>));</span><br><span class="line">        System.out.println(Math.round(<span class="number">9.5</span>));</span><br><span class="line">        System.out.println(Math.round(<span class="number">9.8</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*0.8715393731162016</span></span><br><span class="line"><span class="comment">1876651818</span></span><br><span class="line"><span class="comment">1246645657</span></span><br><span class="line"><span class="comment">1659850256</span></span><br><span class="line"><span class="comment">1890712276</span></span><br><span class="line"><span class="comment">1135262753</span></span><br><span class="line"><span class="comment">-9</span></span><br><span class="line"><span class="comment">-9</span></span><br><span class="line"><span class="comment">-10</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">10*/</span></span><br></pre></td></tr></table></figure>

<h2 id="3-重新认识String类"><a href="#3-重新认识String类" class="headerlink" title="3.重新认识String类"></a>3.重新认识String类</h2><p>String 对象最重要的特点：<strong>不可变（immutable）</strong>不可变不可变，重要的事情说三遍。String 用来存储字符的数据是private 的，而且不提供任何修改内容的方法，<strong>所以String 对象一旦生成，其内容就是完全不可能被修改的。</strong></p>
<p>String是一个final类，不可变。</p>
<p>String 对象的字符内容是存储在一个字符数组 value[] 中 的。</p>
<p><img src="/posts/a4cff879/image-20210502134230914.png" alt="image-20210502134230914"></p>
<p><img src="/posts/a4cff879/image-20210502134630605.png" alt="image-20210502134630605"></p>
<p><img src="/posts/a4cff879/image-20210502134822887.png" alt="image-20210502134822887"></p>
<p><code>String s = new String(&quot;abc&quot;);</code>方式创建对象，在内存中创建了几个对象？<br><strong>两个</strong>:一个是堆空间中new结构，另一个是char[]对应的常量池中的数据：”abc”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LearnString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String content = <span class="string">&quot;01234567ABCDefgh&quot;</span>;<span class="comment">// java为String开后门，不用new String创建</span></span><br><span class="line">        <span class="comment">// String的length()是个方法不是属性哦，数组的length是属性</span></span><br><span class="line">        System.out.println(content.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其实是生成了一个新的String对象</span></span><br><span class="line">        System.out.println(content.toUpperCase());<span class="comment">//全部大写，生成副本</span></span><br><span class="line">        System.out.println(content.toLowerCase());<span class="comment">//全部小写，生成副本</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// content指向对象的内容并没有变化</span></span><br><span class="line">        System.out.println(content);</span><br><span class="line">        <span class="comment">//返回指定索引处的字符。索引范围为从 0 到 length() - 1</span></span><br><span class="line">        System.out.println(content.charAt(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// System.out.println(content.charAt(99));</span></span><br><span class="line">        System.out.println(content.substring(<span class="number">5</span>));</span><br><span class="line">        System.out.println(content.substring(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*16</span></span><br><span class="line"><span class="comment">01234567ABCDEFGH</span></span><br><span class="line"><span class="comment">01234567abcdefgh</span></span><br><span class="line"><span class="comment">01234567ABCDefgh</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">567ABCDefgh</span></span><br><span class="line"><span class="comment">1234*/</span></span><br></pre></td></tr></table></figure>

<p><code>substring(int beginIndex，int endIndex)</code> 形式：左闭右开</p>
<p>此方法中的 <code>beginIndex</code> 表示截取的起始索引，截取的字符串中包括起始索引对应的字符；endIndex 表示结束索引，截取的字符串中不包括结束索引对应的字符，如果不指定 <code>endIndex</code>，则表示截取到目标字符串末尾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LearnString2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String content = <span class="string">&quot;Orange_Apple_Banana&quot;</span>;</span><br><span class="line">	<span class="comment">//toCharArray() 方法将字符串转换为字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = content.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            System.out.println(chars[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String sp = <span class="string">&quot;_&quot;</span>;</span><br><span class="line">        String[] s = content.split(sp);<span class="comment">// 分割String，用char数组保存</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">            System.out.println(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String s1 = <span class="string">&quot;  ad &quot;</span>;</span><br><span class="line">        String s2 = s1.trim();<span class="comment">//去除左右两边的空格</span></span><br><span class="line">        String s3 =<span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        System.out.println(s1.compareTo(s2));<span class="comment">//比较String大小</span></span><br><span class="line">        System.out.println(s1.compareTo(s3));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> indexOf = content.indexOf(<span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">        System.out.println(indexOf);</span><br><span class="line">        System.out.println(content.substring(indexOf + <span class="number">1</span>, content.length()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lastIndexOf = content.lastIndexOf(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">        System.out.println(lastIndexOf);</span><br><span class="line">        System.out.println(content.substring(<span class="number">0</span>, lastIndexOf));</span><br><span class="line"></span><br><span class="line">        System.out.println(content.contains(<span class="string">&quot;apple&quot;</span>));</span><br><span class="line">        System.out.println(content.contains(<span class="string">&quot;Apple&quot;</span>));</span><br><span class="line">        System.out.println(content.startsWith(<span class="string">&quot;Orange&quot;</span>));</span><br><span class="line">        System.out.println(content.endsWith(<span class="string">&quot;Banana&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        String content2 = <span class="string">&quot;Orange_Apple_Banana&quot;</span>;</span><br><span class="line">        String content3 = <span class="string">&quot;   orange_Apple_banana   &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 两个String对象比较是否相等，一定要用equals方法</span></span><br><span class="line">        System.out.println(content.equals(content2));</span><br><span class="line">        System.out.println(content.equals(content3));</span><br><span class="line">        System.out.println(content.equalsIgnoreCase(content3.trim()));<span class="comment">//忽略大小写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>indexOf()</code> 方法有以下四种形式：</p>
<ul>
<li><strong>int indexOf(int ch)/int indexOf(String str):</strong> 返回指定字符（索引）或字符串在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</li>
<li><strong>int indexOf(int ch, int fromIndex)/int indexOf(String str, int fromIndex):</strong> 返回从 <code>fromIndex</code> 位置开始查找指定字符（索引）或字符串在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</li>
</ul>
<p><code>lastIndexOf()</code> 方法也有四种形式：</p>
<ul>
<li>前两种把第一次改成最后一次就行；</li>
<li>后两种改为从 <code>fromIndex</code> 位置反向查找即可。</li>
</ul>
<p><code>startsWith()</code>和<code>endsWith()</code> 方法用于测试字符串是否以指定的字符串前/后缀结束。</p>
<p><code>contains()</code> 方法用于判断字符串中是否包含指定的字符或字符串。</p>
<p><strong>equals方法：</strong></p>
<p>equals() 方法用于将字符串与指定的对象比较。</p>
<p>String 类中重写了 equals() 方法用于比较两个字符串的内容是否相等。</p>
<p>如果给定对象与字符串相等，则返回 true；否则返回 false。</p>
<p>注意：String 中 <strong>==</strong> 比较引用地址是否相同，<strong>equals()</strong> 比较字符串的内容是否相同。</p>
<p>用==进行比较时，符号两边的数据类型必须兼容，可自动转换的基本数据类型除外，否则编译 出错。</p>
<p>equalsIgnoreCase() 方法用于将字符串与指定的对象比较，不考虑大小写。</p>
<p>contains() 方法用于判断字符串中是否包含指定的字符或字符串。</p>
<p>trim() 方法用于删除字符串的头尾空白符。</p>
<h2 id="4-String类与char-、byte-之间的转换"><a href="#4-String类与char-、byte-之间的转换" class="headerlink" title="4.String类与char[]、byte[]之间的转换"></a>4.String类与char[]、byte[]之间的转换</h2><p><img src="/posts/a4cff879/image-20210502142039420.png" alt="image-20210502142039420"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;abc1234&quot;</span>;</span><br><span class="line">        <span class="keyword">char</span>[] c1 = s1.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; c1.length;i++)&#123;</span><br><span class="line">            System.out.println(c1[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] c2 = &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">        String s2 = <span class="keyword">new</span> String(c2);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/a4cff879/image-20210502142755814.png" alt="image-20210502142755814"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;abc1234&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] b1 = s1.getBytes();<span class="comment">// 可以在getBytes中指定编码集</span></span><br><span class="line">        System.out.println(Arrays.toString(b1));<span class="comment">// 输出UTF-8编码，默认编码集</span></span><br><span class="line"></span><br><span class="line">        String s2 = <span class="keyword">new</span> String(b1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（三）</title>
    <url>/posts/cb72181d.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Scanner（扫描器）对象"><a href="#1-Scanner（扫描器）对象" class="headerlink" title="1.Scanner（扫描器）对象"></a>1.Scanner（扫描器）对象</h2><p>java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。</p>
<p>下面是创建 Scanner 对象的基本语法：</p>
<p><code>import java.util.Scanner;</code></p>
<p><code>Scanner s = new Scanner(System.in);</code></p>
<span id="more"></span>

<p><img src="/posts/cb72181d/image-20210226155906265.png" alt="image-20210226155906265"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Scanner s = <span class="keyword">new</span> Scanner(System.in);<span class="comment">// 创建Scanner对象s</span></span><br><span class="line">	    System.out.println(<span class="string">&quot;使用next方式接受：&quot;</span>);</span><br><span class="line">	    <span class="comment">//判断用户有没有输入字符串</span></span><br><span class="line">	    <span class="keyword">if</span> (s.hasNext())&#123;</span><br><span class="line">	    	String str = s.next();</span><br><span class="line">	    	System.out.println(<span class="string">&quot;输入的内容是：&quot;</span>+str);</span><br><span class="line">	    &#125;</span><br><span class="line">	    s.close();<span class="comment">// 凡是属于IO流的类如果不关闭会一直占用资源</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* input:  hello world</span></span><br><span class="line"><span class="comment">output:hello*/</span> hello之前的空格会过滤</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Scanner s = <span class="keyword">new</span> Scanner(System.in);<span class="comment">// 创建Scanner对象s</span></span><br><span class="line">	    System.out.println(<span class="string">&quot;使用nextLine方式接受：&quot;</span>);</span><br><span class="line">	    <span class="comment">//判断用户有没有输入字符串</span></span><br><span class="line">	    <span class="keyword">if</span> (s.hasNextLine())&#123;</span><br><span class="line">	    	String str = s.nextLine();</span><br><span class="line">	    	System.out.println(<span class="string">&quot;输入的内容是：&quot;</span>+str);</span><br><span class="line">	    &#125;</span><br><span class="line">	    s.close();<span class="comment">// 凡是属于IO流的类如果不关闭会一直占用资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* input:  hello world</span></span><br><span class="line"><span class="comment">output:  hello world*/</span> hello之前的空格会接收</span><br></pre></td></tr></table></figure>

<p><img src="/posts/cb72181d/image-20210226173438395.png" alt="image-20210226173438395"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> sign = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (s.hasNextDouble())&#123;</span><br><span class="line">			sum += s.nextDouble();</span><br><span class="line">			sign ++;</span><br><span class="line">			System.out.println(<span class="string">&quot;你输入了第&quot;</span>+sign+<span class="string">&quot;个数据，结果是&quot;</span>+sum);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(sign+<span class="string">&quot;个数的总和是&quot;</span>+sum+<span class="string">&quot;，平均值是&quot;</span>+sum/sign);</span><br><span class="line">	    s.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-选择分支"><a href="#2-选择分支" class="headerlink" title="2.选择分支"></a>2.选择分支</h2><h3 id="if选择分支"><a href="#if选择分支" class="headerlink" title="if选择分支"></a>if选择分支</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入内容：&quot;</span>);</span><br><span class="line">		String str = s.nextLine();</span><br><span class="line">		<span class="comment">// equals:用于判断字符串是否相等，与==不一样，少用==判断</span></span><br><span class="line">		<span class="keyword">if</span>(s.equals(<span class="string">&quot;hello&quot;</span>))&#123;</span><br><span class="line">			System.out.println(str);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;End!&quot;</span>);</span><br><span class="line">	    s.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/cb72181d/image-20210226180441511.png" alt="image-20210226180441511"></p>
<h3 id="switch选择分支"><a href="#switch选择分支" class="headerlink" title="switch选择分支"></a>switch选择分支</h3><p><img src="/posts/cb72181d/image-20210226180716484.png" alt="image-20210226180716484"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">char</span> grade = <span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (grade)&#123;<span class="comment">// 大致同C++</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:<span class="comment">// case语句有穿透效果，用break跳出</span></span><br><span class="line">                System.out.println(<span class="string">&quot;优秀&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">            	System.out.println(<span class="string">&quot;良好&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            	System.out.println(<span class="string">&quot;挂科&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            	System.out.println(<span class="string">&quot;未知&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;<span class="comment">// JDK7的新特性，switch支持string字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-循环结构"><a href="#3-循环结构" class="headerlink" title="3.循环结构"></a>3.循环结构</h2><p>包括while，do-while和for循环，break和continue跳出循环。大致语法结构与C++相同。</p>
<p>在JDK5中引入了一种主要用于数组的增强型for循环。</p>
<p>关于goto，它是java的保留字，但是并没有得到正式使用。</p>
<p><img src="/posts/cb72181d/image-20210226184655016.png" alt="image-20210226184655016"></p>
<p><img src="/posts/cb72181d/image-20210226185120597.png" alt="image-20210226185120597"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x:nums)&#123;<span class="comment">// 增强for循环，遍历数组中的元素</span></span><br><span class="line">			System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4 5 6</span></span><br></pre></td></tr></table></figure>

<h2 id="4-Java中的方法"><a href="#4-Java中的方法" class="headerlink" title="4.Java中的方法"></a>4.Java中的方法</h2><p><img src="/posts/cb72181d/image-20210226190359631.png" alt="image-20210226190359631"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">		System.out.println(sum);<span class="comment">// 3</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="comment">// static修饰，可以直接在main方法中使用</span></span><br><span class="line">		<span class="keyword">return</span> a+b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/cb72181d/image-20210226191028284.png" alt="image-20210226191028284"></p>
<p><img src="/posts/cb72181d/image-20210226191746005.png" alt="image-20210226191746005"></p>
<p>记住：<strong>Java中的方法都是值传递</strong>。<strong>其实 Java 只存在一种传参的方式，就是用实参给形参赋值。</strong></p>
<h2 id="5-方法的重载（非常重要）"><a href="#5-方法的重载（非常重要）" class="headerlink" title="5.方法的重载（非常重要）"></a>5.方法的重载（非常重要）</h2><p><img src="/posts/cb72181d/image-20210226195152023.png" alt="image-20210226195152023"></p>
<p>方法重载基本类似C++中的函数重载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum1 = add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">double</span> sum2 = add(<span class="number">1.0</span>,<span class="number">2.0</span>);</span><br><span class="line">		<span class="keyword">double</span> sum3 = add(<span class="number">1</span>,<span class="number">2.0</span>);</span><br><span class="line">		System.out.println(sum1);</span><br><span class="line">		System.out.println(sum2);</span><br><span class="line">		System.out.println(sum3);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a+b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a+b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">// 注意：仅仅返回类型不同不足以成为方法的重载，要求参数列表必须不同</span></span><br><span class="line"><span class="comment">//必须参数类型不同，名字相同也不行</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/cb72181d/image-20210403104515242.png" alt="image-20210403104515242"></p>
<p>重载的特殊之处在于：如果参数满足自动类型转换的方法有好几个，重载规则是选择最近的调用。</p>
<p>比如：int add(int a)和int add(double b)，如果传入byte,short,int类型的参数a，会调用第一个，传入float,double类型的参数a会调用第二个。自己写的话最好避免这样的情况。</p>
<h2 id="6-给main函数传参"><a href="#6-给main函数传参" class="headerlink" title="6.给main函数传参"></a>6.给main函数传参</h2><h3 id="6-1通过命令行传参"><a href="#6-1通过命令行传参" class="headerlink" title="6.1通过命令行传参"></a>6.1通过命令行传参</h3><p><img src="/posts/cb72181d/image-20210226195848316.png" alt="image-20210226195848316"></p>
<p>上图中<code>String args[]</code>意思同<code>String[] args</code>，前者是类C的写法，后者是Java写法。</p>
<p><img src="/posts/cb72181d/image-20210226200420492.png" alt="image-20210226200420492"></p>
<p>注意：要通过java命令运行放在package中的class文件，必须回退到包的路径（此处是src目录）。</p>
<p>通过java命令给main方法传递参数”this is…”，并打印参数。</p>
<h3 id="6-2通过IDEA传参"><a href="#6-2通过IDEA传参" class="headerlink" title="6.2通过IDEA传参"></a>6.2通过IDEA传参</h3><p><img src="/posts/cb72181d/image-20210403162513517.png" alt="image-20210403162513517"></p>
<p><img src="/posts/cb72181d/image-20210403162656746.png" alt="image-20210403162656746"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输出：</span><br><span class="line"><span class="number">4</span></span><br><span class="line">anb</span><br><span class="line"><span class="number">123</span></span><br><span class="line">qw sd df</span><br><span class="line">王小明</span><br></pre></td></tr></table></figure>

<h2 id="7-可变参数（不定项参数）"><a href="#7-可变参数（不定项参数）" class="headerlink" title="7.可变参数（不定项参数）"></a>7.可变参数（不定项参数）</h2><p><img src="/posts/cb72181d/image-20210226200859067.png" alt="image-20210226200859067"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">		demo.test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);<span class="comment">// 2</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>... i)</span></span>&#123;</span><br><span class="line">		System.out.println(i[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-数组"><a href="#8-数组" class="headerlink" title="8.数组"></a>8.数组</h2><p>数组是引用数据类型。数组的长度是固定的，一旦创建就不能修改。</p>
<p><img src="/posts/cb72181d/image-20210226202658385.png" alt="image-20210226202658385"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] num1;<span class="comment">// 1.首选声明方法</span></span><br><span class="line">		num1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];<span class="comment">// 定义，存放10个int型数字		</span></span><br><span class="line">		<span class="keyword">int</span> num2[];<span class="comment">// 2.</span></span><br><span class="line">		<span class="keyword">int</span>[] num3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">12</span>];<span class="comment">// 3.</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; num1.length;i ++)&#123;</span><br><span class="line">			num1[i] = i+<span class="number">1</span>;<span class="comment">// 赋值</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x: num1)&#123;</span><br><span class="line">			System.out.println(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/cb72181d/image-20210226204957419.png" alt="image-20210226204957419"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">// 静态初始化:创建 +赋值</span></span><br><span class="line">		<span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line">		<span class="comment">// 动态初始化：包含默认初始化</span></span><br><span class="line">		<span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">		b[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/cb72181d/image-20210226205614686.png" alt="image-20210226205614686"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arrays = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span>[] result = reverse(arrays);</span><br><span class="line">		printArray(result);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 打印数组</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arrays)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> array:arrays)&#123;</span><br><span class="line">			System.out.println(array);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 翻转数组</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] reverse(<span class="keyword">int</span>[] arrays)&#123;</span><br><span class="line">		<span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[arrays.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,j = result.length-<span class="number">1</span>;i &lt; arrays.length;i++,j--)&#123;</span><br><span class="line">			result[j] = arrays[i];</span><br><span class="line">		&#125;</span><br><span class="line"> 		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>多维数组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[][] array = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line">		System.out.println(array[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-内存分析"><a href="#9-内存分析" class="headerlink" title="9.内存分析"></a>9.内存分析</h2><p><img src="/posts/cb72181d/image-20210226204256773.png" alt="image-20210226204256773"></p>
<p>数组的内存机制：</p>
<p>1.声明数组array，存放于栈中；</p>
<p>2.创建数组array，在堆中开辟空间。(<strong>数组对象本身是在堆中的</strong>)</p>
<p><img src="/posts/cb72181d/image-20210226204804592.png" alt="image-20210226204804592"></p>
<h2 id="10-Arrays类"><a href="#10-Arrays类" class="headerlink" title="10.Arrays类"></a>10.Arrays类</h2><p><img src="/posts/cb72181d/image-20210227113849263.png" alt="image-20210227113849263"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">// Arrays类中的方法都是通过类名调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">67</span>,<span class="number">345</span>,<span class="number">2</span>,<span class="number">456</span>,<span class="number">67</span>,<span class="number">45</span>&#125;;</span><br><span class="line">		<span class="comment">// 打印数组元素：Arrays.toString</span></span><br><span class="line">		System.out.println(Arrays.toString(a));</span><br><span class="line">		</span><br><span class="line">		Arrays.sort(a);<span class="comment">// 对数组排序，从小到大</span></span><br><span class="line">		System.out.println(Arrays.toString(a));</span><br><span class="line">		</span><br><span class="line">		Arrays.fill(a, <span class="number">0</span>);<span class="comment">// 将数组全部用0填充</span></span><br><span class="line">		System.out.println(Arrays.toString(a));</span><br><span class="line">		Arrays.fill(a, <span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>);<span class="comment">// 将数组（左闭右开）下标2~4全部用1填充</span></span><br><span class="line">		System.out.println(Arrays.toString(a));</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（九）</title>
    <url>/posts/2969f165.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-万类之祖：Object类"><a href="#1-万类之祖：Object类" class="headerlink" title="1.万类之祖：Object类"></a>1.万类之祖：Object类</h2><p><strong>所有的类，都间接或者直接的继承自Object 类。</strong></p>
<p><strong>数组属于引用类型，也是继承自Object 类。</strong></p>
<p>Object 类没有成员变量，只有一些成员方法。</p>
<p>注意：hashCode和equals方法基本面试必考！！！</p>
<span id="more"></span>

<p>Object getClass() 方法用于获取对象的运行时对象的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunoobTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 创建 RunoobTest 类的对象</span></span><br><span class="line">        RunoobTest obj = <span class="keyword">new</span> RunoobTest();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// RunoobTest 继承 Object 类，Object 是所有类的超类</span></span><br><span class="line">        <span class="comment">// 调用 getClass() 方法</span></span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//class RunoobTest</span></span><br></pre></td></tr></table></figure>

<p><strong>Object toString() 方法</strong>用于返回对象的字符串表示形式。对于有数据的类，常用 toString() 方法展示数据内容。</p>
<p>当输出对象s时，会调用toString() 方法。唯一的一点区别就是：若对象是null时，打印s显示null（保护机制，避免异常），而打印s.toString()会出现NullPointerException。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子演示</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Circle&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;radius=&quot;</span> + radius +</span><br><span class="line">                <span class="string">&quot;, color=&#x27;&quot;</span> + color + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>默认返回格式：<strong>对象的 class 名称 + @ + hashCode 的十六进制字符串</strong>。</p>
<p>Object hashCode() 方法用于获取对象的 hash 值。</p>
<p>返回对象哈希值，是一个整数，表示在哈希表中的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunoobTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// toString() with Object</span></span><br><span class="line">        Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line">        System.out.println(obj1.toString());</span><br><span class="line">        Object obj2 = <span class="keyword">new</span> Object();</span><br><span class="line">        System.out.println(obj2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java.lang.Object@d716361</span></span><br><span class="line"><span class="comment">//1878246837</span></span><br></pre></td></tr></table></figure>

<p>Object equals() 方法用于比较两个对象是否相等。</p>
<p>equals() 方法比较两个对象，是判断两个对象引用指向的是同一个对象，即比较 2 个对象的内存地址是否相等。</p>
<p><strong>注意：</strong>如果子类重写了 equals() 方法，就需要重写hashCode()方法，比如 String 类就重写了 equals() 方法，同时也重写了 hashCode() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunoobTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Object 类使用 equals() 方法</span></span><br><span class="line">        <span class="comment">// 创建两个对象</span></span><br><span class="line">        Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line">        Object obj2 = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 判断 obj1 与 obj2 是否相等</span></span><br><span class="line">        <span class="comment">// 不同对象，内存地址不同，不相等，返回 false</span></span><br><span class="line">        System.out.println(obj1.equals(obj2)); <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// obj1 赋值给 obj3</span></span><br><span class="line">        <span class="comment">// String 重写了 equals() 方法</span></span><br><span class="line">        <span class="comment">// 对象引用，内存地址相同，相等，返回 true</span></span><br><span class="line">        Object obj3 = obj1;</span><br><span class="line">        System.out.println(obj1.equals(obj3)); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p><strong>hashCode和equals是我们最常覆盖的两个方法。</strong></p>
<p>覆盖的原则：equals是true，hashCode就应该相等，这是一种约定俗成的规范。</p>
<p>即equals为true是hashCode相等的充分非必要条件，hashCode相等是equals为true的必要不充分条件。</p>
<p>在IDEA中，右键–&gt;Generate，可以选择生成hashCode和equals方法。</p>
<p><strong>自动生成</strong>的equals方法比自己手动写要更准确，手动可能存在漏洞。</p>
<p><strong>以后直接自动生成就行。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> MerchandiseV2)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        MerchandiseV2 that = (MerchandiseV2) o;</span><br><span class="line">        <span class="comment">// 判断成员变量等是否相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getCount() == that.getCount() &amp;&amp;</span><br><span class="line">                Double.compare(that.getSoldPrice(), getSoldPrice()) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                Double.compare(that.getPurchasePrice(), getPurchasePrice()) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getName().equals(that.getName()) &amp;&amp;</span><br><span class="line">                getId().equals(that.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(getName(), getId(), getCount(), getSoldPrice(), getPurchasePrice());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>用“==”不能判断两个对象是否相等，只能判断两个引用是否指向同一个对象。</p>
<p><img src="/posts/2969f165/image-20210404113052887.png" alt="image-20210404113052887"></p>
<h2 id="2-判断String类是否相等"><a href="#2-判断String类是否相等" class="headerlink" title="2.判断String类是否相等"></a>2.判断String类是否相等</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;aaabbb&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String s2 = <span class="string">&quot;aaa&quot;</span> + <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt; TODO 说好的每次创建一个新的String对象呢？</span></span><br><span class="line">        System.out.println(<span class="string">&quot;s1和s2用==判断结果：&quot;</span>+(s1 == s2));</span><br><span class="line">		<span class="comment">// 是因为Java对String的优化，发现有一样的String，就直接返回</span></span><br><span class="line">        System.out.println(<span class="string">&quot;s1和s2用 equals 判断结果：&quot;</span>+(s1.equals(s2)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt; TODO 打乱Java对String的的优化，再试试看</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入s1&quot;</span>);</span><br><span class="line">        s1 = scanner.nextLine();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入s2&quot;</span>);</span><br><span class="line">        s2 = scanner.nextLine();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;s1和s2用==判断结果：&quot;</span>+(s1 == s2));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;s1和s2用 equals 判断结果：&quot;</span>+(s1.equals(s2)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*s1和s2用==判断结果：true</span></span><br><span class="line"><span class="comment">s1和s2用 equals 判断结果：true</span></span><br><span class="line"><span class="comment">请输入s1</span></span><br><span class="line"><span class="comment">acsde</span></span><br><span class="line"><span class="comment">请输入s2</span></span><br><span class="line"><span class="comment">acsde</span></span><br><span class="line"><span class="comment">s1和s2用==判断结果：false</span></span><br><span class="line"><span class="comment">s1和s2用 equals 判断结果：true*/</span></span><br></pre></td></tr></table></figure>

<h2 id="3-Class类"><a href="#3-Class类" class="headerlink" title="3.Class类"></a>3.Class类</h2><p>Class类是代表类的类。</p>
<p>每个Class类的实例，都代表了一个类。</p>
<p><code>getName()</code> 来产生完整（带包名）的类名，使用 <code>getSimpleName()</code> 产生不带包名的类名。</p>
<h2 id="4-JUnit单元测试"><a href="#4-JUnit单元测试" class="headerlink" title="4.JUnit单元测试"></a>4.JUnit单元测试</h2><p>先讲讲什么是单元测试？</p>
<p>IDEA为Java类创建JUnit单元测试。</p>
<p><img src="/posts/2969f165/image-20210404125900225.png" alt="image-20210404125900225"></p>
<p><img src="/posts/2969f165/image-20210404131222019.png" alt="image-20210404131222019"></p>
<p>此时的Java类要求：① 此类是public的  ②此类提供公共的无参的构造器</p>
<ul>
<li><p>此类中声明单元测试方法。</p>
<p>此时的单元测试方法：方法的权限是public,没有返回值，没有形参</p>
</li>
<li><p>此单元测试方法上需要<strong>声明注解：@Test</strong>,并在单元测试类中导入：import org.junit.Test;（不同版本junit可能导入不一样）</p>
</li>
<li><p>声明好单元测试方法以后，就可以在方法体内测试相关的代码。</p>
</li>
<li><p>写完代码以后，左键双击单元测试方法名，右键：run as - JUnit Test</p>
</li>
<li><p>说明：</p>
</li>
<li><p>1.如果执行结果没有任何异常：绿条</p>
</li>
<li><p>2.如果执行结果出现异常：红条</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（二一）</title>
    <url>/posts/5b571d4d.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="8-调用运行时类的指定结构（重点）"><a href="#8-调用运行时类的指定结构（重点）" class="headerlink" title="8.调用运行时类的指定结构（重点）"></a>8.调用运行时类的指定结构（重点）</h2><p>主要是属性和方法，构造器。属性和<strong>方法</strong>更常用。</p>
<span id="more"></span>

<p>首先是调用属性。</p>
<p>提示：第一个方法不常用，开发常用第二个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用运行时类的指定结构：属性、方法、构造器</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    <span class="comment">// 创建运行时类的对象</span></span><br><span class="line">    Person p = (Person)clazz.newInstance();</span><br><span class="line">    <span class="comment">// 获取指定的属性，要求运行时类的属性声明为public</span></span><br><span class="line">    <span class="comment">// 通常不太用</span></span><br><span class="line">    Field age = clazz.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置当前属性的值，set：参数1，指明设置对象的哪个属性，参数2，指明属性值设为多少</span></span><br><span class="line">    age.set(p,<span class="number">12</span>);</span><br><span class="line">    <span class="comment">// 获取当前属性的值，get：指明获取对象的哪个属性</span></span><br><span class="line">    <span class="keyword">int</span> pAge = (<span class="keyword">int</span>)age.get(p);</span><br><span class="line">    System.out.println(pAge);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取指定的属性的常用做法，开发中常用</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    <span class="comment">// 创建运行时类的对象</span></span><br><span class="line">    Person p = (Person)clazz.newInstance();</span><br><span class="line">    <span class="comment">// 1.获取运行时类中指定变量名的属性，私有属性也能拿到</span></span><br><span class="line">    Field name = clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.保证当前属性是可访问的</span></span><br><span class="line">    name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    name.set(p,<span class="string">&quot;Newton&quot;</span>);</span><br><span class="line">    System.out.println(name.get(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如何操作运行时类中的指定方法</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    <span class="comment">//  创建运行时类的对象</span></span><br><span class="line">    Person p = (Person)clazz.newInstance();</span><br><span class="line">    <span class="comment">//  1.获取指定的某个方法，private String showNation(String Nation)</span></span><br><span class="line">    <span class="comment">//  getDeclaredMethod：参数1，指明获取的方法的名称，参数2，指明获取的方法的形参列表</span></span><br><span class="line">    Method showNation = clazz.getDeclaredMethod(<span class="string">&quot;showNation&quot;</span>, String.class);</span><br><span class="line">    <span class="comment">// 2.保证当前方法是可访问的</span></span><br><span class="line">    showNation.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 3.通过invoke执行方法</span></span><br><span class="line">    <span class="comment">//  invoke：参数1，方法的调用者，参数2，给方法形参赋值得到实参</span></span><br><span class="line">    <span class="comment">// invoke的返回值即为调用的方法的返回值，没有返回值返回null</span></span><br><span class="line">    Object chn = showNation.invoke(p, <span class="string">&quot;CHN&quot;</span>);<span class="comment">// 默认为Object，可以强转</span></span><br><span class="line">    System.out.println(chn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如何调用静态方法，private static void info()</span></span><br><span class="line">    Method info = clazz.getDeclaredMethod(<span class="string">&quot;info&quot;</span>);</span><br><span class="line">    info.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    info.invoke(Person.class);</span><br><span class="line">    <span class="comment">// info.invoke(null);这样也行，任意对象都能调用静态方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如何调用运行时类的指定的构造器，不太常用</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private Person(String name)</span></span><br><span class="line">    <span class="comment">// 1.获取指定的构造器</span></span><br><span class="line">    <span class="comment">// 参数：指明构造器的参数列表</span></span><br><span class="line">    Constructor constructor = clazz.getDeclaredConstructor(String.class);</span><br><span class="line">    <span class="comment">// 2.保证当前构造器是可访问的</span></span><br><span class="line">    constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 3.调用此构造器创建运行时类的对象</span></span><br><span class="line">    Person p = (Person)constructor.newInstance(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    System.out.println(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JavaSE阶段回顾总结：</p>
<p><a href="https://www.bilibili.com/video/BV1MJ411v7tJ">https://www.bilibili.com/video/BV1MJ411v7tJ</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（二十）</title>
    <url>/posts/41769e7b.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Java反射机制"><a href="#1-Java反射机制" class="headerlink" title="1.Java反射机制"></a>1.Java反射机制</h2><span id="more"></span>

<p><img src="/posts/41769e7b/image-20210727172953297.png" alt="image-20210727172953297"></p>
<p>红色要求重点掌握，其他作为了解内容。</p>
<p><img src="/posts/41769e7b/image-20210727173601290.png" alt="image-20210727173601290"></p>
<p>反射示例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String  name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showNation</span><span class="params">(String Nation)</span></span>&#123;</span><br><span class="line">        System.out.println(Nation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReflectionTest.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 反射之前对Person类的操作</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建Person类对象</span></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        <span class="comment">// 2.通过对象调用内部的属性、方法</span></span><br><span class="line">        p1.age = <span class="number">11</span>;</span><br><span class="line">        System.out.println(p1.toString());</span><br><span class="line">        p1.show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反射之后对Person类的操作</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line">        Constructor cons = clazz.getConstructor(String.class,<span class="keyword">int</span>.class);</span><br><span class="line">        <span class="comment">// 1.通过反射创建Person类对象</span></span><br><span class="line">        Object obj = cons.newInstance(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        Person p = (Person) obj;</span><br><span class="line">        System.out.println(p.toString());</span><br><span class="line">        <span class="comment">// 2.通过反射调用对象内部的属性、方法</span></span><br><span class="line">        <span class="comment">// 调用属性</span></span><br><span class="line">        Field age = clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        age.set(p,<span class="number">11</span>);</span><br><span class="line">        System.out.println(p.toString());</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        Method show = clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">        show.invoke(p);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射调用Person类的私有结构</span></span><br><span class="line">        <span class="comment">// 调用私有构造器</span></span><br><span class="line">        Constructor cons1 = clazz.getDeclaredConstructor(String.class);</span><br><span class="line">        cons1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object obj1 = cons1.newInstance(<span class="string">&quot;Mike&quot;</span>);</span><br><span class="line">        Person p2 = (Person) obj1;</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">        <span class="comment">// 调用私有属性</span></span><br><span class="line">        Field name = clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        name.set(p2,<span class="string">&quot;James&quot;</span>);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">        <span class="comment">// 调用私有方法</span></span><br><span class="line">        Method showNation = clazz.getDeclaredMethod(<span class="string">&quot;showNation&quot;</span>, String.class);</span><br><span class="line">        showNation.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        String nation = (String)showNation.invoke(p2,<span class="string">&quot;IceLand&quot;</span>);</span><br><span class="line">        System.out.println(nation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-疑问解答"><a href="#2-疑问解答" class="headerlink" title="2.疑问解答"></a>2.疑问解答</h2><p>1.通过直接new的方式和反射的方式都能调用类的公共结构，开发中用哪个？</p>
<p>答：一般使用直接new的方式。（明确造哪个类的对象）</p>
<p>当不确定造哪个类的对象时，使用反射，反射具有动态性的特性。</p>
<p>2.反射与OOP中的封装性是否矛盾？</p>
<p>答：不矛盾。</p>
<h2 id="3-Class类"><a href="#3-Class类" class="headerlink" title="3.Class类"></a>3.Class类</h2><p>Class类定义在java.lang.Class之下。</p>
<p>类的加载过程：程序经过javac命令编译后生成一个或多个字节码(.class)文件，接着用java命令对某个字节码文件解释执行。</p>
<p>解释执行的过程相当于将某个字节码文件加载到内存中，此过程称为类的加载。</p>
<p>加载到内存中的类称为运行时类，作为Class类的一个实例。</p>
<p><strong>Class的实例就对应着一个运行时类！</strong></p>
<p><strong>加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类。</strong></p>
<p>运行时类在它的生命周期不会重复加载，只有一个。</p>
<h2 id="4-获取Class类的实例（四种方法）"><a href="#4-获取Class类的实例（四种方法）" class="headerlink" title="4.获取Class类的实例（四种方法）"></a>4.获取Class类的实例（四种方法）</h2><p>前3种方式都需要掌握，最后1种作为了解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取Class的实例的方式</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 前3种方式都需要掌握，最后1种作为了解</span></span><br><span class="line">    <span class="comment">// 方式1：调用运行时类的属性.class</span></span><br><span class="line">    Class&lt;Person&gt; clazz1 = Person.class;<span class="comment">// &lt;Person&gt;可以省略，加了泛型避免被强转</span></span><br><span class="line">    System.out.println(clazz1);</span><br><span class="line">    <span class="comment">// 方式2：通过运行时类的对象，调用getClass()</span></span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">    Class clazz2 = p1.getClass();</span><br><span class="line">    System.out.println(clazz2);</span><br><span class="line">    <span class="comment">// 方式3：调用class的静态方法，forName(String classPath)，需要全类名</span></span><br><span class="line">    Class clazz3 = Class.forName(<span class="string">&quot;Java_05.Person&quot;</span>);</span><br><span class="line">    System.out.println(clazz3);</span><br><span class="line"></span><br><span class="line">    System.out.println(clazz1 == clazz2);<span class="comment">//true</span></span><br><span class="line">    System.out.println(clazz1 == clazz3);<span class="comment">//true</span></span><br><span class="line">    <span class="comment">// 对应同一个运行时类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式4：使用类的加载器Classloader</span></span><br><span class="line">    ClassLoader classloader = ReflectionTest.class.getClassLoader();</span><br><span class="line">    Class clazz4 = classloader.loadClass(<span class="string">&quot;Java_05.Person&quot;</span>);</span><br><span class="line">    System.out.println(clazz4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式3用的比较多。</p>
<p>Class实例可以是哪些结构？</p>
<p><img src="/posts/41769e7b/image-20210730121121036.png" alt="image-20210730121121036"></p>
<p><img src="/posts/41769e7b/image-20210730121243893.png" alt="image-20210730121243893"></p>
<h2 id="5-类的加载与ClassLoader的理解"><a href="#5-类的加载与ClassLoader的理解" class="headerlink" title="5.类的加载与ClassLoader的理解"></a>5.类的加载与ClassLoader的理解</h2><p>了解内容。</p>
<p><img src="/posts/41769e7b/image-20210730121854721.png" alt="image-20210730121854721"></p>
<p>类加/装载器的作用：</p>
<p><img src="/posts/41769e7b/image-20210730122635446.png" alt="image-20210730122635446"></p>
<p><img src="/posts/41769e7b/image-20210730122814235.png" alt="image-20210730122814235"></p>
<p>例子演示。</p>
<p>使用Classloader加载src目录下的配置文件。<br>        Properties：用来读取配置文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    Properties pros =  <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">//此时的文件默认在当前的module下。</span></span><br><span class="line">    <span class="comment">//读取配置文件的方式一：</span></span><br><span class="line">    <span class="comment">//        FileInputStream fis = new FileInputStream(&quot;jdbc.properties&quot;);</span></span><br><span class="line">    <span class="comment">//        FileInputStream fis = new FileInputStream(&quot;src\\jdbc1.properties&quot;);</span></span><br><span class="line">    <span class="comment">//        pros.load(fis);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取配置文件的方式二：使用ClassLoader</span></span><br><span class="line">    <span class="comment">//配置文件默认识别为：当前module的src下</span></span><br><span class="line">    ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();</span><br><span class="line">    InputStream is = classLoader.getResourceAsStream(<span class="string">&quot;jdbc1.properties&quot;</span>);</span><br><span class="line">    pros.load(is);</span><br><span class="line"></span><br><span class="line">    String user = pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    String password = pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;user = &quot;</span> + user + <span class="string">&quot;,password = &quot;</span> + password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-创建运行时类的对象（重要）"><a href="#6-创建运行时类的对象（重要）" class="headerlink" title="6.创建运行时类的对象（重要）"></a>6.创建运行时类的对象（重要）</h2><p>先写代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;Person&gt; obj = Person.class;</span><br><span class="line">Person p = obj.newInstance();<span class="comment">// newInstance创建对应的运行时类的对象</span></span><br><span class="line"><span class="comment">// 本质上是调用了空参构造器，也可以调用有参构造器</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>newInstance():调用此方法，创建对应的运行时类的对象。内部调用了运行时类的空参的构造器。</p>
<p>要想此方法正常的创建运行时 在javabean中要求提供一个public的空参构造器。原因：</p>
<ol>
<li>便于通过反射，创建运行时类的对象</li>
<li>便于子类继承此运行时类时，默认调用super()时，保证父类此构造器</li>
</ol>
<p>通过创建运行时类的对象体会反射的动态性。</p>
<h2 id="7-获取运行时类的完整结构"><a href="#7-获取运行时类的完整结构" class="headerlink" title="7.获取运行时类的完整结构"></a>7.获取运行时类的完整结构</h2><p>作为了解内容，不要求掌握。</p>
<p>我们可以通过反射，获取对应的运行时类中所有的属性、方法、构造器、父类、接口、父类的泛型、包、注解、异常等。。。。</p>
<p><strong>获取属性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取属性结构</span></span><br><span class="line">    <span class="comment">//getFields():获取当前运行时类及其父类中声明为public访问权限的属性</span></span><br><span class="line">    Field[] fields = clazz.getFields();</span><br><span class="line">    <span class="keyword">for</span>(Field f : fields)&#123;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getDeclaredFields():获取当前运行时类中声明的所属性。（不包含父类中声明的属性</span></span><br><span class="line">    Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span>(Field f : declaredFields)&#123;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getMethods():获取当前运行时类及其所父类中声明为public权限的方法</span></span><br><span class="line">    Method[] methods = clazz.getMethods();</span><br><span class="line">    <span class="keyword">for</span>(Method m : methods)&#123;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">//getDeclaredMethods():获取当前运行时类中声明的所方法。（不包含父类中声明的方法</span></span><br><span class="line">    Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span>(Method m : declaredMethods)&#123;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取构造器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    <span class="comment">//getConstructors():获取当前运行时类中声明为public的构造器</span></span><br><span class="line">    Constructor[] constructors = clazz.getConstructors();</span><br><span class="line">    <span class="keyword">for</span>(Constructor c : constructors)&#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">//getDeclaredConstructors():获取当前运行时类中声明的所的构造器</span></span><br><span class="line">    Constructor[] declaredConstructors = clazz.getDeclaredConstructors();</span><br><span class="line">    <span class="keyword">for</span>(Constructor c : declaredConstructors)&#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取父类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">    Class superclass = clazz.getSuperclass();</span><br><span class="line">    System.out.println(superclass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取运行时类的带泛型的父类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">    Type genericSuperclass = clazz.getGenericSuperclass();</span><br><span class="line">    System.out.println(genericSuperclass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取运行时类的带泛型的父类的泛型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">    Type genericSuperclass = clazz.getGenericSuperclass();</span><br><span class="line">    ParameterizedType paramType = (ParameterizedType) genericSuperclass;</span><br><span class="line">    <span class="comment">//获取泛型类型</span></span><br><span class="line">    Type[] actualTypeArguments = paramType.getActualTypeArguments();</span><br><span class="line">    <span class="comment">//        System.out.println(actualTypeArguments[0].getTypeName());</span></span><br><span class="line">    System.out.println(((Class)actualTypeArguments[<span class="number">0</span>]).getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取运行时类实现的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">    Class[] interfaces = clazz.getInterfaces();</span><br><span class="line">    <span class="keyword">for</span>(Class c : interfaces)&#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">//获取运行时类的父类实现的接口</span></span><br><span class="line">    Class[] interfaces1 = clazz.getSuperclass().getInterfaces();</span><br><span class="line">    <span class="keyword">for</span>(Class c : interfaces1)&#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取运行时类所在的包</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">    Package pack = clazz.getPackage();</span><br><span class="line">    System.out.println(pack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取运行时类声明的注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">    Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line">    <span class="keyword">for</span>(Annotation annos : annotations)&#123;</span><br><span class="line">        System.out.println(annos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（二）</title>
    <url>/posts/866cbb4f.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-IDEA快捷键"><a href="#1-IDEA快捷键" class="headerlink" title="1.IDEA快捷键"></a>1.IDEA快捷键</h2><p>psvm：<code>public static void main(String[] args)</code></p>
<p>sout：<code>System.out.println(&quot;&quot;)</code></p>
<p>ctrl + D：复制当前行到下一行</p>
<p>Alt + Insert：生成构造器，get/set方法</p>
<span id="more"></span>

<h2 id="2-HelloWorld"><a href="#2-HelloWorld" class="headerlink" title="2.HelloWorld"></a>2.HelloWorld</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;hello world!&quot;</span>);<span class="comment">// print line</span></span><br><span class="line">		System.out.print(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-数据类型扩展"><a href="#3-数据类型扩展" class="headerlink" title="3.数据类型扩展"></a>3.数据类型扩展</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.整数扩展</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">010</span>,i2 = <span class="number">10</span>,i3 = <span class="number">0x10</span>;</span><br><span class="line">		System.out.println(i);<span class="comment">// 八进制0，以0开头的就是八进制</span></span><br><span class="line">		System.out.println(i2);<span class="comment">// 十进制，默认</span></span><br><span class="line">		System.out.println(i3);<span class="comment">// 十六进制0x</span></span><br><span class="line">        <span class="comment">// 二进制0b</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 8 10 16 */</span></span><br><span class="line"><span class="comment">// 2.浮点数扩展</span></span><br><span class="line"><span class="comment">// 最好完全避免使用浮点数进行比较，因为存在精度丢失！！！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.字符扩展</span></span><br><span class="line"><span class="comment">// 所有字符本质还是数字</span></span><br><span class="line"><span class="comment">// java中采用Unicode编码字符char，2字节，0~65536(2^16)，对应16进制Unicode字符U0000~UFFFF</span></span><br><span class="line"><span class="comment">//Java 中的 char 类型之所以占 2 个字节，是因为 Java 使用的是 Unicode 字符集而不是 ASCII 字符集</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">char</span> c1 = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">		<span class="keyword">char</span> c2 = <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">        <span class="keyword">char</span> c3 = <span class="string">&#x27;\u0061&#x27;</span>;<span class="comment">// 采用十六进制，对应十进制下的97，即a</span></span><br><span class="line">		System.out.println(c1);</span><br><span class="line">		System.out.println((<span class="keyword">int</span>)c1);</span><br><span class="line">		System.out.println(c2);</span><br><span class="line">		System.out.println((<span class="keyword">int</span>)c2);</span><br><span class="line">        System.out.println(c3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*A</span></span><br><span class="line"><span class="comment">65</span></span><br><span class="line"><span class="comment">中</span></span><br><span class="line"><span class="comment">20013</span></span><br><span class="line"><span class="comment">a*/</span></span><br></pre></td></tr></table></figure>

<h2 id="4-类型转换"><a href="#4-类型转换" class="headerlink" title="4.类型转换"></a>4.类型转换</h2><p>整型、实型（常量）、字符型数据可以混合运算。运算中，<strong>不同类型的数据先转化为同一类型，然后进行运算</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">低  ------------------------------------&gt;  高</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>,<span class="keyword">short</span>,<span class="keyword">char</span>—&gt; <span class="keyword">int</span> —&gt; <span class="keyword">long</span>—&gt; <span class="keyword">float</span> —&gt; <span class="keyword">double</span> </span><br></pre></td></tr></table></figure>

<p>数据类型转换必须满足如下规则：</p>
<ul>
<li><p>不能对boolean类型进行类型转换。</p>
</li>
<li><p>不能把对象类型转换成不相关类的对象。</p>
</li>
<li><p> 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</p>
</li>
</ul>
<h3 id="4-1-强制类型转换：从高级到低级"><a href="#4-1-强制类型转换：从高级到低级" class="headerlink" title="4.1 强制类型转换：从高级到低级"></a>4.1 强制类型转换：从高级到低级</h3><ul>
<li>条件是转换的数据类型必须是兼容的。</li>
<li>格式：<code>(type)value</code>是要强制类型转换后的数据类型</li>
</ul>
<p>隐含的强制类型转换：</p>
<ul>
<li>整数的默认类型是 int。</li>
<li>浮点型不存在这种情况，因为在定义 float 类型时必须在数字后面跟上 F 或者 f，浮点数的默认类型是double。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = <span class="number">10_0000_0000</span>;</span><br><span class="line"><span class="keyword">int</span> years = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">long</span> total1 = m*years;<span class="comment">// 右边是int型，溢出</span></span><br><span class="line"><span class="keyword">long</span> total2 = m*(<span class="keyword">long</span>)years;<span class="comment">// 右边是long型，溢出</span></span><br><span class="line">System.out.println(total1);</span><br><span class="line">System.out.println(total2);</span><br><span class="line"><span class="comment">/*-1474836480  溢出</span></span><br><span class="line"><span class="comment">20000000000*/</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：强制类型转换过程中可能导致溢出或损失精度</strong>，例如：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i =<span class="number">128</span>;   </span><br><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)i;<span class="comment">// b = -128,内存溢出</span></span><br></pre></td></tr></table></figure>

<p>  因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。</p>
<ul>
<li><p>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">int</span>)<span class="number">23.7</span> == <span class="number">23</span>;        </span><br><span class="line">(<span class="keyword">int</span>)-<span class="number">45.89f</span> == -<span class="number">45</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-2自动类型转换：从低级到高级"><a href="#4-2自动类型转换：从低级到高级" class="headerlink" title="4.2自动类型转换：从低级到高级"></a>4.2自动类型转换：从低级到高级</h3><p>必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。</p>
<p>char不能自动转换为short，因为它们都是2字节，但是char是无符号数，在正数范围超过了short。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 补充</span></span><br><span class="line"><span class="comment">// JDK7新特性，数字之间可以用下划线分隔</span></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">10_0000_0000</span>;</span><br><span class="line">System.out.println(m);</span><br></pre></td></tr></table></figure>

<h2 id="5-class的属性"><a href="#5-class的属性" class="headerlink" title="5.class的属性"></a>5.class的属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="comment">// 属性：先简单理解为变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//类变量，静态变量 static</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> salary = <span class="number">2500</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实例变量，成员变量，在类的里面，方法体之外，从属于对象</span></span><br><span class="line">    String name;<span class="comment">//如果不自行初始化，默认为</span></span><br><span class="line">    <span class="keyword">int</span> age;<span class="comment">//如果不自行初始化，默认为0 0.0</span></span><br><span class="line">    <span class="comment">// boolean默认为false，除了基本类型，其余默认值都是null</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//main方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//局部变量:必须声明和初始化值</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        </span><br><span class="line">        Demo demo = <span class="keyword">new</span> Demo();<span class="comment">// 创建对象demo</span></span><br><span class="line">        System.out.println(demo.age);<span class="comment">// 0</span></span><br><span class="line">        System.out.println(demo.name);<span class="comment">// null</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(salary);<span class="comment">// 类变量可以直接打印</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-常量"><a href="#6-常量" class="headerlink" title="6.常量"></a>6.常量</h2><p>常量确定后在程序运行过程中不允许修改。</p>
<p>语法格式：<code>final 常量名 = 值</code></p>
<p><code>final double PI = 3.14159</code> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类变量</span></span><br><span class="line"><span class="comment">// static,final都是修饰符，不区分先后顺序</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>

<h2 id="7-变量命名规范（再次强调）"><a href="#7-变量命名规范（再次强调）" class="headerlink" title="7.变量命名规范（再次强调）"></a>7.变量命名规范（再次强调）</h2><p>1.变量，方法名：monthSalary，Run()，首字母小写和驼峰命名原则，除第一个单词以外后面单词首字母大写。</p>
<p>2.常量：MAX_VALUE，大写字母和下划线。</p>
<p>3.类名：GoodMan，首字母大写和驼峰命名原则。</p>
<h2 id="8-Java运算符"><a href="#8-Java运算符" class="headerlink" title="8.Java运算符"></a>8.Java运算符</h2><p>大部分同C++。</p>
<p><img src="/posts/866cbb4f/image-20210226144639115.png" alt="image-20210226144639115"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> a = <span class="number">121415531646L</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">234</span>;</span><br><span class="line"><span class="keyword">short</span> c = <span class="number">23</span>;</span><br><span class="line"><span class="keyword">byte</span> d = <span class="number">4</span>;</span><br><span class="line">System.out.println(a+b+c+d);<span class="comment">// long,运算中有long结果就是long</span></span><br><span class="line">System.out.println(b+c+d);<span class="comment">// int,运算中无long结果就是int</span></span><br><span class="line">System.out.println(c+d);<span class="comment">// int,运算中无long结果就是int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 幂运算，Math是自带的工具类</span></span><br><span class="line"><span class="keyword">double</span> pow = Math.pow(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">// Math.pow()返回double型</span></span><br><span class="line">System.out.println(pow);</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串连接符 + ,String，只要+两边有至少一个String就能运算</span></span><br><span class="line"><span class="keyword">int</span> a =<span class="number">10</span>;<span class="comment">// Srting必须用双引号</span></span><br><span class="line"><span class="keyword">int</span> b =<span class="number">20</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>+a+b);<span class="comment">// 1020</span></span><br><span class="line">System.out.println(a+b+<span class="string">&quot;&quot;</span>);<span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三元运算符,同C++</span></span><br><span class="line"><span class="number">2</span> &lt; <span class="number">3</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>

<h2 id="9-Package包机制"><a href="#9-Package包机制" class="headerlink" title="9.Package包机制"></a>9.Package包机制</h2><p><u>为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间，防止命名空间重复。</u></p>
<p>右键新建Package，将class文件拖入Package，方便程序管理，相当于文件夹的作用。</p>
<p><img src="/posts/866cbb4f/image-20210226145141548.png" alt="image-20210226145141548"></p>
<p><img src="/posts/866cbb4f/image-20210226152120269.png" alt="image-20210226152120269"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demo</span></span><br><span class="line"><span class="keyword">package</span> com.cnblogs.www.conyoo;<span class="comment">// 注意包语句必须放在class文件最上面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blog</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">import</span> com.kunag.base.*; <span class="comment">// 导入该包中的所有类</span></span><br></pre></td></tr></table></figure>

<h2 id="10-JavaDoc生成文档"><a href="#10-JavaDoc生成文档" class="headerlink" title="10.JavaDoc生成文档"></a>10.JavaDoc生成文档</h2><p><img src="/posts/866cbb4f/image-20210226153609818.png" alt="image-20210226153609818"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Java_01;</span><br><span class="line"><span class="comment">/** 类的注释</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> grant drew</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 方法的注释</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> grant drew</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception</span>&#123;<span class="comment">// 只是演示，不需要深入理解</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>javadoc命令：生成API文档。</p>
<p><code>jvadoc -sncoding UTF-8 -charset UTF-8 Doc.java</code></p>
<p>index.html即生成的帮助文档首页。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（五）</title>
    <url>/posts/13c1c43f.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-方法重写（覆盖）（非常重要）"><a href="#1-方法重写（覆盖）（非常重要）" class="headerlink" title="1.方法重写（覆盖）（非常重要）"></a>1.方法重写（覆盖）（非常重要）</h2><p>又被称为方法覆盖，override</p>
<p><strong>覆盖才是继承的精髓和终极奥义</strong></p>
<p>记住：重写是方法的重写，和属性无关</p>
<p>覆盖：通过使用和父类方法签名一样，而且返回值也必须一样的方法，可以让子类覆盖掉父类的方法</p>
<p>如果方法签名一样，但返回值不同，会报错</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B=&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A=&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.test();<span class="comment">//A</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态方法的调用只与左边定义的数据类型有关</span></span><br><span class="line">        <span class="comment">// 父类的引用指向了子类</span></span><br><span class="line">        B b = <span class="keyword">new</span> A();</span><br><span class="line">        b.test();<span class="comment">//B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*A=&gt;test()</span></span><br><span class="line"><span class="comment">B=&gt;test()*/</span></span><br></pre></td></tr></table></figure>

<p>test方法去掉static修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B=&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Override 重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A=&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态方法与非静态方法区别很大！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.test();</span><br><span class="line"></span><br><span class="line">        B b = <span class="keyword">new</span> A();<span class="comment">// 子类重写了父类的方法</span></span><br><span class="line">        <span class="comment">// 重写只与非静态方法有关</span></span><br><span class="line">        b.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*A=&gt;test()</span></span><br><span class="line"><span class="comment">A=&gt;test()*/</span></span><br></pre></td></tr></table></figure>

<p>静态方法是类的方法，而非静态方法是对象的方法。</p>
<p>在demo1中，b是A new出来的对象，所以调用A的方法test。</p>
<blockquote>
<p><strong>重写的关键字只能是public，不能是static或者private，子类继承父类才有重写</strong></p>
</blockquote>
<p>重写：（IDEA快捷键：Alt + Insert：override）</p>
<ul>
<li>需要有继承关系，子类重写父类的方法！</li>
<li>方法名必须相同</li>
<li>参数列表必须相同</li>
<li>修饰符：范围可以扩大但不能缩小，<code>public &gt; porotected &gt; default &gt; private</code></li>
<li>抛出的异常：范围可以缩小但不能扩大，例：<code>ClassNotFoundException(小)--&gt;Exception(大)</code></li>
</ul>
<p>-为什么需要重写？</p>
<p>-父类的功能，子类不一定需要或不一定满足！</p>
<p>-什么方法不能重写？</p>
<ol>
<li>static方法：它属于类，不属于实例（对象）</li>
<li>final 常量</li>
<li>private方法</li>
</ol>
<h2 id="2-多态（重要）"><a href="#2-多态（重要）" class="headerlink" title="2.多态（重要）"></a>2.多态（重要）</h2><p><img src="/posts/13c1c43f/image-20210305195037264.png" alt="image-20210305195037264"></p>
<p>多态注意事项：</p>
<ol>
<li>多态是方法的多态，属性没有多态</li>
<li>必须是父类与子类间的继承关系</li>
<li>存在条件：继承关系，方法需要重写，<strong>父类引用指向子类对象！</strong></li>
<li>一个Person类既可以引用Person类型的对象，也可以引用Person类的任何一个子类的对象</li>
<li>可以调用哪些方法，取决于引用类型是什么，具体调用哪个方法，取决于对象所属的类是什么</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于同一方法run有不同的行为</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;<span class="comment">// 方法覆盖，体现了多态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;son&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一个对象的实现类型是确定的</span></span><br><span class="line">        <span class="comment">// 如new Student();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 但是可以指向的引用类型就不确定了</span></span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="comment">// Student能调用的方法都是自己的或者继承父类的！</span></span><br><span class="line">        <span class="comment">//父类的引用指向子类的对象</span></span><br><span class="line">        Person s2 = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="comment">//Person可以指向子类，但是不能调用子类独有的方法，只能重写</span></span><br><span class="line">        Object s3 = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象能执行哪些方法，主要看左边的类型，与右边关系不大</span></span><br><span class="line">        s2.run();<span class="comment">//子类重写父类的方法，执行子类的方法</span></span><br><span class="line">        <span class="comment">//s2.eat(); 无法重写，报错</span></span><br><span class="line">        s1.run();</span><br><span class="line">        s1.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当父类的引用指向子类的实例，只能通过父类的引用，像父类一样操作子类的对象</strong>，也就是说左边“名”的类型，决定了能执行哪些操作（调用哪些方法…）。</p>
<p>总结：无论一个方法是使用哪个引用被调用的，”它都是在实际的对象上执行的”。执行的任何一个方法，都是这个对象所属的类的方法。如果没有，就去父类找，再没有，就去父类的父类找，依次寻找，直到找到。那么自然的，即使是在继承自父类的代码里，去调用一个方法，也是先从子类开始，一层层继承关系的找。这也是Java选择单继承的重要原因之一。在多继承的情况下，如果使用不当，多态可能会非常复杂，以至于使用的代价超过其带来的好处。</p>
<p>在这里我再总结一下这三个模式。</p>
<p>1）父类引用指向子类对象，<strong>可以调用只在父类中的方法</strong>（继承） 2）父类引用指向子类对象，<strong>可以调用子类覆盖了父类的方法</strong>（覆盖，多态） 3）父类引用指向子类对象，在1）和2）这两种情况下。如果这个方法的代码中又调用了别的方法，那么还是会遵循这个规则。举个例子，如果父类中有m1，m2两个方法。子类覆盖了m2方法。那么如果调用m1，则m1中调用的m2会是子类中定义的m2。</p>
<h2 id="3-instanceof和类型转换"><a href="#3-instanceof和类型转换" class="headerlink" title="3.instanceof和类型转换"></a>3.instanceof和类型转换</h2><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>instanceof 是 Java 的一个二元操作符，类似于 ==，&gt;，&lt; 等操作符。</p>
<p>它的作用是测试它左边的对象是否是它右边的类（或子类）的实例，返回 boolean 的数据类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Object &gt; Person &gt; Student</span></span><br><span class="line">        <span class="comment">// Object &gt; Person &gt; Teacher</span></span><br><span class="line">        <span class="comment">// Object &gt; String</span></span><br><span class="line">        Object object = <span class="keyword">new</span> Student();<span class="comment">//注意object是Student类的对象</span></span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Student);<span class="comment">//true</span></span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Person);<span class="comment">//true</span></span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Object);<span class="comment">//true</span></span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Teacher);<span class="comment">//false</span></span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> String);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>System.out.println(x instanceof Y);</code>能不能编译（无关对错）通过取决于x指向的类型是不是与Y有继承·关系。</p>
<p>如果引用时null，肯定返回false。</p>
<p><strong>“is-a”规则</strong></p>
<p>用来判断是否应该将数据设计为继承关系，它指出子类的每个对象也是父类的对象。</p>
<p>例如：将Student类设计为Person类的子类，因为“Student is a Person”。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ol>
<li><strong>父类引用指向子类的对象，不能反过来</strong></li>
<li>把子类转换为父类，向上转型</li>
<li>把父类转换为子类，向下转型，强制转换，<strong>只能在继承关系下进行强制转换</strong></li>
<li>方便方法的调用，减少重复代码</li>
<li>在将父类强制类型转换成子类之前，应该使用instanceof进行检查</li>
<li>一般情况下，最好尽量少使用强制转换和instanceof</li>
<li>父类若转换为子类，父类引用必须指向的是一个子类对象。实质上是将一个指向子类对象的父类引用改为了子类引用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注:Person是Student的父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 类型之间的转换（高到低）：父  子</span></span><br><span class="line">        Person s = <span class="keyword">new</span> Student();<span class="comment">//低 --&gt; 高，自动转换</span></span><br><span class="line">        <span class="comment">//将s这个对象转换为Student类型，就可以使用Student类方法</span></span><br><span class="line">        Student obj = (Student)s;<span class="comment">//高 --&gt; 低，强制类型转换</span></span><br><span class="line">        obj.go();</span><br><span class="line">        <span class="comment">//上面两行等价于((Student)s).go();</span></span><br><span class="line"></span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        Person person = student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所谓强制转型（转自CSDN）</strong></p>
<ul>
<li><p>你没有改变对象，只是改变了引用而已</p>
</li>
<li><p>父类引用不能访问子类方法</p>
<p>所以当你用父类引用指向子类对象时，不能访问子类的方法</p>
<p>而当你转回子类引用指向子类对象时，又可以访问子类方法了</p>
</li>
<li><p>记住，这个过程中对象一直没变过，一直都是那个子类对象，变的只是引用</p>
</li>
</ul>
<h2 id="4-static关键字"><a href="#4-static关键字" class="headerlink" title="4.static关键字"></a>4.static关键字</h2><p>静态方法里面只能调用静态的东西，而main函数也是静态的。</p>
<p><img src="/posts/13c1c43f/image-20210502090403539.png" alt="image-20210502090403539"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2.</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;匿名代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.只执行一次</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 3.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*静态代码块</span></span><br><span class="line"><span class="comment">匿名代码块</span></span><br><span class="line"><span class="comment">构造方法*/</span></span><br></pre></td></tr></table></figure>

<p>小例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态导入包</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		System.out.println(random());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-抽象类（不是重点"><a href="#5-抽象类（不是重点" class="headerlink" title="5.抽象类（不是重点)"></a>5.抽象类（不是重点)</h2><p><img src="/posts/13c1c43f/image-20210305220537625.png" alt="image-20210305220537625"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// abstract 抽象类</span></span><br><span class="line"><span class="comment">// Java类是单继承的，但是接口可以多继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="comment">//抽象方法，只有方法名字，没有方法的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//1.不能new这个抽象类，只能靠子类去实现它</span></span><br><span class="line">    <span class="comment">//2.抽象类中可以写普通方法</span></span><br><span class="line">    <span class="comment">//3.抽象方法必须在抽象类中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类的所有方法，继承它的子类都必须要实现它的方法，除非它也是抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 注解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.不能new这个抽象类，只能靠子类去实现它</p>
<p>2.抽象类中可以写普通方法</p>
<p>3.抽象方法必须在抽象类中</p>
<h2 id="6-接口（重要）"><a href="#6-接口（重要）" class="headerlink" title="6.接口（重要）"></a>6.接口（重要）</h2><p>Java通过接口来实现C++中多继承的效果。</p>
<p>接口和类是两个并列的结构。</p>
<p><img src="/posts/13c1c43f/image-20210305222342257.png" alt="image-20210305222342257"></p>
<p><img src="/posts/13c1c43f/image-20210502111638626.png" alt="image-20210502111638626"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//interface修饰接口，接口都需要实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//接口中的所有定义其实都是抽象的，默认为public abstract</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(String name)</span></span>;<span class="comment">// public abstract void run(String name);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TimeService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">timer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类可以通过implements实现接口</span></span><br><span class="line"><span class="comment">// 实现接口的类，需要重写接口中的所有方法</span></span><br><span class="line"><span class="comment">// 利用接口实现多继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span>,<span class="title">TimeService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接口作用</strong></p>
<ol>
<li>约束</li>
<li>定义一些方法，让不同的人实现</li>
<li>接口中方法默认用<code>public abstract</code>修饰</li>
<li>接口中属性默认用<code>public static final</code>修饰，也即静态常量</li>
<li>接口不能被实例化，接口中没有构造方法</li>
<li>接口中定义的静态方法只能通过接口来调用</li>
<li>通过实现类的对象，可以调用接口的default方法</li>
<li>通过implements可以实现多个接口</li>
<li>必须要重写接口中的方法</li>
</ol>
<h2 id="7-N种内部类"><a href="#7-N种内部类" class="headerlink" title="7.N种内部类"></a>7.N种内部类</h2><p><img src="/posts/13c1c43f/image-20210306112110052.png" alt="image-20210306112110052"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是外部类的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是内部类的方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//内部类可以获得外部类的私有属性</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getID</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        <span class="comment">// 通过外部类来实例化内部类</span></span><br><span class="line">        Outer.Inner inner = outer.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">        inner.in();<span class="comment">//这是内部类的方法</span></span><br><span class="line">        inner.getID();<span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个java类中可以有多个class类，但是只能有一个public class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下小例子只作为扩展眼界，不必深究。</p>
<p>小例子1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//局部内部类</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小例子2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//没有名字初始化类，不用将实例保存到变量中</span></span><br><span class="line">        <span class="keyword">new</span> Apple().eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 成员内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">D</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-属性访问修饰符"><a href="#8-属性访问修饰符" class="headerlink" title="8.属性访问修饰符"></a>8.属性访问修饰符</h2><p><img src="/posts/13c1c43f/image-20210403100049939.png" alt="image-20210403100049939"></p>
<p><img src="/posts/13c1c43f/image-20210403100119985.png" alt="image-20210403100119985"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（八）</title>
    <url>/posts/53a4d03a.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-System类不简单"><a href="#1-System类不简单" class="headerlink" title="1.System类不简单"></a>1.System类不简单</h2><span id="more"></span>

<p><img src="/posts/53a4d03a/image-20210403163004447.png" alt="image-20210403163004447"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LearnSystem</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startMS = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> endMS = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;程序执行使用了几个毫秒？&quot;</span> + (endMS - startMS));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startNS = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        counter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> endNS = System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;程序执行使用了几个纳秒？&quot;</span> + (endNS - startNS));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一般常用毫米</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">程序执行使用了几个毫秒？0</span></span><br><span class="line"><span class="comment">程序执行使用了几个纳秒？7600*/</span></span><br></pre></td></tr></table></figure>

<p><code>System.currentTimeMillis()</code> 返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">currentTimeMillis</span><span class="params">()</span> <span class="comment">// 返回long</span></span></span><br></pre></td></tr></table></figure>

<h2 id="2-String类的好兄弟：StringBuilder"><a href="#2-String类的好兄弟：StringBuilder" class="headerlink" title="2.String类的好兄弟：StringBuilder"></a>2.String类的好兄弟：StringBuilder</h2><p>它是一个非常方便用于拼接和处理字符串的类，它和String不同在于<strong>它是可变的</strong>。</p>
<p>这对“好兄弟”的关系有点像C++中的string类和vector。</p>
<p><strong>StringBuffer</strong> 与<strong>StringBuilder</strong>类似。 </p>
<p><strong>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</strong></p>
<p><strong>String、StringBuffer、StringBuilder三者的对比</strong></p>
<ul>
<li><code>String</code>:不可变的字符序列；底层使用char[]存储</li>
<li><code>StringBuffer</code>:可变的字符序列；线程安全的，效率低；底层使用char[]存储</li>
<li><code>StringBuilder</code>:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；底层使用char[]存储</li>
</ul>
<p>虽然可以直接拼接String字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率。</p>
<p>为了能高效拼接字符串，Java标准库提供了<code>StringBuilder</code>，它是一个可变对象，可以预分配缓冲区，这样，往<code>StringBuilder</code>中新增字符时，不会创建新的临时对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//StringBuilder首先是可变的</span></span><br><span class="line">        <span class="comment">//而且对它进行操作的方法，都会返回this自引用。这样我们就可以一直点下去，对String进行构造。</span></span><br><span class="line">        StringBuilder strBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">long</span> longVal = <span class="number">123456789</span>;</span><br><span class="line">		<span class="comment">//StringBuilder sb = new StringBuilder(&quot;Run&quot;);// 可以传入参数</span></span><br><span class="line">        <span class="comment">//StringBuilder sb = new StringBuilder(10);// 初始长度为10，可以一直append</span></span><br><span class="line">    </span><br><span class="line">        strBuilder.append(<span class="keyword">true</span>).append(<span class="string">&quot;abc&quot;</span>).append(longVal);</span><br><span class="line"></span><br><span class="line">        System.out.println(strBuilder.toString());<span class="comment">// 转换为String对象</span></span><br><span class="line">        System.out.println(strBuilder.reverse().toString());<span class="comment">//反转</span></span><br><span class="line">        System.out.println(strBuilder.reverse().toString());</span><br><span class="line">        System.out.println(strBuilder.toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(strBuilder.delete(<span class="number">0</span>, <span class="number">4</span>).toString());<span class="comment">// 左闭右开</span></span><br><span class="line"></span><br><span class="line">        System.out.println(strBuilder.insert(<span class="number">3</span>,<span class="string">&quot;LLLLL&quot;</span>).toString());<span class="comment">// 放在索引为3的位置</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/53a4d03a/image-20210502145658876.png" alt="image-20210502145658876"></p>
<p><img src="/posts/53a4d03a/image-20210502145722353.png" alt="image-20210502145722353"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常用方法</span></span><br><span class="line">增：append(xxx)</span><br><span class="line">删：delete(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span><br><span class="line">改：setCharAt(<span class="keyword">int</span> n ,<span class="keyword">char</span> ch) / replace(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span><br><span class="line">查：charAt(<span class="keyword">int</span> n )</span><br><span class="line">插：insert(<span class="keyword">int</span> offset, xxx)</span><br><span class="line">长度：length();</span><br><span class="line">*遍历：<span class="keyword">for</span>() + charAt() / toString()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>append、reverse、delete和insert均不会创建新对象，直接在原对象上修改。</p>
</blockquote>
<h2 id="3-多态里更多的语法"><a href="#3-多态里更多的语法" class="headerlink" title="3.多态里更多的语法"></a>3.多态里更多的语法</h2><p>静态多态：重载（Overload）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重载调用哪个方法，和参数的引用类型相关，和引用实际指向的类型无关</span></span><br><span class="line">merchandiseTest.testMerchandiseOverload(m);</span><br><span class="line">merchandiseTest.testMerchandiseOverload((Phone) m);</span><br><span class="line">merchandiseTest.testMerchandiseOverload((ShellColorChangePhone) m);</span><br><span class="line"><span class="comment">//甚至是个null也可以，但是要用强制类型转换，告诉Java这个类型是什么，否则找不到一个唯一的方法去调用</span></span><br><span class="line"><span class="comment">// 重载的参数类型，相同位置，不一定要有继承或者兼容的关系，完全free style</span></span><br><span class="line"><span class="comment">//如果引用类型没有完全匹配的，则会根据继承关系，沿着参数当前类型，向下撸       </span></span><br><span class="line">merchandiseTest.testMerchandiseOverloadNotExactlyMatchType((ShellColorChangePhone) <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>重载总结：静态多态，调用的方法和参数实际指向的对象无关，只和引用本身的类型相关。</p>
<p>因为调用时参数类型是确定的，所以，在编译期间就可以明确的知道哪个方法会被调用。如果有多种可能，则会有编译错误</p>
<p>如果没有类型完全匹配的候选，则根据类型的继承关系向下撸着找。找到最贴近参数类型的那个方法</p>
<p>无论是静态方法，还是成员方法，重载寻找方法的顺序是一样的，在这里就不赘述了</p>
<p>动态多态：覆盖（Override）</p>
<h2 id="4-继承专属的访问控制符"><a href="#4-继承专属的访问控制符" class="headerlink" title="4.继承专属的访问控制符"></a>4.继承专属的访问控制符</h2><p>protected 可见性= default + 对子类可见</p>
<p>子类覆盖父类的方法，不可以使用可见性更低的修饰符，但可以使用可见性更高的修饰符。</p>
<h2 id="5-final修饰符"><a href="#5-final修饰符" class="headerlink" title="5.final修饰符"></a>5.final修饰符</h2><p>final意为最终的。不可变！！不需要再扩充功能了，已经够用了。</p>
<p><img src="/posts/53a4d03a/image-20210404091023201.png" alt="image-20210404091023201"></p>
<p>我们常用的String类就是用final修饰的，不能被随意修改。</p>
<p>final修饰变量，也就成了常量，必须在定义时初始化，或在构造器里初始化，且不能修改。</p>
<p>final修饰static变量，必须在定义时初始化，或在<code>static&#123;&#125;</code>代码块里赋值。</p>
<p>final修饰父类的方法，确保不会被子类覆盖。</p>
<p><strong>final不能修饰构造方法！</strong></p>
<p>final修饰的类不可被继承：比如：String类、System类、StringBuffer类。</p>
<p><strong>final修饰引用</strong>：不能修改令引用指向别的对象，但是可以修改引用指向的对象。</p>
<p>这就有C语言的常量指针内味了，不可修改指针的指向，但能修改指针指向的值。</p>
<p>注：常量指针与指向常量的指针不一样！</p>
<h2 id="6-继承里的静态方法"><a href="#6-继承里的静态方法" class="headerlink" title="6.继承里的静态方法"></a>6.继承里的静态方法</h2><p>静态方法可以被继承，方法签名和返回值必须一样。</p>
<p>用引用调用（即用对象）静态方法不会被覆盖，不推荐这样调用，应该用类名调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">m.staticMethod();</span><br><span class="line">((Phone) m).staticMethod(); <span class="comment">// 会调用对应对象的方法</span></span><br><span class="line">((ShellColorChangePhone) m).staticMethod();</span><br><span class="line"><span class="comment">// TODO 有些东西，学会就应该马上忘掉，比如上面使用引用调用静态方法的内容</span></span><br><span class="line">((MerchandiseV2) <span class="keyword">null</span>).staticMethod();</span><br><span class="line">((Phone) <span class="keyword">null</span>).staticMethod(); <span class="comment">// 会调用对应对象的方法</span></span><br><span class="line">((ShellColorChangePhone) <span class="keyword">null</span>).staticMethod();</span><br><span class="line"><span class="comment">// TODO 有些东西，学会就应该马上忘掉，比如上面使用有类型的null引用调用静态方法的内容</span></span><br></pre></td></tr></table></figure>

<h2 id="7-for-each循环"><a href="#7-for-each循环" class="headerlink" title="7.for-each循环"></a>7.for-each循环</h2><p>语法基本同C++/Python中的类似写法，循环对象必须是一个数组或者一个实现了Iterable接口的类对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="comment">//forEach写法（效果跟下面同等）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i:arr)</span><br><span class="line">	System.out.println(<span class="string">&quot;数组元素:&quot;</span>+i);</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（六）</title>
    <url>/posts/76cf8fe6.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Java异常机制（Exception）"><a href="#Java异常机制（Exception）" class="headerlink" title="Java异常机制（Exception）"></a>Java异常机制（Exception）</h2><span id="more"></span>

<p><img src="/posts/76cf8fe6/image-20210306125425820.png" alt="image-20210306125425820"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//小例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> A().a();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        b();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Exception in thread &quot;main&quot; java.lang.StackOverflowError 栈溢出</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/76cf8fe6/image-20210306130118928.png" alt="image-20210306130118928"></p>
<p><img src="/posts/76cf8fe6/image-20210306130155892.png" alt="image-20210306130155892"></p>
<h3 id="错误（Error）与异常（Exception）"><a href="#错误（Error）与异常（Exception）" class="headerlink" title="错误（Error）与异常（Exception）"></a>错误（Error）与异常（Exception）</h3><p><img src="/posts/76cf8fe6/image-20210306130317211.png" alt="image-20210306130317211"></p>
<p><img src="/posts/76cf8fe6/image-20210306130400193.png" alt="image-20210306130400193"></p>
<p>Exception可以分成运行时异常和非运行时异常。</p>
<p>以上理论只作为了解内容，重点是如何处理异常。</p>
<h3 id="异常处理（抛出与捕获）"><a href="#异常处理（抛出与捕获）" class="headerlink" title="异常处理（抛出与捕获）"></a>异常处理（抛出与捕获）</h3><p><img src="/posts/76cf8fe6/image-20210306130827800.png" alt="image-20210306130827800"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//try监控区域</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(a/b);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ArithmeticException e)&#123;</span><br><span class="line">            <span class="comment">//catch用于捕获异常</span></span><br><span class="line">            System.out.println(<span class="string">&quot;程序异常，变量b不能为0&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//处理善后工作，无论是否异常都会执行</span></span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//try-catch代码块是必要的</span></span><br><span class="line">        <span class="comment">//finally不是必须的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">new</span> Test().a();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            <span class="comment">//catch(想要捕获的异常类型)</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        b();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try-catch…-catch结构：一般把较大的异常放在后面。</p>
<p>假设要捕获多个异常，必须从小到大，否则会报错！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(a/b);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Error e)&#123;</span><br><span class="line">            <span class="comment">//catch用于捕获异常</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Throwable&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//处理善后工作，无论是否异常都会执行</span></span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//try-catch代码块是必要的</span></span><br><span class="line">        <span class="comment">//finally不是必须的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IDEA异常处理快捷键：</p>
<p><img src="/posts/76cf8fe6/image-20210306132935760.png" alt="image-20210306132935760"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> Test().test(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//假设这个方法处理不了这个异常，就从方法上抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> ArithmeticException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException();<span class="comment">//主动抛出异常，一般在方法中使用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/76cf8fe6/image-20210306135620960.png" alt="image-20210306135620960"></p>
<p><strong>异常处理的一般经验</strong>：捕获那些你知道如何处理的异常，继续传播（抛出）那些不知道如何处理的异常。</p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>大部分情况下，我们不需要自定义异常。</p>
<p><img src="/posts/76cf8fe6/image-20210306135807062.png" alt="image-20210306135807062"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义的异常类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="comment">//传递数字&gt;10抛出异常</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> detail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.detail = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//toString:异常的打印信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyException&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;detail=&quot;</span> + detail +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可能会存在异常的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">throws</span> MyException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;传递的参数为：&quot;</span>+a);</span><br><span class="line">        <span class="keyword">if</span> (a&gt;<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyException(a);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//传递的参数为：1 OK</span></span><br><span class="line">            test(<span class="number">11</span>);</span><br><span class="line">            <span class="comment">//传递的参数为：11 MyException=&gt;MyException&#123;detail=11&#125;</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyException=&gt;&quot;</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/76cf8fe6/image-20210306143205863.png" alt="image-20210306143205863"></p>
<p>IDEA代码出现波浪线（一些异常等），按住Alt + Enter进行处理。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>异常</tag>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（十七）</title>
    <url>/posts/b0469d44.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-File类"><a href="#1-File类" class="headerlink" title="1.File类"></a>1.File类</h2><p>File类的一个对象，代表一个文件或一个文件目录(俗称：文件夹)</p>
<p>File类声明在java.io包下</p>
<p>File类中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及到<strong>写入或</strong></p>
<p><strong>读取文件内容</strong>的操作。如果需要读取或写入文件内容，必须使用<strong>IO流</strong>来完成。</p>
<p>后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的”终点”。</p>
<span id="more"></span>

<h3 id="File类的常用构造器：File的实例化"><a href="#File类的常用构造器：File的实例化" class="headerlink" title="File类的常用构造器：File的实例化"></a>File类的常用构造器：File的实例化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String filePath)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String parentPath,String childPath)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(File parentFile,String childPath)</span></span></span><br></pre></td></tr></table></figure>

<p>说明：<br>    IDEA中：</p>
<p>如果大家开发使用JUnit中的<strong>单元测试方法</strong>测试，相对路径即为当前Module下。</p>
<p>如果大家使用main()测试，相对路径即为当前的Project下。<br>    Eclipse中：</p>
<p>不管使用单元测试方法还是使用main()测试，相对路径都是当前的Project下。</p>
<p>路径分隔符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">windows和DOS系统默认使用“\”来表示</span><br><span class="line"><span class="comment">// D:\xxx\Java01_基础    在java中就需要加上\\，或者/也行</span></span><br><span class="line"></span><br><span class="line">UNIX和URL使用“/”来表示</span><br><span class="line"><span class="comment">// home/cyb</span></span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 方式1：</span></span><br><span class="line">    <span class="comment">// 相对路径, 相对于当前module</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);<span class="comment">// hello.txt</span></span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    File file1 = <span class="keyword">new</span> File(<span class="string">&quot;D:/xxx/xxx/hello.txt&quot;</span>);<span class="comment">// D:\xxx\xxx\hello.txt</span></span><br><span class="line">    System.out.println(file);</span><br><span class="line">    System.out.println(file1);</span><br><span class="line">    <span class="comment">// 方式2：</span></span><br><span class="line">    File file2 = <span class="keyword">new</span> File(<span class="string">&quot;D:/Java&quot;</span>,<span class="string">&quot;Java基础&quot;</span>);</span><br><span class="line">    System.out.println(file2);<span class="comment">// D:\Java\Java基础</span></span><br><span class="line">    <span class="comment">// 方式3：</span></span><br><span class="line">    File file3 = <span class="keyword">new</span> File(file2,<span class="string">&quot;hi.txt&quot;</span>);</span><br><span class="line">    System.out.println(file3);<span class="comment">// D:\Java\Java基础\hi.txt</span></span><br><span class="line">    <span class="comment">// 以上的file对象只是内存层面的，在硬盘中实际并不存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/b0469d44/image-20210613125356257.png" alt="image-20210613125356257"></p>
<h3 id="File类的常用方法"><a href="#File类的常用方法" class="headerlink" title="File类的常用方法"></a>File类的常用方法</h3><p>File类的获取功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAbsolutePath</span><span class="params">()</span>：获取绝对路径</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPath</span><span class="params">()</span> ：获取路径</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> ：获取名称</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getParent</span><span class="params">()</span>：获取上层文件目录路径。若无，返回<span class="keyword">null</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">length</span><span class="params">()</span> ：获取文件长度（即：字节数）。不能获取目录的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lastModified</span><span class="params">()</span> ：获取最后一次的修改时间，毫秒值</span></span><br><span class="line"><span class="function">如下的两个方法适用于文件目录</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String[] <span class="title">list</span><span class="params">()</span> ：获取指定目录下的所有文件或者文件目录的名称数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> File[] <span class="title">listFiles</span><span class="params">()</span> ：获取指定目录下的所有文件或者文件目录的File数组</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;D:\\Hexo\\blog&quot;</span>);</span><br><span class="line">    System.out.println(file.getPath());</span><br><span class="line">    String[] list = file.list();</span><br><span class="line">    <span class="keyword">for</span> (String s: list)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    File[] files = file.listFiles();</span><br><span class="line">    <span class="keyword">for</span> (File f:files)&#123;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*D:\Hexo\blog</span></span><br><span class="line"><span class="comment">.deploy_git</span></span><br><span class="line"><span class="comment">.git</span></span><br><span class="line"><span class="comment">.gitignore</span></span><br><span class="line"><span class="comment">db.json</span></span><br><span class="line"><span class="comment">xxx省略</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">D:\Hexo\blog\.deploy_git</span></span><br><span class="line"><span class="comment">D:\Hexo\blog\.git</span></span><br><span class="line"><span class="comment">D:\Hexo\blog\.gitignore</span></span><br><span class="line"><span class="comment">D:\Hexo\blog\db.json</span></span><br><span class="line"><span class="comment">xxx*/</span></span><br></pre></td></tr></table></figure>

<p>File类的重命名功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">renameTo</span><span class="params">(File dest)</span>:把文件重命名为指定的文件路径</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    File file1 = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    File file2 = <span class="keyword">new</span> File(<span class="string">&quot;F:\\VS_cpp\\hi.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 要想保证返回true，file1必须在硬盘中存在，file2不能存在</span></span><br><span class="line">    <span class="comment">// 结果是true，file1不存在hello，file2多了hi，文件内容还是hello的，只是改名了</span></span><br><span class="line">    <span class="keyword">boolean</span> renameTo = file1.renameTo(file2);</span><br><span class="line">    System.out.println(renameTo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>File类的判断功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">()</span>：判断是否是文件目录</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span> ：判断是否是文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span> ：判断是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRead</span><span class="params">()</span> ：判断是否可读</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">()</span> ：判断是否可写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHidden</span><span class="params">()</span> ：判断是否隐藏</span></span><br></pre></td></tr></table></figure>

<p>File类的创建功能：硬盘中文件的创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">createNewFile</span><span class="params">()</span> ：创建文件。若文件存在，则不创建，返回<span class="keyword">false</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mkdir</span><span class="params">()</span> ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mkdirs</span><span class="params">()</span> ：创建文件目录。如果上层文件目录不存在，一并创建</span></span><br></pre></td></tr></table></figure>

<p>注意事项：如果你创建文件或者文件目录没有写盘符路径，那么，默认在项目 路径下。</p>
<p>File类的删除功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span>：删除文件或者文件夹</span></span><br></pre></td></tr></table></figure>

<p>删除注意事项：</p>
<p>Java中的删除不走回收站。 要删除一个文件目录，请注意<strong>该文件目录内不能包含文件或者文件目录</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 文件的创建与删除</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!file.exists())&#123;</span><br><span class="line">        file.createNewFile();</span><br><span class="line">        System.out.println(<span class="string">&quot;创建成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        file.delete();</span><br><span class="line">        System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-IO流"><a href="#2-IO流" class="headerlink" title="2.IO流"></a>2.IO流</h2><p>输入input：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。</p>
<p>输出output：将程序（内存） 数据输出到磁盘、光盘等存储设备中。</p>
<p>分界是以内存为标准：进内存处理就是输入流、 出内存就是输出流。</p>
<p><strong>程序员从内存（程序）的角度来看是输入还是输出。</strong></p>
<p>最基本的流：4个抽象基类</p>
<table>
<thead>
<tr>
<th>(抽象基类)</th>
<th>字节流</th>
<th>字符流</th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td>InputStream</td>
<td>Reader</td>
</tr>
<tr>
<td>输出流</td>
<td>OutputStream</td>
<td>Writer</td>
</tr>
</tbody></table>
<p>字节流：Byte，字符流：char。字符流更适合处理文本文件。</p>
<p>流的分类</p>
<ol>
<li>操作数据单位：字节流、字符流</li>
<li>数据的流向：输入流、输出流</li>
<li>流的角色：节点流、处理流</li>
</ol>
<p><strong>流的体系结构</strong></p>
<p><img src="/posts/b0469d44/image-20210613133535194.png" alt="image-20210613133535194"></p>
<p><strong>说明：红框对应的是IO流中的4个抽象基类。</strong></p>
<p>蓝框的流需要大家重点关注。<strong>看到流的名字要明确它属于哪两种分类。</strong></p>
<ul>
<li>基本的四个抽象基类</li>
<li>文件的四个</li>
<li>缓冲的四个</li>
<li>转换的两个流<ul>
<li><code>BufferedReader br= new BufferedReader(new InputStreamReader(System.in));</code></li>
<li><code>BufferedWriter bw = new BufferedWriter(new OutStreamWriter(System.out));</code></li>
</ul>
</li>
</ul>
<p>关于节点流（文件流）和处理流：</p>
<p><img src="/posts/b0469d44/image-20210613134128610.png" alt="image-20210613134128610"></p>
<p><strong>重点说明的几个流：</strong></p>
<p>抽象基类         节点流（或文件流）                               缓冲流（处理流的一种）</p>
<ul>
<li>InputStream     FileInputStream   (read(byte[] buffer))        BufferedInputStream (read(byte[] buffer))</li>
<li>OutputStream    FileOutputStream  (write(byte[] buffer,0,len)  BufferedOutputStream (write(byte[] buffer,0,len) / flush()</li>
<li>Reader          FileReader (read(char[] cbuf))                 BufferedReader (read(char[] cbuf) / readLine())</li>
<li>Writer          FileWriter (write(char[] cbuf,0,len)           BufferedWriter (write(char[] cbuf,0,len) / flush()</li>
</ul>
<p>InputStream &amp; Reader</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">InputStream 和 Reader 是所有输入流的基类</span><br><span class="line">InputStream</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">read</span><span class="params">(byte[] b)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">read</span><span class="params">(byte[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">Reader</span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> [] c)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> [] c, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 程序中打开的文件 IO 资源不属于内存里的资源，垃圾回收机制无法回收该资</span></span></span><br><span class="line">源，所以应该显式关闭文件 IO 资源</span><br><span class="line"></span><br><span class="line"><span class="comment">// FileInputStream 从文件系统中的某个文件中获得输入字节。FileInputStream</span></span><br><span class="line">用于读取非文本数据之类的原始字节流。要读取字符流，需要使用 FileReader</span><br></pre></td></tr></table></figure>

<p><img src="/posts/b0469d44/image-20210725074959543.png" alt="image-20210725074959543"></p>
<p><img src="/posts/b0469d44/image-20210725075010681.png" alt="image-20210725075010681"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO流</tag>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（十一）</title>
    <url>/posts/a2f332aa.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-类的结构：代码块（初始化块）"><a href="#1-类的结构：代码块（初始化块）" class="headerlink" title="1.类的结构：代码块（初始化块）"></a>1.类的结构：代码块（初始化块）</h2><ol>
<li>代码块的作用：用来初始化类、对象的信息</li>
<li>分类：静态代码块 VS 非静态代码块</li>
<li>代码块要是使用修饰符，只能使用static</li>
</ol>
<span id="more"></span>

<p>静态代码块：</p>
<ul>
<li><p>内部可以输出语句</p>
</li>
<li><p>随着<strong>类的加载而执行</strong>,而且只执行一次</p>
</li>
<li><p>作用：初始化类的信息</p>
</li>
<li><p>静态方法也随着类的加载而加载，但是不执行</p>
</li>
<li><p>如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行</p>
</li>
<li><p>静态代码块的执行要优先于非静态代码块的执行</p>
</li>
<li><p>静态代码块内只能调用静态的属性、静态的方法，<strong>不能</strong>调用<strong>非静态</strong>的结构</p>
</li>
</ul>
<p>非静态代码块：</p>
<ul>
<li>内部可以输出语句</li>
<li>随着<strong>对象的创建</strong>而执行</li>
<li>每创建一个对象，就执行一次非静态代码块</li>
<li>作用：可以在创建对象时，对对象的属性等进行初始化</li>
<li>如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行</li>
<li>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</li>
</ul>
<p><img src="/posts/a2f332aa/image-20210502102003114.png" alt="image-20210502102003114"></p>
<p><img src="/posts/a2f332aa/image-20210502102122061.png" alt="image-20210502102122061"></p>
<p><strong>总结：由父及子，静态先行。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">成员变量赋值顺序</span><br><span class="line"> * ①默认初始化</span><br><span class="line"> * ②显式初始化/⑤在代码块中赋值，看先后顺序</span><br><span class="line"> * ③构造器中初始化</span><br><span class="line"> * ④有了对象以后，可以通过<span class="string">&quot;对象.属性&quot;</span>或<span class="string">&quot;对象.方法&quot;</span>的方式，进行赋值</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * 执行的先后顺序：① - ② / ⑤ - ③ - ④</span><br></pre></td></tr></table></figure>

<h2 id="2-抽象类的应用：模板方法设计模式"><a href="#2-抽象类的应用：模板方法设计模式" class="headerlink" title="2.抽象类的应用：模板方法设计模式"></a>2.抽象类的应用：模板方法设计模式</h2><p><img src="/posts/a2f332aa/image-20210502105438764.png" alt="image-20210502105438764"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SubTemplate t = <span class="keyword">new</span> SubTemplate();</span><br><span class="line">        t.spendTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板方法设计模式的一个应用案例</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span></span>&#123;</span><br><span class="line">    <span class="comment">// 计算某段代码执行时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spendTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        code(); <span class="comment">// 不确定部分</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间是：&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubTemplate</span> <span class="keyword">extends</span> <span class="title">Template</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">1000</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> isFlag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>;j &lt;= Math.sqrt(i);j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i % j == <span class="number">0</span>)&#123;</span><br><span class="line">                    isFlag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isFlag)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-时间日期API"><a href="#3-时间日期API" class="headerlink" title="3.时间日期API"></a>3.时间日期API</h2><p><img src="/posts/a2f332aa/image-20210502150445942.png" alt="image-20210502150445942"></p>
<p><img src="/posts/a2f332aa/image-20210502151051302.png" alt="image-20210502151051302"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JunitTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// JDK8之前的日期和时间API</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//返回1970年XXX到现在的时间差，时间戳形式</span></span><br><span class="line">        System.out.println(start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//构造器1：Date()，对应当前时间的Date对象</span></span><br><span class="line">        Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(date1.toString());</span><br><span class="line">        System.out.println(date1.getTime());<span class="comment">// 返回毫秒数,时间戳</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造器2：Date(long Date)</span></span><br><span class="line">        Date date2 = <span class="keyword">new</span> Date(<span class="number">1619941526721L</span>);<span class="comment">//记得加L</span></span><br><span class="line">        System.out.println(date2.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建java.sql.Date对象，它是java.util.Date的子类</span></span><br><span class="line">        java.sql.Date date3 = <span class="keyword">new</span> java.sql.Date(<span class="number">1619941526721L</span>);</span><br><span class="line">        System.out.println(date3.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将java.util.Date对象转换为java.sql.Date对象</span></span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        Date date4 = <span class="keyword">new</span> java.sql.Date(<span class="number">1619941526721L</span>);</span><br><span class="line">        java.sql.Date date5 = (java.sql.Date) date4;</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        Date date6 = <span class="keyword">new</span> Date();</span><br><span class="line">        java.sql.Date date7 = <span class="keyword">new</span> java.sql.Date(date6.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-java-text-SimpleDataFormat类"><a href="#4-java-text-SimpleDataFormat类" class="headerlink" title="4.java.text.SimpleDataFormat类"></a>4.java.text.SimpleDataFormat类</h2><p>SimpleDateFormat对日期Date类的格式化和解析</p>
<ul>
<li>两个操作<ul>
<li>格式化：日期 —&gt;字符串</li>
<li>解析：格式化的逆过程，字符串 —&gt; 日期</li>
</ul>
</li>
<li>SimpleDateFormat的实例化:new + 构造器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat sdf1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">//格式化</span></span><br><span class="line">String format1 = sdf1.format(date);</span><br><span class="line">System.out.println(format1);<span class="comment">//2019-02-18 11:48:27</span></span><br><span class="line"><span class="comment">//解析:要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现),</span></span><br><span class="line"><span class="comment">//否则，抛异常</span></span><br><span class="line">Date date2 = sdf1.parse(<span class="string">&quot;2020-02-18 11:48:27&quot;</span>);</span><br><span class="line">System.out.println(date2);</span><br></pre></td></tr></table></figure>

<h2 id="5-Calendar类：日历类、抽象类"><a href="#5-Calendar类：日历类、抽象类" class="headerlink" title="5.Calendar类：日历类、抽象类"></a>5.Calendar类：日历类、抽象类</h2><p>它是抽象类，所以不能实例化。</p>
<p><img src="/posts/a2f332aa/image-20210502160622844.png" alt="image-20210502160622844"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCalendar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//实例化</span></span><br><span class="line">        <span class="comment">//1.创建子类GregorianCalendar的对象</span></span><br><span class="line">        <span class="comment">//2.调用其静态方法getInstance()，方便记忆</span></span><br><span class="line">        Calendar calendar = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//常用方法</span></span><br><span class="line">        <span class="comment">//get方法获取常用的属性信息</span></span><br><span class="line">        <span class="keyword">int</span> days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(days);</span><br><span class="line">        System.out.println(calendar.get(Calendar.DAY_OF_WEEK));</span><br><span class="line">        <span class="comment">//set修改信息</span></span><br><span class="line">        calendar.set(Calendar.DAY_OF_MONTH,<span class="number">19</span>);</span><br><span class="line">        <span class="keyword">int</span> day = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(day);</span><br><span class="line">        <span class="comment">//add追加信息</span></span><br><span class="line">        calendar.add(Calendar.DAY_OF_MONTH,<span class="number">2</span>);</span><br><span class="line">        day = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(day);</span><br><span class="line">        <span class="comment">//getTime():日历类---&gt;Date</span></span><br><span class="line">        Date date = calendar.getTime();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">        <span class="comment">//setTime():Date---&gt;日历类</span></span><br><span class="line">        Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">        calendar.setTime(date1);</span><br><span class="line">        System.out.println(calendar.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（十三）</title>
    <url>/posts/dffb7d20.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-BigInteger类和BigDecimal类"><a href="#1-BigInteger类和BigDecimal类" class="headerlink" title="1.BigInteger类和BigDecimal类"></a>1.BigInteger类和BigDecimal类</h2><p><img src="/posts/dffb7d20/image-20210502211408301.png" alt="image-20210502211408301"></p>
<span id="more"></span>

<p><img src="/posts/dffb7d20/image-20210502211423255.png" alt="image-20210502211423255"></p>
<p><img src="/posts/dffb7d20/image-20210502211432078.png" alt="image-20210502211432078"></p>
<h2 id="2-枚举类的使用"><a href="#2-枚举类的使用" class="headerlink" title="2.枚举类的使用"></a>2.枚举类的使用</h2><p>JDK1.5之前自定义枚举类了解就行。</p>
<ul>
<li><p>重点掌握JDK1.5的新特性，enum关键字定义枚举类。</p>
</li>
<li><p>类的对象只有有限个，确定的。</p>
</li>
<li><p>当需要定义一组常量时，强烈建议使用枚举类。</p>
</li>
<li><p>若枚举只有一个对象 , 则可以作为一种<strong>单例模式</strong>的实现方式。</p>
</li>
</ul>
<p><img src="/posts/dffb7d20/image-20210503090139873.png" alt="image-20210503090139873"></p>
<p>看看就行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//enum关键字定义枚举类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeasonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Season summer = Season.SUMMER;</span><br><span class="line">        System.out.println(summer);<span class="comment">//SUMMER，无需重写toString</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义的枚举类默认继承于java.lang.Enum类</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season</span></span>&#123;</span><br><span class="line">    <span class="comment">//提供当前枚举类的对象，之间用&quot;,&quot;隔开，&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>),<span class="comment">//默认为private final</span></span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>);</span><br><span class="line">    <span class="comment">//声明Season对象的四有属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="comment">//私有化类的构造器，并给属性赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他诉求，获取对象属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/dffb7d20/image-20210503091556341.png" alt="image-20210503091556341"></p>
<p><img src="/posts/dffb7d20/image-20210503091617899.png" alt="image-20210503091617899"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Season[] values = Season.values();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; values.length;i++)&#123;</span><br><span class="line">        System.out.println(values[i].toString());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;____________________________&quot;</span>);</span><br><span class="line">    <span class="comment">//valueOf(String objname)，返回枚举类中对象名是objname的对象</span></span><br><span class="line">    Season winter = Season.valueOf(<span class="string">&quot;WINTER&quot;</span>);</span><br><span class="line">    System.out.println(winter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*SPRING</span></span><br><span class="line"><span class="comment">SUMMER</span></span><br><span class="line"><span class="comment">AUTUMN</span></span><br><span class="line"><span class="comment">WINTER</span></span><br><span class="line"><span class="comment">____________________________</span></span><br><span class="line"><span class="comment">WINTER*/</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/dffb7d20/image-20210503092548552.png" alt="image-20210503092548552"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个枚举值分别实现同一个接口方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeasonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Season season1 = Season.SUMMER;</span><br><span class="line">        Season season2 = Season.SPRING;</span><br><span class="line">        Season season3 = Season.AUTUMN;</span><br><span class="line">        season1.show();</span><br><span class="line">        season2.show();</span><br><span class="line">        season3.show();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*summer</span></span><br><span class="line"><span class="comment">spring</span></span><br><span class="line"><span class="comment">autumn*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义的枚举类默认继承于java.lang.Enum类</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season</span> <span class="keyword">implements</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="comment">//提供当前枚举类的对象，之间用&quot;,&quot;隔开，&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;spring&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;summer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;autumn&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;winter&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//声明Season对象的四有属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="comment">//私有化类的构造器，并给属性赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他诉求，获取对象属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-注解-Annotation）"><a href="#3-注解-Annotation）" class="headerlink" title="3.注解 (Annotation）"></a>3.注解 (Annotation）</h2><p><img src="/posts/dffb7d20/image-20210503093537140.png" alt="image-20210503093537140"></p>
<p>一定程度上可以说： <strong>框架 = 注解 + 反射 + 设计模式</strong>。</p>
<p><img src="/posts/dffb7d20/image-20210503093702587.png" alt="image-20210503093702587"></p>
<p><strong>自定义Annotation</strong>：</p>
<p><img src="/posts/dffb7d20/image-20210503094509895.png" alt="image-20210503094509895"></p>
<p><img src="/posts/dffb7d20/image-20210503094431440.png" alt="image-20210503094431440"></p>
<p>没有成员定义的 Annotation 称为 <strong>标记</strong> ，包含成员变量的 Annotation 称为<strong>元数据</strong> Annotation</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注解声明为@interface</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">//内部定义成员，通常使用value表示</span></span><br><span class="line">    <span class="comment">//可以指定成员的默认值，使用default定义</span></span><br><span class="line">    <span class="comment">//自定义注解必须使用反射才有意义</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;string&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>元注解：注解其他注解的注解</p>
<p><img src="/posts/dffb7d20/image-20210503095742361.png" alt="image-20210503095742361"></p>
<p><img src="/posts/dffb7d20/image-20210503095819473.png" alt="image-20210503095819473"></p>
<p>默认为CLASS。<img src="/posts/dffb7d20/image-20210503095906860.png" alt="image-20210503095906860"></p>
<p><img src="/posts/dffb7d20/image-20210503095953225.png" alt="image-20210503095953225"></p>
<p><strong>自定义注解一般会指明以上两个元注解：Retention、Target。</strong></p>
<p>下面两个用到频率较低。</p>
<p><img src="/posts/dffb7d20/image-20210503100238905.png" alt="image-20210503100238905"></p>
<p>Java 8对注解处理提供了两点改进： <strong>可重复的注解</strong> 及 <strong>可用于类型的注解</strong> 。此外，反射也得到了加强，在 </p>
<p>Java8 中能够得到方法参数的名称。这会简化标注在方法参数上的注解。</p>
<p><img src="/posts/dffb7d20/image-20210503101428719.png" alt="image-20210503101428719"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（十九）</title>
    <url>/posts/3de09458.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-缓冲流（处理流的一种）"><a href="#1-缓冲流（处理流的一种）" class="headerlink" title="1.缓冲流（处理流的一种）"></a>1.缓冲流（处理流的一种）</h2><p>缓冲流也就是对4个文件（文本）流的包装。</p>
<p>目的：提高文件的读写效率，内部提供了一个缓冲区。</p>
<span id="more"></span>

<p>缓冲流涉及到的类：</p>
<p>BufferedInputStream</p>
<p>BufferedOutputStream</p>
<p>BufferedReader</p>
<p>BufferedWriter</p>
<p>使用BufferedInputStream和BufferedOutputStream:处理非文本文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现文件复制</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">    BufferedOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.造文件</span></span><br><span class="line">        File srcfile = <span class="keyword">new</span> File(<span class="string">&quot;miku.png&quot;</span>);</span><br><span class="line">        File destfile = <span class="keyword">new</span> File(<span class="string">&quot;test.png&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.造流：先造节点流，再造缓冲流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(srcfile);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(destfile);</span><br><span class="line">        bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">        bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line">        <span class="comment">// 3.复制过程</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 4.流的关闭</span></span><br><span class="line">        <span class="comment">//说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bis != <span class="keyword">null</span>)</span><br><span class="line">                bis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bos != <span class="keyword">null</span>)</span><br><span class="line">                    bos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用BufferedReader和BufferedWriter：处理文本文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">    BufferedWriter bw = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 一步到位</span></span><br><span class="line">        br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(<span class="string">&quot;hao.txt&quot;</span>)));</span><br><span class="line">        bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读写操作</span></span><br><span class="line">        <span class="comment">// 方式1：使用char数组</span></span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = br.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line">            bw.flush();<span class="comment">// 刷新缓冲区</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式2：使用String</span></span><br><span class="line">        String data;</span><br><span class="line">        <span class="keyword">while</span> ((data = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 方法1</span></span><br><span class="line">            bw.write(data+<span class="string">&quot;\n&quot;</span>);<span class="comment">// data中不包含换行符</span></span><br><span class="line">            <span class="comment">// 方法2</span></span><br><span class="line">            <span class="comment">//bw.write(data);</span></span><br><span class="line">            <span class="comment">//bw.newLine();//提供换行的操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 关闭流</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (br != <span class="keyword">null</span>)</span><br><span class="line">                br.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bw != <span class="keyword">null</span>)</span><br><span class="line">                    bw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-转换流（处理流的一种）"><a href="#2-转换流（处理流的一种）" class="headerlink" title="2.转换流（处理流的一种）"></a>2.转换流（处理流的一种）</h2><p>转换流提供了在字节流和字符流之间的转换。</p>
<p>作用：处理文件乱码问题，实现编码和解码功能。</p>
<p>InputStreamReader：将一个字节的输入流转换为字符的输入流</p>
<p>解码：字节、字节数组 —&gt;字符数组、字符串</p>
<p>OutputStreamWriter：将一个字符的输出流转换为字节的输出流</p>
<p>编码：字符数组、字符串 —&gt; 字节、字节数组</p>
<p>这两个流都属于字符流。（看后缀）</p>
<p>说白了。看下图，就是为了使用字符流处理字节流</p>
<p><img src="/posts/3de09458/image-20210725104835755.png" alt="image-20210725104835755"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// InputStreamReader的解码示例</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    InputStreamReader isr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;hao.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 第2个参数可以省略，IDEA默认为UTF-8，文件才用UTF-8保存，所以用它解码</span></span><br><span class="line">        isr = <span class="keyword">new</span> InputStreamReader(fis,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = isr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            String str = <span class="keyword">new</span> String(cbuf,<span class="number">0</span>,len);</span><br><span class="line">            System.out.print(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isr != <span class="keyword">null</span>)</span><br><span class="line">                isr.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 综合使用InputStreamReader和OutputStreamWriter</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    InputStreamReader isr = <span class="keyword">null</span>;</span><br><span class="line">    OutputStreamWriter osw = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        File file1 = <span class="keyword">new</span> File(<span class="string">&quot;hao.txt&quot;</span>);</span><br><span class="line">        File file2 = <span class="keyword">new</span> File(<span class="string">&quot;hao_GBK.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file1);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file2);</span><br><span class="line"></span><br><span class="line">        isr = <span class="keyword">new</span> InputStreamReader(fis,<span class="string">&quot;utf-8&quot;</span>);<span class="comment">// 解码</span></span><br><span class="line">        osw = <span class="keyword">new</span> OutputStreamWriter(fos,<span class="string">&quot;gbk&quot;</span>);<span class="comment">// 编码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = isr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            osw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isr != <span class="keyword">null</span>)</span><br><span class="line">                isr.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (osw != <span class="keyword">null</span>)</span><br><span class="line">                    osw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-其他流的使用（了解内容）"><a href="#3-其他流的使用（了解内容）" class="headerlink" title="3.其他流的使用（了解内容）"></a>3.其他流的使用（了解内容）</h2><p>3.1标准输入、输出流（处理流的一种）</p>
<p>System.in:标准的输入流，默认从键盘输入</p>
<p>System.out:标准的输出流，默认从控制台输出</p>
<p>和后续的打印流和数据流一起作为了解内容。</p>
<p>后面只有对象流是需要重点掌握的。</p>
<p>3.2打印流<br>        PrintStream 和PrintWriter</p>
<p>提供了一系列重载的print()和println()方法，用于多种数据类型的输出</p>
<p>System.out返回的是PrintStream的实例</p>
<p>3.3数据流<br>        DataInputStream 和 DataOutputStream</p>
<p>作用：用于读取或写出基本数据类型的变量或字符串</p>
<h2 id="4-对象流（处理流的一种）"><a href="#4-对象流（处理流的一种）" class="headerlink" title="4.对象流（处理流的一种）"></a>4.对象流（处理流的一种）</h2><p>对象流：<br>ObjectInputStream 和 ObjectOutputStream</p>
<p>作用：<br>ObjectOutputStream:内存中的对象—&gt;存储中的文件、通过网络传输出去：序列化过程<br>ObjectInputStream:存储中的文件、通过网络接收过来 —&gt;内存中的对象：反序列化过程</p>
<p>对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。//当其它程序获取了这种二进制流，就可以恢复成原来的Java对象。</p>
<p>Java对象要求可序列化才能进行序列化和反序列化过程。</p>
<p>String对象和自定义Person对象的序列化与反序列化示例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 通过ObjectOutputStream实现序列化过程</span></span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line"></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> String(<span class="string">&quot;high quality man&quot;</span>));</span><br><span class="line">        oos.flush();<span class="comment">// 刷新操作</span></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> Person(<span class="number">23</span>,<span class="string">&quot;xuqingen&quot;</span>));</span><br><span class="line">        oos.flush();<span class="comment">// 刷新操作，每写出一次就需要刷新一次</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (oos != <span class="keyword">null</span>)</span><br><span class="line">                oos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -------------</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 通过ObjectInputStream实现反序列化过程</span></span><br><span class="line">    ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        String str = (String) obj;</span><br><span class="line">        System.out.println(str);</span><br><span class="line"></span><br><span class="line">        Person p = (Person) ois.readObject();</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ois != <span class="keyword">null</span>)</span><br><span class="line">                ois.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2352466735L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是 可序列化的，该类必须实现如下两个接口之一。<br>否则，会抛出 NotSerializableException 异常。<br>Serializable（通常会选这个）<br>Externalizable</p>
<p>实现序列化的对象所属的类需要满足</p>
<ol>
<li>需要实现接口：Serializable</li>
<li>当前类提供一个全局常量：serialVersionUID（随便写，没有严格要求）</li>
<li>除了当前Person类需要实现Serializable接口之外，还必须保证其内部所属性也必须是可序列化的。（默认情况下，基本数据类型可序列化）</li>
</ol>
<p>补充：ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量</p>
<p><img src="/posts/3de09458/image-20210726095040084.png" alt="image-20210726095040084"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO流</tag>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（十二）</title>
    <url>/posts/92e5de72.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-JDK8中新日期时间API"><a href="#1-JDK8中新日期时间API" class="headerlink" title="1.JDK8中新日期时间API"></a>1.JDK8中新日期时间API</h2><p>日期时间API的迭代</p>
<p>第一代：jdk 1.0 Date类</p>
<p>第二代：jdk 1.1 Calendar类，一定程度上替换Date类</p>
<p>第三代：jdk 1.8 提出了新的一套API</p>
<p>前两代存在的问题举例</p>
<p>可变性：像日期和时间这样的类应该是不可变的。</p>
<p>偏移性：Date中的年份是从1900开始的，而月份都从0开始。</p>
<p>格式化：格式化只对Date用，Calendar则不行。</p>
<p>此外，它们也不是线程安全的；不能处理闰秒等。</p>
<span id="more"></span>

<p><img src="/posts/92e5de72/image-20210502163607157.png" alt="image-20210502163607157"></p>
<p><img src="/posts/92e5de72/image-20210502164631141.png" alt="image-20210502164631141"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">APITest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// LocalDate、LocalTime、LocalDateTime的使用</span></span><br><span class="line">        LocalDate localdate = LocalDate.now();<span class="comment">//根基当前时间创建对象</span></span><br><span class="line">        LocalTime localtime = LocalTime.now();</span><br><span class="line">        <span class="comment">//LocalDateTime用的较多</span></span><br><span class="line">        LocalDateTime localdatetime = LocalDateTime.now();</span><br><span class="line">        System.out.println(localdate);</span><br><span class="line">        System.out.println(localtime);</span><br><span class="line">        System.out.println(localdatetime);</span><br><span class="line">        <span class="comment">//根据指定时间创建对象</span></span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.of(<span class="number">2021</span>,<span class="number">3</span>,<span class="number">31</span>,<span class="number">15</span>,<span class="number">25</span>,<span class="number">45</span>);</span><br><span class="line">        System.out.println(localDateTime);</span><br><span class="line">        <span class="comment">//getXxx()获取对象信息</span></span><br><span class="line">        System.out.println(localDateTime.getDayOfMonth());</span><br><span class="line">        System.out.println(localDateTime.getDayOfWeek());</span><br><span class="line">        System.out.println(localDateTime.getMonth());</span><br><span class="line">        System.out.println(localDateTime.getMonthValue());</span><br><span class="line">        <span class="comment">//withXxx()修改信息并返回新的对象，体现不可变性</span></span><br><span class="line">        LocalDate localDate = localdate.withDayOfMonth(<span class="number">4</span>);</span><br><span class="line">        System.out.println(localDate);</span><br><span class="line">        System.out.println(localdate);</span><br><span class="line">        <span class="comment">//plusXxx(),minusXxx()对当前对象加减相应时间，体现不可变性</span></span><br><span class="line">        LocalDateTime localDateTime1 = localDateTime.plusDays(<span class="number">12</span>);</span><br><span class="line">        System.out.println(localDateTime);</span><br><span class="line">        System.out.println(localDateTime1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/92e5de72/image-20210502193652086.png" alt="image-20210502193652086"></p>
<p>Instant类，时间戳。</p>
<p><img src="/posts/92e5de72/image-20210502193732034.png" alt="image-20210502193732034"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">APITest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//now()获取本初子午线对应的标准时间</span></span><br><span class="line">        Instant instant = Instant.now();</span><br><span class="line">        System.out.println(instant);</span><br><span class="line">        <span class="comment">//2021-05-02T11:41:52.974Z</span></span><br><span class="line">        <span class="comment">//添加时间偏移量</span></span><br><span class="line">        OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(<span class="number">5</span>));</span><br><span class="line">        System.out.println(offsetDateTime);</span><br><span class="line">        <span class="comment">//2021-05-02T16:41:52.974+05:00</span></span><br><span class="line">        <span class="comment">//获取自1970年对应的毫秒数</span></span><br><span class="line">        <span class="keyword">long</span> milli = instant.toEpochMilli();</span><br><span class="line">        System.out.println(milli);</span><br><span class="line">        <span class="comment">//返回毫秒数对应的Instant对象</span></span><br><span class="line">        Instant instant1 = Instant.ofEpochMilli(<span class="number">1619956303369L</span>);</span><br><span class="line">        System.out.println(instant1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/92e5de72/image-20210502195424494.png" alt="image-20210502195424494"></p>
<h2 id="2-Java比较器（重要）"><a href="#2-Java比较器（重要）" class="headerlink" title="2.Java比较器（重要）"></a>2.Java比较器（重要）</h2><p>利用比较器对多个对象进行排序。</p>
<p>Java 实现对象排序的方式有两种：</p>
<ul>
<li><p>自然排序： java.lang.Comparable</p>
</li>
<li><p>定制排序： java.util.Comparator</p>
</li>
</ul>
<p><img src="/posts/92e5de72/image-20210502201039171.png" alt="image-20210502201039171"></p>
<p>重写compareTo()方法的<strong>一般规则</strong>如上图蓝色字体。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String name, <span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Goods&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//指明排序方,价格从低到高排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">            Goods goods = (Goods)o;</span><br><span class="line">            <span class="comment">//方法1</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.price &gt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.price &lt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//涉及到String类和包装类的比较建议就直接用实现好的方法</span></span><br><span class="line">            <span class="comment">//方法2，包装类中的compare</span></span><br><span class="line">            <span class="comment">//return Integer.compare(this.price,goods.price);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;传入的数据类型不一致！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompareTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Comparable接口的使用举例</span></span><br><span class="line">        <span class="comment">//像String、包装类等实现了Comparable接口，重写了compareTo()方法</span></span><br><span class="line">        <span class="comment">//给出了比较两个对象大小的方式</span></span><br><span class="line">        String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;As&quot;</span>,<span class="string">&quot;cd&quot;</span>,<span class="string">&quot;sd1&quot;</span>,<span class="string">&quot;12&quot;</span>&#125;;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        <span class="comment">//自定义类实现Comparable接口</span></span><br><span class="line">        <span class="comment">//在compareTo(obj)指明如何排序</span></span><br><span class="line">        Goods[] goods = <span class="keyword">new</span> Goods[<span class="number">4</span>];</span><br><span class="line">        goods[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;xiaomi&quot;</span>,<span class="number">19</span>);</span><br><span class="line">        goods[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;lenovo&quot;</span>,<span class="number">25</span>);</span><br><span class="line">        goods[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;apple&quot;</span>,<span class="number">199</span>);</span><br><span class="line">        goods[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;dell&quot;</span>,<span class="number">35</span>);</span><br><span class="line">        Arrays.sort(goods);</span><br><span class="line">        System.out.println(Arrays.toString(goods));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*[12, As, cd, sd1]</span></span><br><span class="line"><span class="comment">[Goods&#123;name=&#x27;xiaomi&#x27;, price=19&#125;, Goods&#123;name=&#x27;lenovo&#x27;, price=25&#125;, Goods&#123;name=&#x27;dell&#x27;, price=35&#125;, Goods&#123;name=&#x27;apple&#x27;, price=199&#125;]*/</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/92e5de72/image-20210502204316839.png" alt="image-20210502204316839"></p>
<p>接上面例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompareTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;As&quot;</span>,<span class="string">&quot;cd&quot;</span>,<span class="string">&quot;sd1&quot;</span>,<span class="string">&quot;12&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//从大到小排序</span></span><br><span class="line">        Arrays.sort(arr,<span class="keyword">new</span> Comparator())&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1,Object o2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> String &amp;&amp; o2 <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">                    String s1 = (String)o1;</span><br><span class="line">                    String s2 = (String)o2;</span><br><span class="line">                    <span class="keyword">return</span> -s1.compareTo(s2);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;传入的数据类型不一致！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        Goods[] goods = <span class="keyword">new</span> Goods[<span class="number">4</span>];</span><br><span class="line">        goods[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;xiaomi&quot;</span>,<span class="number">19</span>);</span><br><span class="line">        goods[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;lenovo&quot;</span>,<span class="number">25</span>);</span><br><span class="line">        goods[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;xiaomi&quot;</span>,<span class="number">199</span>);</span><br><span class="line">        goods[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;dell&quot;</span>,<span class="number">35</span>);</span><br><span class="line">        <span class="comment">//先按名称从低到高，再按价格从高到低排序</span></span><br><span class="line">        Arrays.sort(goods,<span class="keyword">new</span> Comparator()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1,Object o2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Goods &amp;&amp; o2 <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">                    Goods g1 = (Goods)o1;</span><br><span class="line">                    Goods g2 = (Goods)o2;</span><br><span class="line">                    <span class="keyword">if</span> (g1.getName().equals(g2.getName()))&#123;</span><br><span class="line">                        <span class="keyword">return</span> -Integer.compare(g1.getPrice(),g2.getPrice());</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> g1.getName().compareTo(g2.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;传入的数据类型不一致！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(goods));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*[sd1, cd, As, 12]</span></span><br><span class="line"><span class="comment">[Goods&#123;name=&#x27;dell&#x27;, price=35&#125;, Goods&#123;name=&#x27;lenovo&#x27;, price=25&#125;, Goods&#123;name=&#x27;xiaomi&#x27;, price=199&#125;, Goods&#123;name=&#x27;xiaomi&#x27;, price=19&#125;]*/</span></span><br></pre></td></tr></table></figure>

<p>比较</p>
<ul>
<li>Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小。</li>
<li>Comparator接口属于临时性的比较。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（十五）</title>
    <url>/posts/748a102.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Collection子接口之二：Set接口"><a href="#1-Collection子接口之二：Set接口" class="headerlink" title="1.Collection子接口之二：Set接口"></a>1.Collection子接口之二：Set接口</h2><p>Set相比于List和Map来说实际用的较少。</p>
<p>Set 接口是 Collection 的子接口， set 接口没有提供额外的方法。</p>
<p>Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set 集合中，则添加操作失败。</p>
<p>Set 判断两个对象是否相同不是使用 == 运算符，而是 根据 equals() 方法。</p>
<span id="more"></span>

<p>Set 接口的实现类常用的有： <strong>HashSet、LinkedHashSet和TreeSet</strong> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">*          |----Set接口：存储无序的、不可重复的数据   --&gt;高中讲的“集合”</span><br><span class="line">*              |----HashSet：作为Set接口的主要实现类；线程不安全的；可以存储<span class="keyword">null</span>值</span><br><span class="line">*                  |----LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历</span><br><span class="line">*                 在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。                   对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</span><br><span class="line">*              |----TreeSet：可以照添加对象的指定属性，进行排序。</span><br></pre></td></tr></table></figure>

<p>HashSet最常用。</p>
<p><img src="/posts/748a102/image-20210612100053823.png" alt="image-20210612100053823"></p>
<p>以HashSet为例说明：</p>
<p><strong>Set的无序性并不等于随机性。</strong>遍历HashSet时不按照定义顺序，但还是有特定顺序。</p>
<p>这里的无序性是指Set的存储不像数组那样按顺序存储，而是分散的，存储位置由数据的hash值决定。</p>
<p>不可重复性：保证添加的元素照equals()判断时，不能返回true.即：相同的元素只能添加一个。</p>
<p><strong>元素添加过程：(以HashSet为例)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，</span><br><span class="line">此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置，判断</span><br><span class="line">数组此位置上是否已经元素：</span><br><span class="line">    如果此位置上没其他元素，则元素a添加成功。 ---&gt;情况<span class="number">1</span></span><br><span class="line">    如果此位置上其他元素b(或以链表形式存在的多个元素，则比较元素a与元素b的hash值：</span><br><span class="line">        如果hash值不相同，则元素a添加成功。---&gt;情况<span class="number">2</span></span><br><span class="line">        如果hash值相同，进而需要调用元素a所在类的equals()方法：</span><br><span class="line">               equals()返回<span class="keyword">true</span>,元素a添加失败</span><br><span class="line">               equals()返回<span class="keyword">false</span>,则元素a添加成功。---&gt;情况<span class="number">3</span></span><br><span class="line"></span><br><span class="line">对于添加成功的情况<span class="number">2</span>和情况<span class="number">3</span>而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。</span><br><span class="line">jdk <span class="number">7</span> :元素a放到数组中，指向原来的元素。</span><br><span class="line">jdk <span class="number">8</span> :原来的元素在数组中，指向元素a</span><br><span class="line">总结：七上八下</span><br><span class="line"></span><br><span class="line">HashSet底层：数组+链表的结构。（前提：jdk7）hash是数据结构中的知识</span><br></pre></td></tr></table></figure>

<p>hashCode方法就是用于计算hash值的。hash值分布越均匀说明hashCode函数设计的越好。</p>
<p>要求：向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和</p>
<p>equals()</p>
<p>要求：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码</p>
<ul>
<li>   重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。</li>
</ul>
<p><img src="/posts/748a102/image-20210612101425782.png" alt="image-20210612101425782"></p>
<p>LinkedHashSet在添加数据的同时，每个数据还维护了2个引用，记录此数据的前一个数据和后一个数据。</p>
<p>优点：对于频繁的遍历操作，它的效率比HashSet高。</p>
<p><strong>TreeSet:</strong></p>
<p>它的一个重要用途就是排序。按照添加对象的指定属性进行排序。</p>
<p>TreeSet中添加的数据要求是<strong>相同类的对象</strong>。</p>
<p>TreeSet 两种排序方法： 自然排序（实现Comparable接口）  和 定制排序（实现Comparator接口） 。默认</p>
<p>情况下， TreeSet 采用自然排序。</p>
<p>自然排序中，TreeSet比较两个对象是否相同的标准：compareTo方法返回0，不再根据equals方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自然排序</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Set set = <span class="keyword">new</span> TreeSet();</span><br><span class="line">    set.add(<span class="number">1</span>);</span><br><span class="line">    set.add(<span class="number">24</span>);</span><br><span class="line">    set.add(-<span class="number">34</span>);</span><br><span class="line">    set.add(<span class="number">3</span>);</span><br><span class="line">    Iterator ite = set.iterator();</span><br><span class="line">    <span class="keyword">while</span> (ite.hasNext())&#123;<span class="comment">// 按照从小到大的顺序输出</span></span><br><span class="line">        <span class="comment">// String也是一样的</span></span><br><span class="line">        System.out.println(ite.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set s = <span class="keyword">new</span> TreeSet();</span><br><span class="line">    s.add(<span class="keyword">new</span> Person(<span class="string">&quot;ad&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    s.add(<span class="keyword">new</span> Person(<span class="string">&quot;kg&quot;</span>,<span class="number">23</span>));</span><br><span class="line">    s.add(<span class="keyword">new</span> Person(<span class="string">&quot;ki&quot;</span>,<span class="number">6</span>));</span><br><span class="line">    s.add(<span class="keyword">new</span> Person(<span class="string">&quot;bg&quot;</span>,<span class="number">43</span>));</span><br><span class="line"></span><br><span class="line">    Iterator iterator = s.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;<span class="comment">// 按照Person的姓名排序</span></span><br><span class="line">        <span class="comment">// 姓名一样只会出现第一个</span></span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Person.java*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">            Person p = (Person)o;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(p.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入类型不匹配&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用定制排序判断两个元素相等的标准是：通过 Comparator 比较两个元素返回了 0 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定制排序</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Comparator com = <span class="keyword">new</span> Comparator()&#123;</span><br><span class="line">        <span class="comment">// 按照年龄从小到大排序，两个年龄一样返回0，意味着只出现第一个</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1,Object o2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> Person &amp;&amp; o2 <span class="keyword">instanceof</span> Person )&#123;</span><br><span class="line">                Person p1 = (Person)o1;</span><br><span class="line">                Person p2 = (Person)o2;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(p1.getAge(),p2.getAge());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入的数据类型不匹配&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Set set = <span class="keyword">new</span> TreeSet(com);<span class="comment">// 传入参数com定制排序</span></span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="string">&quot;ad&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="string">&quot;kg&quot;</span>,<span class="number">23</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="string">&quot;ki&quot;</span>,<span class="number">6</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="string">&quot;bg&quot;</span>,<span class="number">43</span>));</span><br><span class="line">    Iterator ite = set.iterator();</span><br><span class="line">    <span class="keyword">while</span> (ite.hasNext())&#123;</span><br><span class="line">        System.out.println(ite.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Collection子接口之三：Map接口"><a href="#2-Collection子接口之三：Map接口" class="headerlink" title="2.Collection子接口之三：Map接口"></a>2.Collection子接口之三：Map接口</h2><p><img src="/posts/748a102/image-20210612111933894.png" alt="image-20210612111933894"></p>
<p>Map常用实现类的结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">|----Map:双列数据，存储key-value对的数据   ---类似于高中的函数：y = f(x)</span><br><span class="line">*       |----HashMap:作为Map的主要实现类；线程不安全的，效率高；存储<span class="keyword">null</span>的key和value</span><br><span class="line">*              |----LinkedHashMap:保证在遍历map元素时，可以照添加的顺序实现遍历。</span><br><span class="line">*                    原因：在原的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。</span><br><span class="line">*                    对于频繁的遍历操作，此类执行效率高于HashMap。</span><br><span class="line">*       |----TreeMap:保证照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序</span><br><span class="line">*                      底层使用红黑树</span><br><span class="line">*       |----Hashtable:作为古老的实现类；线程安全的，效率低；不能存储<span class="keyword">null</span>的key和value</span><br><span class="line">*              |----Properties:常用来处理配置文件。key和value都是String类型</span><br><span class="line">*</span><br><span class="line">*</span><br><span class="line">*      HashMap的底层：数组+链表  （jdk7及之前)</span><br><span class="line">*                    数组+链表+红黑树 （jdk <span class="number">8</span>)</span><br></pre></td></tr></table></figure>

<p>存储结构的理解:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;Map中的key:无序的、不可重复的，使用Set存储所的key  ---&gt; key所在的类要重写equals()和hashCode() （以HashMap为例)</span><br><span class="line">&gt;Map中的value:无序的、可重复的，使用Collection存储所的value ---&gt;value所在的类要重写equals()</span><br><span class="line">&gt; 一个键值对：key-value构成了一个Entry对象。</span><br><span class="line">&gt;Map中的entry:无序的、不可重复的，使用Set存储所的entry</span><br></pre></td></tr></table></figure>

<p><img src="/posts/748a102/image-20210612112947789.png" alt="image-20210612112947789"></p>
<p>HashMap和HashSet一样是无序的。</p>
<p>HashMap与LinkedHashMap的关系与HashSet与LinkedHashSet的关系类似，后者遍历输出顺序按照定义顺</p>
<p>序。</p>
<p><strong>常用方法:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 添加：put(Object key,Object value)</span><br><span class="line">* 删除：remove(Object key)</span><br><span class="line">* 修改：put(Object key,Object value)</span><br><span class="line">* 查询：get(Object key)</span><br><span class="line">* 长度：size()</span><br><span class="line">* 遍历：keySet() / values() / entrySet()</span><br></pre></td></tr></table></figure>

<p><img src="/posts/748a102/image-20210612113337366.png" alt="image-20210612113337366"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="keyword">null</span>,<span class="number">1</span>);</span><br><span class="line">map.put(<span class="number">12</span>,<span class="string">&quot;asd&quot;</span>);<span class="comment">// 增</span></span><br><span class="line">map.remove(<span class="number">12</span>);<span class="comment">// 删</span></span><br><span class="line">map.put(<span class="number">12</span>,<span class="string">&quot;awe&quot;</span>);<span class="comment">// 改</span></span><br><span class="line">System.out.println(map.get(<span class="number">12</span>));<span class="comment">// 查</span></span><br><span class="line"></span><br><span class="line">Map map1 = <span class="keyword">new</span> HashMap();</span><br><span class="line">map1.put(<span class="string">&quot;a&quot;</span>,<span class="number">12</span>);</span><br><span class="line">map1.put(<span class="string">&quot;b&quot;</span>,<span class="number">1</span>);</span><br><span class="line">map1.put(<span class="string">&quot;a&quot;</span>,<span class="number">11</span>);</span><br><span class="line">map.putAll(map1);</span><br><span class="line">System.out.println(map);</span><br><span class="line"></span><br><span class="line">map.clear();</span><br><span class="line">System.out.println(map);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历Map,Map没有迭代器</span></span><br><span class="line">Map map2 = <span class="keyword">new</span> HashMap();</span><br><span class="line">map2.put(<span class="string">&quot;a&quot;</span>,<span class="number">12</span>);</span><br><span class="line">map2.put(<span class="string">&quot;b&quot;</span>,<span class="number">1</span>);</span><br><span class="line">map2.put(<span class="string">&quot;c&quot;</span>,<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有的key，keySet()</span></span><br><span class="line">Set set = map2.keySet();</span><br><span class="line">Iterator iterator = set.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历所有的value，values()</span></span><br><span class="line">Collection values = map2.values();</span><br><span class="line">Iterator iterator1 = values.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator1.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator1.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历所有的key-value，entrySet(),entrySet集合中的元素都是entry</span></span><br><span class="line"><span class="comment">//映射关系的类型是 Map.Entry 类型，它是 Map 接口的内部接口</span></span><br><span class="line"><span class="keyword">for</span> (Object o : map2.entrySet()) &#123;</span><br><span class="line">    Map.Entry entry = (Map.Entry)o;</span><br><span class="line">    System.out.println(entry);<span class="comment">//a=12</span></span><br><span class="line">    System.out.println(entry.getKey()+<span class="string">&quot;--&gt;&quot;</span>+entry.getValue());<span class="comment">//a--&gt;12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>底层原理</strong></p>
<p>HashMap在jdk7中实现原理:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap map = <span class="keyword">new</span> HashMap():</span><br><span class="line">*      在实例化以后，底层创建了长度是<span class="number">16</span>的一维数组Entry[] table。</span><br><span class="line">*      ...可能已经执行过多次put...</span><br><span class="line">*      map.put(key1,value1):</span><br><span class="line">*      首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。</span><br><span class="line">*      如果此位置上的数据为空，此时的key1-value1添加成功。 ----情况<span class="number">1</span></span><br><span class="line">*      如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据的哈希值：</span><br><span class="line">*              如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。----情况<span class="number">2</span></span><br><span class="line">*              如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：</span><br><span class="line">*                      如果equals()返回<span class="keyword">false</span>:此时key1-value1添加成功。----情况<span class="number">3</span></span><br><span class="line">*                      如果equals()返回<span class="keyword">true</span>:使用value1替换value2。</span><br><span class="line">*</span><br><span class="line">*      补充：关于情况<span class="number">2</span>和情况<span class="number">3</span>：此时key1-value1和原来的数据以链表的方式存储。</span><br><span class="line">*</span><br><span class="line">*     在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的<span class="number">2</span>倍，并将原的数据复制过来。</span><br></pre></td></tr></table></figure>

<p>HashMap在jdk8中相较于jdk7在底层实现方面的不同:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">new</span> HashMap():底层没创建一个长度为<span class="number">16</span>的数组</span><br><span class="line"><span class="number">2.</span> jdk <span class="number">8</span>底层的数组是：Node[],而非Entry[]</span><br><span class="line"><span class="number">3.</span> 首次调用put()方法时，底层创建长度为<span class="number">16</span>的数组</span><br><span class="line"><span class="number">4.</span> jdk7底层结构：数组+链表。jdk8中底层结构：数组+链表+红黑树。</span><br><span class="line"><span class="number">4.1</span> 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）</span><br><span class="line"><span class="number">4.2</span> 当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; <span class="number">8</span> 且当前数组的长度 &gt; <span class="number">64</span>时，此时此索引位置上的所数据改为使用红黑树存储。</span><br></pre></td></tr></table></figure>

<p>LinkedHashMap的底层原理作为了解内容。</p>
<p><img src="/posts/748a102/image-20210612130347106.png" alt="image-20210612130347106"></p>
<p><strong>TreeMap:</strong></p>
<p><img src="/posts/748a102/image-20210612143329084.png" alt="image-20210612143329084"></p>
<p>TreeMap用到的还是比HashMap少。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向TreeMap中添加key-value，要求key必须是用一个类创建的对象</span></span><br><span class="line"><span class="comment">// 因为要按照key进行排序：自然排序 、定制排序</span></span><br><span class="line"><span class="comment">// 排序类似TreeSet</span></span><br><span class="line">TreeMap treemap = <span class="keyword">new</span> TreeMap();</span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;tom&quot;</span>,<span class="number">13</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;jordan&quot;</span>,<span class="number">43</span>);</span><br><span class="line">Person p3 = <span class="keyword">new</span> Person(<span class="string">&quot;jack&quot;</span>,<span class="number">27</span>);</span><br><span class="line">treemap.put(p1,<span class="number">48</span>);</span><br><span class="line">treemap.put(p2,<span class="number">78</span>);</span><br><span class="line">treemap.put(p3,<span class="number">75</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自然排序</span></span><br><span class="line">Set set = treemap.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Object o:set)&#123;</span><br><span class="line">    Map.Entry entry = (Map.Entry)o;</span><br><span class="line">    System.out.println(entry.getKey()+<span class="string">&quot;--&gt;&quot;</span>+entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定制排序</span></span><br><span class="line">TreeMap treeMap = <span class="keyword">new</span> TreeMap(<span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> Person &amp;&amp; o2 <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">            Person p1 = (Person)o1;</span><br><span class="line">            Person p2 = (Person)o2;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(p1.getAge(),p2.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入数据类型不匹配&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Person p4 = <span class="keyword">new</span> Person(<span class="string">&quot;tom&quot;</span>,<span class="number">13</span>);</span><br><span class="line">Person p5 = <span class="keyword">new</span> Person(<span class="string">&quot;jordan&quot;</span>,<span class="number">43</span>);</span><br><span class="line">Person p6 = <span class="keyword">new</span> Person(<span class="string">&quot;jack&quot;</span>,<span class="number">27</span>);</span><br><span class="line">treeMap.put(p4,<span class="number">48</span>);</span><br><span class="line">treeMap.put(p5,<span class="number">45</span>);</span><br><span class="line">treeMap.put(p6,<span class="number">56</span>);</span><br><span class="line"></span><br><span class="line">Set set1 = treeMap.keySet();</span><br><span class="line">Iterator iterator = set1.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Collections工具类"><a href="#3-Collections工具类" class="headerlink" title="3.Collections工具类"></a>3.Collections工具类</h2><p>常用方法：均为static方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">reverse(List)：反转 List 中元素的顺序</span><br><span class="line">shuffle(List)：对 List 集合元素进行随机排序</span><br><span class="line">sort(List)：根据元素的自然顺序对指定 List 集合元素升序排序</span><br><span class="line">sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</span><br><span class="line">swap(List，<span class="keyword">int</span>， <span class="keyword">int</span>)：将指定 list 集合中的 i 处元素和 j 处元素进行交换，i、j为下标索引</span><br><span class="line"><span class="function">Object <span class="title">max</span><span class="params">(Collection)</span>：根据元素的自然顺序，返回给定集合中的最大元素</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">Object <span class="title">max</span><span class="params">(Collection，Comparator)</span>：根据 Comparator 指定的顺序，返回给定集合中的最大元素</span></span><br><span class="line"><span class="function">Object <span class="title">min</span><span class="params">(Collection)</span></span></span><br><span class="line"><span class="function">Object <span class="title">min</span><span class="params">(Collection，Comparator)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection，Object)</span>：返回指定集合中指定元素的出现次数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List dest,List src)</span>：将src中的内容复制到dest中</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list，Object oldVal，Object newVal)</span>：使用新值替换 List 对象的所旧值</span></span><br><span class="line"><span class="function">eg.</span></span><br><span class="line"><span class="function">List list </span>= <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">add XXX</span><br><span class="line">Collections.reverse(list);</span><br><span class="line">特别说明copy方法，dest不能比src更小，标准写法如下：</span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">add XXX</span><br><span class="line">List dest = Arrays.asList(<span class="keyword">new</span> Object[list.size()]);<span class="comment">// 标准写法</span></span><br><span class="line">Collections.copy(dest,list);</span><br></pre></td></tr></table></figure>

<p>Collections 类中提供了多个 synchronizedXxx () 方法，该方法可使将指定集合包装成线程同步的集合，从而</p>
<p>可以解决多线程并发访问集合时的线程安全问题。</p>
<p>说明：ArrayList和HashMap都是线程不安全的，如果程序要求线程安全，我们可以将ArrayList、HashMap</p>
<p>转换为线程的。使用synchronizedList(List list） 和 synchronizedMap(Map map）。</p>
<p><code>List list1 = Collections.synchronizedList(list)</code>，返回的list1是线程安全的。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（十八）</title>
    <url>/posts/472db507.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>四个节点流：</strong></p>
<p><strong>FileReader使用。</strong></p>
<p>read初级方法，一个一个字符读入。</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FileReader fr = <span class="keyword">null</span>;<span class="comment">// 需要抛出异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.实例化File对象，指明要操作的文件</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.提供具体的流</span></span><br><span class="line">        fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">        <span class="comment">// 3.数据的读入</span></span><br><span class="line">        <span class="comment">// read()：返回读入的1个字符，达到文件末尾返回-1</span></span><br><span class="line">        <span class="comment">// 方式1</span></span><br><span class="line">        <span class="keyword">int</span> data = fr.read();</span><br><span class="line">        <span class="keyword">while</span> (data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)data);</span><br><span class="line">            data = fr.read();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 方式2</span></span><br><span class="line">        <span class="comment">//int data;</span></span><br><span class="line">        <span class="comment">//while ((data = fr.read()) != -1)&#123;</span></span><br><span class="line">        <span class="comment">//    System.out.println(data);</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 4.流的关闭操作</span></span><br><span class="line">            <span class="keyword">if</span> (fr != <span class="keyword">null</span>)</span><br><span class="line">                fr.close();<span class="comment">// 处理流关闭本身的异常</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了保证流资源一定可以执行关闭操作。需要使用try-catch-finally处理</span></span><br><span class="line">    <span class="comment">// 使用throws如果IO流已经创建，但是中途抛出异常导致流没有关闭可能造成内存泄漏</span></span><br><span class="line">    <span class="comment">// ctrl+alt+T，将选中代码用try-catch-finally包住</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>read重载方法，一次读入一个char数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 对read()操作升级，使用它的重载方法</span></span><br><span class="line">    FileReader fr = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.File类的实例化</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.FileReader类的实例化</span></span><br><span class="line">        fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">        <span class="comment">// 3.读入操作</span></span><br><span class="line">        <span class="comment">// read(char[] cbuf)：返回每次读入cbuf数组中的字符个数，如果达到文件末尾，返回-1</span></span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(cbuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 错误演示1：数组可能存在不能完全覆盖</span></span><br><span class="line">            <span class="comment">// 比如2次分别读入5、3个字符，第2次输出时会包括第1次的后2个字符</span></span><br><span class="line">            <span class="comment">//    for (int i = 0;i &lt; cbuf.length;i++)&#123;</span></span><br><span class="line">            <span class="comment">//        System.out.print(cbuf[i]);</span></span><br><span class="line">            <span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 正确示范1</span></span><br><span class="line">            <span class="comment">//    for (int i = 0;i &lt; len;i++)&#123;// 拿到几个字符就输出几个</span></span><br><span class="line">            <span class="comment">//        System.out.print(cbuf[i]);</span></span><br><span class="line">            <span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 错误演示2：数组可能存在不能完全覆盖</span></span><br><span class="line">            <span class="comment">//String str = new String(cbuf);</span></span><br><span class="line">            <span class="comment">//System.out.print(str);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 正确示范2</span></span><br><span class="line">            String str = <span class="keyword">new</span> String(cbuf,<span class="number">0</span>,len);</span><br><span class="line">            System.out.print(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fr != <span class="keyword">null</span>)&#123;<span class="comment">// if放在try的里面还是外面都一样</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 4.流的关闭</span></span><br><span class="line">                fr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>read()的理解：返回读入的一个字符。如果达到文件末尾，返回-1</p>
<p>异常的处理：为了保证流资源一定可以执行关闭操作。需要使用try-catch-finally处理</p>
<p>读入的文件一定要存在，否则就会报FileNotFoundException</p>
<p>输入的标准化过程总结：<br>① 创建File类的对象，指明读取的数据的来源。（要求此文件一定要存在）<br>② 创建相应的输入流，将File类的对象作为参数，传入流的构造器中<br>③ 具体的读入过程：<br>    创建相应的byte[] 或 char[]。<br>④ 关闭流资源<br>说明：程序中出现的异常需要使用try-catch-finally处理。</p>
<p>OutputStream &amp; Writer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b/<span class="keyword">int</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b/<span class="keyword">char</span>[] cbuf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b/<span class="keyword">char</span>[] buff, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>; 需要先刷新，再关闭此流</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为字符流直接以字符作为操作单位，所以 Writer 可以用字符串来替换字符数组，</span></span><br><span class="line">即以 String 对象作为参数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String str, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FileOutputStream 从文件系统中的某个文件中获得输出字节。FileOutputStream</span></span><br><span class="line">用于写出非文本数据之类的原始字节流。要写出字符流，需要使用 FileWriter</span><br></pre></td></tr></table></figure>

<p><img src="/posts/472db507/image-20210725082550623.png" alt="image-20210725082550623"></p>
<p><img src="/posts/472db507/image-20210725082605840.png" alt="image-20210725082605840"></p>
<p><strong>FileWriter使用。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileWriter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 从内存中写出数据到硬盘文件中，文件不存在会自动创建</span></span><br><span class="line">    FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.提供File类对象，指明写出到的文件</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;hello1.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.提供FileWriter的对象，用于数据的写出</span></span><br><span class="line">        fw = <span class="keyword">new</span> FileWriter(file,<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 3.写出的操作</span></span><br><span class="line">        fw.write(<span class="string">&quot;I have a dream!\n&quot;</span>);<span class="comment">// 以String形式写入</span></span><br><span class="line">        fw.write(<span class="string">&quot;you have a dream!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fw != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 4.流的关闭</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>输出操作，对应的File可以不存在的。并不会报异常<br>File对应的硬盘中的文件如果不存在，在输出的过程中，会自动创建此文件。<br>File对应的硬盘中的文件如果存在：<br>如果流使用的构造器是：FileWriter(file,false) / FileWriter(file):对原文件的覆盖<br>如果流使用的构造器是：FileWriter(file,true):不会对原文件覆盖，而是在原文件基础上追加内容<br>因为字符流直接以字符作为操作单位，所以 Writer 可以用字符串来替换字符数组，<br>即以 String 对象作为参数<br>void write(String str);<br>void write(String str , int off, int len);</p>
<p>输出的标准化过程总结：<br>① 创建File类的对象，指明写出的数据的位置。（不要求此文件一定要存在）<br>② 创建相应的输出流，将File类的对象作为参数，传入流的构造器中<br>③ 具体的写出过程：<br>    write(char[]/byte[] buffer,0,len)<br>④ 关闭流资源</p>
<p>说明：程序中出现的异常需要使用try-catch-finally处理。</p>
<p><strong>使用FileReader和FileWriter实现文本文件的复制。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">    FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建File类的对象，指明读入和写出的文件</span></span><br><span class="line">        File srcfile = <span class="keyword">new</span> File(<span class="string">&quot;hao.txt&quot;</span>);</span><br><span class="line">        File destfile = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.创建输入流和输出流的对象</span></span><br><span class="line">        fr = <span class="keyword">new</span> FileReader(srcfile);<span class="comment">// hao文件必须存在</span></span><br><span class="line">        fw = <span class="keyword">new</span> FileWriter(destfile);</span><br><span class="line">        <span class="comment">// 3.数据的读入和写出操作</span></span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> len;<span class="comment">// 记录每次读到cbuf数组的字符个数</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fw.write(cbuf,<span class="number">0</span>,len);<span class="comment">// 每次写出len个字符</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 4.关闭流</span></span><br><span class="line">        <span class="keyword">if</span> (fr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fw != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fw.close();<span class="comment">// 可以并列写，也可以写在fr的finally中（嵌套）</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>FileInputStream / FileOutputStream使用。</strong></p>
<p>对于文本文件(.txt,.java,.c,.cpp)，使用字符流处理</p>
<p>对于非文本文件(.jpg,.mp3,.mp4,.avi,.doc,.ppt,…)，使用字节流处理</p>
<p>想要复制图片，只要将FileReader和FileWriter改成相应的FileInputStream和FileOutputStream就行。</p>
<p>用FileInput(Output)Stream这两个类也能读入写出文本文件，不过需要做一些处理，否则可能乱码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.造文件</span></span><br><span class="line">        File srcfile = <span class="keyword">new</span> File(<span class="string">&quot;miku.png&quot;</span>);</span><br><span class="line">        File destfile = <span class="keyword">new</span> File(<span class="string">&quot;test.png&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.造流</span></span><br><span class="line">        fis = <span class="keyword">new</span> FileInputStream(srcfile);</span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(destfile);</span><br><span class="line">        <span class="comment">// 3.复制过程</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];<span class="comment">// 数字太小影响复制速度，太大占用内存大</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 4.流的关闭</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="keyword">null</span>)</span><br><span class="line">                fis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fos != <span class="keyword">null</span>)</span><br><span class="line">                    fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>相对路径在IDEA和Eclipse中使用的区别？</strong></p>
<p>IDEA:</p>
<p>如果使用单元测试方法，相对路径基于当前的Module的。</p>
<p>如果使用main()测试，相对路径基于当前Project的。<br>Eclipse:</p>
<p>单元测试方法还是main(),相对路径都是基于当前Project的。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO流</tag>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（十六）</title>
    <url>/posts/6246eadb.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-泛型（Generic）"><a href="#1-泛型（Generic）" class="headerlink" title="1.泛型（Generic）"></a>1.泛型（Generic）</h2><p>和C++中的模板有些相似。</p>
<p>从 JDK 1 5 以后 Java 引入了 参数化类型 Parameterized type 的概念允许我们在创建集合时再指定集合元素</p>
<p>的类型 正如： List<String> 这表明该 List 只能保存字符串类型的对象 。</String></p>
<span id="more"></span>

<p><img src="/posts/6246eadb/image-20210612152128756.png" alt="image-20210612152128756"></p>
<p><img src="/posts/6246eadb/image-20210612152136110.png" alt="image-20210612152136110"></p>
<p>集合中使用泛型总结：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">*  ① 集合接口或集合类在jdk5<span class="number">.0</span>时都修改为带泛型的结构。</span><br><span class="line">*  ② 在实例化集合类时，可以指明具体的泛型类型</span><br><span class="line">*  ③ 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。</span><br><span class="line">*    比如：add(E e)  ---&gt;实例化以后：add(Integer e)</span><br><span class="line">*  ④ 注意点：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换</span><br><span class="line">*  ⑤ 如果实例化时，没指明泛型的类型。默认类型为java.lang.Object类型。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在集合中使用泛型</span></span><br><span class="line"><span class="comment">// 泛型不能是基本数据类型，只能用包装类</span></span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="comment">// JDK7写法，类型推断：ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line">list.add(<span class="number">12</span>);<span class="comment">// 编译时就会进行类型检查，保证数据的安全</span></span><br><span class="line">list.add(<span class="number">234</span>);</span><br><span class="line">list.add(<span class="number">345</span>);</span><br><span class="line">list.add(<span class="number">45</span>);</span><br><span class="line"><span class="comment">//list.add(&quot;asf&quot;);爆红，不能添加String</span></span><br><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="keyword">for</span> (Integer integer:list)&#123;</span><br><span class="line">    <span class="comment">// 避免了强制类型转换</span></span><br><span class="line">    <span class="keyword">int</span> score = integer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    <span class="keyword">int</span> score = iterator.next();</span><br><span class="line">    System.out.println(score);</span><br><span class="line">&#125;</span><br><span class="line">--------</span><br><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">map.put(<span class="string">&quot;tom&quot;</span>,<span class="number">12</span>);</span><br><span class="line">Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entry = map.entrySet();</span><br><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entry.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    Map.Entry&lt;String, Integer&gt; next = iterator.next();</span><br><span class="line">    System.out.println(next);</span><br><span class="line">&#125;</span><br><span class="line">--------<span class="comment">/*带泛型的自然排序*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(o.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-如何自定义泛型结构"><a href="#2-如何自定义泛型结构" class="headerlink" title="2.如何自定义泛型结构"></a>2.如何自定义泛型结构</h2><p>自定义泛型类、泛型接口、泛型方法。</p>
<p><img src="/posts/6246eadb/image-20210612165225224.png" alt="image-20210612165225224"></p>
<p>泛型的主要优点是能够在编译时而不是在运行时检查错误。</p>
<p>泛型类的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在实例化时指明类的泛型</span></span><br><span class="line">    Order&lt;String&gt; order = <span class="keyword">new</span> Order&lt;&gt;(<span class="string">&quot;sda&quot;</span>,<span class="number">12</span>,<span class="string">&quot;dfs&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// subOrder是Order的子类，定义时已经指明了泛型类型</span></span><br><span class="line">    <span class="comment">// 所以实例化时不用再说明</span></span><br><span class="line">    subOrder suborder = <span class="keyword">new</span> subOrder();</span><br><span class="line">    <span class="comment">// 测试泛型方法</span></span><br><span class="line">    Order&lt;String&gt; order = <span class="keyword">new</span> Order&lt;&gt;();</span><br><span class="line">    Integer[] arr = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="comment">// 泛型方法在调用时指定泛型参数</span></span><br><span class="line">    List&lt;Integer&gt; list = order.copyFromArrayToList(arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Order.java*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    String ordername;</span><br><span class="line">    <span class="keyword">int</span> orderId;</span><br><span class="line">    T orderT;<span class="comment">// 在类的内部使用类的泛型</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//        T[] arr = new T[10];</span></span><br><span class="line">        <span class="comment">//编译通过</span></span><br><span class="line">        T[] arr = (T[]) <span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">(String ordername,<span class="keyword">int</span> orderId,T orderT)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderId = orderId;</span><br><span class="line">        <span class="keyword">this</span>.ordername = ordername;</span><br><span class="line">        <span class="keyword">this</span>.orderT = orderT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态方法中不能使用类的泛型。因为静态方法随类加载</span></span><br><span class="line">    <span class="comment">//public static void show(T orderT)&#123;</span></span><br><span class="line">    <span class="comment">//    System.out.println(orderT);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//        try&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;catch(T t)&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如下的个方法都不是泛型方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getOrderT</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderT</span><span class="params">(T orderT)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderT = orderT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没任何关系。</span></span><br><span class="line">    <span class="comment">//换句话说，泛型方法所属的类是不是泛型类都没关系。</span></span><br><span class="line">    <span class="comment">//泛型方法，可以声明为静态的。原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt;  <span class="function">List&lt;E&gt; <span class="title">copyFromArrayToList</span><span class="params">(E[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;E&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(E e : arr)&#123;</span><br><span class="line">            list.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">subOrder</span> <span class="keyword">extends</span> <span class="title">Order</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/6246eadb/image-20210612171355721.png" alt="image-20210612171355721"></p>
<p><img src="/posts/6246eadb/image-20210612171745520.png" alt="image-20210612171745520"></p>
<h2 id="3-泛型在继承方面的体现"><a href="#3-泛型在继承方面的体现" class="headerlink" title="3.泛型在继承方面的体现"></a>3.泛型在继承方面的体现</h2><p>虽然类A是类B的父类，但是G<A> 和G<B>二者不具备子父类关系，二者是并列关系</B></A></p>
<p>补充：类A是类B的父类，A<G> 是 B<G>的父类</G></G></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Object obj = <span class="keyword">null</span>;</span><br><span class="line">    String str = <span class="keyword">null</span>;</span><br><span class="line">    obj = str;</span><br><span class="line"></span><br><span class="line">    Object[] arr1 = <span class="keyword">null</span>;</span><br><span class="line">    String[] arr2 = <span class="keyword">null</span>;</span><br><span class="line">    arr1 = arr2;</span><br><span class="line">    <span class="comment">//编译不通过</span></span><br><span class="line">    <span class="comment">//        Date date = new Date();</span></span><br><span class="line">    <span class="comment">//        str = date;</span></span><br><span class="line">    List&lt;Object&gt; list1 = <span class="keyword">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="comment">//此时的list1和list2的类型不具子父类关系</span></span><br><span class="line">    <span class="comment">//编译不通过</span></span><br><span class="line">    <span class="comment">//        list1 = list2;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        反证法：</span></span><br><span class="line"><span class="comment">        假设list1 = list2;</span></span><br><span class="line"><span class="comment">           list1.add(123);导致混入非String的数据。出错。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    show(list1);</span><br><span class="line">    show1(list2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(List&lt;Object&gt; list)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    AbstractList&lt;String&gt; list1 = <span class="keyword">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="keyword">null</span>;</span><br><span class="line">    ArrayList&lt;String&gt; list3 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    list1 = list3;</span><br><span class="line">    list2 = list3;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list4 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-通配符的使用"><a href="#4-通配符的使用" class="headerlink" title="4.通配符的使用"></a>4.通配符的使用</h2><p>通配符：?</p>
<p>类A是类B的父类，G<A>和G<B>是没关系的，二者共同的父类是：G&lt;?&gt;</B></A></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Object&gt; list1 = <span class="keyword">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="keyword">null</span>;</span><br><span class="line">    List&lt;?&gt; list = <span class="keyword">null</span>;<span class="comment">// List&lt;?&gt;相当于一个通用父类</span></span><br><span class="line"></span><br><span class="line">    list = list1;</span><br><span class="line">    list = list2;</span><br><span class="line">    <span class="comment">//编译通过</span></span><br><span class="line">    <span class="comment">//        print(list1);</span></span><br><span class="line">    <span class="comment">//        print(list2);</span></span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list3.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    list3.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    list3.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    list = list3;</span><br><span class="line">    <span class="comment">//添加(写入)：对于List&lt;?&gt;就不能向其内部添加数据。</span></span><br><span class="line">    <span class="comment">//除了添加null之外。</span></span><br><span class="line">    <span class="comment">//        list.add(&quot;DD&quot;);</span></span><br><span class="line">    <span class="comment">//        list.add(&#x27;?&#x27;);</span></span><br><span class="line"></span><br><span class="line">    list.add(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//获取(读取)：允许读取数据，读取的数据类型为Object。</span></span><br><span class="line">    Object o = list.get(<span class="number">0</span>);</span><br><span class="line">    System.out.println(o);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(List&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">    Iterator&lt;?&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        Object obj = iterator.next();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有限制的通配符：</p>
<p><img src="/posts/6246eadb/image-20210612184152402.png" alt="image-20210612184152402"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;? extends Person&gt; list1 = <span class="keyword">null</span>;<span class="comment">// ?&lt;=Person</span></span><br><span class="line">    List&lt;? <span class="keyword">super</span> Person&gt; list2 = <span class="keyword">null</span>;<span class="comment">// ?&gt;=Person</span></span><br><span class="line"></span><br><span class="line">    List&lt;Student&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Person&gt; list4 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Object&gt; list5 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    list1  = list3;</span><br><span class="line">    list1  = list4;</span><br><span class="line">    <span class="comment">//list1  = list5;报错</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//list2  = list3;报错</span></span><br><span class="line">    list2  = list4;</span><br><span class="line">    list2  = list5;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    list1 = list3;</span><br><span class="line">    Person p = list1.get(<span class="number">0</span>);<span class="comment">// 左边只能用范围的最大值Person接收</span></span><br><span class="line">    list2  = list4;</span><br><span class="line">    Object obj = list2.get(<span class="number">0</span>);<span class="comment">// 左边只能用范围的最大值Object接收</span></span><br><span class="line">    <span class="comment">// 总结：写上限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（十四）</title>
    <url>/posts/68d66445.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-集合框架概述"><a href="#1-集合框架概述" class="headerlink" title="1.集合框架概述"></a>1.集合框架概述</h2><p>参考博客：<a href="https://www.acwing.com/blog/content/4414/">https://www.acwing.com/blog/content/4414/</a></p>
<p>集合、数组都是对多个数据进行存储操作的结构，简称Java容器。</p>
<span id="more"></span>

<p><strong>Java集合类库将接口与实现分离。</strong></p>
<p><img src="/posts/68d66445/image-20210503103116117.png" alt="image-20210503103116117"></p>
<p>这两个都是接口，不是类。</p>
<p>Collection的接口继承树：</p>
<p><img src="/posts/68d66445/image-20210503103324545.png" alt="image-20210503103324545"></p>
<p>Map的接口继承树：</p>
<p><img src="/posts/68d66445/image-20210503103348318.png" alt="image-20210503103348318"></p>
<p>List接口：动态数组，存储有序可重复数据；Set接口：集合，存储无序不可重复数据；Queue接口：队列。</p>
<p>Map接口：类似函数，存储key-value的键值对，一个key不能对应多个value。</p>
<h2 id="2-Collection接口方法"><a href="#2-Collection接口方法" class="headerlink" title="2.Collection接口方法"></a>2.Collection接口方法</h2><p>推荐一个Java全面教程：<a href="https://blog.csdn.net/qq_38490457/article/details/108281646">https://blog.csdn.net/qq_38490457/article/details/108281646</a></p>
<p><img src="/posts/68d66445/image-20210503103440883.png" alt="image-20210503103440883"></p>
<p>Collection接口的13种常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以ArrayList作为示例，不能直接new Collection，它是个接口</span></span><br><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.add(Object e);将元素e添加到集合coll中</span></span><br><span class="line">coll.add(<span class="string">&quot;asd&quot;</span>);<span class="comment">// 任意类型都行</span></span><br><span class="line">coll.add(<span class="number">123</span>);<span class="comment">// 自动装箱</span></span><br><span class="line">coll.add(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.size();获取的添加的元素的个数</span></span><br><span class="line">System.out.println(coll.size());<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.coll2.addAll(Collection coll1);将coll1添加到coll2中</span></span><br><span class="line">Collection coll1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll1.add(<span class="number">12</span>);</span><br><span class="line">coll1.add(<span class="string">&quot;asdf&quot;</span>);</span><br><span class="line">coll.addAll(coll1);</span><br><span class="line">System.out.println(coll);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.clear();清空集合元素</span></span><br><span class="line">coll1.clear();</span><br><span class="line"><span class="comment">// 5.isEmpty();判断集合是否为空，即size为0</span></span><br><span class="line">System.out.println(coll1.isEmpty());<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>向Collection接口的实现类的对象中添加数据obj时，要求重写equals()，因为cnontains方法会调用equals。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">coll.add(<span class="number">123</span>);</span><br><span class="line">coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">coll.add(<span class="keyword">false</span>);<span class="comment">// 包装类Boolean</span></span><br><span class="line">coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));<span class="comment">// 自定义类Person</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.contains(Object obj);判断当前集合中是否包含obj</span></span><br><span class="line"><span class="comment">// 我们在判断时会调用obj对象所在类的equals方法</span></span><br><span class="line"><span class="keyword">boolean</span> contains = coll.contains(<span class="number">123</span>);</span><br><span class="line">System.out.println(contains);<span class="comment">// true</span></span><br><span class="line"><span class="comment">// equals方法判断对象内容是否相等，==判断是否同一个对象</span></span><br><span class="line"><span class="comment">// contains看内容是否相等</span></span><br><span class="line">System.out.println(coll.contains(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>)));<span class="comment">// true</span></span><br><span class="line"><span class="comment">// Person没有重写equals方法，是false，重写之后就是true</span></span><br><span class="line">System.out.println(coll.contains(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>)));<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.coll2.containsAll(Collection coll1);判断coll1中所有元素是否都在coll2中</span></span><br><span class="line"><span class="comment">// 也是调用元素的 equals 方法来比较的,拿两个集合的元素挨个比较</span></span><br><span class="line">Collection coll1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll1.add(<span class="number">123</span>);</span><br><span class="line">System.out.println(coll.containsAll(coll1));<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.remove(Object ojb);移除集合中的元素</span></span><br><span class="line">coll.remove(<span class="number">123</span>);<span class="comment">// 返回是否移除成功，true或false</span></span><br><span class="line">coll.remove(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">System.out.println(coll);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.removeAll(Collection coll1);从当前集合中移除coll1中的所有元素</span></span><br><span class="line">Collection coll2 = Arrays.asList(<span class="keyword">false</span>,<span class="keyword">new</span> String(<span class="string">&quot;asd&quot;</span>));</span><br><span class="line">coll.removeAll(coll2);</span><br><span class="line">System.out.println(coll);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.retainAll(Collection coll3);求两集合的交集，结果存放在当前集合，不影响集合coll3</span></span><br><span class="line">coll.add(<span class="number">1</span>);</span><br><span class="line">coll.add(<span class="keyword">new</span> String(<span class="string">&quot;ad&quot;</span>));</span><br><span class="line">Collection coll3 = Arrays.asList(<span class="number">1</span>,<span class="keyword">new</span> String(<span class="string">&quot;ad&quot;</span>));</span><br><span class="line">coll.retainAll(coll3);</span><br><span class="line">System.out.println(coll);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.equals(Object obj);判断两个集合是否相等</span></span><br><span class="line">Collection coll4 = Arrays.asList(<span class="keyword">new</span> String(<span class="string">&quot;asd&quot;</span>),<span class="keyword">false</span>);</span><br><span class="line">System.out.println(coll2.equals(coll4));<span class="comment">//false,ArrayList有序，交换顺序是不等的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7.hasnCode();返回当前对象的哈希值</span></span><br><span class="line">Collection coll = Arrays.asList(<span class="keyword">false</span>,<span class="keyword">new</span> String(<span class="string">&quot;asd&quot;</span>),<span class="number">123</span>);</span><br><span class="line">System.out.println(coll.hashCode());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8.toArray();集合 -- &gt; 数组</span></span><br><span class="line">Object[] arr = coll.toArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">    System.out.print(arr[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓展：数组 -- &gt; 集合,调用Arrays类的静态方法asList()</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>&#125;);</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">// new int[]构造的数组被看成了一个整体</span></span><br><span class="line">List arr1 = Arrays.asList(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>&#125;);</span><br><span class="line">System.out.println(arr1.size());<span class="comment">//1</span></span><br><span class="line"><span class="comment">// 只有用包装类如Integer才会看成多个元素</span></span><br><span class="line">List arr2 = Arrays.asList(<span class="keyword">new</span> Integer[]&#123;<span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>&#125;);</span><br><span class="line">System.out.println(arr2.size());<span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>还有一个iterator方法放在下个知识点，它的作用是返回迭代器对象，用于集合遍历。</p>
<h2 id="3-使用Iterator接口遍历集合"><a href="#3-使用Iterator接口遍历集合" class="headerlink" title="3.使用Iterator接口遍历集合"></a>3.使用Iterator接口遍历集合</h2><p><img src="/posts/68d66445/image-20210611193315961.png" alt="image-20210611193315961"></p>
<p>迭代器的执行原理：</p>
<p><img src="/posts/68d66445/image-20210611194015297.png" alt="image-20210611194015297"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll.add(<span class="string">&quot;asd&quot;</span>);<span class="comment">// 任意类型都行</span></span><br><span class="line">coll.add(<span class="number">123</span>);<span class="comment">// 自动装箱</span></span><br><span class="line">coll.add(<span class="keyword">new</span> String(<span class="string">&quot;fsdf&quot;</span>));</span><br><span class="line"></span><br><span class="line">Iterator iterator = coll.iterator();</span><br><span class="line"><span class="comment">// 输出第一个元素</span></span><br><span class="line">System.out.println(iterator.next());<span class="comment">// 如果下一个元素没有会异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//next()推荐配合hasNext()使用</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器内部定义了remove方法，可以在便利的时候删除集合中的元素</span></span><br><span class="line"><span class="comment">// 注意：此处的remove方法不同于集合的remove方法</span></span><br><span class="line">Iterator ite = coll.iterator();</span><br><span class="line"><span class="keyword">while</span> (ite.hasNext())&#123;</span><br><span class="line">    Object obj = ite.next();</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;fsdf&quot;</span>.equals(obj))&#123;</span><br><span class="line">        <span class="comment">// “fsdf&quot;从集合中删除了</span></span><br><span class="line">        ite.remove();<span class="comment">//remove跟着next指针走</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/68d66445/image-20210611195203094.png" alt="image-20210611195203094"></p>
<h2 id="4-使用for-each遍历集合"><a href="#4-使用for-each遍历集合" class="headerlink" title="4.使用for-each遍历集合"></a>4.使用for-each遍历集合</h2><p>JDK5.0的新特性，增强for循环</p>
<p>可用于迭代访问Collection和数组。</p>
<p>和C++中的for-each用法类似。</p>
<p>foreach适用于循环次数未知，只是进行集合或数组遍历，for则在<strong>较复杂的循环</strong>中效率更高。</p>
<p>foreach<strong>不能</strong>对数组或集合进行<strong>修改</strong>（添加删除操作），如果想要<strong>修改就要用for循环</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll.add(<span class="string">&quot;asd&quot;</span>);<span class="comment">// 任意类型都行</span></span><br><span class="line">coll.add(<span class="number">123</span>);<span class="comment">// 自动装箱</span></span><br><span class="line">coll.add(<span class="keyword">new</span> String(<span class="string">&quot;fsdf&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Object obj:coll)&#123;</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : arr)&#123;</span><br><span class="line">    System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-Collection子接口之一：List接口"><a href="#5-Collection子接口之一：List接口" class="headerlink" title="5.Collection子接口之一：List接口"></a>5.Collection子接口之一：List接口</h2><p>鉴于 Java 中数组用来存储数据的局限性，我们通常使用 List 替代数组。</p>
<p>List 集合类中元素有序、且可重复 ，集合中的每个元素都有其对应的顺序索引。</p>
<p>List 容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</p>
<p>List 接口的实现类常用的有： <strong>ArrayList 、 LinkedList 和 Vector</strong> 。</p>
<p>三者的异同？</p>
<p>相同点：都用于存储有序、可重复元素。</p>
<p>不同点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">   |----List接口：存储序的、可重复的数据。  --&gt;“动态”数组,替换原的数组</span><br><span class="line">     |----ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储      |----LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储</span><br><span class="line">     |----Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储</span><br></pre></td></tr></table></figure>

<p>ArrayList是最常用的，但是线程不安全。</p>
<p><strong>一些源码分析</strong></p>
<p>ArrayList的源码分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jdk 7</span></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();<span class="comment">//底层创建了长度是10的Object[]数组elementData</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//elementData[0] = new Integer(123);</span></span><br><span class="line">...</span><br><span class="line">list.add(<span class="number">11</span>);<span class="comment">//如果此次的添加导致底层elementData数组容量不够，则扩容</span></span><br><span class="line"><span class="comment">//默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</span></span><br><span class="line"><span class="comment">//结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//jdk 8中ArrayList的变化</span></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();<span class="comment">//底层Object[] elementData初始化为&#123;&#125;.并没创建长度为10的数组</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]</span></span><br><span class="line">...<span class="comment">//后续的添加和扩容操作与jdk 7 无异。</span></span><br><span class="line"><span class="comment">//小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。</span></span><br></pre></td></tr></table></figure>

<p>LinkedList的源码分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList list = <span class="keyword">new</span> LinkedList(); <span class="comment">//内部声明了Node类型的first和last属性，默认值为null</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//将123封装到Node中，创建了Node对象。</span></span><br><span class="line"><span class="comment">//其中，Node定义为：体现了LinkedList的双向链表的说法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Vector的源码分析：</p>
<p>jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。在扩容方面，默认扩容为原来</p>
<p>的数组长度的2倍。</p>
<p>List接口的常见方法：</p>
<p><img src="/posts/68d66445/image-20210612090751182.png" alt="image-20210612090751182"></p>
<p>注意：subList返回子集合，不会对原集合造成影响。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">最常用的几种方法</span><br><span class="line">增：add(Object obj)</span><br><span class="line">删：remove(<span class="keyword">int</span> index) / remove(Object obj)这两个方法是重载的</span><br><span class="line">改：set(<span class="keyword">int</span> index, Object ele)</span><br><span class="line">查：get(<span class="keyword">int</span> index)</span><br><span class="line">插：add(<span class="keyword">int</span> index, Object ele)</span><br><span class="line">长度：size()</span><br><span class="line">遍历：① Iterator迭代器方式</span><br><span class="line">     ② 增强<span class="keyword">for</span>循环</span><br><span class="line">     ③ 普通的循环</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（四）</title>
    <url>/posts/7c5f0178.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-数组的拓展"><a href="#1-数组的拓展" class="headerlink" title="1.数组的拓展"></a>1.数组的拓展</h2><h3 id="1-1冒泡排序"><a href="#1-1冒泡排序" class="headerlink" title="1.1冒泡排序"></a>1.1冒泡排序</h3><p>时间复杂度：o(n$^2$)</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">34</span>,<span class="number">5673</span>,<span class="number">3</span>,<span class="number">456</span>,<span class="number">124</span>,<span class="number">4562</span>,<span class="number">23</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span>[] sort = sorted(a);</span><br><span class="line">		System.out.println(Arrays.toString(sort));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 冒泡排序</span></span><br><span class="line">	<span class="comment">// 核心思路：1.比较相邻的两个元素，如果左边大于右边就交换顺序</span></span><br><span class="line">	<span class="comment">// 2.每一次比较都会产生一个最大或最小的数</span></span><br><span class="line">	<span class="comment">// 3.下一轮可以减少一次排序</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sorted(<span class="keyword">int</span>[] a)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; a.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; a.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span> (a[j+<span class="number">1</span>] &lt; a[j])&#123;</span><br><span class="line">					<span class="keyword">int</span> temp = a[j];</span><br><span class="line">					a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">					a[j+<span class="number">1</span>] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2稀疏数组"><a href="#1-2稀疏数组" class="headerlink" title="1.2稀疏数组"></a>1.2稀疏数组</h3><p><img src="/posts/7c5f0178/image-20210227121053148.png" alt="image-20210227121053148"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[][] array1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">		array1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">		array1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;输出原始数组：&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span>[] x:array1)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> y:x)&#123;</span><br><span class="line">				System.out.print(y + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 转换为稀疏数组保存</span></span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">11</span>;i ++)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">11</span>;j ++)&#123;</span><br><span class="line">				<span class="keyword">if</span> (array1[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">					sum ++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;有效数字的个数是：&quot;</span>+sum);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span>[][] array2 = <span class="keyword">new</span> <span class="keyword">int</span>[sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">		array2[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">		array2[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">		array2[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 对于多维数组a，a.length返回a的第一维长度</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array1.length;i ++)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; array1[i].length;j ++)&#123;</span><br><span class="line">				<span class="keyword">if</span> (array1[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">					array2[count][<span class="number">0</span>] = i;</span><br><span class="line">					array2[count][<span class="number">1</span>] = j;</span><br><span class="line">					array2[count][<span class="number">2</span>] = array1[i][j];</span><br><span class="line">					count ++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 输出稀疏数组</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span>[] x:array2)&#123;<span class="comment">// 注意&quot;\t&quot;不要写成单引号，否则会相加</span></span><br><span class="line">			System.out.println(x[<span class="number">0</span>]+<span class="string">&quot;\t&quot;</span>+x[<span class="number">1</span>]+<span class="string">&quot;\t&quot;</span>+x[<span class="number">2</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 读取稀疏数组</span></span><br><span class="line">		<span class="keyword">int</span>[][] array3 = <span class="keyword">new</span> <span class="keyword">int</span>[array2[<span class="number">0</span>][<span class="number">0</span>]][array2[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; array2.length;i++)&#123;</span><br><span class="line">			array3[array2[i][<span class="number">0</span>]][array2[i][<span class="number">1</span>]] = array2[i][<span class="number">2</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span>[] x:array3)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> y:x)&#123;</span><br><span class="line">				System.out.print(y+<span class="string">&quot; &quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-面向对象编程（OOP）"><a href="#2-面向对象编程（OOP）" class="headerlink" title="2.面向对象编程（OOP）"></a>2.面向对象编程（OOP）</h2><p><strong>Java的核心思想就是OOP。</strong></p>
<img src="/posts/7c5f0178/image-20210227142737516.png" alt="image-20210227142737516" style="zoom:67%;">

<img src="/posts/7c5f0178/image-20210227142935926.png" alt="image-20210227142935926" style="zoom:67%;">

<h2 id="3-静态方法与非静态方法"><a href="#3-静态方法与非静态方法" class="headerlink" title="3.静态方法与非静态方法"></a>3.静态方法与非静态方法</h2><p>静态方法（类方法）的特点：只能使用参数和静态变量（包括自己类的和别的类的允许访问的），没有this自引用，但是可以通过new的对象或传入的参数对象来引用。</p>
<p>Demo1：new一个对象来调用非静态方法（随对象创建进行加载）。</p>
<p><img src="/posts/7c5f0178/image-20210227144507848.png" alt="image-20210227144507848"></p>
<p>Demo2：用类名来调用静态方法（随类进行加载）。</p>
<p><img src="/posts/7c5f0178/image-20210227150226347.png" alt="image-20210227150226347"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;&#125;		</span><br><span class="line">	<span class="comment">// 两个非静态方法之间可以直接调用</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">		b();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 静态方法a不能直接调用非静态方法b</span></span><br><span class="line">    <span class="comment">// 因为静态方法a随class一起加载，而非静态方法b在对象创建(类实例化)时才存在</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">		b();<span class="comment">// 非法的调用</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 非静态方法a可以直接调用静态方法b</span></span><br><span class="line">    <span class="comment">// 因为静态方法a随class一起加载，而非静态方法b在对象创建(类实例化)时才存在</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">		b();<span class="comment">// 合法的调用</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：非静态方法可以调用非静态方法以及静态方法；静态方法不能调用非静态方法。</p>
<h2 id="4-java中的方法都是值传递"><a href="#4-java中的方法都是值传递" class="headerlink" title="4.java中的方法都是值传递"></a>4.java中的方法都是值传递</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span></span>&#123;</span><br><span class="line">    <span class="comment">// 值传递</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">		Demo.change(a);</span><br><span class="line">		System.out.println(a);<span class="comment">// a的值还是1</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">		a = <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span></span>&#123;</span><br><span class="line">	<span class="comment">// 引用传递：对象，本质还是值传递</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Person person = <span class="keyword">new</span> Person();</span><br><span class="line">		System.out.println(person.name);<span class="comment">// null</span></span><br><span class="line">		Demo.change(person);</span><br><span class="line">		System.out.println(person.name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">        <span class="comment">//person是一个对象</span></span><br><span class="line">        <span class="comment">// 指向--&gt; Person person = new Person();它是一个具体的人，可以改变属性</span></span><br><span class="line">		person.name = <span class="string">&quot;java&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义Person类，有一个属性：name</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-类与对象的创建"><a href="#5-类与对象的创建" class="headerlink" title="5.类与对象的创建"></a>5.类与对象的创建</h2><p><img src="/posts/7c5f0178/image-20210227152818697.png" alt="image-20210227152818697"></p>
<p>养成习惯，专门在一个主程序中写main方法，用于测试。在别的类中不要加上main方法。</p>
<p><img src="/posts/7c5f0178/image-20210227153327859.png" alt="image-20210227153327859"></p>
<p><img src="/posts/7c5f0178/image-20210227155204438.png" alt="image-20210227155204438"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Student.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 属性：字段</span></span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>.name+<span class="string">&quot;在学习&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Demo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">// 类实例化后会返回一个自己的对象！</span></span><br><span class="line">		<span class="comment">// 类是抽象的，对象是类的具体实例</span></span><br><span class="line">		Student xiaoming = <span class="keyword">new</span> Student();</span><br><span class="line">		Student xiaohong = <span class="keyword">new</span> Student();</span><br><span class="line">		</span><br><span class="line">		xiaoming.name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">		xiaoming.age = <span class="number">18</span>;</span><br><span class="line">		System.out.println(xiaoming.name);</span><br><span class="line">		System.out.println(xiaoming.age);</span><br><span class="line">		xiaoming.study();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*小明</span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment">小明在学习*/</span></span><br></pre></td></tr></table></figure>

<h2 id="6-类的构造器（构造方法）"><a href="#6-类的构造器（构造方法）" class="headerlink" title="6.类的构造器（构造方法）"></a>6.类的构造器（构造方法）</h2><p>类中的构造方法是在进行创建对象时必须调用的。它只能在创建对象时被间接调用。</p>
<p>它有以下两个特点：</p>
<ul>
<li>必须和类的名字相同</li>
<li>必须没有返回类型，也不能写void</li>
</ul>
<p>如果类中什么都不写，它会存在默认构造方法。</p>
<p>1.使用new关键字本质上是在调用构造器</p>
<p>2.用来初始化值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 构造器实例化初始值</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = <span class="string">&quot;wang&quot;</span>;</span><br><span class="line">	&#125;  </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="comment">// 构造器实例化初始值</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 有参构造</span></span><br><span class="line">	<span class="comment">//一旦定义有参构造，无参构造必须显式定义，否则报错</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Person person = new Person(&quot;wang&quot;,23);</span></span><br><span class="line"><span class="comment">// 根据方法重载进行有参构造</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 构造器实例化初始值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造器的重载与相互调用</span></span><br><span class="line">    <span class="comment">//在构造器里调用重载的构造器时，必须是方法的第一行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">&quot;xiaoming&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-创建对象内存分析"><a href="#7-创建对象内存分析" class="headerlink" title="7.创建对象内存分析"></a>7.创建对象内存分析</h2><p><img src="/posts/7c5f0178/image-20210305150045041.png" alt="image-20210305150045041"></p>
<h2 id="8-小结类与对象"><a href="#8-小结类与对象" class="headerlink" title="8.小结类与对象"></a>8.小结类与对象</h2><p><strong>对象的引用</strong></p>
<p>引用类型：除8种基本类型之外的都是引用类型。</p>
<p>对象是通过引用来操作的（如上图）：栈 —&gt; 堆（地址）。</p>
<p><strong>属性</strong></p>
<p>也即字段Field，成员变量</p>
<p>会进行默认初始化（缺省值）：</p>
<ul>
<li>数字：0  0.0</li>
<li>char：<code>\u0000</code></li>
<li>boolean：false</li>
<li>引用类型：null</li>
</ul>
<p><strong>类</strong></p>
<p>1.属性：静态的属性</p>
<p>2.方法：动态的行为</p>
<h2 id="9-OOP三大特性之封装"><a href="#9-OOP三大特性之封装" class="headerlink" title="9.OOP三大特性之封装"></a>9.OOP三大特性之封装</h2><p><img src="/posts/7c5f0178/image-20210305151408746.png" alt="image-20210305151408746"></p>
<p>1.提高程序的安全性，保护数据</p>
<p>2.隐藏代码的实现细节</p>
<p>3.统一接口get/set</p>
<p>4.系统可维护性增加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="comment">// private:属性私有</span></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">char</span> gender;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="comment">// 提供一些可以操作这些属性的方法</span></span><br><span class="line">	<span class="comment">// 提供一些public的get、set方法，自己实现</span></span><br><span class="line">	<span class="comment">// get获得这个数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// set给数据设置值</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		<span class="comment">// 合法性验证</span></span><br><span class="line">		<span class="keyword">if</span> (age &gt;= <span class="number">130</span> || age &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">this</span>.age = <span class="number">3</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.age = age;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">		s1.setName(<span class="string">&quot;student1&quot;</span>);</span><br><span class="line">		System.out.println(s1.getName());</span><br><span class="line">		s1.setAge(<span class="number">999</span>);<span class="comment">// 不合法的</span></span><br><span class="line">		System.out.println(s1.getAge());</span><br><span class="line">		s1.setAge(<span class="number">75</span>);</span><br><span class="line">		System.out.println(s1.getAge());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*student1</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">75*/</span></span><br></pre></td></tr></table></figure>

<h2 id="10-OOP三大特性之继承"><a href="#10-OOP三大特性之继承" class="headerlink" title="10.OOP三大特性之继承"></a>10.OOP三大特性之继承</h2><p><img src="/posts/7c5f0178/image-20210305160318864.png" alt="image-20210305160318864"></p>
<ul>
<li>在Java中，所有的类都默认直接或者间接继承Object类</li>
<li>Java中类只有单继承，没有多继承！一个儿子只能有一个爸爸，而一个爸爸可以有多个儿子</li>
<li>私有的东西无法被继承</li>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong></li>
<li>被final修饰的class不能被继承</li>
<li>子类可以通过this访问公共继承自父类的属性，相当于子类对象里藏着一个父类对象</li>
<li>就好像子类的引用可以一物二用，既可以当作父类的引用使用，又可以当作子类的引用<br>使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 如果是private就不能继承到子类</span></span><br><span class="line">	<span class="comment">// 使用public子类就能继承父类的属性，方法</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> money = <span class="number">10_000</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.money;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(<span class="keyword">int</span> money)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.money = money;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Student继承Person，派生类，子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Teacher继承Person，派生类，子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Student student = <span class="keyword">new</span> Student();</span><br><span class="line">		student.say();</span><br><span class="line">		System.out.println(student.getMoney());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*hello</span></span><br><span class="line"><span class="comment">10000*/</span></span><br></pre></td></tr></table></figure>

<p><strong>super演示（重要）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> String name = <span class="string">&quot;kuangshen&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Student继承Person，派生类，子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name = <span class="string">&quot;qingjiang&quot;</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		System.out.println(name);</span><br><span class="line">		System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">		System.out.println(<span class="keyword">super</span>.name);<span class="comment">//kuangshen</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Student&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		print();<span class="comment">// Student</span></span><br><span class="line">		<span class="keyword">this</span>.print();<span class="comment">// Student</span></span><br><span class="line">		<span class="keyword">super</span>.print();<span class="comment">// Person</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Student student = <span class="keyword">new</span> Student();</span><br><span class="line">		student.test(<span class="string">&quot;请将&quot;</span>);</span><br><span class="line">        student.test1();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*请将</span></span><br><span class="line"><span class="comment">qingjiang</span></span><br><span class="line"><span class="comment">kuangshen*/</span></span><br></pre></td></tr></table></figure>

<p>子类与父类的构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> String name = <span class="string">&quot;kuangshen&quot;</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Person无参执行了&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Teacher继承Person，派生类，子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 隐藏代码：调用了父类的无参构造</span></span><br><span class="line">        <span class="keyword">super</span>();<span class="comment">// 默认的，调用父类的构造器必须在子类的第一行</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Teacher无参执行了&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Teacher teacher = <span class="keyword">new</span> Teacher();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Person无参执行了</span></span><br><span class="line"><span class="comment">Teacher无参执行了*/</span></span><br></pre></td></tr></table></figure>

<p>super的注意点</p>
<ul>
<li><p>子类对象里可以认为有一个特殊的父类的对象，这个父类对象和子类对象之<br>间通过super 关键字来沟通，super是沟通的桥梁</p>
</li>
<li><p>super();调用父类的构造器，<strong>必须在当前类（子类）的第一行</strong></p>
</li>
<li><p>super必须只能出现在子类的方法或者构造器中</p>
</li>
<li><p>super和this不能同时调用构造方法（因为都必须放第一行）</p>
</li>
<li><p>super并不是父类的引用，和this自引用不一样，如果一样那不就成组合了嘛</p>
</li>
</ul>
<p>super与this的不同点</p>
<ul>
<li>代表的对象不同</li>
<li>this没继承也能使用，super只能在继承时使用</li>
<li>this();调用本类的构造，super();调用父类的构造</li>
<li>this可以作为返回值，但super不可以</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门笔记（十）</title>
    <url>/posts/ac5bd4a1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-包装类-Wrapper-的使用"><a href="#1-包装类-Wrapper-的使用" class="headerlink" title="1.包装类 (Wrapper) 的使用"></a>1.包装类 (Wrapper) 的使用</h2><span id="more"></span>

<p><img src="/posts/ac5bd4a1/image-20210404124237876.png" alt="image-20210404124237876"></p>
<p><img src="/posts/ac5bd4a1/image-20210404132608185.png" alt="image-20210404132608185"></p>
<p>包装类的重点就在于基本数据类型、包装类和String类之间的转换。</p>
<p><strong>重点记住：自动装/拆箱，parseXXX()/valueOf()。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本数据类型--&gt;包装类：调用包装类的构造器</span></span><br><span class="line"><span class="meta">@org</span>.junit.jupiter.api.Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    Integer in1 = <span class="keyword">new</span> Integer(num1);</span><br><span class="line">    System.out.println(in1.toString());</span><br><span class="line"></span><br><span class="line">    Integer in2 = <span class="keyword">new</span> Integer(<span class="string">&quot;1234&quot;</span>);</span><br><span class="line">    System.out.println(in2);<span class="comment">// 输出对象默认调用toString</span></span><br><span class="line"></span><br><span class="line">    Float f1 = <span class="keyword">new</span> Float(<span class="string">&quot;123.34F&quot;</span>);</span><br><span class="line">    System.out.println(f1);</span><br><span class="line">    Float f2 = <span class="keyword">new</span> Float(<span class="string">&quot;234&quot;</span>);</span><br><span class="line">    System.out.println(f2);</span><br><span class="line"></span><br><span class="line">    Boolean b1 = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);<span class="comment">//true</span></span><br><span class="line">    System.out.println(b1);</span><br><span class="line">    Boolean b2 = <span class="keyword">new</span> Boolean(<span class="string">&quot;TRue12&quot;</span>);<span class="comment">//false，不会报错</span></span><br><span class="line">    System.out.println(b2);</span><br><span class="line">    Boolean b3 = <span class="keyword">new</span> Boolean(<span class="string">&quot;TRue&quot;</span>);<span class="comment">//true，忽略大小写</span></span><br><span class="line">    System.out.println(b3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包装类--&gt;基本数据类型：调用包装类的xxxValue()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Integer in1 = <span class="keyword">new</span> Integer(<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">int</span> i1 = in1.intValue();</span><br><span class="line">    System.out.println(i1%<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK5.0新特性，自动装箱与自动拆箱</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 基本数据类型--&gt;包装类的对象</span></span><br><span class="line">        method(num1);</span><br><span class="line">        <span class="comment">// 自动装箱：基本数据类型--&gt;包装类</span></span><br><span class="line">        <span class="comment">//不需要调用包装类的构造器</span></span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">18</span>;</span><br><span class="line">        Integer in1 = num2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自动拆箱：包装类--&gt;基本数据类型</span></span><br><span class="line">        <span class="keyword">int</span> num3 = in1;</span><br><span class="line">        System.out.println(num3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本数据类型、包装类--&gt;String类型：调用String重载的valueOf()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 方式1：连接运算</span></span><br><span class="line">    String s1 = num1+<span class="string">&quot;&quot;</span>;</span><br><span class="line">    System.out.println(s1);</span><br><span class="line">    <span class="comment">// 方式2</span></span><br><span class="line">    <span class="keyword">float</span> f1 = <span class="number">12.3F</span>;</span><br><span class="line">    String s2 = String.valueOf(f1);<span class="comment">//基本数据类型</span></span><br><span class="line">    System.out.println(s2);</span><br><span class="line"></span><br><span class="line">    Double d1 = <span class="keyword">new</span> Double(<span class="number">12.4</span>);<span class="comment">//包装类</span></span><br><span class="line">    String s3 = String.valueOf(d1);</span><br><span class="line">    System.out.println(s3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String类型--&gt;基本数据类型、包装类：调用包装类的parseXXX()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> num1 = Integer.parseInt(s1);</span><br><span class="line">    System.out.println(num1+<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    String s2 = <span class="string">&quot;true&quot;</span>;</span><br><span class="line">    <span class="keyword">boolean</span> num2 = Boolean.parseBoolean(s2);</span><br><span class="line">    System.out.println(num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关于包装类使用的面试题</span></span><br><span class="line"><span class="comment">// 问test1和test2输出是否相等</span></span><br><span class="line"><span class="comment">// 问test3的输出内容</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterviewTest</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 三元运算符要求后面两个返回值类型一致，否则自动类型转换</span></span><br><span class="line">		Object o1 = <span class="keyword">true</span> ? <span class="keyword">new</span> Integer(<span class="number">1</span>) : <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">		System.out.println(o1);<span class="comment">// 1.0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Object o2;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">true</span>)</span><br><span class="line">			o2 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			o2 = <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">		System.out.println(o2);<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">		Integer j = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">		System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line"><span class="comment">/*解释：</span></span><br><span class="line"><span class="comment">三目运算符比较基本数据类型，所以在编译阶段自动拆箱为 int 和 double 类型，由于三目运算符要求 表达式2 和 表达式3 类型一致，所以在编译阶段自动类型提升（即 int 自动类型转换为 double 类型），再自动装箱为Object，输出时使用多态调用重写的toString();即Double包装类的toString();*/</span></span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[],</span></span><br><span class="line"><span class="comment">//保存了从-128~127范围的整数。如果我们使用自动装箱的方式，给Integer赋值的范围在</span></span><br><span class="line"><span class="comment">//-128~127范围内时，可以直接使用数组中的元素，不用再去new了。目的：提高效率		</span></span><br><span class="line">		Integer m = <span class="number">1</span>;</span><br><span class="line">		Integer n = <span class="number">1</span>;</span><br><span class="line">		System.out.println(m == n);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">		Integer x = <span class="number">128</span>;<span class="comment">//相当于new了一个Integer对象</span></span><br><span class="line">		Integer y = <span class="number">128</span>;<span class="comment">//相当于new了一个Integer对象</span></span><br><span class="line">		System.out.println(x == y);<span class="comment">//false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充知识：搞懂Java集合类，参照文章<a href="https://mp.weixin.qq.com/s/8EeWLdK7UZt81sGpQZvh9A%EF%BC%8C%E6%9B%B4%E5%A4%9A%E5%86%85%E5%AE%B9%E7%9C%8B%E5%85%AC%E4%BC%97%E5%8F%B7%E3%80%82">https://mp.weixin.qq.com/s/8EeWLdK7UZt81sGpQZvh9A，更多内容看公众号。</a></p>
<h2 id="2-单例（Singleton）设计模式"><a href="#2-单例（Singleton）设计模式" class="headerlink" title="2.单例（Singleton）设计模式"></a>2.单例（Singleton）设计模式</h2><p>什么是设计模式？</p>
<p>设计 模式 是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式 。 设</p>
<p>计模免去我们自己再思考和摸索 。就 像是经典的棋谱，不同的棋局，我们用不同 的 棋谱。</p>
<p>简而言之，就两字，<strong>“套路”</strong>。</p>
<p>设计模式和算法一样，也是语言无关的。用Java较多。</p>
<p>入门可以参考大话设计模式。</p>
<p>所谓 类的<strong>单例设计模式</strong>，就是采取一定的方法保证在整个的软件系统中，对某个类 只能存在<strong>一个对象实例</strong> ，</p>
<p>并且该类只提供<strong>一个</strong>取得其对象实例的方法。</p>
<p>如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的<strong>构造器的访问权限设置为 private</strong> ，这样，就不能用 new 操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能调用<strong>该类的某个静态方法</strong>以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的 <strong>该类对象的变量也必须定义成静态的</strong> 。</p>
<p><strong>单例模式分为两种：饿汉式和懒汉式。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bank bank1 = Bank.getInstance();</span><br><span class="line">        Bank bank2 = Bank.getInstance();</span><br><span class="line">        System.out.println(bank1 == bank2);</span><br><span class="line"></span><br><span class="line">        Order order1 = Order.getInstance();</span><br><span class="line">        Order order2 = Order.getInstance();</span><br><span class="line">        System.out.println(order1 == order2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 饿汉式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.私有化构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Bank</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.内部创建类的对象，必须是静态的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bank instance = <span class="keyword">new</span> Bank();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.提供公有静态方法，返回类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒汉式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.私有化构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Order</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.声明当前类对象，没有初始化，必须是静态的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Order instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.提供公有静态方法，返回类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Order();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对比</strong></p>
<ol>
<li>饿汉式：</li>
</ol>
<p>坏处：对象加载时间过长。</p>
<p>好处：饿汉式是线程安全的。</p>
<ol start="2">
<li>懒汉式：</li>
</ol>
<p>好处：延迟对象的创建。</p>
<p>目前的懒汉式写法坏处：线程不安全。—&gt;到多线程内容时，再修改</p>
<p><img src="/posts/ac5bd4a1/image-20210502094523609.png" alt="image-20210502094523609"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程详解笔记（一）</title>
    <url>/posts/8083204b.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-线程简介"><a href="#1-线程简介" class="headerlink" title="1.线程简介"></a>1.线程简介</h2><p>参考视频：狂神多线程详解，尚硅谷Java入门视频。</p>
<p>学习建议：先学完IO流再来学习多线程。</p>
<span id="more"></span>

<p>线程（thread）</p>
<p><img src="/posts/8083204b/image-20210612193035124.png" alt="image-20210612193035124"></p>
<p>进程（process）</p>
<p><img src="/posts/8083204b/image-20210612212103470.png" alt="image-20210612212103470"></p>
<p>程序、进程和线程的区别：</p>
<p><img src="/posts/8083204b/image-20210612212228192.png" alt="image-20210612212228192"></p>
<p>通常在一个进程中可以包含若干个线程，一个进程至少有一个线程。线程数CPU调度和执行的单位。</p>
<p><img src="/posts/8083204b/image-20210612212444861.png" alt="image-20210612212444861"></p>
<p>核心概念：</p>
<p><img src="/posts/8083204b/image-20210612212658925.png" alt="image-20210612212658925"></p>
<p>一个Java应用程序Java.exe，至少有三个线程，main()主线程，gc()垃圾回收线程，异常处理线程。当然发生异常时，会影响主线程。</p>
<p>并行与并发：</p>
<p>并行： 多个 CPU 同时执行多个任务。比如：多个人同时做不同的事 。</p>
<p>并发： 一个 CPU（采用时间片）同时执行多个任务。比如：秒杀、多个人做同一件事。</p>
<p>何时需要多线程？</p>
<p>程序需要同时执行两个或多个任务。</p>
<p>程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。</p>
<p>需要一些后台运行的程序时。</p>
<h2 id="2-创建线程"><a href="#2-创建线程" class="headerlink" title="2.创建线程"></a>2.创建线程</h2><p>有三种创建线程的方式：</p>
<ol>
<li>Thread class：继承java.lang.Thread类<strong>（重点）</strong></li>
<li>Runnable接口：实现Runnable接口<strong>（重点）</strong></li>
<li>Callable接口：实现Callable接口（了解）</li>
</ol>
<h2 id="3-Thread"><a href="#3-Thread" class="headerlink" title="3.Thread"></a>3.Thread</h2><p>1.自定义线程类继承Thread类</p>
<p>2.重写run()方法，编写线程执行体</p>
<p>3.创建线程对象，调用start()方法启动线程（作用：启动当前线程，调用当前线程的run方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread_1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程方式1：创建一个继承Thread类的子类，重写run方法，通过此对象调用start启动线程</span></span><br><span class="line">    <span class="comment">// 总结：线程开启不一定立即执行，由CPU调度执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// run方法线程体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在看源码...&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// main线程，主线程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个线程对象</span></span><br><span class="line">        Thread_1 th1 = <span class="keyword">new</span> Thread_1();</span><br><span class="line">        <span class="comment">// 调用start方法，开启线程</span></span><br><span class="line">        <span class="comment">// 看源码和学多线程是并发运行的</span></span><br><span class="line">        th1.start();<span class="comment">// 并不是直接调用run方法</span></span><br><span class="line">		<span class="comment">// 不能用th1执行2次start，会报异常，需要新创建一个线程对象执行start</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在学习多线程...&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过创建Thread类的匿名子类来启动多线程</span></span><br><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">// 重写run方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure>

<p><img src="/posts/8083204b/image-20210726113402721.png" alt="image-20210726113402721"></p>
<p><img src="/posts/8083204b/image-20210726114809437.png" alt="image-20210726114809437"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">helloThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//if (i % 3 == 0)&#123;</span></span><br><span class="line">            <span class="comment">//    yield();// 释放当前CPU的执行权，可能再次抢到</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">40</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;<span class="comment">// 只能用try-catch处理异常</span></span><br><span class="line">                    sleep(<span class="number">1000</span>);<span class="comment">// 睡眠1000ms</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">helloThread</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">helloThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        helloThread h1 = <span class="keyword">new</span> helloThread();</span><br><span class="line">        helloThread h2 = <span class="keyword">new</span> helloThread(<span class="string">&quot;myThread&quot;</span>);<span class="comment">// 通过带参构造器给线程命名</span></span><br><span class="line">        h1.setName(<span class="string">&quot;helloThread&quot;</span>);<span class="comment">// 也可以通过setName方法实现</span></span><br><span class="line">        h1.start();</span><br><span class="line">        h2.start();</span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;mainThread&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">20</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    h1.join();<span class="comment">// 在线程a中调用线程b的join()</span></span><br><span class="line">                    <span class="comment">//此时线程a就进入阻塞状态，直到线程b完全执行完才结束阻塞状态</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程详解笔记（三）</title>
    <url>/posts/fd8b6fc1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-多线程安全的单例模式"><a href="#1-多线程安全的单例模式" class="headerlink" title="1.多线程安全的单例模式"></a>1.多线程安全的单例模式</h2><span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Bank</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单例模式之懒汉式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bank instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Bank <span class="title">getInstance</span><span class="params">()</span></span>&#123;<span class="comment">// 加上synchronized就线程安全</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;<span class="comment">// 保证instance只会new一次</span></span><br><span class="line">            instance = <span class="keyword">new</span> Bank();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*这样也可以，效率稍差</span></span><br><span class="line"><span class="comment">        synchronized (Bank.class)&#123;</span></span><br><span class="line"><span class="comment">            if (instance == null)&#123;// 保证instance只会new一次</span></span><br><span class="line"><span class="comment">                instance = new Bank();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            return instance;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        效率高些的方式</span></span><br><span class="line"><span class="comment">        if (instance == null)&#123;多判断一次，其余的线程不需要再等待可以直接返回</span></span><br><span class="line"><span class="comment">            if (instance == null)&#123;// 保证instance只会new一次</span></span><br><span class="line"><span class="comment">                instance = new Bank();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return instance;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-线程的死锁问题"><a href="#2-线程的死锁问题" class="headerlink" title="2.线程的死锁问题"></a>2.线程的死锁问题</h2><p>不同的线程分别占用<strong>对方需要的同步资源</strong>不放弃，都在等待对方放弃 自己需要的同步资源，就形成了线程的死锁</p>
<p>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于 阻塞状态，无法继续</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//MThread mTherad = new MThread();</span></span><br><span class="line">        <span class="comment">//Thread th1 = new Thread(mTherad);</span></span><br><span class="line">        <span class="comment">//Thread th2 = new Thread(mTherad);</span></span><br><span class="line">        <span class="comment">//th1.setName(&quot;窗口1&quot;);</span></span><br><span class="line">        <span class="comment">//th2.setName(&quot;窗口2&quot;);</span></span><br><span class="line">        <span class="comment">//th1.start();</span></span><br><span class="line">        <span class="comment">//th2.start();</span></span><br><span class="line"></span><br><span class="line">        StringBuffer s1 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        StringBuffer s2 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;<span class="comment">// 匿名类创建多线程方式1</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (s1)&#123;<span class="comment">// 同步代码块</span></span><br><span class="line">                    s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                    s2.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                    <span class="comment">// sleep增加死锁概率</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (s2)&#123;</span><br><span class="line">                        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">                        s2.append(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        System.out.println(s1);</span><br><span class="line">                        System.out.println(s2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;<span class="comment">// 匿名类创建多线程方式2</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (s2)&#123;</span><br><span class="line">                    s1.append(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">                    s2.append(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (s1)&#123;</span><br><span class="line">                        s1.append(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">                        s2.append(<span class="string">&quot;4&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        System.out.println(s1);</span><br><span class="line">                        System.out.println(s2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">// 输出</span></span><br><span class="line"><span class="comment">/*ab</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment">abcd</span></span><br><span class="line"><span class="comment">1234*/</span></span><br></pre></td></tr></table></figure>

<p>加个sleep，让死锁的概率高一点</p>
<p>第一个线程等待拿s2，第二个线程等待拿s1，出现死锁</p>
<p>我们使用同步时要避免死锁</p>
<h2 id="3-方式三：Lock锁-—-JDK5-0新增"><a href="#3-方式三：Lock锁-—-JDK5-0新增" class="headerlink" title="3.方式三：Lock锁 — JDK5.0新增"></a>3.方式三：Lock锁 — JDK5.0新增</h2><p><img src="/posts/fd8b6fc1/image-20210727105730339.png" alt="image-20210727105730339"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 1.实例化ReentrantLock</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">// 2.调用lock()上锁</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="comment">// 3.调用unlock()解锁</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread_2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        HThread mTherad = <span class="keyword">new</span> HThread();</span><br><span class="line">        Thread th1 = <span class="keyword">new</span> Thread(mTherad);</span><br><span class="line">        Thread th2 = <span class="keyword">new</span> Thread(mTherad);</span><br><span class="line">        th1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        th2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized 与 Lock的异同？</p>
<p>相同：二者都可以解决线程安全问题</p>
<p>不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器</p>
<p>Lock需要手动的启动同步（lock()，同时结束同步也需要手动的实现（unlock()）</p>
<p>建议使用顺序：</p>
<p>Lock —&gt; 同步代码块（已经进入了方法体，分配了相应资源 ) —&gt; 同步方法（在方法体之外)</p>
<h2 id="4-线程的通信"><a href="#4-线程的通信" class="headerlink" title="4.线程的通信"></a>4.线程的通信</h2><p>线程通信涉及到的三个方法<br>wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。<br>notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。<br>notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。</p>
<p>说明<br>wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。<br>wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的<strong>同步监视器</strong>。否则，会出现IllegalMonitorStateException异常。<br>wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。</p>
<p>使用两个线程打印 1-100 。线程 1, 线程 2 交替打印。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                notify();<span class="comment">// 唤醒等待的线程</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (number &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + number);</span><br><span class="line">                    number++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 使得调用如下wait()方法的线程进入阻塞状态</span></span><br><span class="line">                        wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommunicationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Number num = <span class="keyword">new</span> Number();</span><br><span class="line">        Thread th1 = <span class="keyword">new</span> Thread(num);</span><br><span class="line">        Thread th2 = <span class="keyword">new</span> Thread(num);</span><br><span class="line"></span><br><span class="line">        th1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        th2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>面试题</strong></p>
<p>sleep() 和 wait()的异同？</p>
<p>相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。<br>不同点：<br>两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()<br>调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中<br>关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。</p>
<h2 id="5-实现Callable-接口创建多线程（了解）"><a href="#5-实现Callable-接口创建多线程（了解）" class="headerlink" title="5.实现Callable 接口创建多线程（了解）"></a>5.实现Callable 接口创建多线程（了解）</h2><p><img src="/posts/fd8b6fc1/image-20210727163310166.png" alt="image-20210727163310166"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？</span></span><br><span class="line"><span class="comment"> * 1. call()可以有返回值的。</span></span><br><span class="line"><span class="comment"> * 2. call()可以抛出异常，被外面的操作捕获，获取异常的信息</span></span><br><span class="line"><span class="comment"> * 3. Callable是支持泛型的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumThread</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line">    <span class="comment">//2.实现call方法，将此线程需要执行的操作声明在call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadNew</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3.创建Callable接口实现类的对象</span></span><br><span class="line">        NumThread numThread = <span class="keyword">new</span> NumThread();</span><br><span class="line">        <span class="comment">//4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(numThread);</span><br><span class="line">        <span class="comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//6.获取Callable中call方法的返回值</span></span><br><span class="line">            <span class="comment">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span></span><br><span class="line">            Object sum = futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;总和为：&quot;</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-使用线程池创建多线程"><a href="#6-使用线程池创建多线程" class="headerlink" title="6.使用线程池创建多线程"></a>6.使用线程池创建多线程</h2><p><img src="/posts/fd8b6fc1/image-20210727171140782.png" alt="image-20210727171140782"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 提供指定线程数量的线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread());<span class="comment">// 适合Runnable</span></span><br><span class="line">        <span class="comment">//service.submit();// 适合Callable</span></span><br><span class="line">        service.shutdown();<span class="comment">// 关闭线程池</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程详解笔记（二）</title>
    <url>/posts/b095cc93.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-线程的调度"><a href="#1-线程的调度" class="headerlink" title="1.线程的调度"></a>1.线程的调度</h2><p><img src="/posts/b095cc93/image-20210726124742055.png" alt="image-20210726124742055"></p>
<p><img src="/posts/b095cc93/image-20210726124826978.png" alt="image-20210726124826978"></p>
<p>默认优先级为5。</p>
<p>获取和设置当前线程优先级。</p>
<p>获取：<code>Thread.currentThread().getPriority()</code>，和getName类似。</p>
<p>设置：<code>h1.setPriority(Thread.MAX_PRIORITY)</code>，和setName类似。</p>
<h2 id="2-实现Runnable接口创建线程"><a href="#2-实现Runnable接口创建线程" class="headerlink" title="2.实现Runnable接口创建线程"></a>2.实现Runnable接口创建线程</h2><ol>
<li><p>创建一个实现了Runnable接口的类</p>
</li>
<li><p>实现类去实现Runnable中的抽象方法：run()</p>
</li>
<li><p>创建实现类的对象</p>
</li>
<li><p>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</p>
</li>
<li><p>通过Thread类的对象调用start()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MThread mTherad = <span class="keyword">new</span> MThread();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(mTherad);</span><br><span class="line">        Thread th = <span class="keyword">new</span> Thread(mTherad);<span class="comment">// 两个线程共享一个MThread对象，数据num也是共享的</span></span><br><span class="line">        <span class="comment">// 通过继承Thread的方式创建多线程，各线程对应不同对象，数据不共享，需要加static修饰</span></span><br><span class="line">        thread.start();</span><br><span class="line">        th.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种方式的对比</p>
</li>
</ol>
<p>开发中：优先选择：实现Runnable接口的方式</p>
<p>原因：1. 实现的方式没类的单继承性的局限性</p>
<ol start="2">
<li><p>实现的方式更适合来处理多个线程共享数据的情况。</p>
<p>联系：public class Thread implements Runnable<br>相同点：两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。</p>
<pre><code>   目前两种方式，要想启动线程，都是调用的Thread类中的start()。
</code></pre>
</li>
</ol>
<p>Java中线程分为2类：守护线程和用户线程。</p>
<p>用户线程结束，守护线程也随之结束。</p>
<h2 id="3-线程的生命周期"><a href="#3-线程的生命周期" class="headerlink" title="3.线程的生命周期"></a>3.线程的生命周期</h2><p>线程的生命周期一般要经历五种状态。</p>
<p>新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建 状态</p>
<p>就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已 具备了运行的条件，只是没分配到CPU资源</p>
<p>运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线 程的操作和功能</p>
<p>阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中 止自己的执行，进入阻塞状态</p>
<p>死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</p>
<p><img src="/posts/b095cc93/image-20210726164023834.png" alt="image-20210726164023834"></p>
<h2 id="4-线程的同步"><a href="#4-线程的同步" class="headerlink" title="4.线程的同步"></a>4.线程的同步</h2><p>问题的提出？</p>
<p>多个线程执行的不确定性引起执行结果的不稳定；</p>
<p>多个线程对账本的共享，会造成操作的不完整性，会破坏数据。</p>
<p>所以需要通过线程的同步来解决多线程的安全问题。</p>
<p>问题的原因：当多条语句在操作同一个线程<strong>共享数据</strong>时，一个线程对多条语句只执行了一部分，还没有 执行完，另一个线程参与进来执行。<strong>导致共享数据的错误</strong>。</p>
<p>解决办法：对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。即使这个线程出现了阻塞，也不能让其他线程参与执行。</p>
<p><strong>Java解决方案：同步机制</strong><br>Java对于多线程的安全问题提供了专业的解决方式：同步机制</p>
<p>方式一：同步代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (对象)&#123;</span><br><span class="line">    <span class="comment">// 需要被同步的代码；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>操作共享数据的代码，即为需要被同步的代码。 –&gt;不能包含代码多了，也不能包含代码少了。</li>
<li>共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。</li>
<li><strong>同步监视器</strong>，俗称：<strong>锁</strong>。任何一个类的对象，都可以充当锁。要求：多个线程必须要共用同一把锁。</li>
<li>操作同步代码时，只能有一个线程参与，其他线程等待。相当于一个单线程，效率低但安全。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现Runnable接口的同步代码块</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();<span class="comment">// 也可以换别的对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Object obj = new Object();不能放在这里</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;<span class="comment">// 包在里面的代码是线程安全的</span></span><br><span class="line">                <span class="comment">//  改成synchronized (this) &#123;也行，this指代唯一的MThread对象</span></span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MThread mTherad = <span class="keyword">new</span> MThread();</span><br><span class="line">        Thread th1 = <span class="keyword">new</span> Thread(mTherad);</span><br><span class="line">        Thread th2 = <span class="keyword">new</span> Thread(mTherad);</span><br><span class="line">        th1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        th2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承Thread类的同步代码块</span></span><br><span class="line"><span class="comment">// 注意static Object obj = new Object();要改成静态的，保证不同线程对应的对象共用一把锁</span></span><br><span class="line"><span class="comment">// 也可以写成synchronized (helloThread.class) &#123;</span></span><br><span class="line"><span class="comment">// helloThread是Thread的子类，加上.class是Class的对象（只会加载1次），后面到反射就能理解</span></span><br></pre></td></tr></table></figure>

<p>补充：</p>
<p>在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器（锁）。</p>
<p>在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。</p>
<p>方式二：同步方法</p>
<p>如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span> <span class="params">(String name)</span></span>&#123;</span><br><span class="line">    ….</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于同步方法的总结</p>
<p>同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。</p>
<p>非静态的同步方法，同步监视器是：this（当前类的对象）</p>
<p>静态的同步方法，同步监视器是：当前类本身</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现Runnable接口的同步方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            show();</span><br><span class="line">            <span class="keyword">if</span> (ticket &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;<span class="comment">// 同步方法实现线程同步</span></span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MThread mTherad = <span class="keyword">new</span> MThread();</span><br><span class="line">        Thread th1 = <span class="keyword">new</span> Thread(mTherad);</span><br><span class="line">        Thread th2 = <span class="keyword">new</span> Thread(mTherad);</span><br><span class="line">        th1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        th2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承Thread类的同步方法</span></span><br><span class="line"><span class="comment">// 注意private static synchronized void show()要改成静态的，保证不同线程对应同一个同步方法</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常用算法刷题模板</title>
    <url>/posts/d43df4eb.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Java常用算法刷题模板"><a href="#Java常用算法刷题模板" class="headerlink" title="Java常用算法刷题模板"></a>Java常用算法刷题模板</h2><p>参考1：<a href="https://www.jianshu.com/p/11158dbc7bde">https://www.jianshu.com/p/11158dbc7bde</a></p>
<p>参考2：<a href="https://www.acwing.com/blog/content/593/">https://www.acwing.com/blog/content/593/</a></p>
<span id="more"></span>

<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><h4 id="简单输入"><a href="#简单输入" class="headerlink" title="简单输入"></a>简单输入</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner </span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"></span><br><span class="line">Scanner sc1 = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">Scanner sc2 = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line"><span class="comment">// sc2用到缓冲流，读入更快</span></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> t1, t2, t3;</span><br><span class="line">    Scanner sc1 = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    Scanner sc2 = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line"></span><br><span class="line">    t1 = System.nanoTime();</span><br><span class="line">    String next = sc1.next();</span><br><span class="line">    t2 = System.nanoTime();</span><br><span class="line">    t3 = t2 - t1;</span><br><span class="line">    System.out.println(<span class="string">&quot;sc1:&quot;</span> + t3);</span><br><span class="line">    System.out.println(next);</span><br><span class="line"></span><br><span class="line">    t1 = System.nanoTime();</span><br><span class="line">    String next2 = sc2.next();</span><br><span class="line">    t2 = System.nanoTime();</span><br><span class="line">    t3 = t2 - t1;</span><br><span class="line">    System.out.println(<span class="string">&quot;sc2:&quot;</span> + t3);</span><br><span class="line">    System.out.println(next2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*abc</span></span><br><span class="line"><span class="comment">sc1:7968695900</span></span><br><span class="line"><span class="comment">abc</span></span><br><span class="line"><span class="comment">abc</span></span><br><span class="line"><span class="comment">sc2:1945031900</span></span><br><span class="line"><span class="comment">abc*/</span></span><br></pre></td></tr></table></figure>

<h4 id="复杂输入"><a href="#复杂输入" class="headerlink" title="复杂输入"></a>复杂输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如：1,2,3,4,5</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    String str = sc.next();</span><br><span class="line">    String[] split = str.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span>[] strInt = <span class="keyword">new</span> <span class="keyword">int</span>[split.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; split.length; i++) &#123;</span><br><span class="line">        strInt[i] = Integer.parseInt(split[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(strInt));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*1,2,3,4,5</span></span><br><span class="line"><span class="comment">[1, 2, 3, 4, 5]*/</span></span><br></pre></td></tr></table></figure>

<h4 id="文件输入"><a href="#文件输入" class="headerlink" title="文件输入"></a>文件输入</h4><p> 用于大数据的读入，不用手动输入那么麻烦。BufferedInputStream缓冲流来加速，文件输入流用<strong>绝对路径</strong>，避免不必要的麻烦，要不就把资源文件放在src目录下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> </span><br><span class="line">    FileInputStream(<span class="string">&quot;E:\\input.txt&quot;</span>)));</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">        list.add(sc.nextInt());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="快速读入"><a href="#快速读入" class="headerlink" title="快速读入"></a>快速读入</h4><p>一般我常用的数据输入方法有两种，Scanner和BufferedReader。BufferedReader可以读一行，速度比Scanner快，所以数据较多的时候使用。注意BufferedReader用完记得关。</p>
<p>import建议按需单独导入，最好不要<code>import xxx.*</code>全部导入，单独导入能提高编译速度和避免命名冲突。</p>
<p><code>import java.io.BufferedReader;</code></p>
<p><code>import java.io.IOException;</code></p>
<p><code>import java.io.InputStreamReader;</code></p>
<p>应用示例见蓝桥杯十四第一题。</p>
<p><strong>Scanner</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = scan.nextInt(); <span class="comment">// String: next(), double: nextDouble()</span></span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            nums[i] = scan.nextInt();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>BufferedReader</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(reader.readLine());</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        String[] strs = reader.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            nums[i] = Integer.parseInt(strs[i]);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        reader.close(); <span class="comment">// 记得关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul>
<li><p>按照空格分割字符串</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] s=str.split(<span class="string">&quot; +&quot;</span>);</span><br><span class="line">String[] s=str.split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line"><span class="comment">// 以一个或多个空格分割</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>public int indexOf(String str)</code>：返回字符串中第一次出现str的位置；</p>
</li>
<li><p><code>public int indexOf(String str,int fromIndex)</code>：返回字符串从fromIndex开始第一次出现str的位置；</p>
</li>
<li><p><code>public String substring(int beginIndex)</code>：返回该字符串从beginIndex开始到结尾的子字符串；</p>
</li>
<li><p><code>public String substring(int beginIndex,int endIndex)</code>：返回该字符串从beginIndex开始到endsIndex结尾的子字符串；</p>
</li>
<li><p><code>public char[] toCharArray ()</code>：将此字符串转换为新的字符数组；</p>
</li>
<li><p><code>public String replace (CharSequence target, CharSequence replacement)</code>：将与target匹配的字符串使用replacement字符串替换；</p>
</li>
<li><p><code>String replaceAll(String regex, String replacement)</code>：使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String ss=str.replaceAll(<span class="string">&quot; +&quot;</span>, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">String ss=str.replaceAll(<span class="string">&quot;\\s+&quot;</span>, <span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="comment">// 二者都能把一个或多个空格换成逗号</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="大数"><a href="#大数" class="headerlink" title="大数"></a>大数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BigDecimal类型构造方法</span></span><br><span class="line">BigDecimal(<span class="keyword">double</span> val)</span><br><span class="line">          <span class="comment">//将 double 转换为 BigDecimal，后者是 double 的二进制浮点值准确的十进制表示形式。</span></span><br><span class="line">BigDecimal(<span class="keyword">int</span> val)</span><br><span class="line">          <span class="comment">//将 int 转换为 BigDecimal。</span></span><br><span class="line">BigDecimal(<span class="keyword">long</span> val)</span><br><span class="line">          <span class="comment">//将 long 转换为 BigDecimal。</span></span><br><span class="line">BigDecimal(String val)</span><br><span class="line">          <span class="comment">//将 BigDecimal 的字符串表示形式转换为 BigDecimal。</span></span><br><span class="line"><span class="comment">//BigInteger类型构造方法</span></span><br><span class="line">BigInteger(<span class="keyword">int</span> val)</span><br><span class="line">          <span class="comment">//将 int 转换为 BigInteger。</span></span><br><span class="line">BigInteger(String val)</span><br><span class="line">          <span class="comment">//将 BigDecimal 的字符串表示形式转换为 BigInteger。</span></span><br><span class="line"><span class="comment">//BigInteger转换方法</span></span><br><span class="line"><span class="function">BigInteger <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> val)</span></span></span><br><span class="line"><span class="function">          <span class="comment">//返回其值等于指定 long 的值的 BigInteger。</span></span></span><br><span class="line"><span class="function">          <span class="comment">//如：BigInteger bi1=new BigInteger(1000);</span></span></span><br><span class="line"><span class="function"><span class="comment">//通用方法</span></span></span><br><span class="line"><span class="function"><span class="title">BigInteger</span><span class="params">(BigDecimal)</span>.<span class="title">max</span><span class="params">(BigInteger(BigDecimal)</span>)</span></span><br><span class="line"><span class="function">    <span class="comment">//返回最大数</span></span></span><br><span class="line"><span class="function"><span class="title">BigInteger</span><span class="params">(BigDecimal)</span>.<span class="title">min</span><span class="params">(BigInteger(BigDecimal)</span>)</span></span><br><span class="line"><span class="function">    <span class="comment">//返回最小数</span></span></span><br><span class="line"><span class="function"><span class="title">BigInteger</span><span class="params">(BigDecimal)</span>.<span class="title">add</span><span class="params">(BigInteger(BigDecimal)</span>)</span></span><br><span class="line"><span class="function">    <span class="comment">//相当于：+</span></span></span><br><span class="line"><span class="function"><span class="title">BigInteger</span><span class="params">(BigDecimal)</span>.<span class="title">subtract</span><span class="params">(BigInteger(BigDecimal)</span>)</span></span><br><span class="line"><span class="function">    <span class="comment">//相当于：-</span></span></span><br><span class="line"><span class="function"><span class="title">BigInteger</span><span class="params">(BigDecimal)</span>.<span class="title">multiply</span><span class="params">(BigInteger(BigDecimal)</span>)</span></span><br><span class="line"><span class="function">    <span class="comment">//相当于：*</span></span></span><br><span class="line"><span class="function"><span class="title">BigInteger</span><span class="params">(BigDecimal)</span>.<span class="title">divide</span><span class="params">(BigInteger(BigDecimal)</span>)</span></span><br><span class="line"><span class="function">    <span class="comment">//相当于：/</span></span></span><br><span class="line"><span class="function"><span class="title">BigInteger</span><span class="params">(BigDecimal)</span>.<span class="title">mod</span><span class="params">(BigInteger(BigDecimal)</span>)</span></span><br><span class="line"><span class="function">    <span class="comment">//相当于：%</span></span></span><br><span class="line"><span class="function"><span class="title">BigInteger</span><span class="params">(BigDecimal)</span>.<span class="title">abs</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="comment">//返回其值是此 BigIntege(BigDecimal)r 的绝对值的 BigInteger(BigDecimal)。</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><ul>
<li><p>Calendar实例化</p>
<p>  <code>Calendar calendar = Calendar.getInstance();</code></p>
</li>
<li><p>YEAR 指示年的 get 和 set 的字段数字。</p>
</li>
<li><p>MONTH 指示月份的 get 和 set 的字段数字。</p>
</li>
<li><p>DATE 指示日的 get 和 set 的字段数字。-</p>
</li>
<li><p>HOUR get 和 set 的字段数字,指示当天中的某小时</p>
</li>
<li><p>MINUTE get 和 set 的字段数字,指示当前小时中的某分钟</p>
</li>
<li><p>SECOND get 和 set 的字段数字,指示当前分钟中的某秒</p>
</li>
<li><p>DAY_OF_MONTH get 和 set 的字段数字, 指示以月为起点过了几天。</p>
</li>
<li><p>DAY_OF_WEEK get 和 set 的字段数字, 指示以周为起点过了几天。</p>
</li>
<li><p>DAY_OF_YEAR get 和 set 的字段数字, 指示以年为起点过了几天。</p>
</li>
<li><p>DAY_OF_WEEK_IN_MONTH get 和 set 的字段数字, 指示当前月中的第几个星期。</p>
</li>
</ul>
<blockquote>
<p>public static final int SUNDAY = 1;</p>
<p>public static final int JANUARY = 0;</p>
<p>以上表示，一周的开始是周日，即为1，以此类推。</p>
<p>一年的开始是一月，即为0，所以对月的设置要 - 1，对月的读取要 + 1</p>
</blockquote>
<p>   <code>get(int field); </code>// 获取给定字段的值，field即上面的字段数字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"><span class="comment">// 设置日期为: 2020.1.21</span></span><br><span class="line">calendar.set(Calendar.YEAR, <span class="number">2020</span>);</span><br><span class="line">calendar.set(Calendar.MONTH, <span class="number">0</span>);</span><br><span class="line">calendar.set(Calendar.DAY_OF_MONTH, <span class="number">21</span>);</span><br><span class="line"><span class="comment">// 获取2020.1.21是星期几</span></span><br><span class="line">System.out.print(calendar.get(Calendar.DAY_OF_WEEK));</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">3</span> <span class="comment">// 3代表星期二</span></span><br></pre></td></tr></table></figure>

<h3 id="Calendar类与Date类的转换"><a href="#Calendar类与Date类的转换" class="headerlink" title="Calendar类与Date类的转换"></a>Calendar类与Date类的转换</h3><h4 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">  System.out.println(<span class="string">&quot;毫秒:&quot;</span>+date.getTime());<span class="comment">//输入毫秒</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//时间转字符串</span></span><br><span class="line">  SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">  String time = sdf.format(date);</span><br><span class="line">  System.out.println(<span class="string">&quot;时间转字符串:&quot;</span>+time);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//利用字符串来转时间格式（记得抛出异常）</span></span><br><span class="line">  String time02 = <span class="string">&quot;2018-09-05&quot;</span>;</span><br><span class="line">  SimpleDateFormat  sdf2 = <span class="keyword">new</span> SimpleDateFormat (<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">  Date date2 = sdf2.parse(time02);</span><br><span class="line">  System.out.println(<span class="string">&quot;字符串转时间格式：&quot;</span>+date2);</span><br></pre></td></tr></table></figure>

<h4 id="Calendar类-1"><a href="#Calendar类-1" class="headerlink" title="Calendar类"></a>Calendar类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用默认时区和语言环境获得一个日历</span></span><br><span class="line"> Calendar cal = Calendar.getInstance();</span><br><span class="line"> <span class="comment">// 赋值时年月日时分秒常用的6个值，注意月份下标从0开始，所以取月份要+1</span></span><br><span class="line"> System.out.println(<span class="string">&quot;年:&quot;</span> + cal.get(Calendar.YEAR));</span><br><span class="line"> System.out.println(<span class="string">&quot;月:&quot;</span> + (cal.get(Calendar.MONTH) + <span class="number">1</span>));</span><br><span class="line"> System.out.println(<span class="string">&quot;日:&quot;</span> + cal.get(Calendar.DAY_OF_MONTH));</span><br><span class="line"> System.out.println(<span class="string">&quot;时:&quot;</span> + cal.get(Calendar.HOUR_OF_DAY));</span><br><span class="line"> System.out.println(<span class="string">&quot;分:&quot;</span> + cal.get(Calendar.MINUTE));</span><br><span class="line"> System.out.println(<span class="string">&quot;秒:&quot;</span> + cal.get(Calendar.SECOND));</span><br><span class="line"></span><br><span class="line"> <span class="comment">//手动设置某个日期</span></span><br><span class="line"> Calendar cal02 = Calendar.getInstance();</span><br><span class="line"> <span class="comment">//注意，设置时间的时候月份的下标是在0开始的</span></span><br><span class="line"> <span class="comment">//设置时间不一定要这6个参数3个参数也是可以的</span></span><br><span class="line"> cal02.set(<span class="number">2018</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//二零一八年十月一号十二点</span></span><br><span class="line"> System.out.println(cal02.getTime());<span class="comment">//getTime()返回Date类型</span></span><br></pre></td></tr></table></figure>

<h4 id="Calendar转换为Date"><a href="#Calendar转换为Date" class="headerlink" title="Calendar转换为Date"></a>Calendar转换为Date</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar cal = Calendar.getInstance();</span><br><span class="line">Date date = cal.getTime();</span><br><span class="line">SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">String s = simpleDateFormat.format(date);</span><br><span class="line">System.out.println(<span class="string">&quot;时间为====&quot;</span>+s);</span><br></pre></td></tr></table></figure>

<h4 id="Date转换为Calendar"><a href="#Date转换为Calendar" class="headerlink" title="Date转换为Calendar"></a>Date转换为Calendar</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date2 = <span class="keyword">new</span> Date();</span><br><span class="line">Calendar cal2 = Calendar.getInstance();</span><br><span class="line">cal2.setTime(date2);</span><br><span class="line">System.out.println(cal2.get(Calendar.YEAR) +<span class="string">&quot;-&quot;</span>+(cal2.get(Calendar.MONTH)+<span class="number">1</span>)+<span class="string">&quot;-&quot;</span>+cal2.get(Calendar.DATE));</span><br></pre></td></tr></table></figure>

<p>例题：</p>
<p>从键盘输入一个日期，格式为yyyy-M-d</p>
<p>要求计算该日期与1949年10月1日距离多少天</p>
<p>例如：</p>
<p>用户输入了：1949-10-2 程序输出：1</p>
<p>用户输入了：1949-11-1 程序输出：31</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        String s = sc.next();</span><br><span class="line">        String[] str = s.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        cal.set(Integer.parseInt(str[<span class="number">0</span>]), Integer.parseInt(str[<span class="number">1</span>]) - <span class="number">1</span>, Integer.parseInt(str[<span class="number">2</span>]));</span><br><span class="line">        Calendar standard = Calendar.getInstance();</span><br><span class="line">        standard.set(<span class="number">1949</span>, <span class="number">10</span> - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> t1 = cal.getTimeInMillis();</span><br><span class="line">        <span class="keyword">long</span> t2 = standard.getTimeInMillis();</span><br><span class="line">        System.out.println((t1 - t2) / (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>常用定义：</p>
<p><code>Deque&lt;Integer&gt; q=new LinkedList&lt;Integer&gt;();</code></p>
<ul>
<li><p>LinkedList底层是链表，ArrayDeque底层是数组实现</p>
</li>
<li><p><code>offerFirst / addFirst(Object e);</code> 队首插入</p>
</li>
<li><p><code>offerLast / addLast(Object e);</code>队尾插入</p>
</li>
<li><p><code>pollFirst();</code>队首删除</p>
</li>
<li><p><code>pollLast();</code>队尾删除</p>
</li>
<li><p><code>peekFirst();</code>队首获取</p>
</li>
<li><p><code>peekLast();</code>队尾获取</p>
</li>
</ul>
<h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><h4 id="其他进制字符串-gt-十进制整数"><a href="#其他进制字符串-gt-十进制整数" class="headerlink" title="其他进制字符串-&gt;十进制整数"></a>其他进制字符串-&gt;十进制整数</h4><ul>
<li>public static Integer valueOf(int i)</li>
<li>public static Integer valueOf(String s)</li>
<li>public static Integer valueOf(String s, int radix) - radix为s字符串符合的进制</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Integer.valueOf(<span class="number">12</span>));<span class="comment">//12</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 十进制字符串 =&gt; 十进制整数</span></span><br><span class="line">System.out.println(Integer.valueOf(<span class="string">&quot;12&quot;</span>));<span class="comment">//12</span></span><br><span class="line">System.out.println(Integer.valueOf(<span class="string">&quot;12&quot;</span>,<span class="number">10</span>));<span class="comment">//12</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 二进制字符串 =&gt; 十进制整数</span></span><br><span class="line">System.out.println(Integer.valueOf(<span class="string">&quot;1100&quot;</span>, <span class="number">2</span>));<span class="comment">//12</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 8进制字符串 =&gt; 十进制整数</span></span><br><span class="line">System.out.println(Integer.valueOf(<span class="string">&quot;1100&quot;</span>, <span class="number">8</span>));<span class="comment">//576</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 16进制字符串 =&gt; 十进制整数</span></span><br><span class="line">System.out.println(Integer.valueOf(<span class="string">&quot;1100&quot;</span>, <span class="number">16</span>));<span class="comment">//4352</span></span><br></pre></td></tr></table></figure>

<p>同理，用 public static int parseInt(String s)或 public static int parseInt(String s, int radix)转换为int型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 十进制字符串 =&gt; 十进制整数</span></span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">&quot;12&quot;</span>)); <span class="comment">// 12</span></span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">&quot;12&quot;</span>, <span class="number">10</span>)); <span class="comment">// 12</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 二进制字符串 =&gt; 十进制整数</span></span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">&quot;1100&quot;</span>, <span class="number">2</span>)); <span class="comment">// 12</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 8进制字符串 =&gt; 十进制整数</span></span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">&quot;1100&quot;</span>, <span class="number">8</span>)); <span class="comment">// 576</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 16进制字符串 =&gt; 十进制整数</span></span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">&quot;1100&quot;</span>, <span class="number">16</span>)); <span class="comment">// 4352</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 32进制字符串 =&gt; 十进制整数</span></span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">&quot;1100&quot;</span>, <span class="number">32</span>)); <span class="comment">// 33792</span></span><br></pre></td></tr></table></figure>

<h4 id="十进制整数-gt-其他进制字符串"><a href="#十进制整数-gt-其他进制字符串" class="headerlink" title="十进制整数-&gt;其他进制字符串"></a>十进制整数-&gt;其他进制字符串</h4><ul>
<li>public static String toBinaryString(int i) - 转二进制</li>
<li>public static String toOctalString(int i) - 转八进制</li>
<li>public static String toHexString(int i) - 转十六进制</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">12</span>;</span><br><span class="line"><span class="comment">// 十进制整数 -&gt; 十进制字符串</span></span><br><span class="line">System.out.println(Integer.toString(n));<span class="comment">// 12</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 十进制整数 -&gt; 二进制字符串</span></span><br><span class="line">System.out.println(Integer.toString(n, <span class="number">2</span>));<span class="comment">// 1100</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 十进制整数 -&gt; 8进制字符串</span></span><br><span class="line">System.out.println(Integer.toString(n, <span class="number">8</span>));<span class="comment">// 14</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 十进制整数 -&gt; 16进制字符串</span></span><br><span class="line">System.out.println(Integer.toString(n, <span class="number">16</span>));<span class="comment">// c</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 十进制整数 -&gt; 32进制字符串</span></span><br><span class="line">System.out.println(Integer.toString(n, <span class="number">32</span>));<span class="comment">// c</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String[] arr = <span class="keyword">new</span> String[] &#123;<span class="string">&quot;3&quot;</span>, <span class="string">&quot;22&quot;</span>, <span class="string">&quot;1111&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 按照长度降序</span></span><br><span class="line">    Arrays.sort(arr, (s1, s2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> s2.length() - s1.length();</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组求和"><a href="#数组求和" class="headerlink" title="数组求和"></a>数组求和</h3><ul>
<li><p>Arrays工具类转stream再求和</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">Arrays.stream(array).sum();</span><br></pre></td></tr></table></figure>
</li>
<li><p>for loop 求和，虽然代码量比上面的大一点，但是效率比上面的高很多，建议还是使用for loop求和，别搞花里胡哨的</p>
</li>
</ul>
<h3 id="其他常用模板"><a href="#其他常用模板" class="headerlink" title="其他常用模板"></a>其他常用模板</h3><p>请参考：<a href="https://www.acwing.com/blog/content/593/">https://www.acwing.com/blog/content/593/</a></p>
<h3 id="常用刷题API"><a href="#常用刷题API" class="headerlink" title="常用刷题API"></a>常用刷题API</h3><p>参考1：<a href="https://www.cnblogs.com/chzhyang/p/13494554.html">https://www.cnblogs.com/chzhyang/p/13494554.html</a></p>
<p>参考2：<a href="https://blog.csdn.net/yubo_830/article/details/109112967">https://blog.csdn.net/yubo_830/article/details/109112967</a></p>
<h3 id="一个模板"><a href="#一个模板" class="headerlink" title="一个模板"></a>一个模板</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">    <span class="keyword">static</span> PrintWriter pw = <span class="keyword">new</span> PrintWriter(System.out);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        n = Integer.parseInt(br.readLine());<span class="comment">// 读入一整行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            String s[] = br.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> x1 = Integer.parseInt(s[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> y1 = Integer.parseInt(s[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        pw.print(res);</span><br><span class="line">        pw.flush();</span><br><span class="line">        pw.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> cnt, len;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.l = l;</span><br><span class="line">        <span class="keyword">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Seg</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Seg</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y1, y2, k;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Seg</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y1, <span class="keyword">int</span> y2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y1 = y1;</span><br><span class="line">        <span class="keyword">this</span>.y2 = y2;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Seg seg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x - seg.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Java网络编程笔记（一）</title>
    <url>/posts/7285a54.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Java网络编程"><a href="#1-Java网络编程" class="headerlink" title="1.Java网络编程"></a>1.Java网络编程</h2><p>本系列主要简单概述Java网络编程，为Java web阶段打好基础。</p>
<span id="more"></span>

<p><img src="/posts/7285a54/image-20210731213349104.png" alt="image-20210731213349104"></p>
<p><strong>实现网络通信需要解决的两个问题</strong></p>
<ol>
<li>如何准确地定位网络上一台或多台主机；定位主机上的特定的应用</li>
<li>找到主机后如何可靠高效地进行数据传输</li>
</ol>
<h2 id="2-网络通信要素"><a href="#2-网络通信要素" class="headerlink" title="2.网络通信要素"></a>2.网络通信要素</h2><p><strong>网络通信的两个要素</strong></p>
<p>对应问题一：通信双方地址，IP和端口号</p>
<p>对应问题二：提供网络通信协议：TCP/IP参考模型（应用层、传输层、网络层、物理+数据链路层）</p>
<p>网络通信协议有2套参考模型，其中OSI参考模型过于理想化，未能在因特网上进行广泛推广，TCP/IP参考模型是事实上的国际标准。</p>
<p><img src="/posts/7285a54/image-20210731214817680.png" alt="image-20210731214817680"></p>
<h3 id="通信要素一：IP和端口号"><a href="#通信要素一：IP和端口号" class="headerlink" title="通信要素一：IP和端口号"></a>通信要素一：IP和端口号</h3><p>IP的理解：</p>
<p>IP**:唯一的标识** Internet 上的计算机（通信实体）</p>
<p>在Java中使用InetAddress类代表IP</p>
<p>IP分类：IPv4 和 IPv6 ; 万维网 和 局域网</p>
<p>域名: <a href="http://www.baidu.com/">www.baidu.com</a> <a href="http://www.mi.com/">www.mi.com</a> <a href="http://www.sina.com/">www.sina.com</a> <a href="http://www.jd.com/">www.jd.com</a></p>
<p>本地回路地址：127.0.0.1 对应着：localhost</p>
<p><strong>InetAddress类</strong>:</p>
<p>此类的一个对象就代表着一个具体的IP地址。</p>
<p>实例化，没有提供公共的构造器，而是提供了如下几个静态方法来获取 InetAddress实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getByName(String host) 、 getLocalHost()</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InetAddress <span class="title">getLocalHost</span><span class="params">()</span><span class="comment">// 无参数，获取本机IP</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InetAddress <span class="title">getByName</span><span class="params">(String host)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;<span class="comment">// 类似File file = new File(&quot;hello.txt&quot;);</span></span><br><span class="line">        <span class="comment">// 方式1：IP地址</span></span><br><span class="line">        InetAddress inet1 = InetAddress.getByName(<span class="string">&quot;192.168.10.14&quot;</span>);</span><br><span class="line">        System.out.println(inet1);</span><br><span class="line">        <span class="comment">// 方式2：域名，本地主机</span></span><br><span class="line">        InetAddress inet2 = InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>);<span class="comment">// www.baidu.com</span></span><br><span class="line">        System.out.println(inet2);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常用方法，2个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getHostName() / getHostAddress()</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getHostAddress</span><span class="params">()</span>：返回 IP 地址字符串（以文本表现形式）。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getHostName</span><span class="params">()</span>：获取此 IP 地址的主机名</span></span><br><span class="line"><span class="function"><span class="comment">// -------</span></span></span><br><span class="line"><span class="function">InetAddress inet1 </span>= InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">System.out.println(inet1.getHostName());</span><br><span class="line">System.out.println(inet1.getHostAddress());</span><br><span class="line"><span class="comment">/*www.baidu.com</span></span><br><span class="line"><span class="comment">36.152.44.95*/</span></span><br></pre></td></tr></table></figure>

<p>端口号的理解：</p>
<p>正在计算机上运行的进程。</p>
<ul>
<li>要求：不同的进程不同的端口号</li>
<li>范围：被规定为一个 16 位的整数 0~65535。</li>
<li>端口号与IP地址的组合得出一个网络套接字：Socket</li>
</ul>
<p>网络编程也被称为Socket编程。</p>
<h3 id="通信要素二：网络通信协议"><a href="#通信要素二：网络通信协议" class="headerlink" title="通信要素二：网络通信协议"></a>通信要素二：网络通信协议</h3><p><img src="/posts/7285a54/image-20210731223111621.png" alt="image-20210731223111621"></p>
<p>传输层协议中有两个非常重要的协议：</p>
<p>传输控制协议 TCP(Transmission Control Protocol)</p>
<p>用户数据报协议 UDP(User Datagram Protocol) </p>
<p>这两个协议都是传输层的协议，但有所不同。</p>
<p><img src="/posts/7285a54/image-20210801125424296.png" alt="image-20210801125424296"></p>
<p>TCP的三次握手和四次挥手</p>
<p><img src="/posts/7285a54/image-20210801125823383.png" alt="image-20210801125823383"></p>
<p><img src="/posts/7285a54/image-20210801125836160.png" alt="image-20210801125836160"></p>
<p>TCP类似生活中打电话，UDP类似生活中发短信。</p>
<h3 id="TCP网络编程"><a href="#TCP网络编程" class="headerlink" title="TCP网络编程"></a>TCP网络编程</h3><p>例子1：客户端发送信息给服务端，服务端将数据显示在控制台上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现TCP的网络编程</span></span><br><span class="line"><span class="comment">// 例子1：客户端发送信息给服务端，服务端将数据显示在控制台上</span></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建Socket对象，指明服务器端的ip和端口号</span></span><br><span class="line">        InetAddress inet = InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        socket = <span class="keyword">new</span> Socket(inet,<span class="number">8899</span>);</span><br><span class="line">        <span class="comment">// 2.获取一个输出流，用于输出数据</span></span><br><span class="line">        os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 3.写出数据的操作</span></span><br><span class="line">        os.write(<span class="string">&quot;你好，我是客户端!&quot;</span>.getBytes());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 4.资源的关闭</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (os != <span class="keyword">null</span>)</span><br><span class="line">                os.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (socket != <span class="keyword">null</span>)</span><br><span class="line">                    socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="comment">// 先启动服务端，再启动客户端</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ServerSocket ss = <span class="keyword">null</span>;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    InputStream is = <span class="keyword">null</span>;</span><br><span class="line">    ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建服务器端的ServerSocket，指明自己的端口号</span></span><br><span class="line">        ss = <span class="keyword">new</span> ServerSocket(<span class="number">8899</span>);</span><br><span class="line">        <span class="comment">// 2.调用accept()表示接收来自于客户端的socket</span></span><br><span class="line">        socket = ss.accept();</span><br><span class="line">        <span class="comment">// 3.获取输入流</span></span><br><span class="line">        is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不建议这样写，可能会有乱码，字节转字符</span></span><br><span class="line">        <span class="comment">//byte[] buffer = new byte[20];</span></span><br><span class="line">        <span class="comment">//int len;</span></span><br><span class="line">        <span class="comment">//while ((len = is.read(buffer)) != -1)&#123;</span></span><br><span class="line">        <span class="comment">//    String str = new String(buffer,0,len);</span></span><br><span class="line">        <span class="comment">//    System.out.print(str);</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">// 4.读取输入流中的数据</span></span><br><span class="line">        baos = <span class="keyword">new</span> ByteArrayOutputStream();<span class="comment">// 处理乱码问题</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(baos.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;收到了来自于：&quot;</span> + socket.getInetAddress().getHostAddress() + <span class="string">&quot;的数据&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 5.关闭资源</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (baos != <span class="keyword">null</span>)</span><br><span class="line">                baos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="keyword">null</span>)</span><br><span class="line">                is.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>)</span><br><span class="line">                socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ss != <span class="keyword">null</span>)</span><br><span class="line">                ss.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子2：客户端发送文件给服务端，服务端将文件保存在本地。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子2：客户端发送文件给服务端，服务端将文件保存在本地</span></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建Socket对象，指明服务器端的ip和端口号</span></span><br><span class="line">        socket = <span class="keyword">new</span> Socket(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>),<span class="number">8899</span>);</span><br><span class="line">        <span class="comment">// 2.获取一个输出流，用于输出数据</span></span><br><span class="line">        os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 3.发送文件的操作</span></span><br><span class="line">        fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;miku.png&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 4.资源的关闭</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="keyword">null</span>)</span><br><span class="line">                fis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (os != <span class="keyword">null</span>)</span><br><span class="line">                os.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>)</span><br><span class="line">                socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="comment">// 先启动服务端，再启动客户端</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ServerSocket ss = <span class="keyword">null</span>;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    InputStream is = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建服务器端的ServerSocket，指明自己的端口号</span></span><br><span class="line">        ss = <span class="keyword">new</span> ServerSocket(<span class="number">8899</span>);</span><br><span class="line">        <span class="comment">// 2.调用accept()表示接收来自于客户端的socket</span></span><br><span class="line">        socket = ss.accept();</span><br><span class="line">        <span class="comment">// 3.获取输入流</span></span><br><span class="line">        is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.读取输入流中的数据</span></span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;test2.png&quot;</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;收到了来自于：&quot;</span> + socket.getInetAddress().getHostAddress() + <span class="string">&quot;的数据&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 5.关闭资源</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="keyword">null</span>)</span><br><span class="line">                fos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="keyword">null</span>)</span><br><span class="line">                is.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>)</span><br><span class="line">                socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ss != <span class="keyword">null</span>)</span><br><span class="line">                ss.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：io流不要重复关闭。关闭顺序要求先开后，，否则会报异常“java.io.IOException:Stream Closed”。</p>
<p>外层流关闭后内层流也会关闭。</p>
<p>例子3：客户端发送文件给服务端，服务端将文件保存在本地，并返回信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 这里应该用try-catch-finally来处理异常，这里只是简单处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    Socket socket = <span class="keyword">new</span> Socket(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>),<span class="number">9090</span>);</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    OutputStream os = socket.getOutputStream();</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;beauty.jpg&quot;</span>));</span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭数据的输出</span></span><br><span class="line">    socket.shutdownOutput();<span class="comment">// 必须加上这句，否则会陷入前面的循环出不来</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.接收来自于服务器端的数据，并显示到控制台上</span></span><br><span class="line">    InputStream is = socket.getInputStream();</span><br><span class="line">    ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="keyword">byte</span>[] bufferr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> len1;</span><br><span class="line">    <span class="keyword">while</span>((len1 = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        baos.write(buffer,<span class="number">0</span>,len1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.</span></span><br><span class="line">    fis.close();</span><br><span class="line">    os.close();</span><br><span class="line">    socket.close();</span><br><span class="line">    baos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">9090</span>);</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    Socket socket = ss.accept();</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    InputStream is = socket.getInputStream();</span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;beauty2.jpg&quot;</span>));</span><br><span class="line">    <span class="comment">//5.</span></span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;图片传输完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.服务器端给予客户端反馈</span></span><br><span class="line">    OutputStream os = socket.getOutputStream();</span><br><span class="line">    os.write(<span class="string">&quot;你好，照片我已收到，非常漂亮！&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.</span></span><br><span class="line">    fos.close();</span><br><span class="line">    is.close();</span><br><span class="line">    socket.close();</span><br><span class="line">    ss.close();</span><br><span class="line">    os.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端与服务端：</p>
<p>客户端：自定义，浏览器</p>
<p>服务端：自定义，Tomcat服务器</p>
<p>总结：</p>
<p><img src="/posts/7285a54/image-20210801214156325.png" alt="image-20210801214156325"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java网络编程笔记（二）</title>
    <url>/posts/373eb68c.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-UDP网络编程"><a href="#1-UDP网络编程" class="headerlink" title="1.UDP网络编程"></a>1.UDP网络编程</h2><span id="more"></span>

<p>类 DatagramSocket 和 DatagramPacket 实现了基于 UDP 协议网络程序。</p>
<p>UDP数据报通过数据报套接字 DatagramSocket 发送和接收，系统不保证 UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。</p>
<p>DatagramPacket 对象封装了UDP数据报，在数据报中包含了发送端的IP 地址和端口号以及接收端的IP地址和端口号。</p>
<p>UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接。如同发快递包裹一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UDP网络编程示例</span></span><br><span class="line"><span class="comment">// 发送端</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sender</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DatagramSocket socket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">    String str = <span class="string">&quot;我是UDP方式发送的信息！&quot;</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] data = str.getBytes();</span><br><span class="line">    InetAddress inet = InetAddress.getLocalHost();</span><br><span class="line">    DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(data,<span class="number">0</span>,data.length,inet,<span class="number">9090</span>);</span><br><span class="line"></span><br><span class="line">    socket.send(packet);</span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先启动接收端再启动发送端，反过来不会报异常，但接收不到数据</span></span><br><span class="line"><span class="comment">// 接收端</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiver</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(<span class="number">9090</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">    DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buffer,<span class="number">0</span>,buffer.length);</span><br><span class="line">    socket.receive(packet);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(packet.getData(),<span class="number">0</span>,packet.getLength()));</span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-URL编程"><a href="#2-URL编程" class="headerlink" title="2.URL编程"></a>2.URL编程</h2><p>URL(Uniform Resource Locator)：统一资源定位符，它表示 Internet 上某一 资源的地址。</p>
<p>URL的5个基本结构：</p>
<blockquote>
<p>示例： <a href="http://localhost:8080/examples/beauty.jpg?username=Tom">http://localhost:8080/examples/beauty.jpg?username=Tom</a></p>
<p>协议 主机名 端口名 资源地址 参数列表</p>
</blockquote>
<p><img src="/posts/373eb68c/image-20210802095227188.png" alt="image-20210802095227188"></p>
<p>如何实例化：</p>
<blockquote>
<p>URL url = new URL(“<a href="http://localhost:8080/examples/beauty.jpg?username=Tom&quot;">http://localhost:8080/examples/beauty.jpg?username=Tom&quot;</a>);</p>
</blockquote>
<p>常用方法：</p>
<p>一个URL对象生成后，其属性是不能被改变的，但可以通过它给定的方法来获取这些属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getProtocol</span><span class="params">( )</span> 获取该URL的协议名</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getHost</span><span class="params">( )</span> 获取该URL的主机名</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPort</span><span class="params">( )</span> 获取该URL的端口号</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPath</span><span class="params">( )</span> 获取该URL的文件路径</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFile</span><span class="params">( )</span> 获取该URL的文件名</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getQuery</span><span class="params">( )</span> 获取该URL的查询名</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://localhost:8080/examples/myTest.txt&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;getProtocol() :&quot;</span>+url.getProtocol());</span><br><span class="line">System.out.println(<span class="string">&quot;getHost() :&quot;</span>+url.getHost());</span><br><span class="line">System.out.println(<span class="string">&quot;getPort() :&quot;</span>+url.getPort());</span><br><span class="line">System.out.println(<span class="string">&quot;getPath() :&quot;</span>+url.getPath());</span><br><span class="line">System.out.println(<span class="string">&quot;getFile() :&quot;</span>+url.getFile());</span><br><span class="line">System.out.println(<span class="string">&quot;getQuery() :&quot;</span>+url.getQuery());</span><br><span class="line"></span><br><span class="line"><span class="comment">//=============================</span></span><br><span class="line">getProtocol() :http</span><br><span class="line">getHost() :localhost</span><br><span class="line">getPort() :<span class="number">8080</span></span><br><span class="line">getPath() :/examples/myTest.txt</span><br><span class="line">getFile() :/examples/myTest.txt</span><br><span class="line">getQuery() :<span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>URL类的异常通常用try-catch来捕获。</p>
<p>可以读取、下载对应的url资源：</p>
<p>URLConnection：表示到URL所引用的远程对象的连接。当与一个URL建立连接时， 首先要在一个 URL 对象上通过方法 openConnection() 生成对应的 URLConnection 对象。如果连接过程失败，将产生IOException.</p>
<p>通过URLConnection对象获取的输入流和输出流，即可以与现有的CGI 程序进行交互。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HttpURLConnection urlConnection = <span class="keyword">null</span>;</span><br><span class="line">    InputStream is = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://localhost:8080/examples/beauty.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line"></span><br><span class="line">        urlConnection.connect();</span><br><span class="line"></span><br><span class="line">        is = urlConnection.getInputStream();</span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;day10\\beauty3.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;下载完成&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        <span class="keyword">if</span>(is != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fos != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(urlConnection != <span class="keyword">null</span>)&#123;</span><br><span class="line">            urlConnection.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter notebook快速入门笔记</title>
    <url>/posts/c4bef09b.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Jupyter notebook是用python进行数据科学、机器学习的必备工具。</p>
<p>吴恩达的《深度学习》慕课的课后编程作业、大数据竞赛网站Kaggle上的代码文档、美国大学的数据科学课程的课后资料及编程作业，都是以jupyter notebook文件的形式给出的，也就是<code>.ipynb</code>文件。</p>
<p><a href="https://github.com/TommyZihao/zihaopython/blob/master/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%AD%A6%E4%B9%A0%E6%97%B6%E9%97%B4%E4%B8%8E%E6%88%90%E7%BB%A9%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%88%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%EF%BC%89/Jupyter%20notebook%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B.md">文章参考自TommyZihao</a></p>
<p>推荐教程：<a href="https://www.freeaihub.com/jupyter/setup.html">https://www.freeaihub.com/jupyter/setup.html</a></p>
<p>五大插件推荐：<a href="https://mp.weixin.qq.com/s/nOMQNUd8fqLXvMrRRE7q6A">https://mp.weixin.qq.com/s/nOMQNUd8fqLXvMrRRE7q6A</a></p>
<span id="more"></span>

<p>Jupyter notebook是基于Ipython内核的，在浏览器中以网页形式运行Python代码的工具，十分方便。</p>
<blockquote>
<p>Ipython是啥？</p>
<p>Ipython可以理解成更高级的python解释器，相比原生的python交互式命令行，Ipython有更强大的命令计数、自动补全等交互功能。</p>
<p>Spyder和Jupyter notebook都是以Ipython为内核的。</p>
</blockquote>
<h2 id="安装Jupyter-notebook"><a href="#安装Jupyter-notebook" class="headerlink" title="安装Jupyter notebook"></a>安装Jupyter notebook</h2><p>如果你安装了python数据科学全家桶Anaconda，那么其中自带了Jupyter notebook。</p>
<p>如果你没安装Anaconda，可以直接在命令行里运行这行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install jupyter -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br></pre></td></tr></table></figure>

<h2 id="运行Jupyter-notebook"><a href="#运行Jupyter-notebook" class="headerlink" title="运行Jupyter notebook"></a>运行Jupyter notebook</h2><p>打开命令行，通过cd命令切换到指定文件路径下，输入<code>jupter notebook</code>，回车。稍等片刻即可跳出浏览器网页。如果没有跳转浏览器，也可以手动复制链接到浏览器打开。</p>
<p><img src="/posts/c4bef09b/image-20210306224106698.png" alt="image-20210306224106698"></p>
<h2 id="主要操作界面"><a href="#主要操作界面" class="headerlink" title="主要操作界面"></a>主要操作界面</h2><p><img src="/posts/c4bef09b/image-20210307180617165.png" alt="image-20210307180617165"></p>
<p><img src="/posts/c4bef09b/image-20210307181033194.png" alt="image-20210307181033194"></p>
<p><img src="/posts/c4bef09b/image-20210307180926021.png" alt="image-20210307180926021"></p>
<p>点击右边的New-Python3即可创建python文档。</p>
<p>点击New-Folder可以创建新文件夹。</p>
<p>点击New-Text File可以创建空的<code>.txt</code>文件。</p>
<p>点击New-Terminal可以打开操作系统命令行，你可以使用操作系统对应的命令行进行目录切换、解压文件等操作。</p>
<p>勾选文件夹，点击rename即可重命名。</p>
<h2 id="蓝绿两模式：命令模式、编辑模式"><a href="#蓝绿两模式：命令模式、编辑模式" class="headerlink" title="蓝绿两模式：命令模式、编辑模式"></a>蓝绿两模式：命令模式、编辑模式</h2><p>Jupyter notebook中，代码和文档都存在于一个个单元格中，每个单元格都有蓝色和绿色两种状态。</p>
<ul>
<li>命令模式（蓝色）：用于执行键盘输入的快捷命令（新增单元格、剪切、复制等等）。通过 <code>Esc</code> 键从绿色的编辑模式切换到蓝色的命令模式，此时单元左侧显示蓝色竖线。</li>
<li>编辑模式（绿色）：编辑文本和代码。选中单元并按 <code>Enter</code> 键进入编辑模式，此时单元左侧显示绿色竖线。</li>
</ul>
<blockquote>
<p>命令模式和编辑模式，其实是源自于著名的vim编辑器，vim编辑器以特别难学和学成之后可以超神而闻名于世。</p>
</blockquote>
<h2 id="两种单元格：代码单元格和Markdown单元格"><a href="#两种单元格：代码单元格和Markdown单元格" class="headerlink" title="两种单元格：代码单元格和Markdown单元格"></a>两种单元格：代码单元格和Markdown单元格</h2><p>Jupyter notebook中，有两种单元格：代码单元格和Markdown单元格。</p>
<ul>
<li>代码单元格：这里是你编写代码的地方，通过按 <code>Shift + Enter</code> 运行代码，其结果显示在本单元下方。代码单元左边有 <code>In [1]:</code> 这样的序列标记，方便人们查看代码的执行次序。在<strong>蓝色命令模式下，按<code>y</code>键</strong>可以将Markdown单元格转换为代码单元格。</li>
<li>Markdown 单元格：在这里对文本进行编辑，采用 markdown 的语法规范，可以设置文本格式、插入链接、图片甚至数学公式。同样使用 <code>Shift + Enter</code> 运行 markdown 单元来显示渲染后的文本。在<strong>蓝色命令模式下按<code>m</code>键</strong>可以将代码单元格转换为Markdown单元格。</li>
</ul>
<blockquote>
<p>Markdown是程序员通用的撰写文档的语法，可以轻松实现标题、引用、链接、图片等，非常简洁易学，Github代码托管网站、有道云笔记、简书、知乎、CSDN论坛、电子邮件等都支持Markdown语法。</p>
<p>学习Markdown，推荐博客和视频教程：</p>
<p><a href="https://www.jianshu.com/p/4475b9d8810f">二十分钟精通排版神器Markdown，从此word和秀米是路人</a></p>
<p><a href="https://www.bilibili.com/video/av35579542">Bilibili视频：二十分钟精通排版神器Markdown</a></p>
</blockquote>
<h2 id="抛弃鼠标，只用键盘"><a href="#抛弃鼠标，只用键盘" class="headerlink" title="抛弃鼠标，只用键盘"></a>抛弃鼠标，只用键盘</h2><p>下面介绍Jupyter notebook快捷键，掌握这些快捷键之后，你将彻底解放你拿鼠标的那只手，更专注、高效地敲代码了。在文件操作界面按<code>h</code>键可以查看全部快捷键。</p>
<h2 id="最常用快捷键（必会）"><a href="#最常用快捷键（必会）" class="headerlink" title="最常用快捷键（必会）"></a>最常用快捷键（必会）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">h 查看所有快捷键</span><br><span class="line"></span><br><span class="line">Enter 从命令模式进入编辑模式</span><br><span class="line"></span><br><span class="line">Esc 从编辑模式退回到命令模式</span><br><span class="line"></span><br><span class="line">m 将代码单元格转换为Markdown单元格</span><br><span class="line"></span><br><span class="line">y 将Markdown单元格转换为代码单元格</span><br><span class="line"></span><br><span class="line">shift+Enter 运行本单元格，选择下面的代码块</span><br><span class="line"></span><br><span class="line">ctrl+Enter 运行本单元格</span><br><span class="line"></span><br><span class="line">alt+Enter 运行本单元格，在下方新建一个单元格</span><br><span class="line"></span><br><span class="line">a 在上方新建一个单元格（above）</span><br><span class="line"></span><br><span class="line">b 在下方新建一个单元格（below）</span><br><span class="line"></span><br><span class="line">d 删除选中的单元格（delete）</span><br><span class="line"></span><br><span class="line">x 剪切本单元格</span><br><span class="line"></span><br><span class="line">c 复制本单元格</span><br><span class="line"></span><br><span class="line">shift v 粘贴到上面</span><br><span class="line"></span><br><span class="line">v 粘贴到下面</span><br><span class="line"></span><br><span class="line">l 显示代码行号</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Jupyter notebook</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Latex常用语法总结</title>
    <url>/posts/fcaedc74.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>文章开头加上一句：<code>mathjax: true</code>，即可启动Latex渲染。</p>
<span id="more"></span>

<p>1.打出斜体：$O(n)$,<code>$O(n)$</code></p>
<p>2.打出根号：$\sqrt n$ ,<code>$\sqrt n$</code></p>
<p>3.打出上标（单字符）：A$^2$,<code>A$^2$</code></p>
<p>4.打出上标（多字符）：A$^{mod}$,<code>A$^&#123;mod&#125;$</code></p>
<p>5.打出下标（单字符）：A$_2$,<code>A$_2$</code></p>
<p>6.打出下标（多字符）：A$_{mod}$,<code>A$_&#123;mod&#125;$</code></p>
<p>7.打出log对数：$\log_ax$，<code>$\log_ax$</code>;    $\ln x$，<code>\ln x$</code>;    $\lg x$,<code>$\lg x$</code></p>
<p>8.打出正上方的上标：$\bar a$,<code>$\bar a$</code></p>
<p>9.小写希腊字母：</p>
<p><img src="/posts/fcaedc74/image-20210310195229711.png" alt="image-20210310195229711"></p>
<p>10.大写希腊字母：</p>
<p><img src="/posts/fcaedc74/image-20210310195310812.png" alt="image-20210310195310812"></p>
<p>11.打出关于x的偏微分：$\partial/\partial x$,<code>$\partial/\partial x$</code>，补充一点：\partial可以简写为\part</p>
<p>12.打出除法：$\frac a b$,<code>$\frac a b$</code></p>
<p>13.求和和连乘</p>
<ul>
<li>对于连加的情况，我们通常使用$\Sigma$来表示。它的使用用法也很简单，但是通常都要添加上下标，像<code>$\sum_&#123;&#125;^&#123;&#125;$</code>形式。除了连加，我们有时也使用连乘，虽然没有连加使用得多（连乘都能通过对数写成连加），它只要以<code>$\prod_&#123;&#125;^&#123;&#125;$</code>的形式表示。</li>
</ul>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">&lt;!--连加--&gt;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span><span class="keyword">\sum</span><span class="built_in">_</span>&#123;i = 1&#125;<span class="built_in">^</span>&#123;n&#125;x<span class="built_in">_</span>i<span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"></span><br><span class="line">&lt;!--连乘--&gt;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span><span class="keyword">\prod</span><span class="built_in">_</span>&#123;i = 1&#125;<span class="built_in">^</span>&#123;n&#125;x<span class="built_in">_</span>i<span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在latex中，默认情况下行内公式都是显示像$\sum_{i = 1}^{n}x_i$的效果，如果想要这样$\displaystyle\sum_{i = 1}^{n}x_i$的效果，就需要在前面加上<code>\displaystyle</code>，来重新看一下下面的例子：</li>
</ul>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">&lt;!--连加--&gt;</span><br><span class="line"><span class="built_in">$</span><span class="keyword">\sum</span><span class="built_in">_</span>&#123;i = 1&#125;<span class="built_in">^</span>&#123;n&#125;x<span class="built_in">_</span>i<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\displaystyle</span><span class="keyword">\sum</span><span class="built_in">_</span>&#123;i = 1&#125;<span class="built_in">^</span>&#123;n&#125;x<span class="built_in">_</span>i<span class="built_in">$</span></span><br><span class="line"></span><br><span class="line">&lt;!--连乘--&gt;</span><br><span class="line"><span class="built_in">$</span><span class="keyword">\prod</span><span class="built_in">_</span>&#123;i = 1&#125;<span class="built_in">^</span>&#123;n&#125;x<span class="built_in">_</span>i<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\displaystyle</span><span class="keyword">\prod</span><span class="built_in">_</span>&#123;i = 1&#125;<span class="built_in">^</span>&#123;n&#125;x<span class="built_in">_</span>i<span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>补充：关于上下标的位置有以下三种情况</p>
<p><code>\sum\nolimits_&#123;j=1&#125;^&#123;M&#125;</code> 上下标位于求和符号的水平右端，</p>
<p><code>\sum\limits_&#123;j=1&#125;^&#123;M&#125;</code> 上下标位于求和符号的上下处，</p>
<p><code>\sum_&#123;j=1&#125;^&#123;M&#125;</code> 对上下标位置没有设定，会随公式所处环境自动调整。</p>
<p>14.无穷大：$\infty$,<code>$\infty$</code></p>
<p>正无穷大： +\infty</p>
<p>负无穷大： -\infty</p>
<p>15.极限：</p>
<p>还记得高数里极限的符号吗<img src="/posts/fcaedc74/1684731-20191002102657884-1615601426.png" alt="皱眉">。在latex中的极限表示，也直接使用<code>\lim</code>这个我们时常看到的符号。当然极限通常都是带下标的，所以更多的是使用<code>lim_&#123;&#125;</code>的形式。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">&lt;!--来看看两个重要极限--&gt;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span><span class="keyword">\displaystyle</span><span class="keyword">\lim</span><span class="built_in">_</span>&#123;x <span class="keyword">\rightarrow</span> 0&#125;<span class="keyword">\frac</span>&#123;<span class="keyword">\sin</span> x&#125;&#123;x&#125; = 1<span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span><span class="keyword">\displaystyle</span><span class="keyword">\lim</span><span class="built_in">_</span>&#123;x <span class="keyword">\rightarrow</span> + <span class="keyword">\infty</span>&#125;(1 + <span class="keyword">\frac</span>&#123;1&#125;&#123;x&#125;)<span class="built_in">^</span>x = e<span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p>$\displaystyle\lim_{x \rightarrow 0}\frac{\sin x}{x} = 1$</p>
<p>$\displaystyle\lim_{x \rightarrow + \infty}(1 + \frac{1}{x})^x = e$</p>
<ul>
<li><strong>tip1：</strong>右箭头$\rightarrow$的表示方式为<code>$\rightarrow$</code>，左箭头$\leftarrow$的表示方式是<code>$\leftarrow$</code></li>
<li><strong>tip2：</strong>正无穷$+ \infty$的表示方式为<code>$+ \infty$</code>，负无穷$- \infty$的表示方式是<code>$- \infty$</code></li>
</ul>
<p>16.积分：</p>
<p>如果想要输入积分，则需要使用<code>\int_&#123;&#125;^&#123;&#125;</code>来表示</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span><span class="keyword">\int</span><span class="built_in">_</span>0<span class="built_in">^</span>1 x<span class="built_in">^</span>2 dx<span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line">&lt;!--来看一个更加复杂的例子--&gt;</span><br><span class="line">&lt;!--正态分布的分布函数--&gt;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span>F(x) = <span class="keyword">\int</span><span class="built_in">_</span>&#123;- <span class="keyword">\infty</span>&#125;<span class="built_in">^</span>&#123;+ <span class="keyword">\infty</span>&#125; <span class="keyword">\frac</span>&#123;1&#125;&#123;<span class="keyword">\sqrt</span>&#123;2<span class="keyword">\pi</span>&#125;<span class="keyword">\sigma</span>&#125;e<span class="built_in">^</span>&#123;-(<span class="keyword">\frac</span>&#123;x-<span class="keyword">\mu</span>&#125;&#123;<span class="keyword">\sigma</span>&#125;)<span class="built_in">^</span>2&#125; dx<span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p>$\int_0^1 x^2 dx$</p>
<p>$F(x) = \int_{- \infty}^{+ \infty} \frac{1}{\sqrt{2\pi}\sigma}e^{-(\frac{x-\mu}{\sigma})^2} dx$</p>
<p>17.求导：</p>
<p>使用<code>$\mathrm&#123;d&#125;$</code>来表示求导符号，<code>$\partial$</code>来表示求偏导</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\frac</span> &#123;<span class="keyword">\mathrm</span>&#123;d&#125;L(<span class="keyword">\beta</span>)&#125;&#123;<span class="keyword">\beta</span>&#125;<span class="built_in">$</span></span><br><span class="line"></span><br><span class="line">&lt;!--直接用d来表示求导符的效果--&gt;</span><br><span class="line"><span class="built_in">$</span><span class="keyword">\frac</span> &#123;dL(<span class="keyword">\beta</span>)&#125;&#123;<span class="keyword">\beta</span>&#125;<span class="built_in">$</span></span><br><span class="line"></span><br><span class="line">&lt;!--偏导--&gt;</span><br><span class="line"><span class="built_in">$</span><span class="keyword">\frac</span> &#123;<span class="keyword">\partial</span> L(<span class="keyword">\beta</span><span class="built_in">_</span>0, <span class="keyword">\beta</span><span class="built_in">_</span>1)&#125;&#123;<span class="keyword">\partial</span> <span class="keyword">\beta</span><span class="built_in">_</span>0&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p>$\frac {\mathrm{d}L(\beta)}{\beta}$</p>
<p>$\frac {dL(\beta)}{\beta}$</p>
<p>$\frac {\partial L(\beta_0, \beta_1)}{\partial \beta_0}$</p>
<p>18.打出空格：$a \ b$,<code>$a \ b$</code></p>
<p>19.打出向上向下取整符号：</p>
<p>上取整$\lceil x \rceil$(表示不小于x的最小整数),<code>$\lceil x \rceil$</code></p>
<p>下取整$\lfloor x \rfloor$(表示不大于x的最大整数),<code>$\lfloor x \rfloor$</code></p>
<p>20.打出实数集符号：$\mathbb{R}$，<code>$\mathbb&#123;R&#125;$</code>;$\mathbb{R}^{n}$,<code>$\mathbb&#123;R&#125;^&#123;3&#125;$</code></p>
<p>21.打出换行符号（PS：空格或enter是没用的）：$a\b$，<code>$a\\b$</code></p>
<p>22.方程组的排版：<a href="https://blog.csdn.net/weixin_45744426/article/details/102531827">https://blog.csdn.net/weixin_45744426/article/details/102531827</a></p>
<p>一个示范：$\begin{array}{l}x=x_0+k<em>b^{‘}\ y=y_0-k</em>a^{‘}\end{array}$，无花括号版本的，begin的参数可以选择l、r和c，表示左、右和居中对齐。</p>
<p>23.打出恒等号：$\equiv$，<code>$\equiv$</code></p>
<p>24.打出空格：$a;b$，<code>$a\;b$</code></p>
<p>25.打出整除与不整除：$a\mid b,c\nmid d$，<code>$a\mid b,c\nmid d$</code></p>
]]></content>
      <categories>
        <category>Latex</category>
      </categories>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode刷题笔记</title>
    <url>/posts/2b46d45c.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><span id="more"></span>



<embed src="/file/LeetCodeGuide.pdf" width="105%" height="750" type="application/pdf">]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab快速入门笔记</title>
    <url>/posts/284e5fc1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-初始Matlab"><a href="#1-初始Matlab" class="headerlink" title="1.初始Matlab"></a>1.初始Matlab</h2><p><img src="/posts/284e5fc1/image-20210307201346455.png" alt="image-20210307201346455"></p>
<p>点击新建脚本即创建<code>.m</code>文件。</p>
<span id="more"></span>

<p><strong>命令行窗口</strong></p>
<p><img src="/posts/284e5fc1/image-20210307202741592.png" alt="按向上箭头弹出历史命令"></p>
<p><code>clear</code>：清空工作区</p>
<p><code>clc</code>：清空命令行</p>
<h2 id="2-Matlab帮助系统"><a href="#2-Matlab帮助系统" class="headerlink" title="2.Matlab帮助系统"></a>2.Matlab帮助系统</h2><p><img src="/posts/284e5fc1/image-20210307203526202.png" alt="image-20210307203526202"></p>
<h3 id="查询函数："><a href="#查询函数：" class="headerlink" title="查询函数："></a>查询函数：</h3><p><img src="/posts/284e5fc1/image-20210307203605322.png" alt="image-20210307203605322"></p>
<h3 id="在线查询："><a href="#在线查询：" class="headerlink" title="在线查询："></a>在线查询：</h3><p><img src="/posts/284e5fc1/image-20210307205132363.png" alt="image-20210307205132363"></p>
<h3 id="模糊搜索："><a href="#模糊搜索：" class="headerlink" title="模糊搜索："></a>模糊搜索：</h3><p><img src="/posts/284e5fc1/image-20210307205443076.png" alt="image-20210307205443076"></p>
<h3 id="内存变量列表（who）："><a href="#内存变量列表（who）：" class="headerlink" title="内存变量列表（who）："></a>内存变量列表（who）：</h3><h3 id="内存变量信息（whos）："><a href="#内存变量信息（whos）：" class="headerlink" title="内存变量信息（whos）："></a>内存变量信息（whos）：</h3><p><img src="/posts/284e5fc1/image-20210307210116394.png" alt="image-20210307210116394"></p>
<p>Matlab的最小数据单元就是矩阵，所以size为1*1.</p>
<h3 id="变量检测函数（exist）："><a href="#变量检测函数（exist）：" class="headerlink" title="变量检测函数（exist）："></a>变量检测函数（exist）：</h3><p><img src="/posts/284e5fc1/image-20210307210444329.png" alt="image-20210307210444329"></p>
<h3 id="文件操作："><a href="#文件操作：" class="headerlink" title="文件操作："></a>文件操作：</h3><p><img src="/posts/284e5fc1/image-20210307211255022.png" alt="image-20210307211255022"></p>
<h2 id="3-基础知识"><a href="#3-基础知识" class="headerlink" title="3.基础知识"></a>3.基础知识</h2><p>MATLAB的代码执行如果返回结果但是没有写变量来保存 默认保存在 ans 变量中 。</p>
<p>注意：自己定义变量最好不要命名为ans。</p>
<h3 id="3-1命令"><a href="#3-1命令" class="headerlink" title="3.1命令"></a>3.1命令</h3><p><img src="/posts/284e5fc1/image-20210307212506649.png" alt="image-20210307212506649"></p>
<p><img src="/posts/284e5fc1/image-20210307213023170.png" alt="image-20210307213023170"></p>
<p><img src="/posts/284e5fc1/image-20210307213045734.png" alt="image-20210307213045734"></p>
<p><img src="/posts/284e5fc1/image-20210307213914912.png" alt="image-20210307213914912"></p>
<h3 id="3-2数据类型"><a href="#3-2数据类型" class="headerlink" title="3.2数据类型"></a>3.2数据类型</h3><p><img src="/posts/284e5fc1/image-20210307214128238.png" alt="image-20210307214128238"></p>
<p><img src="/posts/284e5fc1/image-20210307214034914.png" alt="image-20210307214034914"></p>
<p>常量：</p>
<p><img src="/posts/284e5fc1/image-20210307214359948.png" alt="image-20210307214359948"></p>
<p>注意：Matlab可以改变常量的值</p>
<p><img src="/posts/284e5fc1/image-20210307214721096.png" alt="image-20210307214721096"></p>
<p>数值类型包括整型、 浮点型 、 符号型 、 复数类型等 。</p>
<p><img src="/posts/284e5fc1/image-20210307215356971.png" alt="image-20210307215356971"></p>
<p><img src="/posts/284e5fc1/image-20210307215409394.png" alt="image-20210307215409394"></p>
<p>复数：与实数类似，虚数单位用 i 表示即可 。</p>
]]></content>
      <categories>
        <category>Matlab</category>
      </categories>
      <tags>
        <tag>Matlab入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab快速入门笔记（二）</title>
    <url>/posts/ebd04ff8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-迭代法求解线性方程组"><a href="#1-迭代法求解线性方程组" class="headerlink" title="1.迭代法求解线性方程组"></a>1.迭代法求解线性方程组</h2><h3 id="1-1雅可比（Jacobi）迭代法"><a href="#1-1雅可比（Jacobi）迭代法" class="headerlink" title="1.1雅可比（Jacobi）迭代法"></a>1.1雅可比（Jacobi）迭代法</h3><span id="more"></span>

<p><img src="/posts/ebd04ff8/image-20210410224045532.png" alt="image-20210410224045532"></p>
<p><img src="/posts/ebd04ff8/image-20210410224307814.png" alt="image-20210410224307814"></p>
<p>triu用于生成矩阵A的上三角部分的矩阵（其余部分为0），用法基本同tril。</p>
<p><img src="/posts/ebd04ff8/image-20210410225034024.png" alt="image-20210410225034024"></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">X</span> = <span class="title">Jacobi</span><span class="params">(A,b,k)</span></span></span><br><span class="line">D = <span class="built_in">diag</span>(<span class="built_in">diag</span>(A));  <span class="comment">%对角矩阵</span></span><br><span class="line">L = -( <span class="built_in">tril</span>(A) - <span class="built_in">diag</span>(<span class="built_in">diag</span>(A)) ); <span class="comment">%下三角矩阵</span></span><br><span class="line">U = -( <span class="built_in">triu</span>(A) - <span class="built_in">diag</span>(<span class="built_in">diag</span>(A)) ); <span class="comment">%上三角矩阵</span></span><br><span class="line">X = <span class="built_in">zeros</span>(<span class="built_in">length</span>(A),<span class="number">1</span>);</span><br><span class="line">X_New = <span class="built_in">zeros</span>(<span class="built_in">length</span>(A),<span class="number">1</span>);</span><br><span class="line"><span class="built_in">i</span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">i</span>&lt;k</span><br><span class="line">    X_New = D\((L+U)*X) + D\b;</span><br><span class="line">    X = X_New;</span><br><span class="line">    <span class="built_in">i</span> = <span class="built_in">i</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/ebd04ff8/image-20210410231824380.png" alt="image-20210410231824380"></p>
<p>注意：</p>
<ul>
<li>源文件中命令不以分号结尾会显示结果在命令行中，加上就不显示。</li>
<li>函数名与文件名必须相同。</li>
</ul>
<h3 id="1-2高斯-塞德尔-Gauss-Seidel-迭代法"><a href="#1-2高斯-塞德尔-Gauss-Seidel-迭代法" class="headerlink" title="1.2高斯-塞德尔(Gauss-Seidel)迭代法"></a>1.2高斯-塞德尔(Gauss-Seidel)迭代法</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">X</span> = <span class="title">Gauss_Seidel</span><span class="params">(A,b,k)</span></span></span><br><span class="line">D = <span class="built_in">diag</span>(<span class="built_in">diag</span>(A));  <span class="comment">%对角矩阵</span></span><br><span class="line">L = -( <span class="built_in">tril</span>(A) - <span class="built_in">diag</span>(<span class="built_in">diag</span>(A)) ); <span class="comment">%下三角矩阵</span></span><br><span class="line">U = -( <span class="built_in">triu</span>(A) - <span class="built_in">diag</span>(<span class="built_in">diag</span>(A)) ); <span class="comment">%上三角矩阵</span></span><br><span class="line">X = <span class="built_in">zeros</span>(<span class="built_in">length</span>(A),<span class="number">1</span>);</span><br><span class="line">X_New = <span class="built_in">zeros</span>(<span class="built_in">length</span>(A),<span class="number">1</span>);</span><br><span class="line"><span class="built_in">i</span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">i</span>&lt;k</span><br><span class="line">    X_New = (D-L)\(U*X) + (D-L)\b;</span><br><span class="line">    X = X_New;</span><br><span class="line">    <span class="built_in">i</span> = <span class="built_in">i</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Matlab</category>
      </categories>
      <tags>
        <tag>Matlab入门</tag>
        <tag>迭代法</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习笔记（一）</title>
    <url>/posts/ec3642b8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-什么是数据库？"><a href="#1-什么是数据库？" class="headerlink" title="1.什么是数据库？"></a>1.什么是数据库？</h2><p>DataBase，数据仓库，用于存储有组织的数据。</p>
<p>数据库分类：</p>
<ol>
<li><p>关系型数据库：MySQL，Oracle，…</p>
<ul>
<li><p>SQL</p>
</li>
<li><p>RDBMS，即关系数据库管理系统(Relational Database Management System)</p>
</li>
<li><p>通过表和表之间，行和列之间的关系进行数据的存储，如学员信息表</p>
</li>
</ul>
</li>
<li><p>非关系型数据库：Redis，MongDB，…</p>
<ul>
<li><p>NoSQL，Not Only SQL</p>
</li>
<li><p>通过对象存储，由对象自身属性来决定。</p>
</li>
</ul>
</li>
</ol>
<span id="more"></span>

<p>DBMS：数据库管理系统</p>
<p>它是数据库的管理软件，通过DBMS来操作管理数据库</p>
<p>软件安装建议：</p>
<p>尽量不要安装exe，卸载时会有注册表残留，尽可能使用压缩包安装，卸载方便</p>
<h2 id="2-MySQL入门使用"><a href="#2-MySQL入门使用" class="headerlink" title="2.MySQL入门使用"></a>2.MySQL入门使用</h2><p>安装MySQL直接百度教程就行。</p>
<p>打开cmd命令行，输入<code>mysql -u root -p</code>，然后输入密码，进入mysql。</p>
<p><img src="/posts/ec3642b8/image-20210503122112663.png" alt="image-20210503122112663"></p>
<p>然后是安装SQLyog，建议看我的另一篇<a href="https://grant1499.github.io/2021/04/27/%E4%BD%BF%E7%94%A8SQL%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%B7%A5%E5%85%B7/">文章</a>。</p>
<p>新建一个数据库school，名称随意。</p>
<p>在<code>root@localhost</code>处右键创建数据库，然后填入名称，选择字符集、排序规则，<strong>注意不要选错</strong>。</p>
<p><img src="/posts/ec3642b8/image-20210503123218934.png" alt="image-20210503123218934"></p>
<p>右键–&gt;创建表。</p>
<p><img src="/posts/ec3642b8/image-20210503123942013.png" alt="image-20210503123942013"></p>
<p>填入信息。</p>
<p><img src="/posts/ec3642b8/image-20210503124527839.png" alt="image-20210503124527839"></p>
<p>查看表：</p>
<p>选中左侧表下属的student，打开表。</p>
<p>尝试添加删除数据：</p>
<p><img src="/posts/ec3642b8/image-20210503125105714.png" alt="image-20210503125105714"></p>
<h2 id="3-连接数据库"><a href="#3-连接数据库" class="headerlink" title="3.连接数据库"></a>3.连接数据库</h2><p>在cmd中输入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span>mysql <span class="operator">-</span>uroot <span class="operator">-</span>p你的密码 <span class="comment">--连接数据库</span></span><br><span class="line"><span class="comment">-------------------------------</span></span><br><span class="line"><span class="comment">--注意：所有的语句都用;结尾</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> databases;<span class="comment">--查看所有的数据库</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> Database           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> information_schema <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> bipowernode        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> performance_schema <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> school             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sys                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> use school<span class="comment">--使用切换数据库，use 数据库名</span></span><br><span class="line">Database changed</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;<span class="comment">--查看当前数据库所有的表</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_school <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span> student          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">describe</span> student;<span class="comment">--查看查看当前数据库所有表的信息</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type         <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> <span class="type">int</span>(<span class="number">10</span>)      <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">100</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> age   <span class="operator">|</span> <span class="type">int</span>(<span class="number">3</span>)       <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> database school;<span class="comment">--创建一个数据库</span></span><br><span class="line"><span class="comment">-----------------------------------</span></span><br><span class="line">mysql<span class="operator">&gt;</span> exit;<span class="comment">--退出连接</span></span><br><span class="line"><span class="comment">--单行注释（SQL本来的注释）</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">SQL的多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>对于SQLyog的操作：选中语句执行</p>
<p><img src="/posts/ec3642b8/image-20210503134031081.png" alt="image-20210503134031081"></p>
<h2 id="4-数据库的四种语言"><a href="#4-数据库的四种语言" class="headerlink" title="4.数据库的四种语言"></a>4.数据库的四种语言</h2><p>CRUD：增删改查</p>
<ol>
<li>DDL： 数据库定义语言</li>
<li>DML：数据库操作语言</li>
<li>DQL： 数据库查询语言</li>
<li>DCL：  数据库控制语言</li>
</ol>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习笔记（三）</title>
    <url>/posts/913e0d32.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-创建数据库表"><a href="#1-创建数据库表" class="headerlink" title="1.创建数据库表"></a>1.创建数据库表</h2><span id="more"></span>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 注意：表的名称和字段尽量用``包起来</span></span><br><span class="line"><span class="comment">-- 字符串使用单引号括起来！（双引号也行）</span></span><br><span class="line"><span class="comment">-- 所有语句后面加,最后一个不用</span></span><br><span class="line"><span class="comment">-- primary key，主键一般一张表一个</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `student` (</span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;学号&#x27;</span>,</span><br><span class="line">`name` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;匿名&#x27;</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">`pwd` <span class="type">VARCHAR</span>(<span class="number">15</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;12345&#x27;</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">`gender` <span class="type">VARCHAR</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;女&#x27;</span> COMMENT <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">`birthday` DATETIME <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;出生日期&#x27;</span>,</span><br><span class="line">`address` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;家庭住址&#x27;</span>,</span><br><span class="line">`email` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(`id`)</span><br><span class="line">)ENGINE <span class="operator">=</span> INNODB <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8</span><br></pre></td></tr></table></figure>

<h2 id="2-三个常用命令"><a href="#2-三个常用命令" class="headerlink" title="2.三个常用命令"></a>2.三个常用命令</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看数据库和表的创建语句</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE school</span><br><span class="line"><span class="comment">-- CREATE DATABASE `school` /*!40100 DEFAULT CHARACTER SET utf8 */</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student`</span><br><span class="line"><span class="comment">-- CREATE TABLE IF NOT EXISTS `student`(XXX)XXX</span></span><br><span class="line"><span class="keyword">DESC</span> student</span><br><span class="line"><span class="comment">-- 查看表的结构</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/913e0d32/image-20210504173551477.png" alt="image-20210504173551477"></p>
<h2 id="3-数据表的类型"><a href="#3-数据表的类型" class="headerlink" title="3.数据表的类型"></a>3.数据表的类型</h2><p>关于数据库引擎：（了解）</p>
<p>默认使用INNODB，</p>
<p>早些年使用MYISAM。</p>
<p>两者的区别：</p>
<p><img src="/posts/913e0d32/image-20210504173012750.png" alt="image-20210504173012750"></p>
<p>所有数据库文件都存在data目录下，一个文件夹对应一个数据库。</p>
<p>数据库本质还是用文件存储。</p>
<p><img src="/posts/913e0d32/image-20210504173513323.png" alt="image-20210504173513323"></p>
<p>了解。</p>
<p>charset设置数据库表的字符集编码。</p>
<p>不设置的话，默认的不支持中文</p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习笔记（二）</title>
    <url>/posts/dc20ae60.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-操作数据库（了解）"><a href="#1-操作数据库（了解）" class="headerlink" title="1.操作数据库（了解）"></a>1.操作数据库（了解）</h2><p>操作数据库–&gt;操作数据库中的表–&gt;操作数据库中表的数据。</p>
<p>创建、使用和删除数据库。</p>
<p><strong>MySQL关键字不区分大小写。</strong></p>
<span id="more"></span>

<p>1.创建数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE (IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>) xxx; <span class="comment">--注意()表示选用，不是命令的一部分，如果不存在就创建</span></span><br></pre></td></tr></table></figure>

<p>2.删除数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE (IF <span class="keyword">EXISTS</span>) hello</span><br></pre></td></tr></table></figure>

<p>3.使用数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE `school` <span class="comment">--如果你的表名或字段名是一个特殊词语，加上``修饰</span></span><br><span class="line"><span class="comment">--它是为了区分MYSQL的保留字与普通字符而引入的符号，比如使用user容易与sql关键字混淆</span></span><br></pre></td></tr></table></figure>

<p>4.查看所有数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES; <span class="comment">--记得加S</span></span><br></pre></td></tr></table></figure>

<p>以上四条命令对照SQLyog的可视化操作学习。</p>
<p>不会某个命令时，在SQLyog执行可视化操作，然后在历史记录中查看对应的语句。</p>
<h2 id="2-数据库的列类型"><a href="#2-数据库的列类型" class="headerlink" title="2.数据库的列类型"></a>2.数据库的列类型</h2><p>参考教程：<a href="https://www.w3cschool.cn/mysql/mysql-data-types.html">https://www.w3cschool.cn/mysql/mysql-data-types.html</a></p>
<p>MySQL 支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。</p>
<h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><table>
<thead>
<tr>
<th align="left"><strong>类型</strong></th>
<th align="left"><strong>大小</strong></th>
<th align="left"><strong>范围（有符号）</strong></th>
<th align="left"><strong>范围（无符号）</strong></th>
<th align="left"><strong>用途</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">TINYINT</td>
<td align="left">1 字节</td>
<td align="left">(-128，127)</td>
<td align="left">(0，255)</td>
<td align="left">小整数值</td>
</tr>
<tr>
<td align="left">SMALLINT</td>
<td align="left">2 字节，较小</td>
<td align="left">(-32 768，32 767)</td>
<td align="left">(0，65 535)</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="left">MEDIUMINT</td>
<td align="left">3 字节</td>
<td align="left">(-8 388 608，8 388 607)</td>
<td align="left">(0，16 777 215)</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="left"><strong>INT</strong>或INTEGER</td>
<td align="left">4 字节，常用</td>
<td align="left">(-2 147 483 648，2 147 483 647)</td>
<td align="left">(0，4 294 967 295)</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="left">BIGINT</td>
<td align="left">8 字节，类似long</td>
<td align="left">(-9 233 372 036 854 775 808，9 223 372 036 854 775 807)</td>
<td align="left">(0，18 446 744 073 709 551 615)</td>
<td align="left"><strong>极大整数值</strong></td>
</tr>
<tr>
<td align="left"><strong>FLOAT</strong></td>
<td align="left">4 字节</td>
<td align="left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td>
<td align="left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td>
<td align="left"><strong>单精度 浮点数值</strong></td>
</tr>
<tr>
<td align="left"><strong>DOUBLE</strong></td>
<td align="left">8 字节</td>
<td align="left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td align="left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td align="left">双精度 浮点数值</td>
</tr>
<tr>
<td align="left"><strong>DECIMAL</strong></td>
<td align="left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td>
<td align="left">依赖于M和D的值，字符串形式浮点数，金融计算常用</td>
<td align="left">依赖于M和D的值</td>
<td align="left">小数值</td>
</tr>
</tbody></table>
<h3 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h3><blockquote>
<p>java.util.Date</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小 (字节)</th>
<th align="left">范围</th>
<th align="left">格式</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>DATE</strong></td>
<td align="left">3</td>
<td align="left">1000-01-01/9999-12-31</td>
<td align="left"><strong>YYYY-MM-DD</strong></td>
<td align="left">日期值</td>
</tr>
<tr>
<td align="left"><strong>TIME</strong></td>
<td align="left">3</td>
<td align="left">‘-838:59:59’/‘838:59:59’</td>
<td align="left"><strong>HH:MM:SS</strong></td>
<td align="left">时间值或持续时间</td>
</tr>
<tr>
<td align="left">YEAR</td>
<td align="left">1</td>
<td align="left">1901/2155</td>
<td align="left">YYYY</td>
<td align="left">年份值</td>
</tr>
<tr>
<td align="left"><strong>DATETIME</strong>，最常用</td>
<td align="left">8</td>
<td align="left">1000-01-01 00:00:00/9999-12-31 23:59:59</td>
<td align="left"><strong>YYYY-MM-DD HH:MM:SS</strong></td>
<td align="left">混合日期和时间值</td>
</tr>
<tr>
<td align="left"><strong>TIMESTAMP</strong>，时间戳</td>
<td align="left">4</td>
<td align="left">1970-01-01 00:00:00/2038 结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038-1-19 03:14:07</td>
<td align="left">YYYYMMDD HHMMSS</td>
<td align="left">混合日期和时间值，时间戳</td>
</tr>
</tbody></table>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CHAR</td>
<td align="left">0-255字节</td>
<td align="left">定长字符串</td>
</tr>
<tr>
<td align="left"><strong>VARCHAR</strong></td>
<td align="left">0-65535 字节</td>
<td align="left"><strong>变长字符串</strong>，<strong>常用</strong></td>
</tr>
<tr>
<td align="left">TINYBLOB</td>
<td align="left">0-255字节</td>
<td align="left">不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td align="left">TINYTEXT</td>
<td align="left">0-255字节</td>
<td align="left">短文本字符串，用于博客等</td>
</tr>
<tr>
<td align="left">BLOB</td>
<td align="left">0-65 535字节</td>
<td align="left">二进制形式的长文本数据</td>
</tr>
<tr>
<td align="left"><strong>TEXT</strong></td>
<td align="left">0-65 535字节</td>
<td align="left">长文本数据，<strong>存放大文本</strong></td>
</tr>
<tr>
<td align="left">MEDIUMBLOB</td>
<td align="left">0-16 777 215字节</td>
<td align="left">二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td align="left">MEDIUMTEXT</td>
<td align="left">0-16 777 215字节</td>
<td align="left">中等长度文本数据</td>
</tr>
<tr>
<td align="left">LONGBLOB</td>
<td align="left">0-4 294 967 295字节</td>
<td align="left">二进制形式的极大文本数据</td>
</tr>
<tr>
<td align="left">LONGTEXT</td>
<td align="left">0-4 294 967 295字节</td>
<td align="left">极大文本数据</td>
</tr>
</tbody></table>
<h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><p>没有值，未知，<strong>注意不要使用它运算</strong>。</p>
<h2 id="3-数据库的字段属性（重点）"><a href="#3-数据库的字段属性（重点）" class="headerlink" title="3.数据库的字段属性（重点）"></a>3.数据库的字段属性（重点）</h2><p>Unsigned：</p>
<ul>
<li>无符号整数</li>
<li>声明该列不能为负数</li>
</ul>
<p>Zerofill：</p>
<ul>
<li>零填充</li>
<li>不足的位数用0填充，int(3)，5–&gt;005</li>
</ul>
<p>自增：</p>
<ul>
<li><p>通常理解为自增，自动在上一条记录的基础上+1（默认）</p>
</li>
<li><p>通常用来设计唯一的主键，必须是整数类型</p>
</li>
<li><p>可以自定义主键自增的起始值和步长</p>
</li>
</ul>
<p>非空 not null：</p>
<ul>
<li>设置为not null时，不赋值就会报错！</li>
<li>不填写时默认为NULL</li>
</ul>
<p>默认：</p>
<ul>
<li>设置默认值，如果不指定该列的值，设定为默认值</li>
</ul>
<p>拓展：听听就好</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 每个表都必须存在以下五个字段！</span></span><br><span class="line"><span class="comment">id 主键</span></span><br><span class="line"><span class="comment">`version` 乐观锁</span></span><br><span class="line"><span class="comment">is_delete 伪删除</span></span><br><span class="line"><span class="comment">gmt_create 创建时间</span></span><br><span class="line"><span class="comment">gmt_update 修改时间</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>现在只作为了解，以后做项目会用到！</p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Programming Challenges</title>
    <url>/posts/64dec9b3.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="c36c5f8c8943f5d5bfaaa2a3bd5d2c55c9ec429d39feb36a8212aa932109745f">fb26124e0d85f363a66baed35993e1a0948953cce3d484fb31660455b92ccb286ba4467b12dd2afdc0f8bd795964707216933c479f00faf5302337078027ef66e68c754bf0232403ae44399aa06a2cad741400e24549082709cdee4a1c1e38f29d8bb6993c43448bafc4543d636ea5bfe35062ad225c74a80f232ba51d9af45093f5220e616be2d57e02341ffad661bef2886dba249b54377d8b3961fd62e8e7033554e6a1a85b429bcdccd8e910eaca84c8e447cedd760cd76a16c64ec7f94ad050108487716cc544f1ca685285a120a1c590efd559bdca18a90707fae890221e2912f079f089d10fb816e69e85944586941b721161d200273028ce2f3cb2d1a6a47461dcfac58b4612622383de37911e7101936179b0ecfeb18f3600111afc0a3048b3a9bc8162408d2cdd766c056081be36f6984d0fc9924355cadc0cde3eb9b769df924e862815f18fb7ec6ae1a8d0b8359230e2ee703a1691d3996f7f65980af1f6b51e0f4ca66d2e1bee517a6f20bbe49d994eb6c5b2bffcc2c203a71a8ae241db1bcb1f5abb733d3a8dc8e73093f5609780a050bdd21d1bb13644249adec52163790897c1a7554d455040d9de</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Python入门笔记（一）</title>
    <url>/posts/5092f4ee.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h5 id="1-多行语句"><a href="#1-多行语句" class="headerlink" title="1.多行语句"></a>1.多行语句</h5><p>使用 \ 来实现多行语句：（尽量不用续行符）</p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br><span class="line">s = <span class="string">&#x27;string,\</span></span><br><span class="line"><span class="string">abc,\</span></span><br><span class="line"><span class="string">de&#x27;</span>  <span class="comment"># 注意这里续行符后不能存在空格，续行符之后直接换行</span></span><br></pre></td></tr></table></figure>

<p>在  [], {}, 或 () 中的多行语句，不需要使用反斜杠()，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total = [<span class="string">&#x27;item_one&#x27;</span>, <span class="string">&#x27;item_two&#x27;</span>, <span class="string">&#x27;item_three&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;item_four&#x27;</span>, <span class="string">&#x27;item_five&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h5 id="2-print函数的格式化输出"><a href="#2-print函数的格式化输出" class="headerlink" title="2.print函数的格式化输出"></a>2.print函数的格式化输出</h5><p>示例：</p>
<p>练习1：华氏温度转换为摄氏温度。</p>
<blockquote>
<p>提示：华氏温度到摄氏温度的转换公式为：$C=(F−32)÷1.8$</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入华氏温度: &#x27;</span>))</span><br><span class="line">c = (f - <span class="number">32</span>) / <span class="number">1.8</span></span><br><span class="line">print(<span class="string">&#x27;%.1f华氏度 = %.1f摄氏度&#x27;</span> % (f, c)) <span class="comment"># solution1</span></span><br><span class="line">print(<span class="string">&#x27;&#123;:.1f&#125;华氏度 = &#123;:.1f&#125;摄氏度&#x27;</span>.<span class="built_in">format</span>(f,c))<span class="comment"># solution2,不带编号输出</span></span><br><span class="line">print(<span class="string">&#x27;&#123;0:.1f&#125;华氏度 = &#123;1:.1f&#125;摄氏度&#x27;</span>.<span class="built_in">format</span>(f,c))<span class="comment"># solution3,带编号输出</span></span><br><span class="line">print(<span class="string">f&#x27;<span class="subst">&#123;f:<span class="number">.1</span>f&#125;</span>华氏度 = <span class="subst">&#123;c:<span class="number">.1</span>f&#125;</span>摄氏度&#x27;</span>)<span class="comment"># solution4,带关键字输出1</span></span><br><span class="line">print(<span class="string">&#x27;&#123;0:.1f&#125;华氏度 = &#123;1:.1f&#125;摄氏度&#x27;</span>.<span class="built_in">format</span>(f,c))<span class="comment"># solution5,带关键字输出2</span></span><br></pre></td></tr></table></figure>

<h6 id="2-1-操作符的使用："><a href="#2-1-操作符的使用：" class="headerlink" title="2.1 %操作符的使用："></a>2.1 %操作符的使用：</h6><p>%o：oct，八进制</p>
<p>%c:  返回整数对应的Unicode字符</p>
<p>%d：dec，十进制；%2d ：占位符2位，空格填充；%02d：占位符2位，0填充</p>
<p>%x：hex，十六进制</p>
<p>%f：保留小数点后6位有效数字。如果是%.3f则保留3位小数</p>
<p>%e：保留小数点后6位有效数字，按指数形式输出，如果是%.3e则保留3位小数位，使用科学记数法</p>
<p>%s：字符串</p>
<p>%10s：右对齐，占位符10位</p>
<p>%-10s：左对齐，占位符10位</p>
<p>%.2s：截取两位字符串</p>
<p>%10.2s：10位占位符，截取两位字符串</p>
<h6 id="2-2-str-format-格式化："><a href="#2-2-str-format-格式化：" class="headerlink" title="2.2 str.format() 格式化："></a>2.2 str.format() 格式化：</h6><p>{:.2f}: 保留2位小数</p>
<p>{:+.2f}: 带正负号，保留2位小数</p>
<p><strong>{:.0f}: 不带小数</strong></p>
<p>{:0&gt;2d}: 数字补零 (填充左边, 宽度为2)，即右对齐</p>
<p>{:x&lt;4d} : 数字补x (填充右边, 宽度为4) ，即左对齐</p>
<p>{:,} : 以逗号分隔的数字，每三位分隔</p>
<p>{:.2e} : 指数计数法，例1.00e+09 </p>
<p>{:&gt;10d} ,{:&lt;10d} ,{:^10d} : 右，左，居中对齐，宽度为10</p>
<p>{:b},{:d},{:o},{:x},{:#x},{:c}: 输出二，十，八，十六进制数，整数对应的Unicode字符</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>‘&#123;:b&#125;’.format(11)  ‘&#123;:d&#125;’.format(11)  ‘&#123;:o&#125;’.format(11)  ‘&#123;:x&#125;’.format(11)  ‘&#123;:#x&#125;’.format(11)  ‘&#123;:#X&#125;’.format(11)</code></td>
<td>1011  11  13  b  0xb  0XB</td>
</tr>
</tbody></table>
<p>^, &lt;, &gt; 分别是居中、左对齐、右对齐，后面带宽度， : 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。</p>
<p>+ 表示在正数前显示 +，负数前显示 -；<code> </code>（空格）表示在正数前加空格</p>
<p>b、d、o、x 分别是二进制、十进制、八进制、十六进制。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#此外我们可以使用大括号 &#123;&#125; 来转义大括号</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> (<span class="string">&quot;&#123;&#125; 对应的位置是 &#123;&#123;0&#125;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;runoob&quot;</span>))</span><br><span class="line">runoob 对应的位置是 &#123;<span class="number">0</span>&#125;</span><br><span class="line"><span class="comment"># 字符串拼接</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">&#x27;dDASD&#x27;</span>,<span class="string">&#x27;fdsd&#x27;</span>,<span class="string">&#x27;dsf&#x27;</span>)</span><br><span class="line"><span class="comment">#print()会依次打印每个字符串，遇到逗号“,”会输出一个空格</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/5092f4ee/image-20210117141051561.png" alt="image-20210117141051561"></p>
<p>注意引导符号的优先顺序！！！以上表格建议背下来！！！</p>
<h5 id="3-python的主要数据类型"><a href="#3-python的主要数据类型" class="headerlink" title="3.python的主要数据类型"></a>3.python的主要数据类型</h5><ul>
<li> number：int, bool, float, complex 其中bool包括True和False</li>
<li> str：加了引号的字符都被认为是字符串</li>
<li> tuple：元组和列表一样，也是一种序列，与列表不同的是，元组是不可修改的</li>
<li> dict：字典是一种键值对的集合，列表是有序的对象集合，字典是无序的对象集合</li>
<li> set：集合是一个无序的、不重复的数据组合，主要作用有两个，分别是去重和关系测试</li>
<li> list：列表是由一系列特定元素顺序排列的元素组成的</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># list</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="string">&#x27;two&#x27;</span>,<span class="number">3.0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># tuple</span></span><br><span class="line">b = (<span class="number">1</span>,<span class="string">&#x27;throw&#x27;</span>,<span class="number">4.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dict</span></span><br><span class="line">c = &#123;<span class="number">1</span>:<span class="string">&#x27;one&#x27;</span>,<span class="number">2</span>:<span class="string">&#x27;two&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># set</span></span><br><span class="line">d = <span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>])</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">set</span></span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; <span class="comment"># set只保留不重复的数据</span></span><br></pre></td></tr></table></figure>

<h5 id="4-变量类型转换"><a href="#4-变量类型转换" class="headerlink" title="4.变量类型转换"></a>4.变量类型转换</h5><p>可以使用Python中内置的函数对变量类型进行转换。</p>
<ul>
<li><code>int()</code>：将一个数值或字符串转换成整数，可以指定进制。</li>
<li><code>float()</code>：将一个字符串转换成浮点数。</li>
<li><code>str()</code>：将指定的对象转换成字符串形式，可以指定编码。</li>
<li><code>chr()</code>：将整数转换成该编码对应的字符串（一个字符）。</li>
<li><code>ord()</code>：将字符串（一个字符）转换成对应的编码（整数）。</li>
</ul>
<h5 id="5-常用运算符"><a href="#5-常用运算符" class="headerlink" title="5.常用运算符"></a>5.常用运算符</h5><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>[]</code> <code>[:]</code></td>
<td>下标，切片</td>
</tr>
<tr>
<td>**</td>
<td>指数</td>
</tr>
<tr>
<td><code>~ + -</code></td>
<td>按位取反，正负号</td>
</tr>
<tr>
<td><code>* / % //</code></td>
<td>乘，除，模，整除</td>
</tr>
<tr>
<td><code>is</code> <code>is not</code></td>
<td>身份运算符</td>
</tr>
<tr>
<td><code>in</code>  <code>not in</code></td>
<td>成员运算符</td>
</tr>
<tr>
<td><code>not</code> <code>or</code> <code>and</code></td>
<td>逻辑运算符，与C的&amp;&amp;，！，||注意区别</td>
</tr>
</tbody></table>
<p><strong>优先级：not &gt; and &gt;or</strong>　</p>
<p><strong>说明：</strong>   大家可以自己感受一下这两种写法到底是哪一种更好。在之前我们提到的Python之禅中有这么一句话“Flat is better than   nested.”，之所以提倡代码“扁平化”是因为嵌套结构的嵌套层次多了之后会严重的影响代码的可读性，所以能使用扁平化的结构时就不要使用嵌套。</p>
<h5 id="6-循环结构"><a href="#6-循环结构" class="headerlink" title="6.循环结构"></a>6.循环结构</h5><p>在Python中构造循环结构有两种做法，一种是<code>for-in</code>循环，一种是<code>while</code>循环。</p>
<h6 id="6-1-for-in-循环"><a href="#6-1-for-in-循环" class="headerlink" title="6.1 for-in 循环"></a>6.1 for-in 循环</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">用for循环实现1~100求和</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">101</span>): <span class="comment"># 不写的话默认从0开始</span></span><br><span class="line">    <span class="built_in">sum</span> += x</span><br><span class="line">print(<span class="built_in">sum</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">打印乘法口诀表</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">        print(<span class="string">&#x27;%d*%d=%d&#x27;</span> % (i, j, i * j), end=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure>

<p>需要说明的是上面代码中的<code>range(1, 101)</code>可以用来构造一个从1到100的范围，当我们把这样一个范围放到<code>for-in</code>循环中，就可以通过前面的循环变量<code>x</code>依次取出从1到100的整数。当然，<code>range</code>的用法非常灵活，下面给出了一个例子：</p>
<ul>
<li><code>range(101)</code>：可以用来产生0到100范围的整数，需要注意的是取不到101。</li>
<li><code>range(1, 101)</code>：(左闭右开)可以用来产生1到100范围的整数，相当于前面是闭区间后面是开区间。</li>
<li><code>range(1, 101, 2)</code>：可以用来产生1到100的奇数，其中2是步长，即每次数值递增的值。</li>
<li><code>range(100, 0, -2)</code>：可以用来产生100到1的偶数，其中-2是步长，即每次数字递减的值。</li>
</ul>
<h6 id="6-2-while-循环"><a href="#6-2-while-循环" class="headerlink" title="6.2 while 循环"></a>6.2 while 循环</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    counter += <span class="number">1</span></span><br><span class="line">    number = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入: &#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>注意break和continue关键字，作用基本同C/C++.</p>
<h5 id="7-练习：输入两个正整数，计算它们的最大公约数和最小公倍数。"><a href="#7-练习：输入两个正整数，计算它们的最大公约数和最小公倍数。" class="headerlink" title="7.练习：输入两个正整数，计算它们的最大公约数和最小公倍数。"></a>7.练习：输入两个正整数，计算它们的最大公约数和最小公倍数。</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;x = &#x27;</span>))</span><br><span class="line">y = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;y = &#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x &gt; y: <span class="comment"># 这里可以直接简化为 x,y = y,x</span></span><br><span class="line">    t = x</span><br><span class="line">    x = y</span><br><span class="line">    y = t</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(x,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> x%n <span class="keyword">and</span> <span class="keyword">not</span> y%n:</span><br><span class="line">        print(<span class="string">&#x27;&#123;&#125;是最大公约数，&#123;&#125;是最小公倍数&#x27;</span>.<span class="built_in">format</span>(n,x*y//n)) <span class="comment"># &quot;//&quot; 对应C的&quot;/&quot;</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h5 id="8-整数与浮点数"><a href="#8-整数与浮点数" class="headerlink" title="8.整数与浮点数"></a>8.整数与浮点数</h5><p>二进制（Bin）：0b或0B，例0b1010</p>
<p>八进制（Oct）：0o或0O，例0o1010</p>
<p>十进制（Dec）：无，默认十进制</p>
<p>十六进制（Hex）：0x或0X，例0x1010</p>
<p>浮点数科学计数法：<code>1e-6 == 1*10^-6</code></p>
<p>注意浮点数的计算不是完全精确的！！！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># solution 1,使用round函数四舍五入保留一定位数再判断</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(<span class="number">0.1</span>+<span class="number">0.2</span>,<span class="number">5</span>) == <span class="built_in">round</span>(<span class="number">0.3</span>,<span class="number">5</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(<span class="number">0.1</span>+<span class="number">0.2</span>,<span class="number">20</span>) == <span class="built_in">round</span>(<span class="number">0.3</span>,<span class="number">20</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#solution 2,两数作差，当差值足够小时认为近似相等</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>((<span class="number">0.1</span>+<span class="number">0.2</span>)-<span class="number">0.3</span>) &lt; <span class="number">1e-10</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h5 id="9-一些内置数值运算函数"><a href="#9-一些内置数值运算函数" class="headerlink" title="9.一些内置数值运算函数"></a>9.一些内置数值运算函数</h5><table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>abs(x)</td>
<td>x的绝对值  ，计算整数、浮点数结果为非负值，也可用于复数</td>
</tr>
<tr>
<td>divmod(x,y)</td>
<td>(x//y,x%y)，输出为二元组形式</td>
</tr>
<tr>
<td>pow(x,y)或pow(x,y,z)</td>
<td><code>x**y或(x**y)%z</code>，幂运算</td>
</tr>
<tr>
<td>round(x)或round(x,d)</td>
<td>对x四舍五入，保留d位小数，无参则返回x的整数</td>
</tr>
<tr>
<td>max(x1,x2,…,xn)</td>
<td>任意数量的最大值</td>
</tr>
<tr>
<td>min(x1,x2, …,xn)</td>
<td>任意数量的最小值</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">divmod</span>(<span class="number">10</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">pow</span>(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>) == <span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">5</span>)%<span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(<span class="number">1</span>,<span class="number">3</span>),<span class="built_in">round</span>(<span class="number">0.5</span>),<span class="built_in">round</span>(<span class="number">1.5</span>) <span class="comment"># 奇进偶不进只针对round(x)</span></span><br><span class="line"><span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span> <span class="comment"># 奇进偶不进取决于小数点前一位</span></span><br><span class="line"><span class="comment"># 如果保留小数位数是0位或1位，奇进偶不进</span></span><br><span class="line"><span class="comment"># 如果保留位数的后一位数字是5且后面还有数字，则进</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(<span class="number">2.30000045</span>,<span class="number">5</span>) <span class="comment"># 多余的0省略s</span></span><br><span class="line"><span class="number">2.3</span></span><br><span class="line"><span class="comment"># round()函数掌握一进整，二进一即可，可能存在一些精度问题，避免使用太多</span></span><br></pre></td></tr></table></figure>

<h5 id="10-字符串"><a href="#10-字符串" class="headerlink" title="10.字符串"></a>10.字符串</h5><p>两种索引方式：（1）从左到右，从0开始到长度-1,；（2）从右到左，从-1开始到开头</p>
<p>截取方式：</p>
<p><img src="/posts/5092f4ee/image-20210113132138310.png" alt="image-20210113132138310"></p>
<p><strong>牢牢记住</strong>：不管索引还是截断，都是<strong>左闭右开</strong>的！！！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span> = <span class="string">&#x27;IlovePython&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>[<span class="number">3</span>] <span class="comment"># 第4个字符</span></span><br><span class="line"><span class="string">&#x27;v&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>[-<span class="number">3</span>] <span class="comment"># 倒数第3个字符</span></span><br><span class="line"><span class="string">&#x27;h&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>[:] <span class="comment"># 整个字符串</span></span><br><span class="line"><span class="string">&#x27;IlovePython&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>[<span class="number">1</span>:] <span class="comment"># 第2个字符 -&gt; 最后面</span></span><br><span class="line"><span class="string">&#x27;lovePython&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>[<span class="number">2</span>:<span class="number">6</span>] <span class="comment"># 第3个字符 -&gt; 第6个</span></span><br><span class="line"><span class="string">&#x27;oveP&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>[:-<span class="number">1</span>] <span class="comment"># 最前面 -&gt; 倒数第2个(左闭右开，不包括最后一个)</span></span><br><span class="line"><span class="string">&#x27;IlovePytho&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>[-<span class="number">5</span>:-<span class="number">1</span>] <span class="comment"># 倒数第5个 -&gt; 倒数第2个(左闭右开，不包括最后一个)</span></span><br><span class="line"><span class="string">&#x27;ytho&#x27;</span></span><br></pre></td></tr></table></figure>

<p>创建字符串：单、双、三引号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;asdsd&#x27;</span> <span class="keyword">or</span> s = <span class="string">&quot;sadaf&quot;</span></span><br><span class="line">s = <span class="string">&#x27;&#x27;&#x27;asdfdf!</span></span><br><span class="line"><span class="string">afdgg&#x27;&#x27;&#x27;</span> <span class="comment"># 相当于加一个\n</span></span><br></pre></td></tr></table></figure>

<p>len()函数：返回字符串长度或者字符数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#ininstance()和type()判断类型：</span></span><br><span class="line">s = <span class="string">&#x27;adsaf&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(s)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">str</span>&#x27;&gt;</span></span><br><span class="line">&gt;&gt;&gt; type(s) == str</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(s,<span class="built_in">str</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>字符串的相关操作：</p>
<p><code>x + y</code>: 连接两个字符串x，y，不加空格，如果用逗号会自动加空格</p>
<p><code>x * n</code>: 复制n次字符(串)x</p>
<p><code>x in s</code>: x 在s中，返回True</p>
<p><code>x not in s</code>:与上面相反</p>
<p>r/R:原始字符串（raw），所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。在字符串的第一个引号前加上字母 r/R。<code>print( r&#39;\badc\t\n&#39; )</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">&#x27;a&#x27;</span> * <span class="number">8</span>)</span><br><span class="line">aaaaaaaa</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">&#x27;a,b&#x27;</span> * <span class="number">4</span>)</span><br><span class="line">a,ba,ba,ba,b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;fggfsgradgf&#x27;</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>字符串处理函数：</p>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>len(x)</td>
<td>返回字符串x的长度或者是其他组合类型的元素个数</td>
</tr>
<tr>
<td>str(x)</td>
<td>把任意类型转换为字符串形式</td>
</tr>
<tr>
<td>chr(x)</td>
<td>返回Unicode编码对应的单字符，<strong>注意是Unicode不是ASCII</strong></td>
</tr>
<tr>
<td>ord(x)</td>
<td>返回单个字符对应的Unicode编码</td>
</tr>
<tr>
<td>hex(x)</td>
<td>返回整数x对应的十六进制的小写形式，返回字符串</td>
</tr>
<tr>
<td>oct(x)</td>
<td>返回整数x对应的八进制的小写形式返回字符串</td>
</tr>
</tbody></table>
<p>字符串处理方法：（str用于替换字符串变量名）</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>str.lower()</td>
<td>以小写的方式全部返回str的副本</td>
</tr>
<tr>
<td>str.upper()</td>
<td>以大写的方式全部返回str的副本</td>
</tr>
<tr>
<td>str.split(sep=None)</td>
<td>返回一个列表，以sep作为分隔点，sep默认为空格或\n</td>
</tr>
<tr>
<td>str.count(sub)</td>
<td>返回sub子串出现的次数</td>
</tr>
<tr>
<td>str.replace(old,new)</td>
<td>返回字符串str的副本，所有old子串被替换为new</td>
</tr>
<tr>
<td>str.center(width,fillchar)</td>
<td>字符串居中函数，fillchar参数可选，用于填充</td>
</tr>
<tr>
<td>str.format()</td>
<td>格式化字符串</td>
</tr>
<tr>
<td>str.strip(chars)</td>
<td>从字符串str中去掉在其左侧和右侧chars中列出的字符</td>
</tr>
<tr>
<td>str.join(iter)</td>
<td>将iter变量的每一个元素后面增加一个str</td>
</tr>
<tr>
<td>str.isdigit()</td>
<td>如果 str只包含数字则返回 True 否则返回 False.</td>
</tr>
</tbody></table>
<p>str.join(iter)：注意，str是一个字符串，里面包含着你将要将可迭代变量中元素分隔的符号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;abc&quot;</span></span><br><span class="line">print(<span class="string">&quot;,&quot;</span>.join(s))</span><br><span class="line"><span class="comment"># a,b,c</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意str.replace()返回str的副本，并不会修改str</span></span><br><span class="line">s = <span class="string">&quot;bilaoshi&quot;</span></span><br><span class="line">print(s.replace(<span class="string">&quot;bi&quot;</span>,<span class="string">&quot;xu&quot;</span>))</span><br><span class="line">print(s)</span><br><span class="line"><span class="comment"># xulaoshi</span></span><br><span class="line"><span class="comment"># bilaoshi</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;1234&quot;</span>.isdigit()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;213.254&quot;</span>.isdigit()</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Python入门笔记（三）</title>
    <url>/posts/2d9abb64.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-函数"><a href="#1-函数" class="headerlink" title="1.函数"></a>1.函数</h2><p>四种传递参数的方式！！！</p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    print(a+b)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">sum</span>(<span class="number">2</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><strong>位置参数</strong>是比较常用的形式，调用函数时实参和形参的顺序必须一致，并且数量相同。</p>
<p>​    <strong>默认值参数</strong>：函数的参数在定义时也可以指定默认值，函数调用时若该位置没有给定实际参数，则使用默认值代替。但需要注意可选参数应当放在非可选参数后面。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">x,y=<span class="number">10</span></span>):</span></span><br><span class="line">    print(x*y)</span><br><span class="line"></span><br><span class="line">mul(<span class="number">2</span>,<span class="number">5</span>)<span class="comment"># 2 * 5 = 10</span></span><br><span class="line">mul(<span class="number">2</span>)<span class="comment"># 2 * 10 = 20</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">y=<span class="number">10</span>,x</span>):</span> <span class="comment">#ERROR:默认参数不能放在位置参数前面</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">x,z,y=<span class="number">10</span></span>):</span></span><br><span class="line">    print(x*y)</span><br><span class="line">mul(<span class="number">2</span>,<span class="number">3</span>) <span class="comment"># 20</span></span><br></pre></td></tr></table></figure>

<p><strong>关键字参数</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    print(x,y)</span><br><span class="line">    </span><br><span class="line">mul(y = <span class="number">2</span>,x = <span class="number">99</span>)</span><br></pre></td></tr></table></figure>

<p><strong>可变长度参数</strong>：</p>
<p>除了以上传参方式以外，当我们不确定会接受多少个参数的时候可以利用可变长度参数解决。</p>
<p>​    *param接收任意多个参数放在一个元组中</p>
<p>​    **param接收任意多个关键字参数放入字典中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  *param返回元组</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">*x</span>):</span></span><br><span class="line">    print(x)</span><br><span class="line">    </span><br><span class="line">mul(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)<span class="comment"># (2, 3, 4, 5, 6, 7)</span></span><br><span class="line"><span class="comment"># **param返回字典</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span>(<span class="params">**p</span>):</span></span><br><span class="line">    print(p)</span><br><span class="line">demo(a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>)<span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span></span><br><span class="line">demo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)<span class="comment"># ERROR:只能以关键字方式接受参数</span></span><br></pre></td></tr></table></figure>

<h2 id="2-变量的作用域"><a href="#2-变量的作用域" class="headerlink" title="2.变量的作用域"></a>2.变量的作用域</h2><p>局部变量仅在函数内部，且作用域也在函数内部，全局变量的作用域跨越多个函数。</p>
<p>当局部变量与全局变量同名时，函数内部会优先使用局部变量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span> <span class="comment"># 全局变量</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    s = x + y</span><br><span class="line">    print(s)<span class="comment"># 3，局部变量</span></span><br><span class="line">    print(a)<span class="comment"># 1</span></span><br><span class="line"><span class="built_in">sum</span>(a,b)</span><br></pre></td></tr></table></figure>

<p>全局变量指在函数之外定义的变量，在程序执行全过程有效。全部变量在函数内部使用（修改）时，需要提前使用保留字global声明，语法形式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    s = x + y</span><br><span class="line">    a = <span class="number">4</span> <span class="comment"># 未使用global，在函数内部不能修改全局变量</span></span><br><span class="line">    <span class="comment"># 此处的a是一个同名的局部变量</span></span><br><span class="line">    <span class="comment"># 建议尽量不适用global，以免与外面代码形成耦合容易出错</span></span><br><span class="line"><span class="built_in">sum</span>(a,b)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    print(x+y)</span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a = <span class="number">4</span></span><br><span class="line"><span class="built_in">sum</span>(a,b)</span><br><span class="line">print(a)<span class="comment"># a == 4</span></span><br></pre></td></tr></table></figure>

<h2 id="3-函数的返回值"><a href="#3-函数的返回值" class="headerlink" title="3.函数的返回值"></a>3.函数的返回值</h2><ul>
<li>用return返回函数值，作用同C/C++。</li>
<li>return语句可以出现在函数中的任何部分。</li>
<li>return可以同时返回0个或多个函数运算的结果给函数被调用处的变量。</li>
<li>当return返回多个值时，返回的值形成元组数据类型。</li>
<li>函数也可以没有return代表无返回值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    s = x+y</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">print(<span class="built_in">sum</span>(a,b))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    s = x + y</span><br><span class="line">    v = x * y</span><br><span class="line">    <span class="keyword">return</span> s,v</span><br><span class="line">print(mul(a,b)) <span class="comment">#以元组形式返回值</span></span><br><span class="line">m = mul(a,b)</span><br><span class="line">print(m[<span class="number">1</span>])  </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">(3, 2)</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>代码复用（选择题常考）</strong></p>
<p>模块化设计指通过函数的封装功能将程序划分为主程序、子程序和子程序间关系的表达。模块化设计是使用函数设计程度的思考方法，以功能为基本单位，一般由两个基本要求：    </p>
<p>•紧耦合：尽可能合理划分功能模块，功能块内部耦合紧密。</p>
<p>•松耦合：模块间关系尽可能简单，功能块之间耦合度低。</p>
<p>耦合性指程序中各模块之间想相互关联的程度。</p>
<p><strong>匿名函数</strong></p>
<p>匿名函数适合处理临时需要一个类似于函数的功能但又不想定义函数的场合，可以省去函数的定义过程和考虑函数的命名，让代码更加简洁，可读性更好。</p>
<p>适合处理一些简单的函数</p>
<p>使用语法：<code>&lt;函数对象名&gt;=lambda &lt;形式参数列表&gt;:&lt;表达式&gt;</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">x:y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">fun = <span class="keyword">lambda</span> x,y:x+y</span><br><span class="line"><span class="comment"># 1和2是等价的</span></span><br><span class="line">print(fun(<span class="number">2</span>,<span class="number">3</span>))<span class="comment"># 5</span></span><br></pre></td></tr></table></figure>

<h2 id="4-组合数据类型"><a href="#4-组合数据类型" class="headerlink" title="4.组合数据类型"></a>4.组合数据类型</h2><p>注意：对于基本的数据类型，如整数或字符串，可以通过等号实现元素赋值。但对于列表类型，使用等号无法实现真正的赋值。其中，ls = lt语句并不是拷贝lt中 元素给变量ls，而是新关联了一个引用，即ls和lt所指向 的是同一套内容。</p>
<h2 id="5-做题总结"><a href="#5-做题总结" class="headerlink" title="5.做题总结"></a>5.做题总结</h2><p><img src="/posts/2d9abb64/image-20210119221538951.png" alt="image-20210119221538951"></p>
<p>如何读取类似用空格分隔的两个字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>()</span><br><span class="line">s = <span class="built_in">str</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">s1 = s[<span class="number">0</span>]</span><br><span class="line">s2 = s[<span class="number">1</span>]</span><br><span class="line">print(s1,s2)</span><br><span class="line"><span class="comment"># str == &quot;abc defg&quot;</span></span><br><span class="line"><span class="comment"># &quot;abc&quot; &amp; &quot;defg&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-文件"><a href="#6-文件" class="headerlink" title="6.文件"></a>6.文件</h2><p>（记住）<strong>文件主要分为：文本文件和二进制文件</strong>。</p>
<p>1、 文本文件一般由单一特定编码的字符组成，如 UTF-8编码，内容容易统一展示和阅读。 </p>
<p>2、 二进制文件直接由比特0和比特1组成，文件内部数据的组织格式与文件用途有关。二进制是信息按照非字符但特定格式形成的文件，例如，png 格式的图片文件、avi格式的视频文件。</p>
<p>3、二进制文件和文本文件最主要的区别在于是否有统一的字符编码。 </p>
<p> 4、无论文件创建为文本文件或者二进制文件，都可以用“文本文件方式”和“二进制文件方式”打开，但打开后的操作不同。</p>
<p><strong>（记住）</strong>采用文本方式读入文件，文件经过编码形成<strong>字符串</strong>，打印出有含义的字符；采用二进制方式打开文件，文件被解析为<strong>字节流</strong></p>
<p>Python对文本文件和二进制文件采用统一的操作步骤， 即“打开-操作-关闭”</p>
<p>open函数语法：<code>&lt;变量名&gt; = open(&lt;文件路径及文件名&gt;, &lt;打开模式&gt;)</code></p>
<table>
<thead>
<tr>
<th><strong>打开模式</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>‘r’</td>
<td>只读模式，如果文件不存在，返回异常FileNotFoundError，默认值</td>
</tr>
<tr>
<td>‘w’</td>
<td>覆盖写模式，文件不存在则创建，存在则完全覆盖源文件</td>
</tr>
<tr>
<td>‘x’</td>
<td>创建写模式，文件不存在则创建，存在则返回异常FileExistsError</td>
</tr>
<tr>
<td>‘a’</td>
<td>追加写模式，文件不存在则创建，存在则在原文件最后追加内容</td>
</tr>
<tr>
<td>‘b’</td>
<td>二进制文件模式</td>
</tr>
<tr>
<td>‘t’</td>
<td>文本文件模式，默认值</td>
</tr>
<tr>
<td>‘+’</td>
<td>与r/w/x/a一同使用，在原功能基础上增加同时读写功能</td>
</tr>
</tbody></table>
<p><img src="/posts/2d9abb64/image-20210222182101934.png" alt="image-20210222182101934"></p>
<p><img src="/posts/2d9abb64/image-20210222183442871.png" alt="image-20210222183442871"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;abc.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)<span class="comment"># 这里的txt是相对路径（与py文件同一级）</span></span><br><span class="line"><span class="comment"># 如果中文乱码</span></span><br><span class="line"><span class="comment"># 改成open(&quot;abc.txt&quot;,&quot;r&quot;,encoding = &quot;utf-8&quot;)</span></span><br><span class="line">s = f.read()</span><br><span class="line">print(s)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;F:\\Python二级\\abc.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="comment"># 采用绝对路径，用\\表示转义</span></span><br><span class="line"><span class="comment"># 写法2：f = open(&quot;F:/Python二级/abc.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;)</span></span><br><span class="line"><span class="comment"># 写法3：f = open(r&quot;F:\Python二级\abc.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;)</span></span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;b.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)<span class="comment">#  覆盖写模式</span></span><br><span class="line">f.write(<span class="string">&quot;今天天气正好&quot;</span>)</span><br><span class="line">f.close()</span><br><span class="line"><span class="comment"># &quot;rb&quot;, &quot;wb&quot;, &quot;ab&quot; 以二进制形式对文件操作</span></span><br><span class="line"><span class="comment"># 二进制操作千万不要加encoding=&quot;utf-8&quot;</span></span><br><span class="line"><span class="comment"># &quot;rt&quot;与&quot;r&quot;没有区别</span></span><br><span class="line"><span class="comment"># &quot;r+&quot;在原有功能上增加同时读写功能</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;hello.txt&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f: <span class="comment"># 老师推荐，不用close文件</span></span><br><span class="line">    t = f.read()</span><br><span class="line">    print(t)</span><br></pre></td></tr></table></figure>

<p>文件的读取</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>f.read(size=-1)</td>
<td>从文件中读入整个文件内容。参数可选，如果给出，读入  前size长度的字符串或字节流</td>
</tr>
<tr>
<td>f.readline(size  = -1)</td>
<td>从文件中读入一行内容。参数可选，如果给出，读入该行  前size长度的字符串或字节流</td>
</tr>
<tr>
<td>f.readlines(hint=-1)</td>
<td>从文件中读入所有行，以每行为元素形成一个<strong>列表</strong>。参数  可选，如果给出，读入hint行</td>
</tr>
<tr>
<td>f.seek(offset,whence)</td>
<td>改变当前文件操作指针的位置，whence的值：  0：文件开头；1:当前位置 2: 文件结尾</td>
</tr>
</tbody></table>
<p>如果文件不大，可以一次性将文件内容读入，保存到程序内部变量中。f.read()是最常用的一次性读入文件的函数，其结果是一个字符串。 </p>
<p>f.seek(offset,whence)方法能够移动读取指针的位置。</p>
<p>offset ： 开始的偏移量，也就是代表需要移动偏移的字节数，如果是负数表示从倒数第几位开始。 </p>
<p>whence：可选，默认值为 0。给 offset 定义一个参数，表示要从哪个位置开始偏移；0 代表从文件开头开始算起，1 代表从当前位置开始算起，2 代表从文件末尾算起。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;abc.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">s = f.read(<span class="number">5</span>)<span class="comment"># 读取前5个字符</span></span><br><span class="line">print(s)</span><br><span class="line">print(<span class="built_in">type</span>(s))  <span class="comment"># &quot;str&quot;</span></span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;abc.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">s = f.readline()<span class="comment"># 读取一行内容，继续读的话就从下一行开始，会读到行未的换行符</span></span><br><span class="line">print(<span class="built_in">type</span>(s))  <span class="comment"># &quot;str&quot;</span></span><br><span class="line">print(s)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">s = f.readlines()</span><br><span class="line">print(<span class="built_in">type</span>(s))  <span class="comment"># &quot;list&quot;这里是列表类型，不是字符串</span></span><br><span class="line"><span class="comment"># 每一行（包括\n）作为列表中的一个元素</span></span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;abc.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">s = f.read()</span><br><span class="line">print(s)</span><br><span class="line">f.seek(<span class="number">0</span>, <span class="number">0</span>)  <span class="comment"># 文件指针的位置可以理解为光标位置</span></span><br><span class="line">string = f.read()</span><br><span class="line">print(string)</span><br><span class="line">print(<span class="built_in">type</span>(s))  <span class="comment"># &quot;str&quot;</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p>文件的写入</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>f.write(s)</td>
<td>向文件写入一个字符串或字节流</td>
</tr>
<tr>
<td>f.writelines(lines)</td>
<td>将一个<strong>元素为字符串的列表</strong>写入文件</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;abcd.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">f.write(<span class="string">&quot;学习使我快乐&quot;</span>)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;abcd.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">ls = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]</span><br><span class="line">f.writelines(ls)</span><br><span class="line">f.close()<span class="comment"># 文件里是abc连在一起</span></span><br></pre></td></tr></table></figure>

<p><strong>补充知识</strong></p>
<p>w+：在写的基础上增加读的功能（打开文件清空内容）；</p>
<p>r+：在读的基础上增加写的功能（打开文件不清空内容），两者不一样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;abc.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line">s = <span class="string">&quot;塔防&quot;</span></span><br><span class="line">f.write(s)</span><br><span class="line">f.close()<span class="comment"># abc文件中写入“塔防”</span></span><br><span class="line">---------------------Demo1</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;abc.txt&quot;</span>,<span class="string">&quot;w+&quot;</span>)</span><br><span class="line">f.write(<span class="string">&quot;塔防&quot;</span>)</span><br><span class="line">s = f.read()</span><br><span class="line">print(s)<span class="comment"># 空</span></span><br><span class="line"><span class="comment"># abc内容：塔防</span></span><br><span class="line"><span class="comment"># 先写后读，写完后指针走到末尾，读不到内容</span></span><br><span class="line">f.close()</span><br><span class="line">---------------------Demo2</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;abc.txt&quot;</span>,<span class="string">&quot;r+&quot;</span>)</span><br><span class="line">s = f.read()</span><br><span class="line">print(s)<span class="comment"># 塔防</span></span><br><span class="line"><span class="comment"># abc内容：塔防塔防</span></span><br><span class="line">f.write(<span class="string">&quot;塔防&quot;</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h2 id="7-数据的组织维度"><a href="#7-数据的组织维度" class="headerlink" title="7.数据的组织维度"></a>7.数据的组织维度</h2><h3 id="7-1-一维数据"><a href="#7-1-一维数据" class="headerlink" title="7.1 一维数据"></a>7.1 一维数据</h3><p>一维数据是最简单的数据组织类型，由于是线性结构，在Python语言中主要采用列表形式表示。</p>
<p>一维数据的文件存储有多种方式，总体思路是采用特殊字符分隔各数据。常用存储方法包括4种。</p>
<p> （1）采用空格分隔元素，例如： 北京  上海  天津  重庆</p>
<p> （2）采用逗号分隔元素，（重点）例如： 北京,上海,天津,重庆</p>
<p> （3）采用换行分隔包括，例如：</p>
<p>​      北京</p>
<p>​      上海</p>
<p>​      天津</p>
<p>​      重庆 </p>
<p> （4）其他特殊符号分隔，以分号分隔为例，例 如： </p>
<p>​      北京;上海;天津;重庆 </p>
<p><img src="/posts/2d9abb64/image-20210120134702444.png" alt="image-20210120134702444"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##s = &quot;北京,重庆,武汉,广东&quot;  # 注意用英文逗号！！！</span></span><br><span class="line"><span class="comment">##f = open(&quot;demo.csv&quot;, &quot;w&quot;)</span></span><br><span class="line"><span class="comment">##f.write(s)</span></span><br><span class="line"><span class="comment">##f.close()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ls = [<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;西藏&quot;</span>,<span class="string">&quot;武汉&quot;</span>,<span class="string">&quot;广州&quot;</span>] <span class="comment"># 把列表变成字符串</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;test.csv&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">f.write(<span class="string">&quot;,&quot;</span>.join(ls))</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;demo.csv&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">s = f.read()</span><br><span class="line">print(s.strip(<span class="string">&quot;\n&quot;</span>).split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">f.close()</span><br><span class="line"><span class="comment"># [&#x27;北京&#x27;, &#x27;重庆&#x27;, &#x27;武汉&#x27;, &#x27;广东&#x27;]得到列表</span></span><br></pre></td></tr></table></figure>

<h3 id="7-2-二维数据"><a href="#7-2-二维数据" class="headerlink" title="7.2 二维数据"></a>7.2 二维数据</h3><p>1、二维数据由一维数据组成，用CSV格式文件存储。 CSV文件的每一行是一维数据，整个CSV文件是 一个二维数据。</p>
<p>2、二维列表对象输出为CSV格式文件方法如下，采用遍历循环和字符串的join()方法相结合。</p>
<p>二维数据处理等同于二维列表的操作，与一维列表不同，二维列表一般需要借助循环遍历实现对每个数据的处理，基本代码格式如下：</p>
<p><code>for row in ls:</code></p>
<p> <code>for item in row:</code>   </p>
<p> <code>&lt;对第row行第item列元素进行处理&gt;</code> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ls = [[<span class="string">&quot;学校&quot;</span>, <span class="string">&quot;报考人数&quot;</span>, <span class="string">&quot;往年录取人数&quot;</span>, <span class="string">&quot;理科人数&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;xx实验中学&quot;</span>,<span class="string">&quot;100&quot;</span>, <span class="string">&quot;100&quot;</span>, <span class="string">&quot;60&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;xx中学&quot;</span>,<span class="string">&quot;150&quot;</span>,<span class="string">&quot;30&quot;</span>,<span class="string">&quot;80&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;xx高级中学&quot;</span>,<span class="string">&quot;200&quot;</span>,<span class="string">&quot;140&quot;</span>,<span class="string">&quot;160&quot;</span>]]</span><br><span class="line"><span class="comment"># 写入</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;demo1.csv&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> ls:</span><br><span class="line">    f.write(<span class="string">&quot;,&quot;</span>.join(row)+<span class="string">&quot;\n&quot;</span>)<span class="comment"># 在每行后面加换行，以便从下一行继续写入</span></span><br><span class="line"><span class="comment"># 读取</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;demo1.csv&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">ls = f.readlines()</span><br><span class="line">L = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> ls:</span><br><span class="line">    L.append(line.strip(<span class="string">&quot;\n&quot;</span>).split(<span class="string">&quot;,&quot;</span>))<span class="comment"># 将小列表ls放入大列表L</span></span><br><span class="line">print(L)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Python入门笔记（二）</title>
    <url>/posts/60841836.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-进阶赋值方法"><a href="#1-进阶赋值方法" class="headerlink" title="1.进阶赋值方法"></a>1.进阶赋值方法</h2><ul>
<li>同时给多个变量赋同一个值：</li>
</ul>
<p><code>a = b = c = 100</code></p>
<ul>
<li>同时给多个变量赋不同的值：</li>
</ul>
<p><code>a , b , c  = 1, 2 , 3</code></p>
<span id="more"></span>

<h2 id="2-逻辑推理练习"><a href="#2-逻辑推理练习" class="headerlink" title="2.逻辑推理练习"></a>2.逻辑推理练习</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">4.0</span> == <span class="number">4</span> <span class="comment"># True</span></span><br><span class="line"><span class="built_in">bool</span>(<span class="string">&quot;1&quot;</span>),<span class="built_in">bool</span>(<span class="string">&quot;0&quot;</span>) <span class="comment"># True,True</span></span><br><span class="line"><span class="comment">#这里是两个字符串，注意是&quot;0&quot;，不是数字0</span></span><br><span class="line"><span class="built_in">str</span>(<span class="number">32</span>) <span class="comment"># &#x27;32&#x27; ,这里直接变成字符串，不作其他改动，和ASCII码无关</span></span><br><span class="line"><span class="built_in">int</span>(<span class="string">&quot;3.42&quot;</span>) <span class="comment"># 报错</span></span><br><span class="line"><span class="built_in">bool</span>(-<span class="number">1</span>)，<span class="built_in">bool</span>(<span class="string">&quot;&quot;</span>),<span class="built_in">bool</span>(<span class="number">0</span>) <span class="comment"># True,False,False</span></span><br><span class="line"><span class="string">&quot;wrqq&quot;</span> &gt; <span class="string">&quot;acd&quot;</span> <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<ul>
<li>bool函数进行转换时，其结果取决于传入参数与True和 False的等价关系。</li>
</ul>
<p>只需记住一点即可：<strong>数字0，空字符串，None在条件判断语句中等价于 False</strong>，其他数值都等价于True。bool函数在做数据类型转换时遵循该原则。</p>
<ul>
<li><p>用加号连接字符串：不会自动加空格；用逗号连接字符串：自动加空格。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">&#x27;a&#x27;</span>+<span class="string">&#x27;b&#x27;</span>+<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">abc</span><br><span class="line">print(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">a b c</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串大小比较规则</p>
</li>
</ul>
<p>两个字符串在比较大小时，比的不是长度，而是内容，逐个字符按<u>Unicode码</u>比较</p>
<p>字符串左对齐后，逐个字符依次比较，直到可以分出胜负</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算16开根</span></span><br><span class="line"><span class="comment"># solution 1，只适用于正数</span></span><br><span class="line"><span class="number">16</span> ** <span class="number">0.5</span></span><br><span class="line"><span class="number">4.0</span></span><br><span class="line"><span class="comment"># solution 2，可以用于正数，负数和复数</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">math.sqrt(<span class="number">16</span>)</span><br><span class="line"><span class="number">4.0</span></span><br></pre></td></tr></table></figure>

<h2 id="3-列表（List）"><a href="#3-列表（List）" class="headerlink" title="3.列表（List）"></a>3.列表（List）</h2><p>列表的正向和逆向索引与字符串基本相同。</p>
<p>可以直接对列表的数据进行修改和更新。用del语句删除列表元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;第三个元素为 : &quot;</span>, <span class="built_in">list</span>[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">list</span>[<span class="number">2</span>] = <span class="number">2001</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;更新后的第三个元素为 : &quot;</span>, <span class="built_in">list</span>[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">del</span> <span class="built_in">list</span>[<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;删除第三个元素 : &quot;</span>, <span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-1-列表的操作函数"><a href="#3-1-列表的操作函数" class="headerlink" title="3.1 列表的操作函数"></a>3.1 列表的操作函数</h3><p>列表类型继承序列类型特点，有一些通用的操作函数</p>
<table>
<thead>
<tr>
<th><strong>操作函数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>len(ls)</td>
<td>列表ls的元素个数（长度)</td>
</tr>
<tr>
<td>min(ls)</td>
<td>列表ls中的最小元素(内部数据可比较)</td>
</tr>
<tr>
<td>max(ls)</td>
<td>列表ls中的最大元素  (内部数据可比较)</td>
</tr>
<tr>
<td>list(x)</td>
<td>将x转变成列表类型</td>
</tr>
</tbody></table>
<h3 id="3-2-列表的操作方法"><a href="#3-2-列表的操作方法" class="headerlink" title="3.2 列表的操作方法"></a>3.2 列表的操作方法</h3><p>基本语法：&lt;列表变量&gt;.&lt;方法名称&gt;(&lt;方法参数&gt;)</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>ls.append(x)</td>
<td>在列表ls最后增加一个元素x</td>
</tr>
<tr>
<td>ls.insert(index, x)</td>
<td>在列表ls第index位置增加元素x，无返回值</td>
</tr>
<tr>
<td>ls.clear()</td>
<td>删除ls中所有元素</td>
</tr>
<tr>
<td>ls.pop(index)</td>
<td>将列表ls中第index项元素取出并删除该元素，默认最后一个元素，并且返回该元素的值</td>
</tr>
<tr>
<td>ls.remove(x)</td>
<td>将列表中出现的第一个元素x删除，无返回值</td>
</tr>
<tr>
<td>ls.reverse()</td>
<td>列表ls中元素反转</td>
</tr>
<tr>
<td>ls.copy()</td>
<td>生成一个新列表，复制ls中所有元素</td>
</tr>
<tr>
<td>ls.index(obj)</td>
<td>从列表中找出某个值第一个匹配项的索引位置</td>
</tr>
<tr>
<td>ls.count(obj)</td>
<td>统计某个元素在列表中出现的次数</td>
</tr>
<tr>
<td>list.sort( key=None, reverse=False)</td>
<td>reverse – 排序规则，reverse = True 降序， reverse = False 升序（默认）。</td>
</tr>
</tbody></table>
<h3 id="3-3-列表的脚本操作符"><a href="#3-3-列表的脚本操作符" class="headerlink" title="3.3 列表的脚本操作符"></a>3.3 列表的脚本操作符</h3><table>
<thead>
<tr>
<th>Python 表达式</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>len([1, 2, 3])</td>
<td>3</td>
<td>长度</td>
</tr>
<tr>
<td>[1, 2, 3] + [4, 5, 6]</td>
<td>[1, 2, 3, 4, 5, 6]</td>
<td>组合</td>
</tr>
<tr>
<td>[‘Hi!’] * 4</td>
<td>[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td>
<td>重复</td>
</tr>
<tr>
<td>3 in [1, 2, 3]</td>
<td>True</td>
<td>元素是否存在于列表中</td>
</tr>
<tr>
<td>for x in [1, 2, 3]: print(x, end=” “)</td>
<td>1 2 3</td>
<td>迭代</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;L=[<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">2</span>]</span><br><span class="line"><span class="string">&#x27;Taobao&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[-<span class="number">2</span>]</span><br><span class="line"><span class="string">&#x27;Runoob&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">1</span>:]</span><br><span class="line">[<span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt;squares = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares += [<span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br><span class="line"><span class="comment"># list嵌套</span></span><br><span class="line">&gt;&gt;&gt;a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [a, n]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">0</span>]</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="comment"># 列表</span></span><br><span class="line">vowels = [<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;i&#x27;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 降序</span></span><br><span class="line">vowels.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span> ( <span class="string">&#x27;降序输出:&#x27;</span>, vowels )</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">list</span>(<span class="string">&quot;python&quot;</span>)</span><br><span class="line">print(name)</span><br><span class="line">name[<span class="number">2</span>:] = <span class="built_in">list</span>(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">print(name)</span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">5</span>]</span><br><span class="line">numbers[<span class="number">1</span>:<span class="number">1</span>] = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]  <span class="comment"># [1:1]表示1与5之间的位置</span></span><br><span class="line">print(numbers)</span><br><span class="line"></span><br><span class="line">numbers[<span class="number">1</span>:<span class="number">4</span>] = []</span><br><span class="line">print(numbers)</span><br><span class="line"></span><br><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">l.insert(<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment"># 在索引下标2之前插入&#x27;a&#x27;</span></span><br><span class="line">print(l)</span><br><span class="line"><span class="comment"># 注意区别remove和pop</span></span><br><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">l.remove(<span class="number">1</span>) <span class="comment"># 无返回值，删除第一个元素1</span></span><br><span class="line">print(l)</span><br><span class="line">l.pop(<span class="number">2</span>)<span class="comment"># 返回索引下标为2的元素值并删除它</span></span><br><span class="line">print(l)</span><br><span class="line"><span class="comment"># [&#x27;p&#x27;, &#x27;y&#x27;, &#x27;t&#x27;, &#x27;h&#x27;, &#x27;o&#x27;, &#x27;n&#x27;]</span></span><br><span class="line"><span class="comment"># [&#x27;p&#x27;, &#x27;y&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment"># [1, 5]</span></span><br><span class="line"><span class="comment"># [1,2,&#x27;a&#x27;,3,4]</span></span><br><span class="line"><span class="comment"># [2, 3, 4, 5]</span></span><br><span class="line"><span class="comment"># [2, 3, 5]</span></span><br></pre></td></tr></table></figure>

<p>Question: 已知列表ls = [1,3,5,7,9,5]，去掉列表中的重复值。</p>
<p>Answer: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ls = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">5</span>]</span><br><span class="line">s = <span class="built_in">set</span>(ls) <span class="comment"># 利用集合的无重复性</span></span><br><span class="line">ls = <span class="built_in">list</span>(s)</span><br><span class="line">print(ls)</span><br></pre></td></tr></table></figure>

<h2 id="4-字典（Dict）"><a href="#4-字典（Dict）" class="headerlink" title="4.字典（Dict）"></a>4.字典（Dict）</h2><p>字典是另一种可变容器模型，且可存储任意类型对象。</p>
<p>字典的每个键值 key=&gt;value  对用冒号 :  分割，每个对之间用逗号(<strong>,</strong>)分割，整个字典包括在花括号 {} 中 .</p>
<p>键必须是唯一的，但值则不必。</p>
<p>值可以取任何数据类型，但键必须是不可变的，如字符串，数字。key可以使用元组，而不能使用列表、字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;likes&#x27;</span>: <span class="number">123</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;www.runoob.com&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;dict[&#x27;Name&#x27;]: &quot;</span>, <span class="built_in">dict</span>[<span class="string">&#x27;Name&#x27;</span>])<span class="comment"># dict[&#x27;Name&#x27;]:  Runoob</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;dict[&#x27;Age&#x27;]: &quot;</span>, <span class="built_in">dict</span>[<span class="string">&#x27;Age&#x27;</span>]) <span class="comment"># dict[&#x27;Age&#x27;]:  7</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;Age&#x27;</span>] = <span class="number">8</span>               <span class="comment"># 更新 Age</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;School&#x27;</span>] = <span class="string">&quot;菜鸟教程&quot;</span>  <span class="comment"># 添加信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> <span class="built_in">dict</span>[<span class="string">&#x27;Name&#x27;</span>] <span class="comment"># 删除键 &#x27;Name&#x27;</span></span><br><span class="line"><span class="built_in">dict</span>.clear()     <span class="comment"># 清空字典</span></span><br><span class="line"><span class="keyword">del</span> <span class="built_in">dict</span>         <span class="comment"># 删除字典</span></span><br><span class="line"><span class="comment"># 不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住</span></span><br><span class="line"><span class="comment"># 键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行</span></span><br></pre></td></tr></table></figure>

<h3 id="4-1-字典的操作函数"><a href="#4-1-字典的操作函数" class="headerlink" title="4.1 字典的操作函数"></a>4.1 字典的操作函数</h3><table>
<thead>
<tr>
<th><strong>操作函数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>len(d)</td>
<td>字典d的元素个数（长度）</td>
</tr>
<tr>
<td>min(d)</td>
<td>字典d中键的最小值</td>
</tr>
<tr>
<td>max(d)</td>
<td>字典d中键的最大值</td>
</tr>
<tr>
<td>dict()</td>
<td>生成一个空字典</td>
</tr>
</tbody></table>
<h3 id="4-2-字典的操作方法"><a href="#4-2-字典的操作方法" class="headerlink" title="4.2 字典的操作方法"></a>4.2 字典的操作方法</h3><p>基本语法：<code>&lt;字典变量&gt;.&lt;方法名称&gt;(&lt;方法参数&gt;)</code></p>
<table>
<thead>
<tr>
<th><strong>操作方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>d.keys()</td>
<td>返回所有的键信息</td>
</tr>
<tr>
<td>d.values()</td>
<td>返回所有的值信息</td>
</tr>
<tr>
<td>d.items()</td>
<td>返回所有的键值对</td>
</tr>
<tr>
<td>d.get(key, default)</td>
<td>键存在则返回相应值，否则返回默认值</td>
</tr>
<tr>
<td>d.pop(key, default)</td>
<td>键存在则返回相应值，同时删除键值对，否则返回默认值</td>
</tr>
<tr>
<td>d.popitem()</td>
<td>随机从字典中取出一个键值对，以元组(key, value)形式返回</td>
</tr>
<tr>
<td>d.clear()</td>
<td>删除所有的键值对</td>
</tr>
</tbody></table>
<h3 id="创建字典"><a href="#创建字典" class="headerlink" title="创建字典"></a>创建字典</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>,<span class="string">&quot;b&quot;</span>:<span class="number">2</span>&#125; <span class="comment"># 一般的方式创建字典</span></span><br><span class="line">print(d)</span><br><span class="line">data = [(<span class="string">&quot;a&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>)] <span class="comment"># 根据其他序列新建字典</span></span><br><span class="line">print(data)</span><br><span class="line">d = <span class="built_in">dict</span>(data)</span><br><span class="line">print(d)</span><br><span class="line">d = <span class="built_in">dict</span>(lilei = <span class="number">98</span>,hanmeimei = <span class="number">99</span>) <span class="comment"># 根据关键字参数新建字典</span></span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># d.items()以列表返回可遍历的(键, 值) 元组数组</span></span><br><span class="line">d = &#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>,<span class="string">&quot;b&quot;</span>:<span class="number">2</span>,<span class="string">&quot;c&quot;</span>:<span class="number">4</span>&#125;</span><br><span class="line">print(d.keys())<span class="comment"># dict_keys([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]) 返回列表</span></span><br><span class="line">print(d.values())<span class="comment"># dict_values([1, 2, 4]) 返回列表</span></span><br><span class="line">print(d.items())<span class="comment"># 返回的是一个列表，其中包括多个元组</span></span><br><span class="line"><span class="comment"># dict_items([(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 4)])</span></span><br><span class="line">print(<span class="built_in">list</span>(d.items()))<span class="comment"># 用list()转化为列表</span></span><br><span class="line"><span class="comment"># [(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 4)]</span></span><br><span class="line"><span class="keyword">for</span> key, val <span class="keyword">in</span> d.items():</span><br><span class="line">    print(<span class="string">&quot;编号：&#123;&#125;，名称：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(key, val))</span><br><span class="line"><span class="comment"># 编号：a，名称：1</span></span><br><span class="line"><span class="comment"># 编号：b，名称：2</span></span><br><span class="line"><span class="comment"># 编号：c，名称：4</span></span><br></pre></td></tr></table></figure>

<h3 id="字典与列表的互相嵌套"><a href="#字典与列表的互相嵌套" class="headerlink" title="字典与列表的互相嵌套"></a>字典与列表的互相嵌套</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在列表中存储字典</span></span><br><span class="line">student1 = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;lilei&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>,<span class="string">&quot;grade&quot;</span>:<span class="number">98</span>&#125;</span><br><span class="line">student2 = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;hanmeimei&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">19</span>,<span class="string">&quot;grade&quot;</span>:<span class="number">99</span>&#125;</span><br><span class="line">student3 = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;madongmei&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>,<span class="string">&quot;grade&quot;</span>:<span class="number">95</span>&#125;</span><br><span class="line"></span><br><span class="line">student = [student1,student2,student3]</span><br><span class="line"></span><br><span class="line">print(student)</span><br><span class="line"><span class="comment"># 在字典中存储列表</span></span><br><span class="line">favorite_class = &#123;</span><br><span class="line">    <span class="string">&quot;lilei&quot;</span>:[<span class="string">&quot;math&quot;</span>,<span class="string">&quot;English&quot;</span>],</span><br><span class="line">    <span class="string">&quot;hanmeimei&quot;</span>:[<span class="string">&quot;yuwen&quot;</span>],</span><br><span class="line">    <span class="string">&quot;madongmei&quot;</span>:[<span class="string">&quot;computer&quot;</span>,<span class="string">&quot;magic&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">print(favorite_class[<span class="string">&quot;lilei&quot;</span>])</span><br><span class="line">print(favorite_class[<span class="string">&quot;madongmei&quot;</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<h3 id="列表和字典的引用"><a href="#列表和字典的引用" class="headerlink" title="列表和字典的引用"></a>列表和字典的引用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python中的赋值准确理解为贴标签，创建数据是相当于把数据放在盒子里，赋值时就是在盒子上贴标签</span></span><br><span class="line">l1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">l2 = l1</span><br><span class="line">l2[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line">print(<span class="string">f&#x27;l2:<span class="subst">&#123;l2&#125;</span>&#x27;</span>)</span><br><span class="line">print(<span class="string">f&#x27;l1:<span class="subst">&#123;l1&#125;</span>&#x27;</span>)<span class="comment"># 修改l1时l2也发生了变化</span></span><br><span class="line"><span class="comment">#l2:[5, 2, 3, 4]</span></span><br><span class="line"><span class="comment">#l1:[5, 2, 3, 4]</span></span><br><span class="line"><span class="comment"># 用.copy()方法克隆一个数据</span></span><br><span class="line">l1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">l2 = l1.copy()</span><br><span class="line">l2[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line">print(<span class="string">f&#x27;l1:<span class="subst">&#123;l1&#125;</span>&#x27;</span>)</span><br><span class="line">print(<span class="string">f&#x27;l2:<span class="subst">&#123;l2&#125;</span>&#x27;</span>)<span class="comment"># 修改l2时l1不发生变化</span></span><br><span class="line"><span class="comment">#l1:[1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">#l2:[5, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<h2 id="5-复数（complex）"><a href="#5-复数（complex）" class="headerlink" title="5.复数（complex）"></a>5.复数（complex）</h2><p><code>z = 1 + 2j</code></p>
<p>print(z.real,z.imag) # 实部和虚部，都是浮点型</p>
<h2 id="6-元组"><a href="#6-元组" class="headerlink" title="6.元组"></a>6.元组</h2><p>列表和元组的区别：</p>
<ul>
<li>列表元素用方括号包括，元组元素用圆括号包括；</li>
<li>列表中的元素可以修改、添加、删除，是可变的，而元组是不可变的。</li>
</ul>
<p>元组创建后并非是不可改变的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">t = (<span class="number">1</span>,<span class="number">2</span>,l)</span><br><span class="line">l[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line">print(t)</span><br><span class="line"><span class="comment"># (1, 2, [5, 2, 3])</span></span><br><span class="line"><span class="comment"># 元组中的可变元素是可以进行修改的</span></span><br></pre></td></tr></table></figure>

<h2 id="7-集合"><a href="#7-集合" class="headerlink" title="7.集合"></a>7.集合</h2><p>集合中的元素是惟一的，不能重复的。</p>
<p>创建集合:</p>
<p>注意：创建一个空集合必须用 set() 而不是 { }，<strong>因为 { } 是用来创建一个空字典</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>&#125;<span class="comment"># 直接创建</span></span><br><span class="line"></span><br><span class="line">set2 = <span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">4</span>])<span class="comment"># 用set()方法创建</span></span><br><span class="line">print(set1,set2)</span><br><span class="line"><span class="comment"># &#123;1, 2, 3, 4, 5, 7, 8&#125; &#123;1, 2, 3, 4, 6&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.集合的交集&amp;</span></span><br><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>&#125;</span><br><span class="line">print(set1 &amp; set2)</span><br><span class="line"><span class="comment"># &#123;1, 2, 3, 5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.集合的并集|</span></span><br><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>&#125;</span><br><span class="line">print(set1 | set2)</span><br><span class="line"><span class="comment"># &#123;1, 2, 3, 4, 5, 8, 9&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.集合的差集，在set1中但是不在set2</span></span><br><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>&#125;</span><br><span class="line">print(set1 - set2)</span><br><span class="line"><span class="comment"># &#123;8, 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.集合的对称差集，在set1或set2中，不同时在两个集合中</span></span><br><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>&#125;</span><br><span class="line">print(set1 ^ set2)</span><br><span class="line"><span class="comment">#  &#123;3, 4, 8, 9&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="8-程序的控制结构"><a href="#8-程序的控制结构" class="headerlink" title="8.程序的控制结构"></a>8.程序的控制结构</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.if——else语句</span></span><br><span class="line"><span class="keyword">if</span> XXX:</span><br><span class="line">    XXX</span><br><span class="line"><span class="keyword">elif</span> XXX:</span><br><span class="line">    XXX</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    XXX</span><br><span class="line"><span class="comment"># 簡化： eg, 1 if 1 &gt; 2 else 2</span></span><br><span class="line"><span class="comment"># 2.一般的while循环</span></span><br><span class="line"><span class="keyword">while</span> XXX:</span><br><span class="line">    XXX</span><br><span class="line"><span class="comment"># 3.while——else循环</span></span><br><span class="line"><span class="comment"># 当while循环正常执行之后，继续执行else语句并结束</span></span><br><span class="line"><span class="comment"># 只有使用break跳出循环是才不会执行else语句</span></span><br><span class="line"><span class="keyword">while</span> XXX:</span><br><span class="line">    XXX</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    XXX    </span><br><span class="line"><span class="comment"># example</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">5</span>:</span><br><span class="line">    print(i)</span><br><span class="line">    i += <span class="number">1</span>    </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;循环正常结束&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; 输出如下：</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">循环正常结束</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 4.break与continue</span></span><br><span class="line"><span class="comment"># 作用同C/C++中的break和continue，跳出循环，跳出本次循环</span></span><br><span class="line"><span class="comment"># 5.for循环</span></span><br><span class="line"><span class="comment"># for-in循环及range()的使用参见学习笔记一</span></span><br><span class="line"><span class="comment"># 6.for——else循环</span></span><br><span class="line"><span class="comment"># 只有使用break跳出循环是才不会执行else语句</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    print(i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;循环正常结束&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; 输出如下：</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">循环正常结束</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>    </span><br></pre></td></tr></table></figure>

<h2 id="9-异常处理"><a href="#9-异常处理" class="headerlink" title="9.异常处理"></a>9.异常处理</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># try-except结构</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    age = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入年龄数字：&quot;</span>))</span><br><span class="line">    print(age)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">&quot;输入有误！&quot;</span>)</span><br><span class="line"><span class="comment"># try-except-else结构</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    age = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入年龄数字：&quot;</span>))</span><br><span class="line">    print(age)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">&quot;输入有误！&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;输入正确！&quot;</span>)<span class="comment"># 当程序未出现异常（except）时，执行else语句</span></span><br><span class="line"><span class="comment"># try-except-else-finally结构</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    age = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入年龄数字：&quot;</span>))</span><br><span class="line">    print(age)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">&quot;输入有误！&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;输入正确！&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">&quot;运行结束&quot;</span>)<span class="comment"># 不管程序是否出现异常都会执行finally语句</span></span><br><span class="line"><span class="comment"># 捕捉多种异常</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    age = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入年龄数字：&quot;</span>))</span><br><span class="line">    print(age)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    print(<span class="string">&quot;输入内容非数字！&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">&quot;其他错误！&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Python入门笔记（五）</title>
    <url>/posts/f5296746.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-文件读取指针函数seek-用法详解"><a href="#1-文件读取指针函数seek-用法详解" class="headerlink" title="1.文件读取指针函数seek()用法详解"></a>1.文件读取指针函数seek()用法详解</h2><p>seek()方法的语法如下：<code>fileObject.seek(offset, from)</code></p>
<p>offset ： 开始的偏移量，也就是代表需要移动偏移的字节数，如果是负数表示从倒数第几位开始。 </p>
<p>from：可选，默认值为 0。给 offset 定义一个参数，表示要从哪个位置开始偏移；0 代表从文件开头开始算起，1 代表从当前位置开始算起，2 代表从文件末尾算起。</p>
<span id="more"></span>

<p><strong>实例1</strong></p>
<p>下面将用实例演示一下seek()方法的用法<br>下面是‘test.txt’文件内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">0123456789</span><br><span class="line">0123456789</span><br><span class="line">0123456789</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="comment">#只读方式，文件读取指针指向开头</span></span><br><span class="line">print(file.tell())           <span class="comment">#file.tell()返回当前读取指针</span></span><br><span class="line">file_data = file.readline()  <span class="comment">#读取一行数据</span></span><br><span class="line">print(file_data)</span><br><span class="line"></span><br><span class="line">file.seek(<span class="number">3</span>,<span class="number">0</span>)               <span class="comment">#从0开始偏移3个字节</span></span><br><span class="line">print(file.tell())</span><br><span class="line">file_data = file.readline()  <span class="comment">#读取一行数据</span></span><br><span class="line">print(file_data)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line">0123456789</span><br><span class="line"></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3456789</span></span><br><span class="line"></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>上述结果之间空一行是因为读取了末尾的换行符</p>
<p><strong>实例2</strong></p>
<p>下面我再说一个例子，关于文件打开模式为‘a+’情况下的例子<br>文件跟上一个例子一样，先看代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;a+&#x27;</span>)  <span class="comment">#可读写方式，文件读取指针指向末尾，数据追加在末尾</span></span><br><span class="line">print(file.tell())             <span class="comment">#file.tell()返回当前读取指针</span></span><br><span class="line">file.write(<span class="string">&#x27;9876543210\n&#x27;</span>)     <span class="comment">#末尾写入数据</span></span><br><span class="line">print(file.tell())             <span class="comment">#文件写入后返回当前读取指针</span></span><br><span class="line">file_data = file.readline()    <span class="comment">#读取一行数据</span></span><br><span class="line">print(<span class="string">&#x27;one&#x27;</span> + file_data)       <span class="comment">#文件读取指针在末尾，读取数据为空</span></span><br><span class="line">file.seek(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">print(<span class="string">&#x27;two&#x27;</span> + file.readline()) <span class="comment">#文件读取指针在开头，读取第一行数据</span></span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">36</span></span><br><span class="line"><span class="number">48</span></span><br><span class="line">one</span><br><span class="line">two0123456789</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>没有读取到数据是因为文件读取指针指向了末尾，所以在使用‘a+’模式时，如果要读取数据要利用seek(0,0)设置文件读取指针<br>‘test.txt’的变化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">0123456789</span><br><span class="line">0123456789</span><br><span class="line">0123456789</span><br><span class="line"><span class="number">9876543210</span></span><br><span class="line"></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>上述这个例子是我学习Python文件操作时遇到的坑，在利用‘a+’模式打开文件并写入数据后，用readline()怎么都无法读取数据，后来了解到是因为文件读取指针在末尾，所以无法读取数据，要用seek(0，0)方法将文件读取指针重置，才可以读取数据。</p>
<h2 id="2-小练习"><a href="#2-小练习" class="headerlink" title="2.小练习"></a>2.小练习</h2><h3 id="2-1-题目简化："><a href="#2-1-题目简化：" class="headerlink" title="2.1 题目简化："></a>2.1 题目简化：</h3><p>将浮点数num保留整数部分输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># solution 1</span></span><br><span class="line">print(<span class="string">&quot;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">int</span>(num)))</span><br><span class="line"><span class="comment"># solution 2</span></span><br><span class="line">print(<span class="string">&quot;&#123;:.0f&#125;&quot;</span>.<span class="built_in">format</span>(num)) <span class="comment"># 掌握这种做法</span></span><br><span class="line"><span class="comment"># print(&quot;&#123;:d&#125;&quot;.format(num))这样不行，无法直接将浮点型转换为int</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-python的连续不等式写法："><a href="#2-2-python的连续不等式写法：" class="headerlink" title="2.2 python的连续不等式写法："></a>2.2 python的连续不等式写法：</h3><p><code>1 &lt;= n &lt;=  2</code></p>
<p>这种写法在python中是合理的，在其他大多数语言可能不成立。</p>
<h3 id="2-3-小例题1"><a href="#2-3-小例题1" class="headerlink" title="2.3 小例题1"></a>2.3 小例题1</h3><p>让用户输入一个数字，判断它是否等于553，如果不等于则让用户再次输入，否则退出程序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">not</span> n.isdigit()) <span class="keyword">or</span> n != <span class="number">553</span>:<span class="comment">#  错误示范！！！教训！！！</span></span><br><span class="line">	n = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">    </span><br><span class="line">n = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">not</span> n.isdigit()) <span class="keyword">or</span> <span class="built_in">int</span>(n) != <span class="number">553</span>: <span class="comment"># n是字符串，需要先转换！！</span></span><br><span class="line">	n = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br></pre></td></tr></table></figure>

<h3 id="2-4-小例题2"><a href="#2-4-小例题2" class="headerlink" title="2.4 小例题2"></a>2.4 小例题2</h3><p><img src="/posts/f5296746/image-20210204162557662.png" alt="image-20210204162557662"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># solution 1</span></span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">sa = s.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">a = <span class="built_in">int</span>(sa[<span class="number">0</span>])</span><br><span class="line">b = <span class="built_in">int</span>(sa[<span class="number">1</span>])</span><br><span class="line">c = <span class="built_in">int</span>(sa[<span class="number">2</span>])</span><br><span class="line">ls = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(c):</span><br><span class="line">	ls.append(a + b * i)</span><br><span class="line">print(ls)</span><br><span class="line"><span class="comment"># solution 2</span></span><br><span class="line">a,b,c = <span class="built_in">input</span>().split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">a,b,c = <span class="built_in">int</span>(a),<span class="built_in">int</span>(b),<span class="built_in">int</span>(c)</span><br><span class="line">ls = [a + b * i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(c)] <span class="comment"># 生成列表一步到位</span></span><br><span class="line">print(ls)</span><br></pre></td></tr></table></figure>

<h3 id="2-5-小例题3"><a href="#2-5-小例题3" class="headerlink" title="2.5 小例题3"></a>2.5 小例题3</h3><p>判断用户输入的一个数是不是回文数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># solution 1</span></span><br><span class="line">n = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">t = n</span><br><span class="line">m = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> t:</span><br><span class="line">	m = m*<span class="number">10</span> + t%<span class="number">10</span></span><br><span class="line">	t //= <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n == m:</span><br><span class="line">	print(<span class="string">&quot;是&quot;</span>) </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(<span class="string">&quot;否&quot;</span>)</span><br><span class="line"><span class="comment"># solution 2</span></span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">if</span> s == s[::-<span class="number">1</span>]:</span><br><span class="line">    print(<span class="string">&quot;是&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(<span class="string">&quot;否&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3-pass语句"><a href="#3-pass语句" class="headerlink" title="3.pass语句"></a>3.pass语句</h2><p>Python pass 是空语句，是为了保持程序结构的完整性。</p>
<p><strong>pass</strong> 不做任何事情，一般用做占位语句。</p>
<p>在 Python 中有时候会看到一个 def 函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample</span>(<span class="params">n_samples</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>该处的 pass 便是占据一个位置，因为如果定义一个空函数程序会报错，当你没有想好函数的内容是可以用 pass 填充，使程序可以正常运行。（python3中好像可以定义空函数）</p>
<h2 id="4-for循环补充小知识"><a href="#4-for循环补充小知识" class="headerlink" title="4.for循环补充小知识"></a>4.for循环补充小知识</h2><p>在for-in循环中，不能对<code>虚拟变量i</code>进行修改，但是可以对<code>可迭代对象s</code>进行修改。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;abcdefghijklmn&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="string">&quot;a&quot;</span>:</span><br><span class="line">        i = <span class="string">&quot;s&quot;</span></span><br><span class="line">print(s)</span><br><span class="line"><span class="comment"># abcdefghijklmn</span></span><br><span class="line">s = <span class="string">&quot;abcdefghijklmn&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    s = <span class="string">&quot;vn&quot;</span></span><br><span class="line">print(s)</span><br><span class="line"><span class="comment"># vn</span></span><br></pre></td></tr></table></figure>

<h2 id="5-错题1"><a href="#5-错题1" class="headerlink" title="5.错题1"></a>5.错题1</h2><p>以下说法中错误的是（）<br>A、对已经关闭的文件进行读写操作会默认再次打开文件<br>B、对文件操作完成后即使不关闭文件也不会报错，所以可以不关闭文件<br>C、对于非空文本文件，read()返回字符串，readlines()返回列表<br>D、file = open(filename,’rb’)表示只读、二进制方式打开名为filename的文件</p>
<p>答案选A.    B选项是正确的。</p>
<h2 id="6-错题2"><a href="#6-错题2" class="headerlink" title="6.错题2"></a>6.错题2</h2><p>1、编写代码将列表ls  = [‘新年都未有芳华，\n’,’ 二月初惊见草芽。\n’,’白雪却嫌春色晚，\n’,’故穿庭树作飞花。’]、<br>写入a.txt文件内容如下：<br>新年都未有芳华，<br>二月初惊见草芽。<br>白雪却嫌春色晚，<br>故穿庭树作飞花。</p>
<p>2、读取a.txt中的内容，并输出。输出格式如下(输出为一行)：<br>     新年都未有芳华，二月初惊见草芽。白雪却嫌春色晚， 故穿庭树作飞花。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># solution for 1</span></span><br><span class="line">ls  = [<span class="string">&#x27;新年都未有芳华，\n&#x27;</span>,<span class="string">&#x27;二月初惊见草芽。\n&#x27;</span>,<span class="string">&#x27;白雪却嫌春色晚，\n&#x27;</span>,<span class="string">&#x27;故穿庭树作飞花。&#x27;</span>]</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;a.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line">f.writelines(ls)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;a.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> ls:</span><br><span class="line">	f.write(s)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># solution for 2，不会啊</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;a.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">t = f.readlines()</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> t:</span><br><span class="line">	print(line.strip(<span class="string">&quot;\n&quot;</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h2 id="7-练习1"><a href="#7-练习1" class="headerlink" title="7.练习1"></a>7.练习1</h2><p>二千多年前希腊的天文学家希巴克斯命名十二星座，它们是水瓶座、双鱼座、白羊座、金牛座、<br>双子座、巨蟹座、狮子座、处女座、天秤座、天蝎座、射手座、摩羯座。给出一个CSV文件（SunSign.csv），<br>内容示例如下：<br>序号,星座,开始月日,结束月日,Unicode<br>1,水瓶座,120,218,9810<br>2,双色座,219,320,9811<br>3,白羊座,321,419,9800<br>4,金牛座,420,520,9801<br>5,双子座,521,621,9802<br>…（略）<br>以第1行为例,120表示1月20日,218表示2月18日,9810是Unicode码。<br>问题：读入CSV文件中数据，获得用户输入。根据用户输入的星座名称，输出此星座的出生日期范围。<br>参考输入和输出示例格式如下：<br>请输入星座中文名称（例如，双子座）：双子座<br>双子座的生日位于521-621之间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># solution 1</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;SunSign.csv&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">ls = f.readlines()</span><br><span class="line">L = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> ls:</span><br><span class="line">	L.append(line.strip(<span class="string">&quot;\n&quot;</span>).split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">n = <span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> L:</span><br><span class="line">	<span class="keyword">if</span>(l[<span class="number">1</span>] == n):</span><br><span class="line">		print(<span class="string">&quot;&#123;&#125;的生日位于&#123;&#125;-&#123;&#125;之间&quot;</span>.<span class="built_in">format</span>(n,l[<span class="number">2</span>],l[<span class="number">3</span>]))</span><br><span class="line">f.close()</span><br><span class="line"><span class="comment"># solution 2，巧妙的解法</span></span><br><span class="line">n = <span class="built_in">input</span>()</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;SunSign.csv&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">ls = f.readlines()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; ls : </span></span><br><span class="line"><span class="string">[&#x27;序号,星座,开始月日,结束月日,Unicode\n&#x27;,</span></span><br><span class="line"><span class="string">     ...,</span></span><br><span class="line"><span class="string">&#x27;12,魔蝎座,1222,119,9809\n&#x27;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> ls:</span><br><span class="line">    lt = line.split(<span class="string">&quot;,&quot;</span>)<span class="comment"># 用&#x27;,&#x27;分隔产生列表lt</span></span><br><span class="line">    <span class="keyword">if</span> s == lt[<span class="number">1</span>]:</span><br><span class="line">        print(<span class="string">&quot;&#123;&#125;的生日位于&#123;&#125;-&#123;&#125;之间&quot;</span>.<span class="built_in">format</span>(n,lt[<span class="number">2</span>],lt[<span class="number">3</span>]))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h2 id="8-错题3"><a href="#8-错题3" class="headerlink" title="8.错题3"></a>8.错题3</h2><p><img src="/posts/f5296746/image-20210222184011849.png" alt="image-20210222184011849"></p>
<p>当<code>fo.write()</code>完成后，指针指向文件末尾，此时<code>fo.read()</code>无法读取到内容。</p>
<h2 id="9-练习2"><a href="#9-练习2" class="headerlink" title="9.练习2"></a>9.练习2</h2><p><img src="/posts/f5296746/image-20210306230603132.png" alt="image-20210306230603132"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;vacations.csv&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">ls = f.readlines()</span><br><span class="line">s = <span class="built_in">input</span>(<span class="string">&quot;请输入节假日名称(例如,春节):&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> ls:</span><br><span class="line">    lt = line.strip(<span class="string">&quot;\n&quot;</span>).split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> s == lt[<span class="number">1</span>]:</span><br><span class="line">        print(<span class="string">&quot;&#123;&#125;的假期位于&#123;&#125;-&#123;&#125;之间&quot;</span>.<span class="built_in">format</span>(lt[<span class="number">1</span>],lt[<span class="number">2</span>],lt[<span class="number">3</span>]))</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简化版本</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;vacations.csv&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">s = <span class="built_in">input</span>(<span class="string">&quot;请输入节假日名称(例如,春节):&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:<span class="comment"># 直接遍历文件，也是一行一行读取</span></span><br><span class="line">    lt = line.strip(<span class="string">&quot;\n&quot;</span>).split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> s == lt[<span class="number">1</span>]:</span><br><span class="line">        print(<span class="string">&quot;&#123;&#125;的假期位于&#123;&#125;-&#123;&#125;之间&quot;</span>.<span class="built_in">format</span>(lt[<span class="number">1</span>],lt[<span class="number">2</span>],lt[<span class="number">3</span>]))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h5 id="10-练习3"><a href="#10-练习3" class="headerlink" title="10.练习3"></a>10.练习3</h5><p>使用字典和列表型变量完成某课程的考勤记录统计，某班有 74 名同学，名单由考生目录下文件 name.txt 给出，</p>
<p>某课程第一次考勤数据由考生目录下文件 card.csv 给出。请求出第一次缺勤同学的名单。‪</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># solution 1，自己写的，比较复杂</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;name.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">d = <span class="built_in">dict</span>()</span><br><span class="line">lt = f.readlines()</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lt:</span><br><span class="line">    d[line.strip(<span class="string">&quot;\n&quot;</span>)] = <span class="number">0</span></span><br><span class="line">print(d)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">ft = <span class="built_in">open</span>(<span class="string">&quot;card.csv&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">ls = ft.readlines()</span><br><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> ls:</span><br><span class="line">    <span class="keyword">if</span> d.get(l.strip(<span class="string">&quot;\n&quot;</span>).split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>],<span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">        d[l.strip(<span class="string">&quot;\n&quot;</span>).split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>]] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> key,val <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="keyword">if</span> val == <span class="number">0</span>:</span><br><span class="line">        print(key)</span><br><span class="line">ft.close()</span><br><span class="line"><span class="comment"># solution 2，比较简单</span></span><br><span class="line">f_name = <span class="built_in">open</span>(<span class="string">&quot;name.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">f_card = <span class="built_in">open</span>(<span class="string">&quot;card.csv&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">ls = f_name.readlines()</span><br><span class="line">lt = f_card.readlines()</span><br><span class="line">L = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lt:</span><br><span class="line">    L.append(line.split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ls:</span><br><span class="line">    name = i.strip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> L:</span><br><span class="line">        print(name)</span><br><span class="line">f_name.close()</span><br><span class="line">f_card.close()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Python入门笔记（六）</title>
    <url>/posts/90272c9f.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-列表作为函数参数的例子"><a href="#1-列表作为函数参数的例子" class="headerlink" title="1.列表作为函数参数的例子"></a>1.列表作为函数参数的例子</h2><span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x=[],y=[<span class="number">6</span>,<span class="number">7</span>]</span>):</span></span><br><span class="line">    x.append(<span class="number">8</span>)</span><br><span class="line">    y.append(<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line">a,b = [<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">t = func(x=a)</span><br><span class="line">t = func(y=b)</span><br><span class="line">print(func(),end=<span class="string">&quot;;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>执行完第7行：</p>
<p>a = [1,2,8] <strong>注意</strong>：a被func函数修改了</p>
<p>b = [3,4] # 不变</p>
<p>x = [1,2,8]</p>
<p>y = [6,7,8]</p>
<p>t = [1,2,8,6,7,8]</p>
<p>执行完第8行：</p>
<p>a = [1,2,8] # 不变</p>
<p>b = [3,4,8]</p>
<p>x = [8] </p>
<p>y = [3,4,8]</p>
<p>执行完第9行：</p>
<p>func()中传入上一步得到的默认参数x和y</p>
<p>输出[8,8,3,4,8,8];</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x=[],y=[<span class="number">6</span>,<span class="number">7</span>]</span>):</span></span><br><span class="line">    x.append(<span class="number">8</span>)</span><br><span class="line">    print(<span class="string">&quot;x:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(x))</span><br><span class="line">    y.append(<span class="number">8</span>)</span><br><span class="line">    print(<span class="string">&quot;y:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(y))</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line">a,b = [<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">t = func(x=a)</span><br><span class="line">t = func(y=b)</span><br><span class="line">print(func(),end=<span class="string">&quot;;&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;x:[1, 2, 8]</span></span><br><span class="line"><span class="string">y:[6, 7, 8]</span></span><br><span class="line"><span class="string">x:[8]</span></span><br><span class="line"><span class="string">y:[3, 4, 8]</span></span><br><span class="line"><span class="string">x:[8, 8]</span></span><br><span class="line"><span class="string">y:[6, 7, 8, 8]</span></span><br><span class="line"><span class="string">[8, 8, 6, 7, 8, 8];&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-python处理空行输入"><a href="#2-python处理空行输入" class="headerlink" title="2.python处理空行输入"></a>2.python处理空行输入</h2><p>input()遇到空行、回车即停止，即使没接收到有效输入。</p>
<p><img src="/posts/90272c9f/image-20210317205917723.png" alt="image-20210317205917723"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = <span class="built_in">input</span>()  <span class="comment"># 课程名 考分</span></span><br><span class="line"><span class="meta">... </span> </span><br><span class="line"><span class="keyword">while</span> data:</span><br><span class="line">    ...</span><br><span class="line">    data = <span class="built_in">input</span>()</span><br></pre></td></tr></table></figure>

<h2 id="3-Python算法刷题"><a href="#3-Python算法刷题" class="headerlink" title="3.Python算法刷题"></a>3.Python算法刷题</h2><p>一位python大佬：<a href="https://www.acwing.com/user/myspace/index/73331/">https://www.acwing.com/user/myspace/index/73331/</a></p>
<p>输入输出模板参考：（特别详细）<a href="https://blog.csdn.net/weixin_44399621/article/details/105760997">https://blog.csdn.net/weixin_44399621/article/details/105760997</a></p>
<p><strong>对于输入：</strong></p>
<p>常见的不同的输入格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">2</span></span><br><span class="line">m,n=<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().strip().split())</span><br><span class="line">nums=<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().strip().split()))</span><br></pre></td></tr></table></figure>

<p><strong>对于输出：</strong></p>
<p>python中最常用的输出是使用format格式。</p>
<p><strong>二维数组初始化：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result_table=[[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"><span class="comment"># 以下是把一个5行4列的数组初始化为0</span></span><br><span class="line">result_table=[[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"><span class="comment"># 更简便的做法</span></span><br><span class="line">s = [<span class="number">0</span>]*n</span><br></pre></td></tr></table></figure>

<p><strong>标准化输入输出：</strong></p>
<p>例题</p>
<ul>
<li>题目描述<br>  计算a+b</li>
<li>输入描述<br>  输入包括两个正整数a,b(1&lt;=a, b&lt;=10^9)，输入数据包括多组。</li>
<li>输出描述<br>  输出a+b的结果</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入样例：</span><br><span class="line"><span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">10</span> <span class="number">20</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">30</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解法1</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		a,b = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">		print(a+b)</span><br><span class="line">	<span class="keyword">except</span>:</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line"><span class="comment"># 解法2</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">	<span class="keyword">if</span> line == <span class="string">&#x27;\n&#x27;</span>:<span class="keyword">break</span></span><br><span class="line">	a,b = (<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> line.split())</span><br><span class="line">	result = a + b</span><br><span class="line">	sys.stdout.write(<span class="string">&quot;&#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(result))</span><br><span class="line"><span class="comment"># 解法3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> sys.stdin:</span><br><span class="line">	b = a.split()</span><br><span class="line">	print(<span class="built_in">int</span>(b[<span class="number">0</span>])+<span class="built_in">int</span>(b[<span class="number">1</span>]))</span><br><span class="line"><span class="comment"># 解法4</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		<span class="keyword">try</span>:</span><br><span class="line">			a,b = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>(),split())</span><br><span class="line">			print(a + b)</span><br><span class="line">		<span class="keyword">except</span>:</span><br><span class="line">			<span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>import语句</p>
<p> 引入模块，import sys引入python<strong>标准库</strong>中的sys.py模块</p>
</li>
<li><p>sys.stdin</p>
<ul>
<li><p>sys.stdin是一个标准化输入的方法。</p>
</li>
<li><p>使用sys.stdin.readline()可以实现标准输入，其中默认输入的格式是字符串，如果是int，float类型则需要强制转换。</p>
</li>
<li><p>与input()区别<br>  sys.stdin.readline()会将标准输入全部获取，包括末尾的‘\n‘，因此用len计算长度时是把换行符’\n‘计算进去的，而input()获取输入时返回的结果是不包含末尾的换行符’\n‘的。<br>  此外，input()括号内可以直接填写说明文字，例如：</p>
<p>  <code>n = int(input(&#39;Please input a number:\n&#39;))</code></p>
</li>
</ul>
</li>
<li><p>解法4解释</p>
<ul>
<li><code>if __name__=&quot;__main__&quot;</code>：<br>  当.py文件被直接运行时，<code>if __name__=&quot;__main__&quot;</code>之下的代码块将被运行；<br>  当.py文件以模块形式被导入时，<code>if __name__=&quot;__main__&quot;</code>之下的代码块不被运行。<br>  个人理解：相当于程序入口，方便调用。</li>
</ul>
</li>
</ol>
<p>==100-days04.循环结构，开始看130道字符串内置方法==</p>
<p><a href="https://github.com/jackfrued/Python-100-Days">https://github.com/jackfrued/Python-100-Days</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Python入门笔记（四）</title>
    <url>/posts/9ab7a201.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-小练习"><a href="#1-小练习" class="headerlink" title="1.小练习"></a>1.小练习</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># s = &quot;* ** ** hel  l* o*  ** * *  &quot;</span></span><br><span class="line"><span class="comment"># 去除两边的&#x27; &#x27;和&#x27;*&#x27;</span></span><br><span class="line"><span class="keyword">while</span> s[<span class="number">0</span>] == <span class="string">&quot;*&quot;</span> <span class="keyword">or</span> s[<span class="number">0</span>] == <span class="string">&quot; &quot;</span>:</span><br><span class="line">    s.strip()</span><br><span class="line">    s.strip(<span class="string">&quot;*&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> s[-<span class="number">1</span>] == <span class="string">&quot;*&quot;</span> <span class="keyword">or</span> s[-<span class="number">1</span>] == <span class="string">&quot; &quot;</span>:</span><br><span class="line">    s.strip()</span><br><span class="line">    s.strip(<span class="string">&quot;*&quot;</span>)  </span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="2-计算思维"><a href="#2-计算思维" class="headerlink" title="2.计算思维"></a>2.计算思维</h2><p>考点：计算思维的本质是抽象和自动化。</p>
<p>自顶向下设计，自底向上执行。</p>
<h2 id="3-常用内置函数"><a href="#3-常用内置函数" class="headerlink" title="3.常用内置函数"></a>3.常用内置函数</h2><p><img src="/posts/9ab7a201/image-20210121155428455.png" alt="image-20210121155428455"></p>
<h2 id="4-turtle库"><a href="#4-turtle库" class="headerlink" title="4.turtle库"></a>4.turtle库</h2><h3 id="turtle库的引用方式"><a href="#turtle库的引用方式" class="headerlink" title="turtle库的引用方式"></a>turtle库的引用方式</h3><p>第一种，import turtle，则对turtle库中函数调 用采用turtle.&lt;函数名&gt;()形式。</p>
<p>第二种，from turtle import *，则对turtle库中 函数调用直接采用&lt;函数名&gt;()形式，不在使用 turtle.作为前导。</p>
<p>第三种，import turtle as t，则对turtle库中函数 调用采用更简洁的t.&lt;函数名&gt;()形式，保留字as 的作用是将turtle库给予别名t。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line">turtle.fd(<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="keyword">from</span> turtle <span class="keyword">import</span> *</span><br><span class="line">fd(<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="keyword">import</span> turtle <span class="keyword">as</span> t <span class="comment"># 类似取别名</span></span><br><span class="line">t.fd(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<h3 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h3><p><code>turtle.setup(width, height, startx, starty)</code> 窗体函数</p>
<p>作用：设置主窗体的大小和位置 参数： </p>
<p>width ：窗口宽度，如果值是整数，表示的像素值；如果值 是小数，表示窗口宽度与屏幕的比例； </p>
<p>height: 窗口高度，如果值是整数，表示的像素值；如果 值是小数，表示窗口高度与屏幕的比例； </p>
<p>startx：窗口左侧与屏幕左侧的像素距离，如果值是None ，窗口位于屏幕水平中央； </p>
<p>starty：窗口顶部与屏幕顶部的像素距离，如果值是None ，窗口位于屏幕垂直中央。</p>
<h3 id="常用状态函数"><a href="#常用状态函数" class="headerlink" title="常用状态函数"></a>常用状态函数</h3><table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>pendown()</td>
<td>放下画笔</td>
</tr>
<tr>
<td>penup()</td>
<td>拿起画笔</td>
</tr>
<tr>
<td>pensize()</td>
<td>设置画笔线条的粗细</td>
</tr>
<tr>
<td>pencolor()</td>
<td>设置画笔颜色</td>
</tr>
<tr>
<td>color()</td>
<td>设置画笔和填充颜色</td>
</tr>
<tr>
<td>begin_fill()</td>
<td>填充图形前，调用该方法</td>
</tr>
<tr>
<td>end_fill()</td>
<td>填充图形结束</td>
</tr>
<tr>
<td>filling()</td>
<td>返回填充状态，True为填充，较少用到</td>
</tr>
<tr>
<td>clear()</td>
<td>清空当前窗口</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>reset()</td>
<td>清空当前窗口，并重置位置</td>
</tr>
<tr>
<td>write(str,font=None)</td>
<td>输出font字体的字符串</td>
</tr>
<tr>
<td>screensize()</td>
<td>设置画布的长和宽</td>
</tr>
<tr>
<td>hideturtle()</td>
<td>隐藏画笔的turtle形状，比较重要</td>
</tr>
<tr>
<td>showturtle</td>
<td>显示画笔形状</td>
</tr>
<tr>
<td>Isvisible()</td>
<td>如果画笔可见则显示true</td>
</tr>
</tbody></table>
<h3 id="常用运动函数"><a href="#常用运动函数" class="headerlink" title="常用运动函数"></a>常用运动函数</h3><table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>forward()</td>
<td>沿着当前指定方向前进距离</td>
</tr>
<tr>
<td>backward()</td>
<td>沿着当前相反方向后退指定距离</td>
</tr>
<tr>
<td>setheading(angle)</td>
<td>设置当前朝向为angle角度</td>
</tr>
<tr>
<td>circle(r,e)</td>
<td>绘制一个半径r和角度e的圆或弧形</td>
</tr>
<tr>
<td>undo()</td>
<td>撤销画笔最后一步动作</td>
</tr>
<tr>
<td>right(angle)</td>
<td>向右旋转angle角度</td>
</tr>
<tr>
<td>left(angle)</td>
<td>向左旋转angle角度</td>
</tr>
<tr>
<td>goto(x,y)</td>
<td>移动到绝对坐标（x,y）处</td>
</tr>
<tr>
<td>speed()</td>
<td>设置画笔得绘制速度，参数为0-10</td>
</tr>
<tr>
<td>dot(d,color)</td>
<td>绘制一个直径d和颜色color的圆点</td>
</tr>
<tr>
<td>home()</td>
<td>设置当前画笔位置为原点，朝向东</td>
</tr>
</tbody></table>
<p>实例1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># import turtle</span></span><br><span class="line"><span class="comment"># turtle.fd(100)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># from turtle import *</span></span><br><span class="line"><span class="comment"># fd(100)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># import turtle as t</span></span><br><span class="line"><span class="comment"># t.fd(100)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> turtle <span class="keyword">import</span> *</span><br><span class="line">penup() <span class="comment"># 抬起画笔</span></span><br><span class="line">pendown() <span class="comment"># 放下画笔，有点多余</span></span><br><span class="line">fd(<span class="number">100</span>)</span><br><span class="line">done()  <span class="comment"># 避免一闪而过，对于第一种导入方式改成turtle.done()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> turtle <span class="keyword">as</span> t</span><br><span class="line">t.pensize(<span class="number">5</span>) <span class="comment"># 粗细为5pix</span></span><br><span class="line">t.pencolor(<span class="string">&quot;blue&quot;</span>)</span><br><span class="line">t.fd(<span class="number">110</span>)</span><br><span class="line">t.done()</span><br><span class="line"></span><br><span class="line"><span class="comment"># color(),begin_fill()和end_fill()是搭配使用的</span></span><br><span class="line"><span class="keyword">import</span> turtle <span class="keyword">as</span> t</span><br><span class="line">t.color(<span class="string">&quot;green&quot;</span>, <span class="string">&quot;red&quot;</span>)</span><br><span class="line">t.begin_fill()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    t.fd(<span class="number">120</span>)</span><br><span class="line">    t.left(<span class="number">120</span>)</span><br><span class="line">t.end_fill()</span><br><span class="line">t.done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line">turtle.fd(<span class="number">200</span>)</span><br><span class="line"><span class="comment"># turtle.clear()  # 注意！清空窗口(只擦掉痕迹)但画笔停留在200处</span></span><br><span class="line"><span class="comment"># turtle.reset()  # 清空窗口并重置画笔位置</span></span><br><span class="line">turtle.write(<span class="string">&quot;你好&quot;</span>)</span><br><span class="line">turtle.hideturtle()</span><br><span class="line">turtle.done()</span><br><span class="line"></span><br><span class="line"><span class="comment"># hideturtle()和showturtle()是搭配使用的</span></span><br></pre></td></tr></table></figure>

<p>实例2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle <span class="keyword">as</span> t</span><br><span class="line">t.forward(<span class="number">100</span>),简写成fd(<span class="number">100</span>)</span><br><span class="line">t.fd(-<span class="number">100</span>) <span class="comment"># == t.backward(100)</span></span><br><span class="line">t.done()</span><br><span class="line"></span><br><span class="line">t.setheading(<span class="number">60</span>),简写成seth(<span class="number">60</span>)</span><br><span class="line">t.fd(<span class="number">100</span>)</span><br><span class="line">t.circle(<span class="number">100</span>)</span><br><span class="line">t.circle(<span class="number">100</span>, <span class="number">180</span>)</span><br><span class="line">t.circle(<span class="number">100</span>, <span class="number">180</span>, <span class="number">5</span>)</span><br><span class="line">t.undo()  <span class="comment"># 撤销最后一步动作</span></span><br><span class="line">t.done()</span><br><span class="line"></span><br><span class="line"><span class="comment"># right()和left()比较重要</span></span><br><span class="line"><span class="comment"># seth()是朝着某角度方向，left()是旋转某角度</span></span><br><span class="line">t.speed(<span class="number">1</span>)</span><br><span class="line">t.left(<span class="number">60</span>)</span><br><span class="line">t.left(<span class="number">60</span>)  <span class="comment"># 旋转是有记忆的</span></span><br><span class="line">t.fd(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">t.goto(<span class="number">100</span>, <span class="number">200</span>)  <span class="comment"># 向绝对坐标移动，不改变方向</span></span><br><span class="line">t.dot(<span class="number">100</span>, <span class="string">&quot;pink&quot;</span>)</span><br><span class="line">t.home()  <span class="comment"># 画笔回到原点，方向朝东</span></span><br><span class="line">t.done()</span><br></pre></td></tr></table></figure>

<h2 id="5-random库"><a href="#5-random库" class="headerlink" title="5.random库"></a>5.random库</h2><p>使用random库主要目的是生成随机数 </p>
<p>​    这个库提供了不同类型的随机数函数，其中最基本的函数是<code>random.random()</code>，它生成 一个[0.0, 1.0)之间的随机小数，所有其他随机函数都是基于这个函数扩展而来。</p>
<p>random库常用函数： </p>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>seed(a=None)</td>
<td>初始化随机数种子，默认值为当前系统时间</td>
</tr>
<tr>
<td>random()</td>
<td>生成一个[0.0,  1.0)之间的随机小数</td>
</tr>
<tr>
<td>randint(a,  b)</td>
<td>生成一个[a,b]之间的整数</td>
</tr>
<tr>
<td>getrandbits(k)</td>
<td>生成一个k比特长度的随机整数</td>
</tr>
<tr>
<td>randrange(start,  stop[, step])</td>
<td>生成一个[start,  stop)之间以step为步数的随机整数</td>
</tr>
<tr>
<td>uniform(a,  b)</td>
<td>生成一个[a,  b]之间的随机小数</td>
</tr>
<tr>
<td>choice(seq)</td>
<td>从序列类型(例如：列表)中随机返回一个元素，考试常考</td>
</tr>
<tr>
<td>shuffle(seq)</td>
<td>将序列类型中元素随机排列，返回打乱后的序列</td>
</tr>
<tr>
<td>sample(pop,  k)</td>
<td>从pop类型中随机选取k个元素，以列表类型返回</td>
</tr>
</tbody></table>
<p>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">n = random.random()</span><br><span class="line"><span class="comment"># 注意生成随机数的右边区间开闭情况</span></span><br><span class="line">print(n)</span><br><span class="line"><span class="comment"># 学到了，文件名不要设置成random库名，否则会报错循环导入，憨憨</span></span><br><span class="line"><span class="comment"># random.seed()  # seed参数限定了后面生成随机数的值</span></span><br><span class="line">m = random.randint(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">print(m)</span><br><span class="line">t = random.getrandbits(<span class="number">6</span>)</span><br><span class="line">print(<span class="built_in">bin</span>(t))</span><br><span class="line">print(random.randrange(<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>))</span><br><span class="line">print(random.uniform(<span class="number">1</span>,<span class="number">11</span>))</span><br><span class="line">ls = [<span class="number">12</span>,<span class="number">34.56</span>,<span class="number">4</span>,<span class="string">&quot;你&quot;</span>,<span class="string">&quot;我&quot;</span>,<span class="number">1434</span>,<span class="number">34</span>,[<span class="number">2</span>,<span class="number">3</span>,<span class="number">232.4</span>]]</span><br><span class="line">print(random.choice(ls)) <span class="comment"># 有返回值</span></span><br><span class="line">random.shuffle(ls)  <span class="comment"># 无返回值</span></span><br><span class="line">print(ls)</span><br><span class="line">lt = random.sample(ls,<span class="number">3</span>)</span><br><span class="line">print(lt)</span><br></pre></td></tr></table></figure>

<h2 id="6-time库"><a href="#6-time库" class="headerlink" title="6.time库"></a>6.time库</h2><p>处理时间是程序最常用的功能之一，time库是Python提供的处理时间标准库。time库提供系统级精确计时器的计时功能，可以用来分析程序性能，也可让程序暂停运行时间。</p>
<p>time库的功能主要分为3个方面：时间处理、 时间格式化和计时。 </p>
<p>• 时间处理主要包括4个函数：time.time()、 time.gmtime()、time.localtime() 、time.ctime()。 </p>
<p>• 时间格式化主要包括3个函数：time.mktime()、 time.strftime()、time.strptime()。 </p>
<p>• 计 时 主 要 包用到 1 个 函 数 ： time.sleep( )。</p>
<p>使用time.gmtime(secs)获取当前时间戳对应的struct_time对象。</p>
<p>使用time.localtime(secs)获取当前时间戳对应的本地时间的struct_time对象。</p>
<p>time库使用time.mktime()、time.strftime()、 time.strptime()进行时间格式化。 </p>
<p>使用time.mktime(t) 将struct_time对象t转换 为时间戳，注意t代表当地时间。</p>
<p>time.strftime()函数是时间格式化最有效的方法，几 乎可以以任何通用格式输出时间。该方法利用一个 格式字符串，对时间格式进行表达。</p>
<p><strong>strftime()方法的格式化控制符</strong> </p>
<p><img src="/posts/9ab7a201/image-20210125095305368.png" alt="image-20210125095305368"></p>
<p><img src="/posts/9ab7a201/image-20210125101522267.png" alt="image-20210125101522267"></p>
<p>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">print(time.time())  <span class="comment"># 获取当前时间戳</span></span><br><span class="line">print(time.gmtime())  <span class="comment"># 很少考到，返回UTC时间</span></span><br><span class="line">print(time.localtime())  <span class="comment"># 经常考到，一定要记住，返回本地北京时间</span></span><br><span class="line">print(time.ctime())  <span class="comment"># 返回当地时间对应的字符串</span></span><br><span class="line">t = time.localtime()</span><br><span class="line">print(time.mktime(t))</span><br><span class="line">print(time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, t))  <span class="comment"># 记住这些常用的，这是考的最多的</span></span><br><span class="line">timestring = <span class="string">&quot;2020-04-17 10:17:44&quot;</span>  <span class="comment"># 反格式化</span></span><br><span class="line">print(time.strptime(timestring, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>))  <span class="comment"># 和上面相反，用到较少</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># time.sleep()较常用到，记住</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    print(i)</span><br><span class="line">    time.sleep(<span class="number">3</span>)  <span class="comment"># 每次循环睡眠3秒</span></span><br></pre></td></tr></table></figure>

<h2 id="7-PyInstaller库"><a href="#7-PyInstaller库" class="headerlink" title="7.PyInstaller库"></a>7.PyInstaller库</h2><p>PyInstaller是一个十分有用的Python第三方库，它能够在Windows、Linux、Mac OS  X等操作系统下将Python源文件打包，变成直接可运行的可执行文件。通过对源文件打包，Python程序可以在没有安装Python的环境中运行，也可以作为一个独立文件方便传递和管理。</p>
<p><img src="/posts/9ab7a201/image-20210125102142517.png" alt="image-20210125102142517"></p>
<p>第2种方式在dist文件夹中只有一个exe文件。（记住常用参数指令）</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-h,  –help</td>
<td>查看帮助</td>
</tr>
<tr>
<td>–clean</td>
<td>清理打包过程中的临时文件</td>
</tr>
<tr>
<td>-D,  –onedir</td>
<td>默认值，生成dist目录</td>
</tr>
<tr>
<td>-F,  –onefile</td>
<td>在dist文件夹中只生成独立的打包文件</td>
</tr>
<tr>
<td>-i  &lt;图标文件名.ico  &gt;</td>
<td>指定打包程序使用的图标（icon）文件</td>
</tr>
</tbody></table>
<p>eg : <code>pyinstaller -F -i 1.cio yinyang.py</code></p>
<p>eg : <code>pyinstaller -F -w yinyang.py  # -w去掉运行exe时的黑窗口</code></p>
<h2 id="8-jieba库"><a href="#8-jieba库" class="headerlink" title="8.jieba库"></a>8.jieba库</h2><p>1、由于中文文本中的单词不是通过空格或者标点符号分割，中文及类似语言存在一个重要的“分词”问题。</p>
<p>2、jieba（“结巴”）是Python中一个重要的第三方中文分词函数库。</p>
<p>3、jieba库的分词原理是利用一个中文词库，将待分词的内容与分词词库进行比对，通过图结构和动态规划方法找到最大概率的词组。除了分词jieba还提供增加自定义中文单词的功能。</p>
<p>4、jieba库支持三种分词模式：精确模式，将句子最精确地切开，适合文本分析；全模式，把句子中所有可以成词的词语都扫描出来，速度非常快，但是不能解决歧义；搜索引擎模式，在精确模式基础上，对长词再次切分，提高召回率，适合用于搜索引擎分词。</p>
<p>1、<code>jieba.lcut(s)</code>是最常用的中文分词函数，用于精准模式，即将字符串分割成等量的中文词组，返回结果是列表类型。</p>
<p>2、<code>jieba.lcut(s, cut_all = True)</code>用于全模式，即将字符串的所有分词可能均列出来，返回结果是列表类型，冗余性最大。</p>
<p>3、<code>jieba.lcut_for_search(s)</code>返回搜索引擎模式，该模式首先执行精确模式，然后再对其中长词进一步切分获得最终结果。搜索引擎模式更倾向于寻找短词语，这种方式具有一定冗余度，但冗余度相比全模式较少。</p>
<p>4、<code>jieba.add_word()</code>函数，顾名思义，用来向jieba词库增加新的单词。</p>
<p>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line">ls = jieba.lcut(<span class="string">&quot;全国计算机等级考试python科目&quot;</span>)</span><br><span class="line">print(ls)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> jieba <span class="keyword">import</span> *</span><br><span class="line">ls = lcut(<span class="string">&quot;全国计算机等级考试python科目&quot;</span>,cut_all = <span class="literal">True</span>)</span><br><span class="line">print(ls)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line">ls = jieba.lcut_for_search(<span class="string">&quot;全国计算机等级考试python科目&quot;</span>)</span><br><span class="line">print(ls)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line">jieba.add_word(<span class="string">&quot;奥利给&quot;</span>)</span><br><span class="line">ls = jieba.lcut(<span class="string">&quot;作为一个年轻人，我们要努力加油，奥利给！！&quot;</span>)</span><br><span class="line">print(ls)</span><br></pre></td></tr></table></figure>

<h2 id="9-wordcloud库"><a href="#9-wordcloud库" class="headerlink" title="9.wordcloud库"></a>9.wordcloud库</h2><p>1、wordcloud库是专门用于根据文本生成词云的Python第三方库，十分常用且有趣。</p>
<p>2、装wordcloud库在Windows的cmd命令行使用</p>
<p><img src="/posts/9ab7a201/image-20210125111300257.png" alt="image-20210125111300257"></p>
<p><img src="/posts/9ab7a201/image-20210125111332948.png" alt="image-20210125111332948"></p>
<p><strong>WordCloud对象创建的常用参数</strong></p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td>font_path</td>
<td>指定字体文件的完整路径，默认None</td>
</tr>
<tr>
<td>width</td>
<td>生成图片宽度，默认400像素</td>
</tr>
<tr>
<td>height</td>
<td>生成图片高度，默认200像素</td>
</tr>
<tr>
<td>mask</td>
<td>词云形状，默认None，即，方形图</td>
</tr>
<tr>
<td>min_font_size</td>
<td>词云中最小的字体字号，默认4号</td>
</tr>
<tr>
<td>font_step</td>
<td>字号步进间隔，默认1</td>
</tr>
<tr>
<td>min_font_size</td>
<td>词云中最大的字体字号，默认None，根据高度自动调节</td>
</tr>
<tr>
<td>max_words</td>
<td>词云图中最大词数，默认200</td>
</tr>
<tr>
<td>stopwords</td>
<td>被排除词列表，排除词不在词云中显示</td>
</tr>
<tr>
<td>background_color</td>
<td>图片背景颜色，默认黑色</td>
</tr>
</tbody></table>
<p>WordCloud不显示中文问题解决：</p>
<p>在下面的代码中添加<code>font_path=&quot;./kai.ttf&quot;</code>（自己替换），选择一个支持中文的字体。无法确定是否支持中文的话，双击字体打开查看，有中文显示就是支持中文的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wc=WordCloud(font_path=<span class="string">&quot;./kai.ttf&quot;</span>,background_color=<span class="string">&quot;white&quot;</span>,width=<span class="number">800</span>,height=<span class="number">600</span>,max_font_size=<span class="number">50</span>,max_words=<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td>generate(text)</td>
<td>由text文本生成词云</td>
</tr>
<tr>
<td>to_file(filename)</td>
<td>将词云图保存为名为filename的文件</td>
</tr>
</tbody></table>
<p>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> wordcloud</span><br><span class="line">txt = <span class="string">&quot;i like python and i am learning python&quot;</span></span><br><span class="line">wd = wordcloud.WordCloud().generate(txt)</span><br><span class="line">wd.to_file(<span class="string">&quot;test.png&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">txt = <span class="string">&#x27;&#x27;&#x27;程序设计语言是计算机能够识别和理解用户</span></span><br><span class="line"><span class="string">操作意图的一种交互体系，它能够按照特定的规则</span></span><br><span class="line"><span class="string">组织计算机指令，使得计算机能够自动进行各种运算处理</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> wordcloud</span><br><span class="line">ls = jieba.lcut(txt)</span><br><span class="line">txtwords = <span class="string">&#x27; &#x27;</span>.join(ls)</span><br><span class="line">print(txtwords)</span><br><span class="line">wd = wordcloud.WordCloud(font_path=<span class="string">r&quot;F:\下载\方正楷体_GBK.TTF&quot;</span>,width=<span class="number">800</span>,height=<span class="number">600</span>).generate(txtwords) </span><br><span class="line"><span class="comment"># wordcloud默认不支持中文，得设置font_path添加中文字体</span></span><br><span class="line">wd.to_file(<span class="string">&quot;word.png&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="10-python第三方库纵览"><a href="#10-python第三方库纵览" class="headerlink" title="10.python第三方库纵览"></a>10.python第三方库纵览</h2><p>考选择题，以记忆库的名称、作用为主。</p>
<p><img src="/posts/9ab7a201/image-20210125115734415.png" alt="image-20210125115734415"></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python入门</tag>
        <tag>Python库</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫笔记（一）</title>
    <url>/posts/5bfa9466.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="1bed4f258515a14852924851fb5f528e160591474e96b93948fac08e6ad6060e">fb26124e0d85f363a66baed35993e1a0948953cce3d484fb31660455b92ccb286ba4467b12dd2afdc0f8bd795964707216933c479f00faf5302337078027ef66e68c754bf0232403ae44399aa06a2cad741400e24549082709cdee4a1c1e38f29d8bb6993c43448bafc4543d636ea5bfe35062ad225c74a80f232ba51d9af45093f5220e616be2d57e02341ffad661bef2886dba249b54377d8b3961fd62e8e7033554e6a1a85b429bcdccd8e910eaca84c8e447cedd760cd76a16c64ec7f94ad050108487716cc544f1ca685285a120a1c590efd559bdca18a90707fae890221e2912f079f089d10fb816e69e85944586941b721161d200273028ce2f3cb2d1a6a47461dcfac58b4612622383de37911e7101936179b0ecfeb18f3600111afc775a9e1f79696dae92585891ef4dfac160145b8ade1b67eb64723081d43668f083d1232e20edbf9c7a1c72e8b931884226c3228462653e34a1c392bf003a7455e1578ccec33a44cf13f75e99713b1b38ed5bdc402f8eb92851c5c0e5893d94249ca010b463eef4ba084e3bcd5c34d5aad8dfb23c0610548d2e626f8d96719c7d756c08b4a8819d50c4fec2e1dfae1d3d0fed5f161f5dabc4627605d3860cfc00a015bec92d30b3f04e6245753b59e08012db168890c90fa639db1f55a9578be352039db23dcf7f35a11966ce0b618c0a0bfc0a7b6e91615723df09a8fa41527759277d19278c9ac0f2a75a6ede4b8737f9a7d032435ccec01a14dceac045ebe7883862b8b29a3fcce85465f0d88c8b6ecce6bb97cc4a76c05e0d83a93fec13357a059573f490153f9c5bef0804cd61284ec73a04ee7fa72a2b78bb4e4c2661723139dfd15a27d089bb9c5f0458e1a585e2991ba17d6e98d85cb3cce7688d96c172b57d03fcd57f179d17c235e0ab981977808f12f5bb1475f0da43377a28af8cfcf6ec247234fa11dc64dec1400e9803ede279bd62b451d30f42a9b54163fdac7ff1186d144dbb80697b35a8b16f00d4b94592639f5ee17a54cd4c04e85ac3ef343bca0d351d89bd2c32c76b740b1ce685fded996df1167b70941ab44d933a7f305e9e367c8bd5ec7e727c1dffb615c3fe9e56fd87cb80f5ee161aea0e394f7e1d328d701abb47e4fee7009f8bde26530fabc8b27af60a60bc914a8df2cd8d39735b64fd2deab8e38501c5286ca90c54bfe61f8600ca3b1a4f43932c9aa2a7b3dab10b942a2c1ad044241cd56121b2ca54d501a3bc4254b514141c98fcaee71b056b72006d153c2afea30a5b9de7d50caa2843115761776fda13c324ea67023b85f25fdc09c3adca743d482212d6659740f8901a66964ffb34f91a68d91fc312f069340b6c7da2a608c2fb41595f21e68cf1d6ef704026cb0e3b8c1bf1fe1e9498850fd95709cb9c0ca786b727c85b1c0ec3e1e9c336f961563bea2ec6fe39c57df085be74637c8af73361d274c01ae5fbe478707520d390574d3e9bff3fd0744b955a14a4203d9b9564062ba02de1f09b88ddfad8c4a3d01940ad1937d747a4c3215416379cca0bb0ec1cee7d6eac1e323e78c1cb1c75ac9c06a3f23a01521c0e6dfa13eb47d5d450440301fb1771bb00582bfafab7e50ecce74ec29315383fc4d039d14046c30c8237651064f5a8d5476194b06f4c37a06233d1dbb4af14a0626d06d893dd367f9d57a59bb2f8165054d482949f599693ed46312c720ec96cdfc5e4828660461fb1e90a968a903d5e299e48558e60502fa35c816765d4e285eb475259fb94e6991d265488bbdb269c82cee4753a82c0395ec74a763cf9495661bc6f668436f18a297c0a1cbb7c37e112d88be85f4344a6da276956e3625a15ccbb3b2c1d84389ec86d94f852e2327d1f79a69a62a286a0b690e4eee622472f7c4ca8858d20423143f4f986f32875b95f2ea558ee1c076115e38c7f84cf24e7dc1e1e530a9345d5b67085f6f69622a6b50e7271ff19198f09251f21b77aa5b4a2fcd190356f2b4914b185485c4f014cd37daad52e36e4791ef6c4e1d3bf863a8c31f1f52dd3a7695ce296818745c4e91685e081c5cb1ac5a4e3c0b63fbb0e628e536b1fa6db4fdf0ae30a85832a82c8ae03f908b518b377a7b037e2ef931e2ec193470f2c8770ff4ba077bab70bd16ab7d772cc2273fb0019532cd2d7801342c3653ac1397a8e81b5dc1e8a7274cf92b5a3d7f94719cc8dc0b72297d84639584308eeac214422932f52aef1dc5c876a9a434be611dfe198af573e9c340a7b2c9742bb67ef7151120b43d06780f19fa885f99ad4ad164df13427de3020e5e3424e212fbe826063ffb58f0969d85b2ec907932cbdb59d590f72d6ef3df760bd82e3c5fcbf1ebf73d16c4ebc97d4a25c0d68bad230401236ffdfe0e5062e13cd7cc07f98366ab8c637b57b06202a3364f3b0b15993da879251b49523aca771398b3a30c5fc623e9f67c214c8c52d28325da6abe0b3334b1334cb641449c9f82ad09a027ac9ae5c321af9f9d391e9f3f62dd904ee63f154e36c3b8c6888674601cd17d04f6ec7a4886531fea264f40fd2d1efbb1f891dbbc64be544edd1adbb1fb5</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Python进阶笔记（一）</title>
    <url>/posts/f4f081c5.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一-面向对象概述"><a href="#一-面向对象概述" class="headerlink" title="一.面向对象概述"></a>一.面向对象概述</h1><h2 id="1-面向过程与面向对象"><a href="#1-面向过程与面向对象" class="headerlink" title="1.面向过程与面向对象"></a>1.面向过程与面向对象</h2><ol>
<li><p><strong>面向过程</strong> —— <strong>怎么做</strong>？</p>
</li>
<li><p>把完成某一个需求的 <code>所有步骤</code> <code>从头到尾</code> 逐步实现</p>
</li>
<li><p>根据开发需求，将某些 <strong>功能独立</strong> 的代码 <strong>封装</strong> 成一个又一个 <strong>函数</strong></p>
</li>
<li><p>最后完成的代码，就是顺序地调用 <strong>不同的函数</strong></p>
<span id="more"></span>

</li>
</ol>
<p><strong>特点</strong></p>
<ol>
<li><p>注重 <strong>步骤与过程</strong>，不注重职责分工</p>
</li>
<li><p>如果需求复杂，代码会变得很复杂</p>
</li>
<li><p><strong>开发复杂项目，没有固定的套路，开发难度很大！</strong></p>
</li>
<li><p><strong>面向对象</strong> —— <strong>谁来做</strong>？</p>
</li>
</ol>
<blockquote>
<p>相比较函数，<strong>面向对象</strong> 是 <strong>更大</strong> 的 <strong>封装</strong>，根据 <strong>职责</strong> 在 <strong>一个对象中 封装 多个方法</strong></p>
</blockquote>
<ol>
<li>在完成某一个需求前，首先确定 <strong>职责</strong> —— <strong>要做的事情（方法）</strong></li>
<li>根据 <strong>职责</strong> 确定不同的 <strong>对象</strong>，在 <strong>对象</strong> 内部封装不同的 <strong>方法</strong>（多个）</li>
<li>最后完成的代码，就是顺序地让 <strong>不同的对象</strong> 调用 <strong>不同的方法</strong></li>
</ol>
<p><strong>特点</strong></p>
<ol>
<li>注重 <strong>对象和职责</strong>，不同的对象承担不同的职责</li>
<li>更加适合应对复杂的需求变化，<strong>是专门应对复杂项目开发，提供的固定套路</strong></li>
<li><strong>需要在面向过程基础上，再学习一些面向对象的语法</strong></li>
</ol>
<h2 id="2-重要概念：类和对象"><a href="#2-重要概念：类和对象" class="headerlink" title="2.重要概念：类和对象"></a>2.重要概念：类和对象</h2><h3 id="2-1-概念引入"><a href="#2-1-概念引入" class="headerlink" title="2.1 概念引入"></a>2.1 概念引入</h3><p>在洗衣机洗衣服的过程中，洗衣机就是我们所说的对象，整个过程描述如下：图纸—&gt;洗衣机—&gt;洗衣服。在这个过程中，图纸就是类，而洗衣机就是对象。有了类，我们就能根据它来创建对象。</p>
<p><strong>简单的说，类是对象的蓝图和模板，而对象是类的实例。</strong>这个解释虽然有点像用概念在解释概念，但是从这句话我们至少可以看出，类是抽象的概念，而对象是具体的东西。在面向对象编程的世界中，一切皆为对象，对象都有属性和行为，每个对象都是独一无二的，而且对象一定属于某个类（型）。当我们把一大堆拥有共同特征的对象的静态特征（属性）和动态特征（行为）都抽取出来后，就可以定义出一个叫做“类”的东西。</p>
<p><strong>类和对象的关系</strong></p>
<ul>
<li><strong>类是模板</strong>，<strong>对象</strong> 是根据 <strong>类</strong> 这个模板创建出来的，应该 <strong>先有类，再有对象</strong></li>
<li>类只有一个，而对象可以有很多个<ul>
<li><strong>不同的对象</strong> 之间 <strong>属性</strong> 可能会各不相同</li>
</ul>
</li>
<li><strong>类</strong> 中定义了什么 <strong>属性和方法</strong>，<strong>对象</strong> 中就有什么属性和方法，<strong>不可能多，也不可能少</strong></li>
</ul>
<p><strong>总结：类和对象的关系，就是用类去创建一个对象，或者用类去实例化一个对象。</strong></p>
<h3 id="2-2-类"><a href="#2-2-类" class="headerlink" title="2.2 类"></a>2.2 类</h3><p>类是对一系列列具有相同特征和行为的事物的统称，<strong>是一个抽象的概念，不是真实存在的事物</strong>。</p>
<ul>
<li>特征即是属性</li>
<li>行为即是方法</li>
</ul>
<p>在程序开发中，要设计一个类，通常需要满足一下三个要素：</p>
<ol>
<li><strong>类名</strong> 这类事物的名字，<strong>满足大驼峰命名法</strong></li>
<li><strong>属性</strong> 这类事物具有什么样的特征</li>
<li><strong>方法</strong> 这类事物具有什么样的行为</li>
</ol>
<p><strong>大驼峰命名法</strong></p>
<p><code>CapWords</code></p>
<ol>
<li>每一个单词的首字母大写</li>
<li>单词与单词之间没有下划线</li>
</ol>
<p><strong>类名的确定</strong></p>
<p><strong>名词提炼法</strong> 分析 <strong>整个业务流程</strong>，出现的 <strong>名词</strong>，通常就是找到的类</p>
<p><strong>属性和方法的确定</strong></p>
<ul>
<li>对 <strong>对象的特征描述</strong>，通常可以定义成 <strong>属性</strong></li>
<li><strong>对象具有的行为</strong>（动词），通常可以定义成 <strong>方法</strong></li>
</ul>
<blockquote>
<p>提示：需求中没有涉及的属性或者方法在设计类时，不需要考虑</p>
</blockquote>
<h3 id="2-3-对象"><a href="#2-3-对象" class="headerlink" title="2.3 对象"></a>2.3 对象</h3><p>对象是<strong>类创建出来的真实存在的事物</strong>，例如：洗衣机。</p>
<blockquote>
<p>注意：开发中，先有类，再有对象。</p>
</blockquote>
<h3 id="2-4-定义类"><a href="#2-4-定义类" class="headerlink" title="2.4 定义类"></a>2.4 定义类</h3><p>在Python中可以使用<code>class</code>关键字定义类，然后在类中通过之前学习过的函数来定义方法，这样就可以将对象的动态特征描述出来，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名():</span></span><br><span class="line">    代码</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Washer</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wash</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;我会洗衣服&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># __init__是一个特殊方法用于在创建对象时进行初始化操作</span></span><br><span class="line">    <span class="comment"># 通过这个方法我们可以为学生对象绑定name和age两个属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">study</span>(<span class="params">self, course_name</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;%s正在学习%s.&#x27;</span> % (self.name, course_name))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># PEP 8要求标识符的名字用全小写多个单词用下划线连接</span></span><br><span class="line">    <span class="comment"># 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">watch_movie</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.age &lt; <span class="number">18</span>:</span><br><span class="line">            print(<span class="string">&#x27;%s只能观看《熊出没》.&#x27;</span> % self.name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&#x27;%s正在观看爱情大电影.&#x27;</span> % self.name)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明：</strong> 写在类中的函数，我们通常称之为（对象的）方法，这些方法就是对象可以接收的消息。</p>
</blockquote>
<h3 id="2-5-创建和使用对象"><a href="#2-5-创建和使用对象" class="headerlink" title="2.5 创建和使用对象"></a>2.5 创建和使用对象</h3><p>对象又名实例。创建对象也叫做实例化对象。</p>
<p>语法：<code>对象名 = 类名()</code></p>
<p>当我们定义好一个类之后，可以通过下面的方式来创建对象并给对象发消息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 创建学生对象并指定姓名和年龄</span></span><br><span class="line">    stu1 = Student(<span class="string">&#x27;骆昊&#x27;</span>, <span class="number">38</span>)</span><br><span class="line">    <span class="comment"># 给对象发study消息</span></span><br><span class="line">    stu1.study(<span class="string">&#x27;Python程序设计&#x27;</span>)</span><br><span class="line">    <span class="comment"># 给对象发watch_av消息</span></span><br><span class="line">    stu1.watch_movie()</span><br><span class="line">    stu2 = Student(<span class="string">&#x27;王大锤&#x27;</span>, <span class="number">15</span>)</span><br><span class="line">    stu2.study(<span class="string">&#x27;思想品德&#x27;</span>)</span><br><span class="line">    stu2.watch_movie()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="3-面向对象基础语法"><a href="#3-面向对象基础语法" class="headerlink" title="3.面向对象基础语法"></a>3.面向对象基础语法</h2><h3 id="3-1-dir内置函数（知道）"><a href="#3-1-dir内置函数（知道）" class="headerlink" title="3.1 dir内置函数（知道）"></a>3.1 dir内置函数（知道）</h3><ul>
<li>在 <code>Python</code> 中 <strong>对象几乎是无所不在的</strong>，我们之前学习的 <strong>变量</strong>、<strong>数据</strong>、<strong>函数</strong> 都是对象</li>
</ul>
<p>在 <code>Python</code> 中可以使用以下两个方法验证：</p>
<ol>
<li>在 <strong>标识符</strong> / <strong>数据</strong> 后输入一个 <code>.</code>，然后按下 <code>TAB</code> 键，<code>iPython</code> 会提示该对象能够调用的 <strong>方法列表</strong></li>
<li>使用内置函数 <code>dir</code> 传入 <strong>标识符</strong> / <strong>数据</strong>，可以查看对象内的<strong>所有属性及方法</strong></li>
</ol>
<p><strong>提示</strong> <code>__方法名__</code> 格式的方法是 <code>Python</code> 提供的 <strong>内置方法 / 属性</strong>，稍后会给大家介绍一些常用的内置方法 / 属性</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法名</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>01</td>
<td><code>__new__</code></td>
<td>方法</td>
<td><strong>创建对象</strong>时，会被 <strong>自动</strong> 调用</td>
</tr>
<tr>
<td>02</td>
<td><code>__init__</code></td>
<td>方法</td>
<td><strong>对象被初始化</strong>时，会被 <strong>自动</strong> 调用</td>
</tr>
<tr>
<td>03</td>
<td><code>__del__</code></td>
<td>方法</td>
<td><strong>对象被从内存中销毁</strong>前，会被 <strong>自动</strong> 调用</td>
</tr>
<tr>
<td>04</td>
<td><code>__str__</code></td>
<td>方法</td>
<td>返回<strong>对象的描述信息</strong>，<code>print</code> 函数输出使用</td>
</tr>
</tbody></table>
<p><strong>提示</strong> 利用好 <code>dir()</code> 函数，在学习时很多内容就不需要死记硬背了</p>
<h3 id="3-2-定义简单的类（仅包含方法）"><a href="#3-2-定义简单的类（仅包含方法）" class="headerlink" title="3.2 定义简单的类（仅包含方法）"></a>3.2 定义简单的类（仅包含方法）</h3><h4 id="3-2-1-定义只包含方法的类"><a href="#3-2-1-定义只包含方法的类" class="headerlink" title="3.2.1 定义只包含方法的类"></a>3.2.1 定义只包含方法的类</h4><ul>
<li>在 <code>Python</code> 中要定义一个只包含方法的类，语法格式如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> 方法1(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> 方法2(<span class="params">self, 参数列表</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>方法</strong> 的定义格式和之前学习过的<strong>函数</strong> 几乎一样</li>
<li>区别在于第一个参数必须是 <code>self</code>，大家暂时先记住，稍后介绍 <code>self</code></li>
</ul>
<blockquote>
<p>注意：<strong>类名</strong> 的 命名规则 要符合 <strong>大驼峰命名法</strong></p>
</blockquote>
<h4 id="3-2-2-创建对象"><a href="#3-2-2-创建对象" class="headerlink" title="3.2.2 创建对象"></a>3.2.2 创建对象</h4><p>对象又名实例。创建对象也叫做实例化对象。</p>
<p>语法：<code>对象名 = 类名()</code></p>
<h4 id="3-2-3-第一个面向对象程序"><a href="#3-2-3-第一个面向对象程序" class="headerlink" title="3.2.3 第一个面向对象程序"></a>3.2.3 第一个面向对象程序</h4><p><strong>需求</strong></p>
<ul>
<li><strong>小猫</strong> 爱 <strong>吃</strong> 鱼，<strong>小猫</strong> 要 <strong>喝</strong> 水</li>
</ul>
<p><strong>分析</strong></p>
<ol>
<li>定义一个猫类 <code>Cat</code></li>
<li>定义两个方法 <code>eat</code> 和 <code>drink</code></li>
<li>按照需求 —— 不需要定义属性</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span> <span class="comment"># 对类进行封装</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;这是一个猫类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;小猫爱吃鱼&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drink</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;小猫在喝水&quot;</span>)</span><br><span class="line"></span><br><span class="line">tom = Cat() <span class="comment"># 创建一个叫tom的对象</span></span><br><span class="line">tom.drink() <span class="comment"># 调用tom中的方法</span></span><br><span class="line">tom.eat()</span><br><span class="line">print(tom) <span class="comment"># 打印tom对象在内存中的地址</span></span><br><span class="line">addr = <span class="built_in">id</span>(tom)</span><br><span class="line">print(<span class="string">&quot;%x&quot;</span> % addr)</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># 小猫在喝水</span></span><br><span class="line"><span class="comment"># 小猫爱吃鱼</span></span><br><span class="line"><span class="comment"># &lt;__main__.Cat object at 0x7f76373fa670&gt;</span></span><br><span class="line"><span class="comment"># 7f780b7c1670</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-4-引用概念的强调"><a href="#3-2-4-引用概念的强调" class="headerlink" title="3.2.4 引用概念的强调"></a>3.2.4 引用概念的强调</h4><blockquote>
<p>在面向对象开发中，<strong>引用</strong>的概念是同样适用的！</p>
</blockquote>
<ul>
<li>在 <code>Python</code> 中使用类 <strong>创建对象之后</strong>，<code>tom</code> 变量中 仍然记录的是 <strong>对象在内存中的地址</strong></li>
<li>也就是 <code>tom</code> 变量 <strong>引用</strong> 了 <strong>新建的猫对象</strong></li>
<li>使用 <code>print</code> 输出 <strong>对象变量</strong>，默认情况下，是能够输出这个变量 <strong>引用的对象</strong> 是 <strong>由哪一个类创建的对象</strong>，以及 <strong>在内存中的地址</strong>（<strong>十六进制表示</strong>）</li>
</ul>
<blockquote>
<p>提示：在计算机中，通常使用 <strong>十六进制</strong> 表示 <strong>内存地址</strong></p>
<ul>
<li><strong>十进制</strong> 和 <strong>十六进制</strong> 都是用来表达数字的，只是表示的方式不一样</li>
<li><strong>十进制</strong> 和 <strong>十六进制</strong> 的数字之间可以来回转换</li>
</ul>
</blockquote>
<ul>
<li><code>%d</code> 可以以 <strong>10 进制</strong> 输出数字</li>
<li><code>%x</code> 可以以 <strong>16 进制</strong> 输出数字</li>
</ul>
<p>补充知识：引用与赋值</p>
<p>在Python中，令values=[0,1,2];values[1]=values,为何结果是[0,[…],2]?]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>values[<span class="number">1</span>] = values</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>values[<span class="number">0</span>, [...], <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>我预想应当是 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>但结果却为何要赋值无限次？</p>
<p><strong>可以说 Python 没有赋值，只有引用</strong>。你这样相当于创建了一个引用自身的结构，所以导致了无限循环。为了理解这个问题，有个基本概念需要搞清楚。</p>
<p>Python 没有「变量」，我们平时所说的变量其实只是「标签」，是引用。这里的引用类似C语言中的指针。</p>
<h4 id="3-2-5-使用Cat类再创建一个对象"><a href="#3-2-5-使用Cat类再创建一个对象" class="headerlink" title="3.2.5 使用Cat类再创建一个对象"></a>3.2.5 使用Cat类再创建一个对象</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;这是一个猫类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;小猫爱吃鱼&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drink</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;小猫在喝水&quot;</span>)</span><br><span class="line"></span><br><span class="line">tom = Cat()</span><br><span class="line">tom.drink()</span><br><span class="line">tom.eat()</span><br><span class="line">print(tom)</span><br><span class="line"></span><br><span class="line">lazy_cat = Cat()</span><br><span class="line">lazy_cat.eat()</span><br><span class="line">lazy_cat.drink()</span><br><span class="line">print(lazy_cat) <span class="comment"># lazy_cat 和 tom 是两个不同的对象</span></span><br><span class="line">lazy_cat2 = lazy_cat <span class="comment"># 这里涉及到引用</span></span><br><span class="line">print(lazy_cat2) <span class="comment"># lazy_cat2和lazy_cat2表示同一个对象</span></span><br><span class="line"><span class="comment"># 小猫在喝水</span></span><br><span class="line"><span class="comment"># 小猫爱吃鱼</span></span><br><span class="line"><span class="comment"># &lt;__main__.Cat object at 0x7fbcf2de2670&gt;</span></span><br><span class="line"><span class="comment"># 小猫爱吃鱼</span></span><br><span class="line"><span class="comment"># 小猫在喝水</span></span><br><span class="line"><span class="comment"># &lt;__main__.Cat object at 0x7fbcf2de7fd0&gt;</span></span><br><span class="line"><span class="comment"># &lt;__main__.Cat object at 0x7f0869e2afd0&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-案例改造-——-给对象增加属性"><a href="#3-3-案例改造-——-给对象增加属性" class="headerlink" title="3.3 案例改造 —— 给对象增加属性"></a>3.3 案例改造 —— 给对象增加属性</h3><ul>
<li><p>在Python中，要给对象设置属性，非常的容易，但是不推荐使用</p>
<p>因为：对象属性的封装应该封装在类的内部</p>
</li>
<li><p>只需要在 <strong>类的外部的代码</strong> 中直接通过 <code>.</code> 设置一个属性即可</p>
</li>
</ul>
<blockquote>
<p>注意：这种方式虽然简单，但是不推荐使用！</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tom.name = <span class="string">&quot;Tom&quot;</span> <span class="comment"># 这种属性只针对tom</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">lazy_cat.name = <span class="string">&quot;大懒猫&quot;</span> <span class="comment"># 这种属性只针对lazy_cat</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-方法中的self参数"><a href="#3-4-方法中的self参数" class="headerlink" title="3.4 方法中的self参数"></a>3.4 方法中的self参数</h3><blockquote>
<p>由 <strong>哪一个对象</strong> 调用的方法，方法内的 <code>self</code> 就是 <strong>哪一个对象的引用</strong></p>
</blockquote>
<ul>
<li>在类封装的方法内部，<code>self</code> 就表示 <strong>当前调用方法的对象自己</strong></li>
<li><strong>调用方法时</strong>，程序员不需要传递 <code>self</code> 参数</li>
<li>在方法内部<ul>
<li>可以通过 <code>self.</code> <strong>访问对象的属性</strong></li>
<li>也可以通过 <code>self.</code> <strong>调用其他的对象方法</strong></li>
</ul>
</li>
<li>改造代码如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;%s 爱吃鱼&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">tom = Cat()</span><br><span class="line">tom.name = <span class="string">&quot;Tom&quot;</span> <span class="comment"># 访问对象的属性</span></span><br><span class="line">tom.eat() <span class="comment"># 访问对象的方法</span></span><br><span class="line"></span><br><span class="line">lazy_cat = Cat()</span><br><span class="line">lazy_cat.name = <span class="string">&quot;大懒猫&quot;</span></span><br><span class="line">lazy_cat.eat()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">output:</span></span><br><span class="line"><span class="string">Tom 爱吃鱼</span></span><br><span class="line"><span class="string">大懒猫 爱吃鱼</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/f4f081c5/005_%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84self.png" alt="005_方法中的self"></p>
<ul>
<li>在 <strong>类的外部</strong>，通过 <code>变量名.</code> 访问对象的 <strong>属性和方法</strong></li>
<li>在 <strong>类封装的方法中</strong>，通过 <code>self.</code> 访问对象的 <strong>属性和方法</strong></li>
</ul>
<h3 id="3-5-注意避免在类的外部给对象增加属性"><a href="#3-5-注意避免在类的外部给对象增加属性" class="headerlink" title="3.5 注意避免在类的外部给对象增加属性"></a>3.5 注意避免在类的外部给对象增加属性</h3><ul>
<li>将案例代码进行调整，<strong>先调用方法 再设置属性</strong>，观察一下执行效果</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tom = Cat()</span><br><span class="line">tom.drink()</span><br><span class="line">tom.eat()</span><br><span class="line">tom.name = <span class="string">&quot;Tom&quot;</span></span><br><span class="line">print(tom)</span><br></pre></td></tr></table></figure>

<ul>
<li>程序执行报错如下：</li>
<li>原因：python自顶向下执行，执行<code>tom.drink()</code>时不能通过self.name访问name，因为name还未定义。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">AttributeError: <span class="string">&#x27;Cat&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;name&#x27;</span></span><br><span class="line">属性错误：<span class="string">&#x27;Cat&#x27;</span> 对象没有 <span class="string">&#x27;name&#x27;</span> 属性</span><br></pre></td></tr></table></figure>

<p><strong>提示</strong></p>
<ul>
<li>在日常开发中，不推荐在类的外部给对象增加属性<ul>
<li>如果<strong>在运行时，没有找到属性，程序会报错</strong></li>
</ul>
</li>
<li>对象应该包含有哪些属性，应该 <strong>封装在类的内部</strong></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag>Python进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Python进阶笔记（二）</title>
    <url>/posts/c4e66d1d.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p><strong>续…python进阶学习笔记（一）</strong></p>
</blockquote>
<span id="more"></span>

<h1 id="一-面向对象概述"><a href="#一-面向对象概述" class="headerlink" title="一.面向对象概述"></a>一.面向对象概述</h1><h2 id="3-面向对象基础语法"><a href="#3-面向对象基础语法" class="headerlink" title="3.面向对象基础语法"></a>3.面向对象基础语法</h2><h3 id="3-6-初始化方法"><a href="#3-6-初始化方法" class="headerlink" title="3.6 初始化方法"></a>3.6 初始化方法</h3>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag>Python进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言学习笔记（一）</title>
    <url>/posts/fd673177.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-R语言资源推荐"><a href="#1-R语言资源推荐" class="headerlink" title="1.R语言资源推荐"></a>1.R语言资源推荐</h2><p>推荐入门书籍：<a href="https://www.grantdrew.top/posts/900c9142.html">R语言编程</a></p>
<p>推荐入门学习网站：<a href="https://www.w3cschool.cn/r/r_overview.html%EF%BC%8C%E5%85%B6%E5%AE%9E%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B%E4%B9%9F%E6%9C%89">https://www.w3cschool.cn/r/r_overview.html，其实菜鸟教程也有</a></p>
<p>推荐入门视频教程：<a href="https://www.bilibili.com/video/BV19x411X7C6?p=7&amp;share_source=copy_web">https://www.bilibili.com/video/BV19x411X7C6?p=7&amp;share_source=copy_web</a></p>
<span id="more"></span>

<h2 id="2-基本操作命令"><a href="#2-基本操作命令" class="headerlink" title="2.基本操作命令"></a>2.基本操作命令</h2><p>获取或设置当前路径</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">getwd()</span><br><span class="line">setwd(<span class="string">&quot;D:/R-4.0.3/tests&quot;</span>)</span><br><span class="line"><span class="comment"># 注意：路径中的\必须用/或\\代替</span></span><br></pre></td></tr></table></figure>

<p>赋值</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &lt;-，R特有</span></span><br><span class="line">x &lt;- 3</span><br><span class="line"><span class="comment"># =，推荐使用</span></span><br><span class="line">x = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>R是一种基于对象的的向量化编程语言，既是面向对象也是面向函数。</p>
<p>基本运算</p>
<p><img src="/posts/fd673177/image-20210524214853067.png" alt="image-20210524214853067"></p>
<p>逻辑运算；</p>
<p><img src="/posts/fd673177/image-20210524214917013.png" alt="image-20210524214917013"></p>
<h2 id="3-R语言数据结构"><a href="#3-R语言数据结构" class="headerlink" title="3.R语言数据结构"></a>3.R语言数据结构</h2><p><img src="/posts/fd673177/image-20210601203233160.png" alt="image-20210601203233160"></p>
<p><img src="/posts/fd673177/image-20210601203256315.png" alt="image-20210601203256315"></p>
<h2 id="4-向量"><a href="#4-向量" class="headerlink" title="4.向量"></a>4.向量</h2><p>向量是R语言的基本数据类型，常用的向量有：数值向量、逻辑向量和字符向量，以及复数向量。</p>
<p>原子向量有6种类型：逻辑型（logical），整型（integer），双精度型（double），字符型（character），</p>
<p>复数型（complex）和原始型（raw）。</p>
<p>单个向量中的数据必须拥有相同的类型。</p>
<h3 id="4-1数值向量"><a href="#4-1数值向量" class="headerlink" title="4.1数值向量"></a>4.1数值向量</h3><p>由数值组成的向量，单个数值就是长度为1的数值向量。如：<code>x = 1.2</code></p>
<p>常用函数：</p>
<ul>
<li>numeric(length)函数用于创建全为0的指定长度length的数值向量。</li>
<li>c()函数用于将多个对象合并返回数值向量。如：<code>x = c(12,123.23,&quot;asd&quot;,TRUE)</code>将返回一个字符向量。</li>
<li>seq()函数：或“:“，length.out可以简写为length</li>
</ul>
<p><img src="/posts/fd673177/image-20210531193747724.png" alt="image-20210531193747724"></p>
<ul>
<li>rep()函数：</li>
</ul>
<p><img src="/posts/fd673177/image-20210531194714539.png" alt="image-20210531194714539"></p>
<p>例子：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="number">2</span>:<span class="number">3</span> <span class="comment"># 同seq(5)或者seq(1,5)</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">2</span> <span class="number">3</span></span><br><span class="line">&gt; <span class="number">1</span>:<span class="number">5</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">&gt; <span class="number">2</span>:<span class="number">3</span> + <span class="number">1</span>:<span class="number">5</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span> <span class="number">5</span> <span class="number">5</span> <span class="number">7</span> <span class="number">7</span></span><br><span class="line">Warning message:</span><br><span class="line">In <span class="number">2</span>:<span class="number">3</span> + <span class="number">1</span>:<span class="number">5</span> : 长的对象长度不是短的对象长度的整倍数</span><br><span class="line"><span class="comment"># R中两个不同长度的向量运算时，短的会自动循环补齐以配合长的</span></span><br><span class="line">&gt; seq(<span class="number">1</span>,<span class="number">11</span>,<span class="number">3</span>)</span><br><span class="line">[<span class="number">1</span>]  <span class="number">1</span>  <span class="number">4</span>  <span class="number">7</span> <span class="number">10</span></span><br><span class="line">&gt; seq(<span class="number">2</span>,length.out = <span class="number">4</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">--------------</span><br><span class="line">&gt;  <span class="number">1</span>:<span class="number">10</span></span><br><span class="line"> [<span class="number">1</span>]  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span></span><br><span class="line">&gt; seq(<span class="number">1</span>,<span class="number">10</span>,by=<span class="number">0.5</span>)<span class="comment"># 步长为0.5</span></span><br><span class="line"> [<span class="number">1</span>]  <span class="number">1.0</span>  <span class="number">1.5</span>  <span class="number">2.0</span>  <span class="number">2.5</span>  <span class="number">3.0</span>  <span class="number">3.5</span>  <span class="number">4.0</span>  <span class="number">4.5</span>  <span class="number">5.0</span>  <span class="number">5.5</span>  <span class="number">6.0</span></span><br><span class="line">[<span class="number">12</span>]  <span class="number">6.5</span>  <span class="number">7.0</span>  <span class="number">7.5</span>  <span class="number">8.0</span>  <span class="number">8.5</span>  <span class="number">9.0</span>  <span class="number">9.5</span> <span class="number">10.0</span></span><br><span class="line">&gt; seq(<span class="number">1</span>,<span class="number">10</span>,<span class="built_in">length</span>=<span class="number">7</span>)<span class="comment"># 长度为7</span></span><br><span class="line">[<span class="number">1</span>]  <span class="number">1.0</span>  <span class="number">2.5</span>  <span class="number">4.0</span>  <span class="number">5.5</span>  <span class="number">7.0</span>  <span class="number">8.5</span> <span class="number">10.0</span></span><br><span class="line">&gt; seq(along.with=<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>))</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">&gt; seq(along.with=<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>),<span class="built_in">length</span>=<span class="number">3</span>)<span class="comment"># 长度还是由along.with决定</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">&gt; seq(<span class="number">2</span>,<span class="number">3</span>,along.with=<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">[<span class="number">1</span>] <span class="number">2</span> <span class="number">3</span></span><br><span class="line">&gt; seq(<span class="number">2</span>,<span class="number">3</span>,along.with=<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">[<span class="number">1</span>] <span class="number">2.000000</span> <span class="number">2.333333</span> <span class="number">2.666667</span> <span class="number">3.000000</span></span><br><span class="line">---------------</span><br><span class="line">&gt; <span class="built_in">rep</span>(<span class="number">2</span>:<span class="number">5</span>,<span class="built_in">rep</span>(<span class="number">2</span>,<span class="number">4</span>))<span class="comment"># rep(2,4)的值是2,2,2,2向量</span></span><br><span class="line"><span class="comment"># 它作为time参数，规定2:5中对应重复次数为2,2,2,2</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span></span><br><span class="line">&gt; <span class="built_in">rep</span>(<span class="number">2</span>:<span class="number">5</span>,<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>))<span class="comment"># c(2,1,1,3)作为time参数，规定2:5中对应重复次数为2,1,1,3</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span></span><br><span class="line">&gt; <span class="built_in">rep</span>(<span class="number">1</span>:<span class="number">4</span>,each=<span class="number">2</span>,len=<span class="number">4</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line">&gt; <span class="built_in">rep</span>(<span class="number">1</span>:<span class="number">4</span>,each=<span class="number">2</span>,len=<span class="number">10</span>)</span><br><span class="line"> [<span class="number">1</span>] <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">&gt; x = <span class="built_in">c</span>(<span class="number">12</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">&gt; <span class="built_in">length</span>(x)</span><br><span class="line">[<span class="number">1</span>] <span class="number">4</span></span><br><span class="line">---------</span><br><span class="line">x = <span class="built_in">c</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">assian(<span class="string">&quot;x&quot;</span>,<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))<span class="comment"># 和上面等价</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2逻辑向量"><a href="#4-2逻辑向量" class="headerlink" title="4.2逻辑向量"></a>4.2逻辑向量</h3><p>是一组逻辑值(TRUE/FALSE或者简写为T/F)的向量。</p>
<p><img src="/posts/fd673177/image-20210531200145685.png" alt="image-20210531200145685"></p>
<p><img src="/posts/fd673177/image-20210601211549041.png" alt="image-20210601211549041"></p>
<p><img src="/posts/fd673177/image-20210601211627366.png" alt="image-20210601211627366"></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x &lt;- <span class="built_in">c</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>,-<span class="number">2</span>)</span><br><span class="line">&gt; x &lt;= <span class="number">0</span></span><br><span class="line">[<span class="number">1</span>] <span class="literal">FALSE</span> <span class="literal">FALSE</span> <span class="literal">FALSE</span>  <span class="literal">TRUE</span>  <span class="literal">TRUE</span></span><br><span class="line">&gt; class.stu = <span class="built_in">c</span>(<span class="string">&quot;一&quot;</span>,<span class="string">&quot;二&quot;</span>,<span class="string">&quot;三&quot;</span>)</span><br><span class="line">&gt; week = <span class="built_in">c</span>(<span class="string">&quot;一&quot;</span>,<span class="string">&quot;二&quot;</span>,<span class="string">&quot;五&quot;</span>)</span><br><span class="line">&gt; class.stu %in% week</span><br><span class="line">[<span class="number">1</span>]  <span class="literal">TRUE</span>  <span class="literal">TRUE</span> <span class="literal">FALSE</span></span><br><span class="line">&gt; which(x &lt;= <span class="number">0</span>)<span class="comment"># 返回下标，注意下标从1开始</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">4</span> <span class="number">5</span></span><br><span class="line">&gt; which(! class.stu %in% week)</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3字符向量"><a href="#4-3字符向量" class="headerlink" title="4.3字符向量"></a>4.3字符向量</h3><p>是一组字符串组成的向量。（单双引号括起来）</p>
<p>paste/paste0 函数， 用于连接字符（向量）， paste 可以设置连接字符，默认以空格作为连接字符； paste0 以空字符串连接字符，不能设置 sep 值。collapse 参数可以实现用 sep 连接后的字符向量的元素间的再次连接。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; paste(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>) <span class="comment"># 默认以空格连接字符 a 和 b， [1] &quot;a b&quot;</span></span><br><span class="line">paste(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;a b c&quot;</span></span><br><span class="line">&gt; paste(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, sep = <span class="string">&quot;=&quot;</span>) <span class="comment"># 用“=” 连接字符 a 和 b[1] &quot;a=b&quot;</span></span><br><span class="line"><span class="comment">#连接多个元素</span></span><br><span class="line">&gt; paste(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>:<span class="number">5</span>, sep = <span class="string">&quot;&quot;</span>) <span class="comment"># 1:5 中的每个元素与 a 相连[1] &quot;a1&quot; &quot;a2&quot; &quot;a3&quot; &quot;a4&quot; &quot;a5&quot;</span></span><br><span class="line">&gt; paste(<span class="string">&quot;a&quot;</span>,<span class="number">1</span>:<span class="number">5</span>,<span class="string">&quot;.pdf&quot;</span>, sep = <span class="string">&quot;&quot;</span>) <span class="comment"># 批量生成文件名[1] &quot;a1.pdf&quot; &quot;a2.pdf&quot; &quot;a3.pdf&quot; &quot;a4.pdf&quot; &quot;a5.pdf&quot;</span></span><br><span class="line"><span class="comment"># 有总结说：sep 连接的是元素间的扩展，collapse 是一种元素间的折叠坍缩</span></span><br><span class="line">&gt; a &lt;- <span class="built_in">c</span>(<span class="string">&quot;一&quot;</span>, <span class="string">&quot;两&quot;</span>, <span class="string">&quot;三四&quot;</span>)</span><br><span class="line">&gt; paste(a, <span class="string">&quot;片&quot;</span>, sep=<span class="string">&quot;&quot;</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;一片&quot;</span>   <span class="string">&quot;两片&quot;</span>   <span class="string">&quot;三四片&quot;</span></span><br><span class="line">&gt; paste(a, <span class="string">&quot;片&quot;</span>, sep=<span class="string">&quot;&quot;</span>, collapse=<span class="string">&quot;&quot;</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;一片两片三四片&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4向量的访问"><a href="#4-4向量的访问" class="headerlink" title="4.4向量的访问"></a>4.4向量的访问</h3><p><img src="/posts/fd673177/image-20210601212011478.png" alt="image-20210601212011478"></p>
<p><img src="/posts/fd673177/image-20210601214815362.png" alt="image-20210601214815362"></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x</span><br><span class="line">[<span class="number">1</span>]  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">0</span>  <span class="number">5</span> -<span class="number">2</span>  <span class="number">3</span>  <span class="number">0</span></span><br><span class="line">&gt; which(x==<span class="number">3</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">2</span> <span class="number">7</span></span><br><span class="line">&gt; x = <span class="built_in">c</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">&gt; x[<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">1</span>)]</span><br><span class="line">[<span class="number">1</span>] <span class="number">2</span> <span class="number">1</span></span><br><span class="line">&gt; x[x^<span class="number">2</span> - x&gt;=<span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span> <span class="number">4</span></span><br><span class="line">&gt; which.max(x)<span class="comment"># 返回最大值下标</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">4</span></span><br><span class="line">&gt; which.min(x)<span class="comment"># 返回最小值下标</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/fd673177/image-20210601221546509.png" alt="image-20210601221546509"></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x = <span class="built_in">c</span>(a=<span class="number">1</span>,b=<span class="number">4</span>,<span class="built_in">c</span>=<span class="number">6</span>)<span class="comment"># 创建向量时对元素命名</span></span><br><span class="line">&gt; x[<span class="string">&quot;c&quot;</span>]<span class="comment"># 提取对象的子集，有点像字典</span></span><br><span class="line"><span class="built_in">c</span> </span><br><span class="line">6 </span><br><span class="line">&gt; which(x==<span class="number">4</span>)</span><br><span class="line">b </span><br><span class="line">2 </span><br><span class="line">&gt; x[[<span class="string">&quot;a&quot;</span>]]<span class="comment"># 提取对象中的元素</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="4-5向量排序"><a href="#4-5向量排序" class="headerlink" title="4.5向量排序"></a>4.5向量排序</h3><p><img src="/posts/fd673177/image-20210601222040044.png" alt="image-20210601222040044"></p>
<p><img src="/posts/fd673177/image-20210601222150146.png" alt="image-20210601222150146"></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x = <span class="built_in">c</span>(<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">4</span>)</span><br><span class="line">&gt; sort(x)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line">&gt; order(x) <span class="comment"># 默认升序，返回元素排好序对应位置的索引</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">4</span> <span class="number">7</span> <span class="number">2</span> <span class="number">6</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line">&gt; x[order(x)] <span class="comment"># == sort(x)</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line">&gt; rank(x) <span class="comment"># 默认升序</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">4</span> <span class="number">6</span> <span class="number">2</span> <span class="number">7</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line">&gt; rev(x) <span class="comment"># 反转</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">4</span> <span class="number">7</span> <span class="number">9</span> <span class="number">2</span> <span class="number">8</span> <span class="number">5</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>R入门</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言学习笔记（二）</title>
    <url>/posts/cd71ddaf.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-R语言取整函数"><a href="#1-R语言取整函数" class="headerlink" title="1.R语言取整函数"></a>1.R语言取整函数</h2><p><img src="/posts/cd71ddaf/image-20210601222932557.png" alt="image-20210601222932557"></p>
]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>R入门</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言编程</title>
    <url>/posts/900c9142.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="143f5ffb06e42ba0868d3f4ed096022f27aafed729c9b68248af9d6a3ead6ec9">fb26124e0d85f363a66baed35993e1a0948953cce3d484fb31660455b92ccb286ba4467b12dd2afdc0f8bd795964707216933c479f00faf5302337078027ef66e68c754bf0232403ae44399aa06a2cad741400e24549082709cdee4a1c1e38f29d8bb6993c43448bafc4543d636ea5bfe35062ad225c74a80f232ba51d9af45093f5220e616be2d57e02341ffad661bef2886dba249b54377d8b3961fd62e8e7033554e6a1a85b429bcdccd8e910eaca84c8e447cedd760cd76a16c64ec7f94ad050108487716cc544f1ca685285a120a1c590efd559bdca18a90707fae890221e2912f079f089d10fb816e69e85944586941b721161d200273028ce2f3cb2d1a6a47461dcfac58b4612622383de37911e7101936179b0ecfeb18f3600111afc0a3048b3a9bc8162408d2cdd766c056081be36f6984d0fc9924355cadc0cde3eb9b769df924e862815f18fb7ec6ae1a8c28766566a04373e371093a40513b3cb5377721df4441efd8afbf12f5df0cf1e6fbd02ff04939003ab36f09e93968d1808180c9ab3dc821601f9699c8fc9f6526232213e87de924ffe813c18f9c8915f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>R入门</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL语句大全</title>
    <url>/posts/68d55db1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>转载：<a href="https://mp.weixin.qq.com/s/EbdgRbGBgzzRa2pET-6qRA">https://mp.weixin.qq.com/s/EbdgRbGBgzzRa2pET-6qRA</a></p>
<h2 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h2><h3 id="1、说明：创建数据库"><a href="#1、说明：创建数据库" class="headerlink" title="1、说明：创建数据库"></a>1、说明：创建数据库</h3><p>CREATE DATABASE database-name</p>
<h3 id="2、说明：删除数据库"><a href="#2、说明：删除数据库" class="headerlink" title="2、说明：删除数据库"></a>2、说明：删除数据库</h3><p>drop database dbname</p>
<span id="more"></span>

<h3 id="3、说明：备份sql-server"><a href="#3、说明：备份sql-server" class="headerlink" title="3、说明：备份sql server"></a>3、说明：备份sql server</h3><p>— 创建 备份数据的 device<br>USE master<br>EXEC sp_addumpdevice ‘disk’, ‘testBack’, ‘c:mssql7backupMyNwind_1.dat’<br>— 开始 备份<br>BACKUP DATABASE pubs TO testBack </p>
<h3 id="4、说明：创建新表"><a href="#4、说明：创建新表" class="headerlink" title="4、说明：创建新表"></a>4、说明：创建新表</h3><p>create table tabname(col1 type1 [not null] [primary key],col2 type2 [not null],..)</p>
<p>根据已有的表创建新表：<br>A：create table tab_new like tab_old (使用旧表创建新表)<br>B：create table tab_new as select col1,col2… from tab_old definition only</p>
<h3 id="5、说明：删除新表"><a href="#5、说明：删除新表" class="headerlink" title="5、说明：删除新表"></a>5、说明：删除新表</h3><p>drop table tabname </p>
<h3 id="6、说明：增加一个列"><a href="#6、说明：增加一个列" class="headerlink" title="6、说明：增加一个列"></a>6、说明：增加一个列</h3><p>Alter table tabname add column col type注：列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加varchar类型的长度。</p>
<h3 id="7、说明：添加主键：-Alter-table-tabname-add-primary-key-col"><a href="#7、说明：添加主键：-Alter-table-tabname-add-primary-key-col" class="headerlink" title="7、说明：添加主键： Alter table tabname add primary key(col)"></a>7、说明：添加主键： Alter table tabname add primary key(col)</h3><p>说明：删除主键： Alter table tabname drop primary key(col) </p>
<h3 id="8、说明：创建索引：create-unique-index-idxname-on-tabname-col…"><a href="#8、说明：创建索引：create-unique-index-idxname-on-tabname-col…" class="headerlink" title="8、说明：创建索引：create [unique] index idxname on tabname(col….)"></a>8、说明：创建索引：create [unique] index idxname on tabname(col….)</h3><p>删除索引：drop index idxname<br>注：索引是不可更改的，想更改必须删除重新建。</p>
<h3 id="9、说明：创建视图：create-view-viewname-as-select-statement"><a href="#9、说明：创建视图：create-view-viewname-as-select-statement" class="headerlink" title="9、说明：创建视图：create view viewname as select statement"></a>9、说明：创建视图：create view viewname as select statement</h3><p>删除视图：drop view viewname</p>
<p>待更新。。。</p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Sort函数的应用</title>
    <url>/posts/e6c1070a.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="PAT-甲级-1025"><a href="#PAT-甲级-1025" class="headerlink" title="PAT 甲级 1025"></a>PAT 甲级 1025</h2><span id="more"></span>

<p>Programming Ability Test (PAT) is organized by the College of Computer Science and Technology of Zhejiang University. Each test is supposed to run simultaneously in several places, and the ranklists will be merged immediately after the test. Now it is your job to write a program to correctly merge all the ranklists and generate the final rank.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive number <em>N</em> (≤100), the number of test locations. Then <em>N</em> ranklists follow, each starts with a line containing a positive integer <em>K</em> (≤300), the number of testees, and then <em>K</em> lines containing the registration number (a 13-digit number) and the total score of each testee. All the numbers in a line are separated by a space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, first print in one line the total number of testees. Then print the final ranklist in the following format:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registration_number final_rank location_number local_rank</span><br></pre></td></tr></table></figure>

<p>The locations are numbered from 1 to <em>N</em>. The output must be sorted in nondecreasing order of the final ranks. The testees with the same score must have the same rank, and the output must be sorted in nondecreasing order of their registration numbers.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">5</span><br><span class="line">1234567890001 95</span><br><span class="line">1234567890005 100</span><br><span class="line">1234567890003 95</span><br><span class="line">1234567890002 77</span><br><span class="line">1234567890004 85</span><br><span class="line">4</span><br><span class="line">1234567890013 65</span><br><span class="line">1234567890011 25</span><br><span class="line">1234567890014 100</span><br><span class="line">1234567890012 85</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">1234567890005 1 1 1</span><br><span class="line">1234567890014 1 2 1</span><br><span class="line">1234567890001 3 1 2</span><br><span class="line">1234567890003 3 1 2</span><br><span class="line">1234567890004 5 1 4</span><br><span class="line">1234567890012 5 2 2</span><br><span class="line">1234567890002 7 1 5</span><br><span class="line">1234567890013 8 2 3</span><br><span class="line">1234567890011 9 2 4</span><br></pre></td></tr></table></figure>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>  给所有地区的考生排名。题目首先给出N，表示有N个地区，之后每个地区给出K，及K个考生的考号，分数，最后要求你不仅要输出每个考生的总排名，还要输出每个考生的地区排名</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>  首先建立一个结构体，存储考生的考号，分数，地区序号及地区排名，然后建立一个充分大(&gt;=30000)的结构体数组，然后依次每输入一个地区的考生信息，就对该地区的考试进行排序，同时计算其地区排名。输入完毕后，对该结构体数组进行总排序，最终计算总排名并输出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">30010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">char</span> id[<span class="number">14</span>];</span><br><span class="line">    <span class="keyword">int</span> location_num;</span><br><span class="line">    <span class="keyword">int</span> local_rank;</span><br><span class="line">&#125;stu[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Student a,Student b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.score != b.score) <span class="keyword">return</span> a.score &gt; b.score;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(a.id,b.id) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s %d&quot;</span>,stu[num].id,&amp;stu[num].score);</span><br><span class="line">            stu[num].location_num = i+<span class="number">1</span>;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sort(stu+num-m,stu+num,cmp);</span><br><span class="line">        stu[num-m].local_rank = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num-m+<span class="number">1</span>;i &lt; num;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (stu[i].score == stu[i<span class="number">-1</span>].score) stu[i].local_rank = stu[i<span class="number">-1</span>].local_rank;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                stu[i].local_rank = i+<span class="number">1</span>-(num-m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num);</span><br><span class="line">    sort(stu,stu+num,cmp);</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; num;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; stu[i].score != stu[i<span class="number">-1</span>].score) r = i +<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d %d %d\n&quot;</span>,stu[i].id,r,stu[i].location_num,stu[i].local_rank);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Texlive和TexStudio的安装与使用</title>
    <url>/posts/bc17736e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="TexLive2021"><a href="#TexLive2021" class="headerlink" title="TexLive2021"></a>TexLive2021</h2><p>首先我们要安装Texlive，它是一个Tex的发行版。</p>
<p>详细安装配置过程建议参考：<a href="https://blog.csdn.net/Mikchy/article/details/94448707">https://blog.csdn.net/Mikchy/article/details/94448707</a></p>
<p>以及<a href="https://github.com/OsbertWang/install-latex-guide-zh-cn%E3%80%82">https://github.com/OsbertWang/install-latex-guide-zh-cn。</a></p>
<span id="more"></span>

<p>如果出现一些TexLive的安装问题，看这个：<a href="https://blog.csdn.net/dogfat/article/details/106962966%E3%80%82">https://blog.csdn.net/dogfat/article/details/106962966。</a></p>
<ul>
<li><p>注意：路径中不要出现中文，一些特殊符号和空格</p>
</li>
<li><p>特别提一点，安装教程中提到的.bat文件，如果双击打开闪退，就尝试右键管理员身份打开。</p>
</li>
<li><p>如果两种方式都会闪退，说明大概率是你没有<strong>配置好环境变量</strong>。</p>
</li>
<li><p> 配置环境变量时还可能会出问题：提示你此环境变量太大，最长为2047个字符。</p>
</li>
</ul>
<p>这时候新建了一个Path1,把要添加的变量放到Path1里，再在Path里新建变量%Path1%就OK了。</p>
<ul>
<li><p>如果安装时出现如下图所示错误：</p>
<p><img src="/posts/bc17736e/image-20210411205554694.png" alt="image-20210411205554694"></p>
</li>
</ul>
<p>多半是因为系统用户名含有中文！！！</p>
<p>这个问题困扰我很久，才发现大佬的<a href="https://mp.weixin.qq.com/s/9aE4AlHj2XfnymmT8P3I5Q">解决方案</a>。</p>
<p>还有这篇文章给了我提示：<a href="https://www.zhihu.com/people/zhang-shao-fan-45%E3%80%82">https://www.zhihu.com/people/zhang-shao-fan-45。</a></p>
<p>按照文章的提示来做，就能够成功安装上TexLive2021了。(PS：安装过程可能要等很久时间，约1h40min)</p>
<p>注意：千万不要点Abrobt！！！会直接退出安装，后期还要重装。</p>
<p>直到出现这个，才表示安装成功！！！</p>
<p><img src="/posts/bc17736e/image-20210412072427033.png" alt="image-20210412072427033"></p>
<p>接下来到cmd中测试是否成功安装上，输入命令：tex -version。</p>
<p>如果提示’tex’不是内部或外部命令等，说明可能是没有配置好环境变量。</p>
<p>那么我们找到TexLive的安装目录中的bin目录下的win32，将它加入系统变量Path。</p>
<p><img src="/posts/bc17736e/image-20210411230107676.png" alt="image-20210411230107676"></p>
<p>然后继续输入命令：tex -version测试。</p>
<p><img src="/posts/bc17736e/image-20210411230204922.png" alt="image-20210411230204922"></p>
<p>如图表示成功安装，否则需要重新安装。</p>
<h2 id="Tex-Studio"><a href="#Tex-Studio" class="headerlink" title="Tex Studio"></a>Tex Studio</h2><p>下面我们跟着<a href="https://blog.csdn.net/Mikchy/article/details/94448707">教程</a>继续安装Tex Studio。</p>
<p>安装过程非常简单。</p>
<p>安装好之后，我们来测试一下。新建一个文件复制以下内容。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 导言区</span></span><br><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">% 导入中文宏</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;ctex&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 构建命令,取别名，使用degree 代替 ^ circ</span></span><br><span class="line"><span class="keyword">\newcommand</span><span class="keyword">\degree</span>&#123;<span class="built_in">^</span><span class="keyword">\circ</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\title</span>&#123;<span class="keyword">\heiti</span> 浅谈勾股定理&#125;</span><br><span class="line"><span class="keyword">\author</span>&#123;<span class="keyword">\kaishu</span> 张一根&#125;</span><br><span class="line"><span class="keyword">\date</span>&#123;<span class="keyword">\today</span>&#125;</span><br><span class="line"><span class="comment">% 正文区</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">	<span class="keyword">\maketitle</span></span><br><span class="line">	hello world!</span><br><span class="line">	</span><br><span class="line">	勾股定理可以用现代的语言描述如下：</span><br><span class="line">	</span><br><span class="line">	直角三角形斜边的平方等于两腰的平法和。</span><br><span class="line">	</span><br><span class="line">	可以用符号语言描述为：设直角三角形 </span><br><span class="line">	<span class="built_in">$</span><span class="keyword">\angle</span> C=90<span class="keyword">\degree</span> <span class="built_in">$</span>则有：</span><br><span class="line">	<span class="built_in">$</span><span class="built_in">$</span> </span><br><span class="line">	AB<span class="built_in">^</span>2 = BC<span class="built_in">^</span>2 + AC<span class="built_in">^</span>2 </span><br><span class="line">	<span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line">	这就是勾股定理</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>

<p>出现<strong>完成</strong>表示安装成功。</p>
<p><img src="/posts/bc17736e/image-20210412072609787.png" alt="image-20210412072609787"></p>
]]></content>
      <categories>
        <category>Latex</category>
      </categories>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows Termial使用及美化教程</title>
    <url>/posts/b2e908af.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>参考自：<a href="https://blog.csdn.net/yuanlaijike/article/details/107599983">https://blog.csdn.net/yuanlaijike/article/details/107599983</a></p>
<h2 id="如何安装Windows-Terminal"><a href="#如何安装Windows-Terminal" class="headerlink" title="如何安装Windows Terminal"></a>如何安装Windows Terminal</h2><p>直接从Microsoft Store下载就行。</p>
<span id="more"></span>

<p>首先添加git bash到Windows Terminal：</p>
<p><img src="/posts/b2e908af/image-20210426220918332.png" alt="image-20210426220918332"></p>
<p>在命令行选择Git\bin\bash.exe路径。</p>
<p>如果想要添加一个图标，可以下载添加路径就可以了。</p>
<p>常用的配置方式是直接打开JSON文件进行修改。</p>
<h2 id="如何美化"><a href="#如何美化" class="headerlink" title="如何美化"></a>如何美化</h2><p>配置文件的大致布局如下所示，对于我们美化来说，只需要关注 <code>profiles</code> 和 <code>schemes</code> 两块即可。</p>
<p><img src="/posts/b2e908af/20200530155138893.png" alt="img"></p>
<p>让我们先牛刀小试下，调整下终端的字体和字体大小。因为我想对所有终端都应用这个配置。所以我写在了 <code>defaults</code> 中，如下图所示即可。</p>
<p><img src="/posts/b2e908af/2020053015560247.png" alt="img"></p>
<h2 id="把windows-terminal添加到右键菜单"><a href="#把windows-terminal添加到右键菜单" class="headerlink" title="把windows terminal添加到右键菜单"></a>把windows terminal添加到右键菜单</h2><p><a href="https://blog.csdn.net/willingtolove/article/details/109167629?ops_request_misc=&request_id=&biz_id=102&utm_term=windows%20terminal%E5%8F%B3%E9%94%AE%E6%89%BE%E4%B8%8D%E5%88%B0%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-109167629.first_rank_v2_pc_rank_v29">参考教程</a></p>
<p>记得修改<code>startingDirectory</code>属性为<code>null</code>；（PS：没有自己加上就可以）</p>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="/posts/b2e908af/image-20210426221738253.png" alt="image-20210426221738253"></p>
<p><img src="/posts/b2e908af/image-20210426221823207.png" alt="image-20210426221823207"></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>Termial</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>two pointers思想与归并排序</title>
    <url>/posts/2aed1d1d.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>参考自：<a href="https://www.cnblogs.com/coderJiebao/p/Algorithmofnotes08.html">https://www.cnblogs.com/coderJiebao/p/Algorithmofnotes08.html</a></p>
<h2 id="什么是-two-pointers"><a href="#什么是-two-pointers" class="headerlink" title="什么是 two pointers"></a>什么是 two pointers</h2><p>以一个例子引入：给定一个递增的正整数序列和一个正整数 M，求序列中的两个不同位置的数 a 和 b，使得它们的和恰好为 M，输出所有满足条件的方案。</p>
<p>　　本题的一个最直观的想法是，使用二重循环枚举序列中的整数 a 和 b，判断它们的和是否为 M。时间复杂度为 O(n^2)。当n的规模足够大时，这显然是不可取的。</p>
<span id="more"></span>

<p>two pointers 将利用有序序列的枚举特性来有效降低复杂度。它针对本题的算法如下：</p>
<p>令下标 i 的初值为0，下标 j 的初值为 n-1，即令 i、j 分别指向序列的第一个元素和最后一个元素，接下来根据 a[i]+a[j] 与 M 的大小来进行下面三种选择，使 i 不断向右移动、使 j 不断向左移动，直到 i≥j 成立</p>
<ul>
<li><p>若 a[i]+a[j]==M ，说明找到了其中一种方案，令 i=i+1、j=j-1。</p>
</li>
<li><p>若 a[i]+a[j]&gt;M，令 j=j-1。</p>
</li>
<li><p>若 a[i]+a[j]&lt;M，令 i=i+1。</p>
</li>
</ul>
<p>　　反复执行上面三个判断，直到 i≥j 成立，在递增序列的前提下，循环只需要进行到i&gt;=j时停止，所以理想状态下只需要遍历半个序列，**时间复杂度只需要O(n)**。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]+a[j] == M) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, i, j);</span><br><span class="line">        i++; j--;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a[i]+a[j] &lt; M) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="序列合并问题"><a href="#序列合并问题" class="headerlink" title="序列合并问题"></a>序列合并问题</h2><p>再来看<strong>序列合并问题</strong>。假设有两个递增序列 A 与 B，要求将它们合并为一个递增序列 C。</p>
<p>　　同样的，可以设置两个下标 i 和 j ，初值均为0，表示分别指向序列 A 的第一个元素和序列 B 的第一个元素，然后根据 A[i] 与 B[j] 的大小来决定哪一个放入序列 C。</p>
<ul>
<li>若 A[i]≤B[j]，把 A[i] 加入序列 C 中，并让 i 加1</li>
<li>若 A[i]&gt;B[j]，把 B[j] 加入序列 C 中，并让 j 加1</li>
</ul>
<p>上面的分支操作直到 i、j 中的一个到达序列末端为止，然后将另一个序列的所有元素依次加入序列 C 中，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> B[], <span class="keyword">int</span> C[], <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>, index=<span class="number">0</span>;    <span class="comment">// i指向A，j指向B，index指向C</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;n &amp;&amp; j&lt;m) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &lt;= B[j]) &#123;            <span class="comment">// 若 A[i]≤B[j]</span></span><br><span class="line">            C[index++] = A[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                    <span class="comment">// 若 A[i]&gt;B[j]</span></span><br><span class="line">            C[index++] = B[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)    C[index++] = A[i++];    <span class="comment">// 若 A 有剩余</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;m)    C[index++] = B[j++];    <span class="comment">// 若 B 有剩余</span></span><br><span class="line">    <span class="keyword">return</span> index;        <span class="comment">// 返回 C 长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>广义上的 two pointers 是利用问题本身与序列的特性，使用两个下标 i、j 对序列进行扫描（可以同向扫描，也可以反向扫描），以较低的复杂度（一般为 O(n) ）解决问题。 </p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是一种基于“归并”思想的排序方法，本节主要介绍其中最基本的 2-路归并排序。2-路归并排序的原理是，将序列两两分组，将序列归并为$\lceil \frac n 2 \rceil$个组，组内单独排序；然后将这些组再两两归并，生成$\lceil \frac n 4 \rceil$个组，组内再单独排序；以此类推，直到只剩下一个组为止。时间复杂度为 O(nlogn)。</p>
<p>说明：对于偶数个的数组正常对半分就行，对于奇数个的数组，留下最后1个多余的单独1组，其余两两1组。</p>
<p>我们先写一个merge函数将数组的两个区间合并为一个有序区间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 将数组A的 [L1,R1] 与 [L2,R2] 合并为有序区间（此处 L2=R1+1 ）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> L1, <span class="keyword">int</span> R1, <span class="keyword">int</span> L2, <span class="keyword">int</span> R2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=L1, j=L2;</span><br><span class="line">    <span class="keyword">int</span> temp[maxn], index=<span class="number">0</span>;    <span class="comment">// temp 临时储存合并序列</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=R1 &amp;&amp; j&lt;=R2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &lt;= A[j]) &#123;            <span class="comment">// 若 A[i] ≤ A[j]</span></span><br><span class="line">            temp[index++] = A[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                    <span class="comment">// 若 A[i] &gt; A[j]</span></span><br><span class="line">            temp[index++] = A[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">while</span>(i &lt;= R1) temp[index++] = A[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= R2) temp[index++] = A[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;index; ++i) &#123;</span><br><span class="line">        A[L1+i] = temp[i];    <span class="comment">// 将合并后的序列赋值回 A</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-递归实现"><a href="#1-递归实现" class="headerlink" title="1. 递归实现"></a>1. 递归实现</h3><p>只需反复将当前区间 [left,right] 分为两半，对两个子区间 [left,mid] 与 [mid+1, right] 分别递归进行归并排序，然后将两个已经有序的子区间合并为有序序列即可。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 归并排序递归实现</span></span><br><span class="line"><span class="comment">// 只需反复将当前区间 [left,right] 分为两半，对两个子区间 [left,mid] 与 [mid+1, right]</span></span><br><span class="line"><span class="comment">// 分别递归进行归并排序，然后将两个已经有序的子区间合并为有序序列即可。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;    <span class="comment">// 当 left==right 时，只有一个元素，认定为有序</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(A, left, mid);            <span class="comment">// 分为左区间和右区间</span></span><br><span class="line">        mergeSort(A, mid+<span class="number">1</span>, right);</span><br><span class="line">        merge(A, left, mid, mid+<span class="number">1</span>, right);    <span class="comment">// 将左区间和右区间合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-非递归实现"><a href="#2-非递归实现" class="headerlink" title="2.非递归实现"></a>2.非递归实现</h3><p>非递归实现主要考虑到这样一点：每次分组时组内元素个数上限都是2的幂次。于是就可以想到这样的思路：令步长 step 的初值为2，然后将数组中每 step 个元素作为一组，将其内部进行排序；再令 step 乘以2，重复上面的操作，直到 step/2 超过元素个数 n 。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 归并排序非递归实现</span></span><br><span class="line"><span class="comment">// 令步长 step 的初值为2，然后将数组中每 step 个元素作为一组，</span></span><br><span class="line"><span class="comment">// 将其内部进行排序；再令 step 乘以2，重复上面的操作，直到 step/2 超过元素个数 n 。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> A[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// step 为组内元素个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> step=<span class="number">0</span>; step/<span class="number">2</span> &lt;= n; step *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += step) &#123;    <span class="comment">// 对每一组，数组下标从1开始</span></span><br><span class="line">            <span class="keyword">int</span> mid = i + step/<span class="number">2</span> <span class="number">-1</span>;    <span class="comment">// 左区间元素个数为 step/2</span></span><br><span class="line">            <span class="keyword">if</span>(mid+<span class="number">1</span> &lt;= n) &#123;    <span class="comment">// 右区间存在元素</span></span><br><span class="line">                <span class="comment">// 左区间为 [left,mid]，右区间为 [mid+1, min(i+step-1,n)</span></span><br><span class="line">                merge(A, i, mid, mid+<span class="number">1</span>, min(i+step<span class="number">-1</span>, n));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            // 28-32行也可以用 sort 代替 merge 函数，只要时间允许</span></span><br><span class="line"><span class="comment">            sort(A+i, A+min(i+step, n+1));</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用 sort 代替，此处输出归并排序的某一趟结束时的序列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果题目只要求给出归并排序每一趟结束时的序列，可以用sort函数代替 merge 函数，只要时间允许。</p>
<h3 id="3-算法分析"><a href="#3-算法分析" class="headerlink" title="3.算法分析"></a>3.算法分析</h3><p>时间复杂度： O(nlogn)</p>
<p>归并排序的执行效率与要排序的原始数组的有序程度<strong>无关</strong>，所以其时间复杂度是非常<strong>稳定</strong>的，不管是最好情</p>
<p>况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)。</p>
<p>空间复杂度：O(n)</p>
<p>它有一个致命的“弱点”，那就是归并排序不是原地排序算法。</p>
<p>这是因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。</p>
<p>在每次进行合并操作时，需要O(n)的数组空间存放数据。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>tow pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo相关问题汇总</title>
    <url>/posts/ec93326a.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>本文将介绍总结一些hexo的常见/不常见/棘手问题的解决方法。</p>
</blockquote>
<span id="more"></span>

<h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><h2 id="1-插入图片"><a href="#1-插入图片" class="headerlink" title="1.插入图片"></a>1.插入图片</h2><p>只需在 md 文件里使用 <code>![title](同名文件夹/图片名.jpg)</code> ，无需路径名就可以插入图片。</p>
<h2 id="2-文章摘要"><a href="#2-文章摘要" class="headerlink" title="2.文章摘要"></a>2.文章摘要</h2><p>在文章<code>&lt;!--more--&gt;</code>之前的内容将作为首页的摘要部分！</p>
<h2 id="3-解决busuanzi不显示问题必看"><a href="#3-解决busuanzi不显示问题必看" class="headerlink" title="3.解决busuanzi不显示问题必看"></a>3.<a href="https://muyuuuu.github.io/2019/11/22/busuanzi-notdisplay/">解决busuanzi不显示问题必看</a></h2><p>其实核心问题就是找到span id里是否有style = “display: none”，找到对应文件对应位置的代码并删除即可</p>
<h2 id="4-hexo-s本地样式与网页样式不一致？"><a href="#4-hexo-s本地样式与网页样式不一致？" class="headerlink" title="4.hexo s本地样式与网页样式不一致？"></a>4.hexo s本地样式与网页样式不一致？</h2><ul>
<li>其实原因很简单，拉到服务器之前要<code>hexo clean</code>清理一下缓存，然后再生成和部署，你学会了吗？</li>
</ul>
<p>（可能<code>hexo c &amp;&amp; hexo g &amp;&amp; hexo d</code>一步到位，有时候不太行，分开写）</p>
<ul>
<li>或者清理一下浏览器缓存就可以解决。</li>
</ul>
<h2 id="5-markdown语法速成宝典"><a href="#5-markdown语法速成宝典" class="headerlink" title="5.markdown语法速成宝典"></a>5.<a href="https://www.kuangstudy.com/bbs/1356475333565587458">markdown语法速成宝典</a></h2><h2 id="6-推荐hexo搭建文章："><a href="#6-推荐hexo搭建文章：" class="headerlink" title="6.推荐hexo搭建文章："></a>6.推荐hexo搭建文章：</h2><p><a href="https://tding.top/archives/aad98408.html">https://tding.top/archives/aad98408.html</a></p>
<h2 id="7-使用插件备份博客源文件："><a href="#7-使用插件备份博客源文件：" class="headerlink" title="7.使用插件备份博客源文件："></a>7.使用插件备份博客源文件：</h2><p><a href="https://blog.csdn.net/qq_41793001/article/details/103151182">https://blog.csdn.net/qq_41793001/article/details/103151182</a></p>
<hr>
<p>有关备份问题：</p>
<p><img src="/posts/ec93326a/image-20210321201128176.png" alt="image-20210321201128176"></p>
<p>解决方案：<a href="https://cloud.tencent.com/developer/article/1572090">https://cloud.tencent.com/developer/article/1572090</a></p>
<p>文章中提到的<code>.ssh</code>文件夹一般位于C:\Users\你的用户名\xxx。</p>
<p><img src="/posts/ec93326a/image-20210321201346184.png" alt="image-20210321201346184"></p>
<p>如果出现下图的情况，一般就成功了：</p>
<p><img src="/posts/ec93326a/image-20210321201521647.png" alt="image-20210321201521647"></p>
<p>这时我们再检查github上的hexo仓库，会发现用于备份的backup分支已经成功备份。</p>
<p><img src="/posts/ec93326a/image-20210321201725486.png" alt="image-20210321201725486"></p>
<h2 id="8-hexo博客使用Valine添加评论系统："><a href="#8-hexo博客使用Valine添加评论系统：" class="headerlink" title="8.hexo博客使用Valine添加评论系统："></a>8.hexo博客使用<a href="https://valine.js.org/">Valine</a>添加评论系统：</h2><p>参见博客 <a href="https://www.luanzhuxian.com/post/c49d1b87.html">https://www.luanzhuxian.com/post/c49d1b87.html</a>  和 <a href="https://www.zhyong.cn/posts/95cb/">https://www.zhyong.cn/posts/95cb/</a></p>
<p>第三方插件增强邮件提醒：<a href="https://blog.csdn.net/AC916305619/article/details/110379680">https://blog.csdn.net/AC916305619/article/details/110379680</a> 和 <a href="https://github.com/DesertsP/Valine-Admin">https://github.com/DesertsP/Valine-Admin</a></p>
<h2 id="9-文章加密处理："><a href="#9-文章加密处理：" class="headerlink" title="9.文章加密处理："></a>9.文章加密处理：</h2><p>参考<a href="https://blog.csdn.net/weixin_45750972/article/details/111396124">https://blog.csdn.net/weixin_45750972/article/details/111396124</a></p>
<ul>
<li>password: 该Blog使用的密码，注意单词不要拼错，尬</li>
<li>abstract: Blog摘要文字（少量）</li>
<li>message: 密码框上的描述性文字</li>
</ul>
<h2 id="10-添加打赏功能："><a href="#10-添加打赏功能：" class="headerlink" title="10.添加打赏功能："></a>10.添加打赏功能：</h2><p>参考<a href="https://www.dazhuanlan.com/2020/01/20/5e25021a447f6/">https://www.dazhuanlan.com/2020/01/20/5e25021a447f6/</a></p>
<h2 id="11-hexo-d时网络不稳定"><a href="#11-hexo-d时网络不稳定" class="headerlink" title="11.hexo d时网络不稳定"></a>11.hexo d时网络不稳定</h2><p>当执行<code>hexo d</code>命令时出现如下错误时，OpenSSL SSL_read: Connection was aborted, errno 10053…</p>
<p>参考解决方案：<a href="https://blog.csdn.net/weixin_43945983/article/details/110882074">https://blog.csdn.net/weixin_43945983/article/details/110882074</a></p>
<p>先执行<code>git config --global http.sslVerify &quot;false&quot;</code>命令，再执行<code>hexo d</code>就行了。<br>如果还有错，多试几次，网络不好。</p>
<h2 id="12-文章生成永久化链接"><a href="#12-文章生成永久化链接" class="headerlink" title="12.文章生成永久化链接"></a>12.文章生成永久化链接</h2><p>参考：<a href="https://blog.csdn.net/u011063477/article/details/105929290/">https://blog.csdn.net/u011063477/article/details/105929290/</a></p>
<p>安装hexo-abbrlink插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>

<p>站点配置文件(_config.yml)里:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">post/:abbrlink.html</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>  <span class="comment"># 算法：crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>    <span class="comment"># 进制：dec(default) and hex</span></span><br></pre></td></tr></table></figure>

<p>先使用<code>hexo c &amp;&amp; hexo g</code>，清除缓存，重新生成，再使用<code>hexo g</code>会自动在你的文章中加上<code>abbrlink: fbf5310d</code>。</p>
<p>如果打开网站发现打开不同文章都会重定向到一篇文章，而且都会出现undefined.html，说明没有清除缓存。</p>
<p>图像不显示问题：<a href="https://www.pianshen.com/article/65241119972/">https://www.pianshen.com/article/65241119972/</a></p>
<p>如果还是不显示，就<code>hexo s</code>，在md文件中先删除<code>![picture](arctile/image.jpg)</code>其中的<code>arctile/</code>，再粘贴回去，在浏览器刷新一下就能看到了。（PS：一篇文章有多张图片时只要第一张这样做就行了）</p>
<p>个人无意中发现的，原理不清楚。可能是插入图片时会自动把文章同名目录下的图片设定为相对路径，不需要加上文章同名的上一级目录。</p>
<p>一顿操作下来，不停CV，我手都摁麻了。</p>
<h2 id="14-购买域名与绑定域名"><a href="#14-购买域名与绑定域名" class="headerlink" title="14.购买域名与绑定域名"></a>14.购买域名与绑定域名</h2><p>处理域名花了我一下午功夫，事情起因是我突然想着要不要买个域名玩玩，然后去B站搜了一下，发现一个UP做的系列视频，觉得讲得还不错，推荐给大家。</p>
<p>视频地址：<a href="https://www.bilibili.com/video/BV18a4y1Y7e9?share_source=copy_web">https://www.bilibili.com/video/BV18a4y1Y7e9?share_source=copy_web</a></p>
<p>我是在阿里云买的域名，其实腾讯云也还不错。一次性买了三年，花了不到100软妹币。</p>
<p>参考教程：</p>
<p><a href="https://noshore.cn/shuangxianbushu.html#2-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90">https://noshore.cn/shuangxianbushu.html#2-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90</a></p>
<p>其实我更推荐看腾讯云的官方文档，看不懂的话还有人工客服。因为博客的内容毕竟不是最新的，而且不一定适合所有人。</p>
<p>折腾老半天最后还是成功了。</p>
<p><a href="https://www.grantdrew.top/%E5%92%8Chttp://www.grantdrew.top/%E9%83%BD%E8%83%BD%E8%AE%BF%E9%97%AE%E5%BD%93%E5%89%8D%E7%AB%99%E7%82%B9%E3%80%82">https://www.grantdrew.top/和http://www.grantdrew.top/都能访问当前站点。</a></p>
<p>以后用<code>hexo d -g</code>进行双线部署。</p>
<p>tips：绑定域名后访问量将清零！</p>
<p>注意：执行<code>hexo d -g</code>时coding的用户名时你的邮箱或者手机号，输入密码时光标不会动。</p>
<p><img src="/posts/ec93326a/image-20210506145942386.png" alt="image-20210506145942386"></p>
<h2 id="15-配置域名后评论区出现code403"><a href="#15-配置域名后评论区出现code403" class="headerlink" title="15.配置域名后评论区出现code403"></a>15.配置域名后评论区出现code403</h2><p>参考：<a href="https://blog.csdn.net/weixin_43868299/article/details/107601150">https://blog.csdn.net/weixin_43868299/article/details/107601150</a></p>
<h2 id="16-hexo增加展示PDF功能"><a href="#16-hexo增加展示PDF功能" class="headerlink" title="16.hexo增加展示PDF功能"></a>16.hexo增加展示PDF功能</h2><p><a href="https://blog.csdn.net/qq_43827595/article/details/104574959">https://blog.csdn.net/qq_43827595/article/details/104574959</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;% pdf /file/LeetCodeGuide.pdf %&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这么写就行--&gt;</span></span><br></pre></td></tr></table></figure>

<p>记得在next主题下的配置文件搜索pdf把enable设置为true。</p>
<p>测试效果图：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--测试代码--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">&quot;/file/LeetCodeGuide.pdf&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;750&quot;</span> <span class="attr">type</span>=<span class="string">&quot;application/pdf&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/ec93326a/image-20210506135934554.png" alt="image-20210506135934554"></p>
<p>经测试发现如果设置width=”105%”会刚好贴到文章右边框，再宽就不合适了。</p>
<h2 id="17-插入音乐之aplayer音乐播放器"><a href="#17-插入音乐之aplayer音乐播放器" class="headerlink" title="17.插入音乐之aplayer音乐播放器"></a>17.插入音乐之aplayer音乐播放器</h2><p>参考：<a href="https://blog.csdn.net/qq_45533937/article/details/105496572">https://blog.csdn.net/qq_45533937/article/details/105496572</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 方案一</span><br><span class="line"><span class="comment">&lt;!-- 音乐播放器 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">          &#123;% if theme.background_music %&#125;</span><br><span class="line">              <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">marginwidth</span>=<span class="string">&quot;0&quot;</span> <span class="attr">marginheight</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">330</span> <span class="attr">height</span>=<span class="string">86</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123; theme.background_music &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">          &#123;% endif %&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">//将上面代码插入themes\next\layout\_macro\sidebar.swig inner的后面</span><br><span class="line">// 方案二，插入同样位置</span><br><span class="line"><span class="comment">&lt;!--网易云插件--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- require APlayer --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- require MetingJS--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--网易云--&gt;</span>   </span><br><span class="line">    &lt;meting-js</span><br><span class="line">      server=&quot;netease&quot;</span><br><span class="line">      id=&quot;4916164702&quot;</span><br><span class="line">	   type=&quot;playlist&quot; </span><br><span class="line">	   mini=&quot;false&quot;</span><br><span class="line">      fixed=&quot;false&quot;</span><br><span class="line">      list-folded=&quot;true&quot;</span><br><span class="line">      autoplay=&quot;false&quot;</span><br><span class="line">      volume=&quot;0.4&quot;</span><br><span class="line">      theme=&quot;#FADFA3&quot;</span><br><span class="line">      order=&quot;random&quot;</span><br><span class="line">	  loop=&quot;all&quot;</span><br><span class="line">      preload=&quot;auto&quot;</span><br><span class="line">      mutex=&quot;true&quot;&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">meting-js</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可能要等待一会才会在侧边栏看到效果。</p>
<p>注意：私有收藏歌单不能播放！</p>
<p>有时候可能会出现渲染出错，导致侧边栏出现堆html代码，只要<code>hexo c &amp;&amp; hexo g</code>，再重新<code>hexo s</code>就行了。</p>
<p><img src="/posts/ec93326a/image-20210506145254977.png" alt="image-20210506145254977"></p>
<p>直接在网易云中分享歌曲或歌单，选择复制链接就能看到id。</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">默认值</th>
<th align="left">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">id</td>
<td align="left"><strong>必须值</strong></td>
<td align="left">歌曲 id / 播放列表 id / 相册 id / 搜索关键字</td>
</tr>
<tr>
<td align="left">server</td>
<td align="left"><strong>必须值</strong></td>
<td align="left">音乐平台: <code>netease</code>, <code>tencent</code>, <code>kugou</code>, <code>xiami</code>, <code>baidu</code></td>
</tr>
<tr>
<td align="left">type</td>
<td align="left"><strong>必须值</strong></td>
<td align="left"><code>song</code>, <code>playlist</code>, <code>album</code>, <code>search</code>, `artist</td>
</tr>
<tr>
<td align="left">auto</td>
<td align="left">options</td>
<td align="left">music link, support: <code>netease</code>, <code>tencent</code>, <code>xiami</code></td>
</tr>
<tr>
<td align="left">fixed</td>
<td align="left"><code>false</code></td>
<td align="left">开启固定模式</td>
</tr>
<tr>
<td align="left">mini</td>
<td align="left"><code>false</code></td>
<td align="left">开启迷你模式</td>
</tr>
<tr>
<td align="left">autoplay</td>
<td align="left"><code>false</code></td>
<td align="left">自动播放，移动端浏览器暂时不支持此功能</td>
</tr>
<tr>
<td align="left">theme</td>
<td align="left"><code>#2980b9</code></td>
<td align="left">播放器风格色彩设置</td>
</tr>
<tr>
<td align="left">loop</td>
<td align="left"><code>all</code></td>
<td align="left">列表循环模式：<code>all</code>, <code>one</code>,<code>none</code></td>
</tr>
<tr>
<td align="left">order</td>
<td align="left"><code>list</code></td>
<td align="left">列表播放模式： <code>list</code>, <code>random</code></td>
</tr>
<tr>
<td align="left">preload</td>
<td align="left"><code>auto</code></td>
<td align="left">音乐文件预载入模式，可选项： <code>none</code>, <code>metadata</code>, <code>auto</code></td>
</tr>
<tr>
<td align="left">volume</td>
<td align="left"><code>0.7</code></td>
<td align="left">播放器音量</td>
</tr>
<tr>
<td align="left">mutex</td>
<td align="left"><code>true</code></td>
<td align="left">该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停</td>
</tr>
<tr>
<td align="left">lrc-type</td>
<td align="left"><code>0</code></td>
<td align="left">lyric type</td>
</tr>
<tr>
<td align="left">list-folded</td>
<td align="left"><code>false</code></td>
<td align="left">歌词格式类型</td>
</tr>
<tr>
<td align="left">list-max-height</td>
<td align="left"><code>340px</code></td>
<td align="left">播放列表的最大长度</td>
</tr>
<tr>
<td align="left">storage-name</td>
<td align="left"><code>metingjs</code></td>
<td align="left">LocalStorage 中存储播放器设定的键名</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/posts/e8eb0481.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>首先，我们抛出一个经典的问题：如何在一个严格递增序列A中找出给定的数x。</p>
<span id="more"></span>

<p>最直接的办法就是对序列进行现行扫描所有元素，如果找到x则成功，如果没找到就失败。</p>
<p>这种顺序查找的时间复杂度为O(n)，当查询数据较小时，是个很好的选择，但数据量太大就不行了。</p>
<hr>
<p>由此，我们可以通过二分查找来缩短时间。</p>
<h3 id="一般的二分做法（严格递增递减序列）"><a href="#一般的二分做法（严格递增递减序列）" class="headerlink" title="一般的二分做法（严格递增递减序列）"></a>一般的二分做法（严格递增递减序列）</h3><p>明确一点，二分查找是基于<strong>有序序列</strong>的查找算法，这里仅以严格递增序列为例子，对于其他有序序列做法类似。</p>
<p>二分查找的高效在于每一步二分都能够去除当前区间一半的元素，所以时间复杂度为$O(log n)$。</p>
<p>我们先设[left,right]为序列A的整个下标区间，然后不断二分查找。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// A为严格递增序列，left为二分下界，right为二分上界，x为查找的数</span></span><br><span class="line"><span class="comment">// 二分区间为[left,right]，传入[0,n-1]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123; <span class="comment">// 注意&lt;=，取=时还要再判断是否找到x</span></span><br><span class="line">        mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(A[mid] == x) <span class="keyword">return</span> mid;<span class="comment">// 找到x，返回下标</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A[mid] &gt; x) right = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> left = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">// 查找失败，返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> A[n]  = &#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">19</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; binarySearch(A,<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">13</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; binarySearch(A,<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">8</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的循环条件是<code>left &lt;= right</code>，当<code>left&gt;right</code>时可以作为元素x不存在的判定条件。</p>
<p>注意：<code>mid= (left+right)/2</code>中的left+right有可能超出int范围而溢出，所以一般用<code>imd=left + (right-left) &gt;&gt; 1</code>，是等价的。（位运算会稍快一点）</p>
<blockquote>
<p>以下所涉及的序列未说明是严格递增递减序列。</p>
</blockquote>
<p>对于递增（递减）序列，要在其中找到x（如果有多个）的位置范围。如果我们能够求出序列中第一个大于等于x的元素的位置L，以及序列中第一个大于x的元素的位置R，这样元素x在序列中的存在区间就是<code>[L,R)</code>。</p>
<h3 id="如何求序列中第一个大于等于x的元素的位置（下界）"><a href="#如何求序列中第一个大于等于x的元素的位置（下界）" class="headerlink" title="如何求序列中第一个大于等于x的元素的位置（下界）"></a>如何求序列中第一个大于等于x的元素的位置（下界）</h3><p>如果序列中存在元素x，那么序列中第一个大于等于x的元素的位置也就是第一个x的位置，下界；</p>
<p>如果序列中不存在元素x，那么返回值是序列中下标，或者是n。</p>
<p>这里仅以递增序列为例子。</p>
<p>注意：**这里的二分区间是[0,n]**，不再是上面的[0,n-1]，因为x可能比序列中所有元素都大。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// A为递增序列，left为二分下界，right为二分上界，x为查找的数</span></span><br><span class="line"><span class="comment">// 二分区间为[left,right]，传入[0,n]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)&#123; <span class="comment">// 注意&lt;，取=时意味着找到唯一的位置</span></span><br><span class="line">        mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(A[mid] &gt;= x) right =  mid;</span><br><span class="line">        <span class="keyword">else</span> left = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;<span class="comment">// 返回夹出来的位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> A[n]  = &#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">19</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; lower_bound(A,<span class="number">0</span>,n,<span class="number">7</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; lower_bound(A,<span class="number">0</span>,n,<span class="number">20</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p><strong>当<code>A[mid]&gt;=x</code>时，说明第一个大于等于x的元素的位置一定在mid处或mid的左侧，所以往<code>[left,mid]</code>查找。</strong></p>
<p><strong>当<code>A[mid]&lt;x</code>时，说明第一个大于等于x的元素的位置一定在mid右侧，所以往<code>[mid+1,right]</code>查找。</strong></p>
<p><img src="/posts/e8eb0481/image-20210331213556498.png" alt="image-20210331213556498"></p>
<p>​                                                                            配图请细品:)</p>
<p>由于第一个大于等于x的元素的位置肯定存在，所以当<code>left==right</code>时，所夹出来的位置就是所求下标，这里返回right也是一样的。</p>
<h3 id="如何求序列中第一个大于x的元素的位置（上界往上）"><a href="#如何求序列中第一个大于x的元素的位置（上界往上）" class="headerlink" title="如何求序列中第一个大于x的元素的位置（上界往上）"></a>如何求序列中第一个大于x的元素的位置（上界往上）</h3><p>做法类似上一个问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// A为递增序列，left为二分下界，right为二分上界，x为查找的数</span></span><br><span class="line"><span class="comment">// 二分区间为[left,right]，传入[0,n]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)&#123; <span class="comment">// 注意&lt;，取=时意味着找到唯一的位置</span></span><br><span class="line">        mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(A[mid] &gt; x) right =  mid;</span><br><span class="line">        <span class="keyword">else</span> left = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;<span class="comment">// 返回夹出来的位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> A[n]  = &#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">19</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; lower_bound(A,<span class="number">0</span>,n,<span class="number">7</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; lower_bound(A,<span class="number">0</span>,n,<span class="number">20</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>眼力好的同学肯定发现了，这里只是把上一问中的<code>A[mid]&gt;=x</code>换成了<code>A[mid]&gt;x</code>，其他完全一样。</p>
<p>说明：</p>
<p><strong>当<code>A[mid]&gt;x</code>时，说明第一个大于x的元素的位置一定在mid处或mid的左侧，所以往<code>[left,right]</code>查找。</strong></p>
<p><strong>当<code>A[mid]&lt;=x</code>时，说明第一个大于x的元素的位置一定在mid的右侧，所以往<code>[mid+1,right]</code>查找。</strong></p>
<p><img src="/posts/e8eb0481/image-20210331212741322.png" alt="image-20210331212741322"></p>
<h2 id="补充资料"><a href="#补充资料" class="headerlink" title="补充资料"></a>补充资料</h2><p>在STL中，C++其实已经帮我们写好了二分的lower_bound和upper_bound函数。</p>
<p>详见：<a href="https://www.grantdrew.top/posts/cc84a5fd.html#5-lower-bound-upper-bound-%E4%BA%8C%E5%88%86">C++语法（九）</a></p>
<p>如何深入理解二分法以及处理好边界问题：</p>
<p><a href="https://mp.weixin.qq.com/s/3fjDhS3lb5CBrzx6p0XIxw">https://mp.weixin.qq.com/s/3fjDhS3lb5CBrzx6p0XIxw</a></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>个人文章导航</title>
    <url>/posts/e3eddb2e.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="32d60ca5cb3933035a8d031e08b1d44ea81e0be69945ab5c7cfab7bba042a224">fb26124e0d85f363a66baed35993e1a0948953cce3d484fb31660455b92ccb286ba4467b12dd2afdc0f8bd795964707216933c479f00faf5302337078027ef66e68c754bf0232403ae44399aa06a2cad741400e24549082709cdee4a1c1e38f29d8bb6993c43448bafc4543d636ea5bfe35062ad225c74a80f232ba51d9af45093f5220e616be2d57e02341ffad661bef2886dba249b54377d8b3961fd62e8e7033554e6a1a85b429bcdccd8e910eaca84c8e447cedd760cd76a16c64ec7f94ad050108487716cc544f1ca685285a120a1c590efd559bdca18a90707fae890221e2912f079f089d10fb816e69e85944586941b721161d200273028ce2f3cb2d1a6a47461dcfac58b4612622383de37911e7101936179b0ecfeb18f3600111afc775a9e1f79696dae92585891ef4dfac160b934eab29a6000f868f94af7d378088c231d88281e76042ed8fa6335bf3e899ecebc798943c54f86e0caaae4108ee7200897e8dacb394820cffa2cc822f55ee6ec90badb110ced6efdbb12f2d3243cab1e9ad1941b3601aca59c52019feb63790a16795fc430dd99be70e3d92bf5224c192fbe2c5fbc348c87a72e9dcc2adafdac339ec861160261bad711585161d02cbde9230ea38f26be60ef3f199b1749cadae6678e732ff845f93170ed0afd7c81e0008481a9da3145c428ac4eeded0ae8c218bdf24759217243b4466419c718822621a0297cc20549ac0e3616dbc16d3a7205794787795cd58bbd51ee74b64c607df1105de8d94318792360387920c0b9ced8e0ff777acf9d55e8abbf229d207c6836330898f87accf0d9859c96341bf3ab1bb3b449ab6d36d47202e7ea87d09aefd60f4f0a0d8fd52eaf34a700bbc1cb7a1face5fc879de23f8d04e70c0a302cbe75d4df01ccbc1c0f164876a07148d07724dbcd2456cb811a6d07de69294bbc159b518f8bb06d0b8c295062096fe75daadeaa33601b1eadff7c7908ee950b8a67f68bf2bb4d82dea13c69ff35491d843b36a4472cc17535cb73c85f9052a4b5392bbb7ea1c4b2cf1ad8010e7cbd68b9b786fe23630d5486b119ac6dce3e437e5702b9b82f02e9df1379797054fc0fae1ef94af6d556d0476dd1ce5cb997482bc160ff7f567649edca5ceef59cc93f5d56c35db47120fcb0b6c1ee1197c0aae898b84d65c7bae53c554ddd3db012c2dc81e12e0273196caa1c28e148f9ac26d48445a4e23ffbf3c7aa330bcdb52988ab91206cd8b08ea269369c6a2c32c11eec6d460b810aa27b63d27a4c2575ce9f88998fa50f5f554f0d1fa0f4c6ab3cfd7fa330634b0075b16446e23882ea557486b19d6552aa741715ea8449ca5618dc02e2e105ebb731f45e4c19c46f97490bbd2a479996cd7a4ed328dc94eea0283c665377453a41922bb4d2effe0c1b4efc000afac875362cdc6b6eb81c8ca83279d381989a248357e9a30e8e0d55c1859eeb5a9a70183ef2d7c1590fc0293c98e3d598911f7dc1d55c22fe766cc1b64b539b460167c2db434e9fddbb2b1be2301823c600a11ad2963869f62754dd8096f6a060d9ebeac837a03832aa9a9075916f85fb8676e0007102cf0603e262f283fd8138c1a94e7da83bc1ad809e6cf3e45eaf8d39b9d8324269d528033989b6aa5aac49b38578b3d6f0448559d4a8c7b196f18b777192c6601a49cad0a96b6aef87a14615c408530f916cbc72614244e4366db25b46c96ff9da59158e4f38bb027fef4e124f5b13af73dbe2f529b89e563b625eabe21ecf12174c3dec43ed51519a3f9989b0f3d559f8a466a16eecc01048f6f6a30d50fe311f5dc707e3ea5f3b86d8c34b960910f7560e9df88d64a91e4f0a04a6da8530369f4be96d48eab9ef2915c73c90f08c7847bb915e0094307b01d1bb57606ec35a772ddeabc1c27d99c51c0341c0eafd5b3bbd61af7ba1db467e98bc9b2b997a0f342020803ee3524fc45f7771002e25e567ef9aba3c84033429573a56c24341710aabcd865098fde189414b8ade61f0097164699782870ae8f829fb2cd51715f3da13f3136731abd6c4e7750377f3f71ca9ea473879a739a6d304d411ce794e0f46a990136a29337b9cd1213bb368c26fd0639d5173bb8a28b5f2870462706e273bc8664cd1431ee3960f44fe4889848923f4b0721d1ded1e77d79cbba8407fabf7eda609625490908ac280ae3ed963aa188036438e79127a3f4077bea08ed1019d6ecbc3d24b0e0af696d62ae9d12889f4d2cb96e153e02a153b9d7fed8fae3478753a9fe40ea1167e1c4a16bbb5519f087b92476a20ee9a61287eedf90837cab056311da065b445acb6e2e6d63c1b0d42aa26995171162f2899334f54ac976ec80fb8a2f0d790aaf3b6bd89774ea87426936b5ba7bb8a5d93c3ad75e48cfbd52982cf6cf97dc890ee774e34057d3905d8205d6983a461c72022205084e756defe195d7cabeba7760c5d7fe4102e1ac44e43f77a62f566c6f256de8047d910861a489e87fb1e1e1049b45f9febfb39e052b3a613847086d8f2583709ed761c8cbbafbab203584d54b8e91a2a31d476c33d3b56b2744637f61d2a2acf0859dac5a22de280d8487db39b5c81585d45649617c9babd6dfad755a4d49090a0a7c6e2694ea4a79f8e9a9ecdab6272ebef0309ce7c6183531031cbf86f3e84676fe011616b1b7ab623611e9b9ee3441bc90b3ced76ca409cf8be40162e1cfc371f0e1f8732af03bce128a7b21fb99b07d1aa6c7689839a405d9b831a38ffc8422843abc471d45eb917c6342be9019168cb0f7e75dd95fbc7294f35ee269912d32b20a938ce3d5274589d04c1d81a6fa2f49afd2881a790aaebf0ae71144b5394355275d08c73858a9ff90fc59bb6430a48818d583ffb579e02b1e39d3e21be6d65e2942db4f72958f527024fbe4e9baefea17238b7f8ac6b90864eeea4b9c7eb1b00b15ef7fb1ecd28b5e68f9e75b93bf09bc775222f46ba6eb83d9e1be964191023c811e9dcfb9ab39ca4f7a34753ca0b7a89f6efa7b93f5f5dd9fa2318942ac830b640cfe80f25732e89ee37f6fed3532768893c5f02aa8420a819190ba28e98026ce07d3ae91d2a33ab2e454c140ff001630d98faa159266ad63a0c828eb25b911bd0612443d068f375d19e785a30f8d37a5a63222a2d4759844172e6f061e580a4afd55313c82c1f8f06c146474d1728828e06a3eeb920c277db8927df8f7c747cbb8a5f11984cf2e87c9744ffff2c159eb162604a0baf6f6c22ecb8e495e388cd098825790d3e662c9459d08301b2e37732dcccd36d4c914c3dd63c5088d44520eabc105f002c611f3d0f94732e978814ad5c9f16bd77f6d74ec5fd59b876f55f928fb705ce536349466db0c05a4a1782fd0a9c8aef1ce5fe7d7b3604a6c5ae3666e9f286c333e33dfeefdc61a7fe40a21e9571b14bec4902b1b7bf171a11d103c5ea84686c4fb458ff9614668dbfea8c171fcd8c6f349612ad7eac3785ee75fe1780430f2c911500b672d2c39d350d48e142a642d7f51b1df75eb545f6ed3eff2408de62bd6f7623dc4271eb3645417f69ea3fa0bad17d8d946fbecaa9b6b08d09da161691ed014d56f0af130c3df015c177507b0398b5b58983bd9fa6bc23f0576653c1da4fa5669af8e1e0ee65a43027ced0671c3796d2928dd4d63e149e3c1213876a7937e3b63787ab6e37fb5d26ef94adcfcc69aea0f033f22ea616053ad64dd1f60ab7c0e4fe3586219ff0cf9d63d3abf003ccfeba3ae1dbc22547a31af1b7105886e70401ea97163bf9be14a8201fdaa42b9e7141aa82633fd3529af02ae155d91438a4c5afff6ee2b62b6e92313915c51ef77e63370090c8381946d634f6a32663dc8a01fe8052e037aad95d9afc21005b119733f5cba73ac3e151f255800b1e7221084158f11290ec5dac953025a851b4a81871e29f469ae83f958685a5b040b2869e1a2c5a40ebd8180f4c3808a1e086c4dc243704d1de4bc628dad21bb9e8eea094c41296714c9ab65eea42dd3bbcf35cbd7c0d0d31c43c5c258cbd10a5c8d96aac3ff9f7d94c0309baaf8597f3d828225362aab700f2ebfa1fae21fecaa778cc2a4da2a0d6967bc0b9ec356a381544d0be02b0bbad32952fc288dc392c33ada45c6738eae1a557964d4a9bd1ac274eac9f2b5ba3352735fddf71a2cc61b69f43198f2fda0ce983a34797d3964a6fb82fc3b795d307cbd0ec533ef400db6848050877ba0c164b33822b3b116e4f83595a10496e77ce2a6e8703b3294123c64fb949bd487803a78a1a28bc99e3a48c9b419136d1bda438c870577800dee539ec6c334067888a6a5977a7f3ca328682cac11447d3392278fbbd8e2a96e44d9c1dd855264391fffdf6699d76d66963837947583b0082c84a0ddff1a9d11b3b74d5c5e04bc597e51225950cf017ba74e7b3e1b381e89238de8ba526b1b9229f617e34820f7dd29eb1e3441f97346ee60a5154fc349ceaab225efb70d73feb2210d05c27c58fc6555200db49b7c92f08429df3ce91a7411a00db7f585f9b67467c326d99d53bf9605e05292097371815a948add0c1858fb4bbcd8ca39147c9c301c04f293d10fd5e95accdc8b2239359b68762fe968a57b2e8758b4426872abf4623e3c4efafb5b1d525c24485151d4a4bbdeaac19c1c88cd7714b607bdd0b73dfe5c1d27e18d0a18ca066ea769212316d6b3fce6d894c442210d97dca45a2f99c580557b627098b1d16a09d5e180f59315c138176197aa41d27e31db3dc6b0fa6a680afc628342217675e6726cd8d9b9f62fe8921477635528a99f62cedb6591683a4cdc9301bc71419e19214460d34505d23a6d1fd7c67c06159ce4475fcb916fb19a5a9739bb313a01dbe520b405bfe5dee5a416492689168d24c1e628cd1ed4e30976f80cdc6d3e66fc319110598686fadb31bb071e71c628f315c05cbf3d98f0fd202799768c2b38e7e1b1093c942cd3cdc4703625eee265a89f02582302047861365c3e4c94fb63628e613631a661e047b49baac674ab4e18d9352f3a455a2b0508fab59f4e5b2e6109c1ad5a1db9fb557859e4ffe839d5c68e79fee1b5921b2c54cabb3cc8f84b333a3db4279aa1ece69c17b787e80f7f9c433717e3bd5878538a22668e1a730f3c4c903d82ca45ba682ac3357e0224369f4ac0448b18a0117db896a7a41e87355456a72533bb16895e9bf499a5eb1444514c2940fe364c4fdcd2409e4f4518733a1751301c1fea34f76864bdb85ff135f5ac6d1aedf673ce11744543609605c04745bb145a4d1ef7fc3a22d88af2c7bb23877a168c6a90370cab23976ea54d43cfa56d109f8725ef96bb3df37f88539ffb973ab2a623c9e266d5132f01464e1d98f8361cafcbcdbc94b0d17001d9cbb664a2fa415bb697cd1877aedeca89028174b229d939012edde3f3669cb3c0a27000b962a2a4fba7c2ebd9627066035e9c6aade0bb39eb1ebfd5f1b72c1dcfc17461a5604585b2b0c6dd8ef9163bbe4bf597c78a56a812f1adbc6613428cdc364ebb4e6b245728386534bb6baa39f72866eb431b771347dee903b01c836959fd7408c88acf6d0a46edf4b7b62b80bbca78b46dc871c91f484b6da1dffa377324e712f6f5b647adbeb42865c7a0245b30716141fce5cb949905b0ff6749de382865c0bf2616c87a7af492af482dd6df26fad30a313c2ff5e474ab89eb85c3821696ab919e02eee350967d6505e71fcda39a0c2af70958a7fb9e7871948e25058434f8fa7181a0c38d7b76eaa727a6aabd43b5d502b6e7ec33d5135ecc55aa3ed2195c0cbac6c89456af63c40e5047fde53b0d58c694f0a8eb7ea4edb37833882fcab0c42250916471502a595f53c4eb93c0db3463908c5dbf686613a71f09f5e31026e856ff3e8aeec620447c30274649b78765198fe706b6986ec1fd0e755b650cb6694e36317817e069c8f2ff689b1174cdeb858aa1f9cc6672979f014843e11b1d13608b4f3d2511721edb6a5571ddf5d6b1eecf56d588623b82824a696f6b4803e6e164642217539aea6fb021746d63aa962e2e1b89226f3a362bf0d15dfa9cab51e01cb6ca38000d0c898a15d685c58d95488f60a40570af56b3345e60cfee3e8dcf210dd82792db37c78251367df813886cdeee768ae064e95b0389a82fb5bc6caf300e3aa43d032a2021c3d5fd02ef6a2f963bd82e3ede823825f9f871fc33a78c00088ec1df6ebeffbe55422a8b5ca8d55fbbc727e6276c73d0c50a87d7dc3513c3b4ff378482346a0b1a972043ae00968a8f185489fea3d74806d3c35b8fa1e93c16e56c92a63c0e33ffdb13a37cf2e6a6000de451f3181def8053bff2bba7b00885dd87427b920d531a5b1728d6e0d898937232843518b63f8bf41d7510167760ea231a0b3a04363642d0c7e3edbe69822227a69fc54aef5ab7bff249ea6a83249466b40e2b4eb5bd640decae27ef9dce7aabfdaa71685e692f63f0b21074de2addd251f7225b987b763f4db7aab7fbae7349ef0e12a5886c0cf1230328463e8f8c7e345f1aa3069d656cf72bb60e320a0bb005015db22aa6ca1a2fd426207d25d70303c87514122fb8f9a4c99d22a99bb01d1fef5086522f151423145b1fd70742722c4dce604d01893bd2e46720a0a1b9d03db1d778b8fa2ccc34564bcc95dbebea0f8ff2bcedf80ad466bf03ac825f63dcf7987efd1e7ef8098bb3200481094af8157085545a9b30953b51fda5a0f26215e849136a8d6b029cb17484f1f7c25016dd729e25a806fd252a51f2b4ab0bdecee015adc5884688f6e4575aa9a7b0e59bc6fe9fe9528b7e31e89c215beeedef333aefbda94f9bb1714d4d7c854d97d6cf47bbc19fefd41c7200d238610179810cca7845745ed3b33184d746b0bfc70853b2de9e4b2e17708a0589b92b3546481db92f5c7ee07c42011d99346f2b4dedb776982874c683f7b1bdede9d9a92b6420d948427c6f8dc65db8d9b0b446c78f2608326c7a4377717becfd0fff8f94e704e4938ff92afecb88b83e01d2ab09a879e141fd2719a99d4843a242c6612c3c7456a9ef1f4b44f05e9212adc5a0389403d6be586c34d75cdf440f5c5b056e8ead1d901445b8a82a52b51495d0fb89f094579dcb07f8a676ffe36088c5b6ab26b016ad3d4095342b0937d616202283c3bd287dfb6c4670ada00e7c66d3b5f5d27aca8e8c2bc256e41c99efe4946f7f7c24963f835247c3974658c73fe6e5c0df56a0ea9e236069d9034990d68ebad628aadefeaa4e4c672f1aaa0489843f297497bfb4ae734ac47cf711911d750c60d0bce7cd5ab84c53da9bf1cc00798592b1e9e0d52166a91df87f30b66e1ead5c561f7100efeb0f4f4768d206ff07f7a07817f06ba2eb5a2d34c5ff75366c26178d145e944ed95c39e50a40607e1b2e1946d873f02c51e287ef7be172c7e222b66e5a8c2abb19e6bd1bc4400a33933c2b76f1734436d39317bf6185713d2b70c09e145f61aa082d98ae8cb648fc860fc1ecdbbe7e05f3fa25cef4dfd11f83b70725164a5f893533f20f4e2b3204da4796d64e15e99feba56ee0531d2b286dd182c2fb4ebaa48717a99ad6cf03aa753fa01f9a8f358b1faf722192fd31c3f95604d5d76d990f8f7189330686089197f5b19c6154cf63e4c8948acc6265c8eabf89df07245bc34d8d72a9aa104090fcc4df5f803780f209d1787c2540d796b30528be866a824a78934776d3f8598a410df19614eaa2351fcfc0d3eaeb77de2f646bee59691b28375c12fb8ecf8d430d9911f0b102f022ef65d11cc2a0debe4527589c320ff1118be85b265f31306bc2c0c16b162dc6c9eaedc6e72b8369d5d98990a70afc8cb55c0a5a89112c789873817bb0c56d01a5173b77dc5c07660530fe9680cf07f9dbff74abe420a4fbab37c9c782201229c5382e88d8c0e0e490a48c0638f1559dd815abe5833ba96a42a6aa448be7b392530aad2ce81487df7fd397a501d40ca658b04438c173621775830a772a94b174af6ff06aa345afb32a22fe1ac25ad94b32a3a6eb354b71ff331c38d603fa48505dd069d99efb4287ec78e4cec448d27e84a42f6a946bd867c727eda785d72b1af713dde964ab21463263fadc48ca0e79aea8ed1d3bd44fe9be8f0307bc010f002ff169316eeccb1b7be6c34e19250d4a690ceb57ad2f984cea8c36a1cb2db40d4083f390ea36e9da1c81f1e778a295ab1cbcfc08de45672a62536c31ccbfcd3e0e3ee60b57e516cbef1b4a98c54dfa19de4ae3f5d6a4d7d8b47792398d94f38464dff623737c86a26ec010e902720432494a6c127ab281d702a5ac67fd5b0b3ce6eb9d78ab71ce56407339ab91a7c084cb23c8b4ac4da571c751f66acd4aa60c7b0d7207d3190a9cc0e6f0fa44fb7eb0aece9bd35eecfe0191eb442b51628969d24ae3db4387df3f909b49a87ee485512beb64a7489d02e55e62b08e5096a80af33013164ac9538fdedec3d3d31fcba0ad37b639d88bd887b2de506b43ef22de78fc0ed25f2fd97a545db8015f7918119edd217bb1eee6672e2127262178eb28075711c36684052bda536633ed3315b23a31c3ba1060293ecbca53ba694143b851f04e5e9e31d3940b1b76748de495037b9a1c661cdf185a406e0862d7485a5aa1f636f43598661296ab45760748d4865e1627fdf1fa24ab60fc818a90978f6a837d550f4847fbfe69f3ffcb7fb8becd540b45131828c315224bb14fa3381bd2e710cbbdcc1ff66f12d073bc54571d1cbc5e615600004c9b5d0c80c7e3c4904aa2ed5de191f3e2153fa660603459e18c698cfc490c041698dddd24133f0f53cb49ad001d701e0c330fa0bf7f638db58c4a29c7052ca2d0a837b7e25287a54db9af471101093641804fda6447babb27aedb0e9351cff250227095c3e5eecd6b6096f36b453d88c8395da48065954c82229cba9ca1d32cd9644c24093481df7164c01beb9792d37fdca31450b5f22312b5e72a5c15ed23b9cbbe040a14ae1dae78992af1abec557d1d2deabcee6f553a8e8dfab05d5210fecf220390db7bd14b142c4b67cbb6fe2ce40c14f46f16eebc4716d2d3fc2291b4397a1c8fd95ec9ae96ab3604ef851a6aeb9536fd9520dde15c28fdee94ab8e3be6d36dc538345b482bbc2a3deb96d77de4aeded5ba327677397da7e537b8a12ae78c92414d69cc18434688c5752d6e876f5834fbbb295c14bf4eca8d7f13adf8b5b56f3fd8298c73afac0332f21a06d476f75598befad7661bf779ee7d45d5fd39226f2a177bce1261aa7eb541753f9909b13503766ce15c4c7e4e9991074d733032a573cd748ecc9ddfe4b4a5bb89c22a40c5eec43cd387fff673a341ccb9bf09e226cf81913d653d8c8049c7092c624a4ebdba08a3ab0f1856bba1e618a1a223ae45e31a4a9b17f8b0f98ddf8f60d9f666224ae1e86caceb53a297690ae341a84346ab8b69dbadc4528949e8b063886bc98b34ef50d1e20415ee759afd8c12692c995684b508ba53eb85a13232397267c127b4fb0777abc0406298767a2b1d4a47bc5a7037280de7b2577d8f33ecaded6b76e9e3c3fe03e19ff73ee83c4df9da9f7ed57a88b4ede550b15498af2c0375c4cbe4d295b4c01412ee12e5faba9a16864d182f10d2880c1f2aca42180710b6b27ac31434774cfeeb737fb9e11e88ae814b9389b1ace88b002e664cee213b561fbb20be38cd0de5ea9db26c9aa0518d9d997eab4e2a7985272f34fa9d7c05f09e7931cafa2aff54112641a449419bcc47cfb8c684713d5be23507085e9d9398c0fd5d6f71d8019ea402ac43f1e97a02b1dd5c1c30beaf5a0108c618761f5b9c1b144dbe552cdd4664cf889e6373214cadf17d1d293bd31f891b28adde448e3bccae8068fc8a8a668050e73737deacdf18e8638bed49e617e86f6bab11b299dc217278df87385fac51a3a26d2880e01c7aac45f32d972393326bf44c5c3c2188db9b126584cdd1d1190980f4c084edf4de2cadab40d80cdd6621ac1ac31d39baf699338cead167da0364e948dd9b14697022587415199a7ea6e9485da2df8cd4ecc33b979028e4cc576ddc6fadf2d2f327d1bb77807ada54f4006633837486c8df8b52633e047b6fc5784cf5513c04ab6480d89e35794d2a56f40d5c7131fb55efad389db4b56b1440e71a764237c0e6074510dbe5e345758174bf29faa447a580a8b44a9cbcce1876a9fd867a7e416c6e224766b9ec84ca135aee28223e9a19744c77c11641c3071313ca4edca5f54996cef8ff9665acf1a136f72e5377bdbd18d9dc61d021e045a8eea87d744f51936a46476beedb7ccb909e0c287965e6d65d74fc9c63ce015657bdc0e6d61b9dc336e2caa78ec75190fd17149355d2c4c0fd0aa0ef495e291d31569a248d11401ee40785e60d47b374251b57cf4657f927aa67d724ea994059679252c8ef5ea64d3d59a28ccfabf6121e40b7b39939e7c84f34267e4b5781f5ab75683a7821edfaf87ece81c74d0500c3522c7e9e288469ae3b8c3661a14a2d2b50e14a56e71c64e8f6410de3e65f09acba32317c681d81806134dbbab855997add4fbef3f9d0b4789dbeebbc791c8b3d4e3f21b706658fe309b50cd335ce096174baec61aed36d59b42421e1deb8e41d9e6d10dacc4af2577543e43bfc6042713818f6fcd7aba40e2b0783b395c5665eb2019af5a4439e7a42343d8f4c88bf2f70485c87e757356f2fb61aad2f01e1a447af41b9ea3bf13af0cec7c32783556ac1665f5bd54bfc2236052bfdf052ed5c40fbed024b9864fac39878f86d1920ef9f525e3de9720cc193e9e2aba8983b35501300dedba7e0a83fb9438f6d3e5a1ad5cd1331a34e77075a92963c5c1bfcb9a949da861f963f3a101c95c8e597f17e4c33e9bcee77c99297ec9660d760cac6d9fa94f8753af5e0f248439e82bbdac27997c478e5438a84d32cab3d7387f9c8a83f75ffadb3ee455ea1398416e612a20ca3ca7ab5f14e06e9c2cea202dc7d1b02abd3d9edd2c0ccd226b3e95784767dcd25d8f17c1ca537e039cb6c312802f3a93168c51fcfd8f43665c7e0e67ce4e73a1e4a6baa484f243a374103c1b308b3c8cb5c9eeb225940349ec90c4d0f03299a0822eb6a49d4e65ce45ce55a116d9a01ae293a43e507250fa9133d7fea14298d3c8c5a00ae9be06c5d1e37b4200faa4f58ff6abbbd033cc95619d3d18eeb7502189baa25613dae93e6566b98f888d19b3c6aa0e2125012ea941d7048ee2d932c19e170c290eba991b911fce9c7a49c44e8ffaf1266a3874552ac578ca092815a6e5929f5ad81609a6b84ed97a122766370795c9e4fafc9e08f7ac3541009180c375eeec2b312bc0b1f61f417cc44df7856f9882531e9db011f2dea4e856adc36f140276da982904c91e1b838a29211e78bba3e19cac4b9c465f091e2531f04634ed72ea48ec63457725f5d6ca12709809f6407848924b9d03516baeef425ace33d93484e7ce4efaa101b1c77797adc5df3cc2aec35859d5de59012340c2608458ba0b6bffcf330936a6cedfbda4820ac1e8b8edef184fe5da6df717412860af0c0092912fa37e9a2cf2b242815397bb5196c67e7860ce02836ea6105962b93464278a363840d28d5fd9509ded040ed1b5bcd488a83beafe99a1db9063d21922b017d2071a85f400eb3411428cff5e50c07c879ea00654c9b1158b8373b2e4310a3ba424132c9337af38e460d049921a302be73ab42698de2747ded193b1bf6839a299e840acc82946b61d678af9bbd7799d089a42c0320ca10a3e4a906d9e92d1245ae56042fc686fe49462d6d7846881ace8a583056e5ea5d0598d9a50120d9d6bc9bc0c5d2aca43f1bde16c9c470e17bcb805e6162ebc2154957e83608882ed9bd787248d5a13f6429d53970a36fc7f1d2a9dd5582c31b5585ef4ee1c83662df729d28093fa0838e6eeb8b96329f1be6076718a5b1f53ee12ad66464399f093e21c05cc049d5171457ebc3896ffc9398ce925fbe331e0405565679aef17580eca19d10676a049e146d190eb8d2e89ce5a8fde11315f120df0010ddacf4133cfe865a7ee451ffcf2695ddee17fc7f6f01bc68fcdd6bdf3bd3efbc5da4e0e3659347baec341ebbd152d87d91f687a7b5362a2281235b0ed02929a77d105e03b6d06aa5139c6855ccfbc925d7b0ac6d2888aa978fd0acdfe39fcf2d38585897e60e627b1e922bb50624dc55774a1d2d7eb43e15cdb7b95e1675e2d9430c9b28b94199926eb2c7af09b10b0adf5c52dfe2f0c1ef60f22dc0c74da6183d9c2f799e3c8fdfed7cc14596a015562fbd5b7139420ac74c536309dc67476aea06d3010798bcb6aba9fa914e98de3c988739a5916a44d4b6b3dda035cd8d9561cc480dd7311acecda229fe520a7ffe663d6b5ea190965194f7eb5c31670c8f339f3d40bc3129a9a5aa51bd6ad399c503a64ac28c29dbc5baab29c9cd6d3639407bab09f12da0b674e8350ad33b414fcad755aa6b2988c4604810e571a20b207c6fa7342389d6c0cf45d238705a6717864466c454b416f965095971aad0f61431c069370972d36f0c3d384d17e72c89f0bfe52fc373c90c2bca549d27e1f2ce88aa0e633ff689edeffb1deb010f04db06a74031ec466f3d932fcdfc879f604da9ea8842dce093ed49e1e2b5b49e42175f96ded59578eb892d676e608a3bdc9d7ab6a56655262cb75e97340442f62bc3c0f2b62e9a89ac183325a5f5566518c37367856af27e458a31f0c4f2b440eb82b2fd12af44eb79248048ed39127fb37dbd23590a641a8e45224de269882709c3532bef4ba203c31790640385f53c8b994c1e0fa0174d47480dcbd9239cf249bd04208d5e4af610d315e86007d6bdd98861f25dea269f3165d7787a6423c8ddb2332149fa2466ff7accc9f37ea313eb9b6198f15d7de51efc4929a64f832bddd0e4ace2336d9973058f2f8a3faa9856f691dd47f2012c8d62d76328e2583ff4a67b16e6bf073463e9f5372316707c13b9e50e5317e32314855da3b5187ad816231d02cdebadea018515f25583128f3dcaf2dfc540b694a89bd53b50e1f6d55aad650d2ff7977981c3e39797b393274b485e349bc899be3bc82fb6012d9e0b5f899058f9a573cbee8b9c4da9d85ee20d036d86e778f2e0d80e6bdf75c66c486ceacfbb19ac1caa2438cfacfcc2ac6ee8d9ee8b001434b5d00e788e7225a91538ac1dfd240faa6af3bf62ed914da4ece448f44cf7f010f59d398469440334607441d9e0f968cc1b470a8edac916310f618d1a3f463261664d50c981e696da0b25214f0ec9ec05e3c9e3de4350726f5070ed4532a5a359bd72b2ae6139bb218a35fd5044a19f462b58f8f697a17495dc74f2fa975891cb6ee540ccef5c946d4c2fa1e02921432c8576ef7d19ca2195ebdf444fe1c6c59f926d68bd236959a013d7ac86216ecd798d66cb178a5b4370b0decb9b2f4a8a0414d4caf3035d7fe27f0b80ac4c08af8c2dc50f37fbc367e1024ca0580b12faeded8a2744adcbcf71440468ecdbf0bae161f32113f0bfa94cfafd53e1e158bba85c4d9c6feef39d7107c6df378e5b6674ac88b2c0d71a27a75dcbdd8e2bcdd105f0a9505138ff1153bb563a51ae97e597f2a4ad118ab2248f0a0746946dadc0a0f6582c2467470cf51e8c0e4580fd39e65466ad50d93e1037ceab3157b44395f9c0acc894992f6551d4b8a4809337a73bb524c39bc2a8bc34e1d50430d153ce3a1dbefdda7528b9ad8c018e180d93f8d0b955803c437cad546d6b2a62e9569cf8e4a34f2bba1742949babc5bbb94cd1509943fb887fe476dbeea1eeeb9ceaa25e25ebadf59c4b799181044e24fd9b11bc9ee88ea7f908ddd1a6d2910fca0bfd69308c525ccfeb89b57faf1cde00077fef41fc439b765823bf53f0304987feaa0c28aa942b51b8ee159435e2d5a557393ab3d77f013a64b8eb74f6029465e24924b4d566dffccd6ce66f0460547b724e999966faa65e9b118eaf8de83f3d17f202b7e5fb3a8b18d7589d3848f3e434f318cdf7a1aef47fffdff478860d0c2829d9c72a5d06dcf7beab0163ea2e8f0a611de24e04303174d735b8324340bbf9e164fe5850c4c6ed44c05f1c708507da09638884b91bb1f582ce7e00fee3bf2e7c5cbfc4efe910193ea0cbb1e4f46c2dff49ae05d782e7700eca9f18ab6c82726be9429270ddf40a940e95bc0ae55099b13b43b6fbb79bf39e1ed8bd0943c961fee3b4af2f3c59801d64c2bc7602b3df80f81679b794da41a319e619c868c247e541b6877f12872aa912d94f107be916946142a3ca07814ae80f64317007d9c14afc5a3e23501714e168f587cf5a1a8d0d275dddb0656290c836fbf7f0794736527e0fac7ecf91ca7765ea4ee48b0bcfe9627c5f0e16d1f01e4b9c8bebb16010b9dede946fe4db5d70cd671de7c0d6206f62381caa479aac936524d471f13d8a69042b8f3b1104044f3bb7948c64cb45bb59c6c6c66d78cec196f5009bd2611eb3d776c92836cb304515b71847db48dffb88cfeef41a33456f656e5c3d4ccc795f4b51ef6c17aff018e52115113a1cb03b83f01b2af5179bbce24ef8d0ae11003f50bc57e4594b67a8ec85d3082fecaabd425c845fab77c40235f67edfff5a07ad4dc05562cc9fdea7f3c42317ec2eb6e252a2f27656ad38443188ed81ac2d2ce91f4be3117f962f8a61737b4e4ffbfacf130033db5dbcfbd28d995d8d6bc4b11200d8761e1cbadc5fd38d166c1a851d0d5ce073b4a081b9f8653af54d571a6aa3d12c132c8a1f52b2535c555867dab2b04383e7c843f103f059af639c315ea19a9d1d187d436119f979d0e5b02055914f7d080dd64a54b46131ccdbaa62138dace21ac247e0147f9e3babe3d6904039821a23807956cb68275255e1fadabac4a223bbbc5c22354a27507fc97f5aa4b8b8edf296fac8989368e345c3c522585d22fd9b6674d166bd3cd5b4a36bef4a92898b4d01efb99fce0f75567d84770b3637817c016a5ec3fe257cab77030a330bfd336ada04bd279958009bd0cf948c2137aa3eba3edadff8dee009e9c7f1e0edb556d4ece5c965621deb89ac3024a5dd3ace312824ae3c07f830a99b690aac44d4dfe069e4857f0e299383d9d3b36f60de85dae260f53e8c9e9a26df0a4783c878198132887096af4d513c931bb450d846144c6e8e2e6d3b808f3a1c0b807de8548bae6a273b5f4d303070e44145d84084151d801daea17a3fbb5ffd063c5f631380ca574470c3ff7f0745e7e62433474e3801a91ab182a49b05a764de4c151deb11074d7f0b0f71f31293012b11a1e024982341d21d2a8bb0add3760f697b9f3cbd5f10e3ea74c6e7a030970bdb1924faff23d14dd62719405b0b4a885eb8430df34dda431c97f8873372f45434fc9fbfc2a0fb1ee9ea02ad454a99d9f85c5b62f55ac1a088a0682c1fe736f11fe7e0c89afba80a877588e22b1bd3d8e291f2d0feb2cb8901be861cfa1a109191ade7820c1111ae7eee1bb9f6e1333c368083d17a42cbcf67cad8d7574e1b2509232a02952192ccde8c4019bae06da6dc3e3a5f9b48c37e04f185f6a8a9db1c42d2e8c83960a9d72f2bcc2fd44808ba1482ab5d0fc522bbc547f87fa8d7d74953da2a74486a08f4374668c3a6e3482043f79ab857eb1adf4b0683b2265444ee32f57c224b358875e6b72ceb498c0217f7ed1ea6f3509e2284aa1c08e5d2ed03c78317d800860d78ce526103afebc83bf1490bbc6f438bd09b1a88dea7425abee110224dfb9b88b89de6cab0b22e1e8cb29f55e66163a947608f6b8e8e7eb2f3ade854b382a0422a4d904184841316d029a521247fc0939603b0d240ebd637a262c64b64a87f7f99ee79b773d65acc3d9033c3965c4e87611ca8ad1febf6c89454b519dd9c6338b649589dde7246b98edbf9c980a5aecade76faa61540fd696d84ac24a3fe9943fa8a16055a014f029225a00510be5d674c4c66864cac127db66c1ceb14b34e9d79d2bc6b780b56d28ef56db6ebd963f7e77b3634055de136258bdf66d393123de450706584e84cf2fc20e4acc41df1f6206cd8e35893149d808f08db13eed6d6ddc8ec123486784c20023c5ebd9d9b60622330d02f31df85b2c6e7a637215ad0024137535b410fe356687a92d36bd41d1d559bbe4707f35b6a75f5014181c5eb2b3cc0ce404be5f3fd69b2514c408ab421ee97d2b63bad870c720ab7a2e86eb3b0d3a3b759703c607ccb2e8c00645304a02b69ba483fba87991a37e7c22baad051f4d3d5ce0bb7fe338933769a547611199c66ff0beabb77f06381eea333396d08da521c5a9618dd6373934ceb3b4bfdb29fbd9dc1c72b716e5734519c2582abb563203df0532d517c347c6c078f54e017d03aeca816383481c35ec40f82cff77fabf5f96825b7b4aa814d63afaba00ca549f76fa3b11a1ed5d3115ece1aeebb5527fc633abdb3523c180992d22c2fafecb0bc1e83cfd3eb0198a5b740eadaa72111fa975192b5845ee454f9f326259866b32c956084b07e67f821784e53beab99d921f9ad3358a5342a452692c81781c4aab1ee24acac2d05dab32dadfe80c1b76457e1881730d882cc4a1fb455474f134855d396382b6cf4dcfdc74c39b6ad25d49f7e215e4167f93dc37be9db8b22e06c1697a178c3978feebce8f7ed548efad1e90d55b64c5c9ce4b92f68175b0cd94f108150ed3eee0f34f7c84277f7e060eed574c3c2565ebbcf892b7b9393ea8a1e6a30cae6481b1dad3b6cbf50c35f8e4e74bfdad4ee57c38b77b5369ab3704a00a30b320f9f97cd114cf437973b1cfcf7462e9dd0ba0bd0ab3b68b4399299ed35eddac53f9051e031719b56b0f787884c561857120995cee6dcd7bf35f7084a11ee210c02dcf4268a9cc45e69581e2673b1db1fd59731a46b8c955e14149e069d318b19d21fd5e00dc8742fc5f92058f16c5c2c016b8658c813fcae0d797c248e8ba71fbdaae96606800a9699bbcec8f22c80c8ce7c5b83fffe6a79fe82dac74bdfc0dea05aa93a8366b557bf4f4af71184cd02e3aa9825645263d8aba490d6c4f8364edd6bc9aa0c717bea93e7562f3fd62396a485d32ada8f7d791158b5c73679b00e90b7713389fd342429b3b545e9925b819e7d46bcdff2204685577df967e1dbcce9abf6b3d69d4e5d01dddab8ea7017bbae2dcb802424a50514f19686f83f86b8c3796eaa29cd34dfaef506f296f28a3d0b0580d0565daa0d537811464fa9f8ba097caee74b5f361e29a3820adf43c57c2c3116d6ee20a9684893416e43545aa5d6bf9c4c5f0a90fa4601eb2e51e3f0026c13400b54a2b3bb66cdc75c145ac45e0a0937392f9b9aab30822d0798613d8eb8f5ea90dc8ed70d11407e65c6df838a38459b9009a235322d6cfd6b63f758cf2c0a8a66956282d5165b485c30f8f4228db81ead917e9d8653ff6483ae44a1bbe7520595f2f59433a1dc575186be65dfb43e31bff7e3a407eb3980d0d985133818321d8a26917c21b9062a03e5db19b8f5c7806b5b92c11595fc0d96b9c7e0dd7dba0b4e623a081f9dfafa6eddb64b0115617acb467305cfa5aeb1b8cccc98ffce09955a75a86cff215e67d938153d17e1c2f54c4b6f02062a9352f90a3014e03c29093a1a49f4db00818ea0e1c959ea27bc73f582f797caa62c0248146ebaa349db8c2d628e8ff72ba3291b28a76c3b4828d0677edc7b1104bc6ca8584fdd12ffcc36d404b7a6dd77a91b9799e30acc0be46f4f41ecc72a34a487224ce1b25a6c3f1900f6a8d158ebf2dd065c4bded6137c93c9dfe953ab04d48d7332503ce1bfb70f4c94eb723253c74b4ae230605dad5cc0bd5a4425b11a0af565e234dc286e0e4ebaeff2aa786baf6cae3e29666f0ae1725f4d6d5f91dc75ab7b5ae33b63b7996abd0b75524dcd0a68b3ced366fbad165a242a6c426b4de6f7c57c1b61345268047a671307ba7f68bef30e3a40bbb387a56ab0ef4afb2f028348a022a227d916aa93eacb1ded494fdffa60806dc783093a2257cef191a1d983ce5760bc65a33e6a50b148e529172b4152124c845ac709d4217350ecc0bb537d8cc17eabce9f3e55a10d8c699c25827f2b56fe3b134a47da481f5d0c13d5f6ad0c175bee104c23d3767a5be204e818009be4648191b64dd9efe2b9af79b19358267bed7426ff33cfe9d98cc7a34a5970988b0be4eee7a38f2840793d903497740a2324145bcc95bace5052cb57bb9477e88d8aea693c95a63491ba0b9b85aadacdaddae6207aa7f569ffc870ce36899cee27041cd8254687101f4cb63ef995652f688a69359487625e36cbc99306d34523f862a902e3d9d0b250bb26720fe9923f8c4e1d9291888b1b4cdc1533bee237083ee7123e61f4cb06b37e7ed157cb3f17a6563c043afbdfea54a8082100832f7c4ba36c323e02791351568b84c53287175df4a739c6791e50ffd4e37111eb7d310b4bcf1145812e5458ed4a7de638d1e9595be87a4559872abec4b725db30ed2a02cf6b6ceebe093f876a8537b2c11c6beccff0e04298249a053205621df371b011e6c293de927f03c747a3dc819472ff6cba1f670c1ff464a6e079e37ffc56c448fb8f3985cf688077bb178db4196e4f7f1f680e4eb846ac3dcd2f691507a2e374199bae4aa561e21e142163db97746020d8010e6518eb617d4ae7e424fff36bf99de2bccb0c8c2d3cf509ea0e0ff60d59eeec1feca90c38470e75150c7d0821ddcfc946fe4985bb1c8bd66580b396eb8e50530d7678d3394bbe5d855d4ca4a641fb76d3ba8234f655d4dd29fd79cc2fdc043db0a5e7f27b19e0ebec285b8632ecc492a49a81c328ed327a0f2a2992ed9677e11b1673b499c999bfb889ea9355d0cf08d31cb5d54bd0ea6c18f7b0f4cf56a992ee755f99b15096bc13bfc281ea845218c0b94ce28fe9bef02f66d4e51dbc0d9b9a034d21704197c69041585d4c72dfdd955fcc6031f5b965e763bda6626b09352c89506403d295c9b0ec9820b13aeceb6651f71da8b055fdc5a7840ffc079db943b45a7a1c088eade2dd2744b2ae361b446a7361c0858b484f66ccfe6a2e2964507bdcf3f01d58df941840f2ee34b6329f25ff751f52f4f406eeddef62d78e354bb62e6e20eedce203d512359feb274363c3937316c2f2b4a40fbab0bb95f3f29707549095ce9de3eb796a00a7b5c192cfed0c630dec642e4adb0f280313c286a6bc1d1e4aee8d8757070bc9b02338456c1a445f508cf13aaaa3a828e77a385e5943bb24e47b6a0294c2620194be713ca5e54b575e46e24a75b94661500d38f523dd3f4b7bf801857650dc798105d37902e31488acedd0c636c5ca0372391933a54f11cfb1d3281b9d74b5f1e54bddf3d9adbddb1e175b6af8cd97d547e9a92e86fab306340c53e297b9fad69d5d76d1aa0d8cfadcbcf5515cfddddd3a7933a3af1657ea3eeba296e7bb21846c232e0f81ee3b25bcf5fbfde79b14d44742a5b98bb9dbe3abe84bf34d4afbf3c797b0c1a84deb978a41a653df5343954248f5fb5ea02de4b3aef96b74801de1b281293b1908b4c26d146cf689720c0dd1cc2ef66d7fcf95ddb146b57a7712fb6c97988a0cd79bbd2badabc0ffa333b220efe7cef0b856c9598a82eaef3054f76c90395921dc85c44113e31dcfb9352298fdba1f94da92ecacdafc87fe85bde7a547676f3968e3423c1b5eb063cb50e203089848523477046263579cff13fa666020df9d87ca8cf35098228edc39fe22243c5039ae1cba2125e75d336c22a1bbc8ff8da1be3c02d3abd8034ff1d3d87af532553d8047159c3e0ee65caa30601f0aa51786f2c050667b83ca66aa2fad02fe06ef09905407ceb978c7b166b633eee79403cb19b8233f6cc4bc9de4a2efb09ff2bb29e7f3b78465ea7e1ed4251715f03d6b76b614097e205333c5f97df5338d0f5d655465889a952e63f36bea6ba7821eda1fc4c2a14547625a812a6e82cc95f5d42109bdf914401d12ea12440c63bdc8dc2d976e9c025fcc84689ee9c37561347cf654a427256877207ed7bf9a5ed748ece1558f67083cb07efe1993c55efad5cf066528ffd9e45556a249311e6707ab92d77d9d780e6682d93a65c003ba78fa3f4a69f0ea3d2dfaefd960e302714f45483d4003bb886b39f7d31b1e5319aca44b27847784cfc4c41c70c0d3c877c1921381fba4f131513e995dac041ae93a0b629d733282dd1401bc8e9cf3acb0f9bf86e618d124a48bf26991e52a1aeb126a84fd1942e88a6bd0183db8beb738bc05983e7175859ae5726b7b66520d7cad09fab04c44fea51ab4c75171dda72555885f35e5389341cac554b79100ff67beee713265856f5ead96cedc6cecd355c46f7062f374b4344d216e19f616e2ee97aacfd46e27dff7559fc7e42c46e99c3eba9483bc57dc4de8e6328dc9e75f3cae96ecd90e0ea79e2d7bc24e3b903b561835ef6a0557dcfbc580c84712036b865d08f9ee42a35d6a7fb8aea9dd9ed8fa1e6b15562a6c58d2f71ca4aa93924cc4d875444a0362c3ef00c09841c67ea3f64399a628c667e747a834321cf6e9037d995dcbee5d4ffc6091d9110e46393003b15f307415b60fa9ce40e6c88030d97ceab274dc1c00be53f970959ac1ae4e9e3dbc719d0b2ae7000e8dac255ad116c732d8f861da7816a4733076d7a4cc6ff5e83eba191a4202e38bfec306304891fa7643296c80a964848e8e585ca22b7673076adad11f28bbc71bfce1b5bf7ce8eab653ebc4f4fa168f64f038146fdf44b111a49e78527b1535d30fd3f94c77b56d35762ccf6d11b7204cdee8b92d3f47be0248a9b6a74856eec245481d438e70969b61757b205b638fda31d5ebd9bb8ee818e8e49f66f8ab8ffd931cecae9872c978cdf5a583d2f102b88a9e25a4e840add3062f5722ed7ebaa93d2234e8d8e31fad4838e05fe0c3ad79a187c17f8642aa53c704d201d19735d0280acf27dd04fcff2358e16fccf398e17a064c3a3d37235335d0def57273bdf4beb0c6b15a60ace72a3bf339a0ddef8c5b724a50d74c8444e6bf661e754c84c433079389b3c5170cdd993a0edacd3ebad6e26c61f4e6e11dd35cadc0a1f277ccb60a1dd9e03cefe8fc9e68122748d41770f6f99e5c9d2a109bba053785a6e0ce1b04dbea32ef9fe6e64e0c2cafc9c830325578703136f3dcc49396f0b958b69e326e016c31cfe914fc56f170c5a625dfd016354b7ae7d225dc2b8c5c8e2703fe9b7c5def339b6e75b4ef6318554322a8a2c5581cd972dd3fbd3daa0e15bb4aad3d13e15a968fb994da74a7303461a58af1b1147d22b74059558bd3deb03bbf7665fb803b2c22a723508ff7fcc9e3d3edc2a033c7064f8f4400e158e3b2ba14ccc6fcc4be31d26d1bf08add3ae752b69ee5628e71d06a1ce6a3070226c71b74668d57962bfd5f37365c358ba389d8b7f877809ff25271bc0102ccc70bdfc7e2cebcf6b9dfebeaad9f60e84f7a8a4374721a309d4f963277db44bb4bb772c3f78c9479006879e61eeea221bea9d36b6870d1465969b7a87b6975fcddda3cd2d265e3c980d8f86f73aea843c8d54a323de8c62a73c34e52e7b3136e2a0129cc3d59a45fd79a047e1fd16e0d96627a00befecd3e2fc8a9152f18370f1eddecb817ad4e577e0a3338c17c20411eeb3c3cc4406532758333b036f0b7c3801494d81a895f010084f8a6e7a8c4eec4ea97bde104371ff1f96b744d6a5a4b0dfb4338948498e97bd7e06ce982d2511156a5950d8989b2396e33576d33a28c7bdcf0da7e662e9f4c5947ab458895d8a36899f65b6b96daffff2182222b0ae7d9d733007879f2f58fcc1ea729ce8a84debf3d18589b01772dee3ca29c0882204c367f90d34801a0a4a09339443c1d2376aa8ed40a03ba06d1b5c77241196aca2f56a1112b29b665a132fa72c693bfed999ff57fa4cd33f01b05c980307148b53f3731f25419f1f9cd9d4a1b020c220ba848bf7b488deca89280752dbbb5054a8bbde97d33e0e7c58303a299201fd40679162a49aaf93f9de7f47470dbc5629138a3b7508198156e383ce987247282ff4a82847a2a5f1034308f61c8b445eb2a295a06543ea44913f4ad4b4983c13d0dc93432ef45a7d05d9808d426cc1123ba6f991d515d3f17ad213b330b77298f37a81000a0421d0a71613b24b89fe2d77fdb4742db2b064b1d90dbda4cb0a09307bdb8d904e8ce108ff45f22bf385bdb50c9a85e6b1a8e41e1e112bcae29956396dc3a501529e0c73fec180c622cf4870cf4215a2002b3ce5b47f33f1566098c96c11080d1253bb0aa15be7649e8b043cc10009952f81af446db60b84fa8128227d664d05a5ee504d42b9254958d2117891a8e5072e46d80390e65165a5a2aa361ba5bbdc6a615fb1beb69755c204cd16a72000ea0561416011c0b3bfd7618e7c2c068f3fde76cc8af9d62a892bc812f62b8f2b53468423a0c4236d94199ee9ae7b249abc10ae8b87c854f35560501a255735d4d5f3c463a83c6bd67242c937bb184d345fb0be3638d3f80ec275b661291631a40ab98dd8bea03f1f88e4238d410d787e18a5636ae218e61c0dfe6afb262cddd65ea5b91a85a8ccc95a22e39f521e5153863bcedfced11ceb52fe478da1b4f033a5f7349515e9cf854bbc2fb617118e18ae817216c3d4809f84fb14246882bf091f48d3d9c23273063fc86a5a748d21c92f8253ddbe3b7af7ce4eea8e221911aeaac13dfefcac5fbb1dc92bf4240362b793e41969b314459b59d11bbdf648f07f453dab266722db225eb57055815417d3a6affbcddf02ea3e88c6f6431bd5fb4e9632d520d088e04373b9210189640e6c88b3ad29b6fd421535eff709c80dacb327d262c91c1e8fa2e301863bf55ca3170a7696b829a2e432d030e9fac17106cf6bcc52dfb3eb50fa861e452311bb642e60f1fccf8ac37f249982be9f3cbcfdf81c6155e67b321dedb63df6a62a3f156cd4fe20d1c325f9ad1506c0ca5eb8b7f8c9cdf89436962140d9bf301529ac1ec1fb5ba5d9ce25ba74d50cc578107e7aa0893fd769de32a1173f86df2dcc1a3e3d2fec6cf4e5294fb5dcdfb1e193975712e4e4b9571d125eb5e959cafbe060947df35833837d5ef87647556bbcff657cdb57de3b40dd043af910da20af16c9523cb9273f7d939046e3cde758e288ed058b31fbac949307673a484f8c9fce552424e9330b1caebb8d5181fd62e558de948100483f1f7c86cff2a0cbd28a57bef7f649b4c9efe31048adb601e832822613e86fb15e9a303d7a26d27512754134effb0bace0315eaf2551d4ed3fea46d963ce2c9c1501e4f2a22eaf6adb82eba564d1a02dc394679d701d0d311bae61c56f630f5ce456e7bfd1fbc3cf15ebeb029b36396299b26c8fa9117687390e1f2a2be37d50f46c7d750c5f139d2a59d6ce74885d2deaa2f65078fdf44598251f73720d2e3f93971b3ac6e52bfaeca3a3d22f285d91cf8cb95dc11419cc325b62c199843ccbd458101bc7a11b221007e89ba4abeb005b2e3977c2d21b1da5fa7991495a1f90c23b2d1e8ac29fc1f4b87d195b19cb8bf3e438f75a264243b4b0448c0410139f67e71afbb7066cf84f78640dc30be4a1a853f87309e676b47961622a5f5cea679c72bca785a66fbbc508b13409c2fdb9160c08cfb09e64228c57f61a75a1f66551c09216c754697d82746c7a2358c90a9a900d8ee6aea1d6b7a50eba2355a9abfe5d4c8318632689556d7b01fd9025494c8d398a99078ada481b73470f7f3f52de03212c7daa8340114d76666ae4c470843f263df7e4ca66d47e1673fde70f27d09e002afe3a9c39125af728d402b709881ab53af55f1e7724f3485a77a9c121fd541a7910edebf1161a94758d2586f6810567bfd60bafa4dcc012f01eee7a8bd0f26764b47b68b8ed1f8c11b33c10670e287f9df1a40addf450c19cc64c57ec074dfb52c445f9faf5ebeaa9ea79a47ee9ed622210ff561122e1e40f497460e41121f7d0e7219cd268c8246d4f5dacda0d838708b1d4d61d18a30ff4d8c72d3b90750b9df3c36a5e1624b53c3016241b9e5fba6930e64038c90a339c3e75e50a0cd430ad6fd4292a48a27b2df62bd3710ee578eacf281b9cc33dd4c63e7ca8dafa0a602e8ba1df64328c1ab6824befc828418979778252188d35bef8db07936927f59810df6e0df9aca43768b019704d276ace74a01b9dca3930042c1a45aedc14aff445a2af7acf1e3a817d93c1b5ff302d0797b9c6a44b640d0a1f68cfe81d99251a9ce0d84df101b57d6276c60e8829257cbdb05f03ad61ba0d72c6e3a5229ad1d80019edf1adaa4bf9c1f53c217466a319953597a8d40a3d2f92cd8b330b0627566fef8bffdf1b6190a37cae919d1b73f05cc292a89e11427e8ddcae5fa44e8f4ea1931bd8a7ca9ca01645469e3b8c01e3fd18fc6df059b0a3d86af2541ef96e0c1b378ba739ec70baa274b6680ea6b4c65910b9dbbcfff5e6e8c5f39ea996917874c5b6ad6279f72778138c6e75258719c97a4a9416e1c8b26fa483c3aacf49b9cfe0374bb64d168d9a4cb8fea85bbd16b07d2922cff374c9502b07cd0a9fc35c76f0381de647a7f62a121bae009673132e1fa8837b5c9168f82b5b82ca22860f4add1dcd4de67ec876f5389bd9383364cc18353cbae31e3de1589a84527831cd3d0e0640f86e8794b82eb731e2680aa91590f7fd98aa012f4a76d9451de567f2c429b3887d58d25ba35e5de6e9fb6d398ba97c55a5888d90e451803209489a7e67050412aacbd58d508f37a1b17db01f8fe0f14eb4d5573d72bc6ab0978a3c0d5e19514dd11dde4b3e8e24c9cec593c8d7aee08280ae57ebe6504d92fde78998b4730bdedf3a7b994b6ba25b6f18323afea84a40d2c7fd976a11e2e6b04749c4fe06dc60f16b61b018c6fcc6cdbfaf528a7d3ea8768d325154f5d086e76db1f30f1e63489c1f99a9e00b9edc565aa75ade55876fc4b742329a775c0cf7acb3f4d4d4fdd61911802891a3f6c12296ac8c144746bb87710b3734bfa0d6a00b665b3b09be3014c0cbf8feedfa775cebe1ad06c93a3b11b8aee0c586932c8c41f46d34018fd8c61d90730b717d74aacc117c7a7095aead62ec6c9a9a7d9243972774e2d315715e9cb7edaab375689238bf534364f2e2c2d1e43f110da546463bd032aa872a731704081150a751ad879bbf4a2b0aeaada401e22effb7b4bec80dd5def33f0ba63b6a4f8c6ff40258f59467bc64debd56a3978d820136f4677de361439d62ae57e1b46128e855a66b62ef1940af4ddb6b958be10bd4e04422e287940e7338404c0397ee287e746137f60f7d305885f2826f43356aba56c34258a16aaadc28ae79f162985adeb79c79c35d3fe3d18a608d04288c6e48d67ebbdf1f1622ff5e8e745d223b8149f994bd7cfe413e07d2ba428e77a7b058835bee53c794ac0932da0c96a12e44400305f6de6d6aba35577c52d701fa446f3fd6803804b4a858808e98c5b01053251e40998fd793d1249a98f6829422dff749dd007c83a0ac6d7620eb1a0ba39aaba966574ef0af6eb118404d55e30fc35b08b3d9b5ca684da6019a8ef71702cf7fddf5e3fb6d7ae1a672c450acc0d6edf243871d5befa803925df7f90db7a67bf28d74c8d7c9c0c368ed5a4ad26afa5ec7baad89c8cc2c9ee09c065ecca9bad2e4e434d3ba552f34a5ac4c69a6aaa87b588ac7dbf0fbcf8f6a1fd30b7e53296974e2170db941dd50e7453b11644105c08983bcff057ed3cc6f0157cb5bd818d5c9eb78eeb9beff395f988c7354a03d92ffe1fb5e26d6ab6dc3db5d18ee24081d7417ef29a8df4e6708da64600a66167ea1ccd7d04af8fa0af662c22f9150b04a762c8a857b7299147b6fb10d46cb4b82097f6f81a0ece2e63b4357dbb884810080bdbd82db940a839f0e87f3d2c271829e9b97bba7cc3eaf33b8824f058798077b58c26ae79bdc4ca23339a7195c4815e3ff0ce217d20f0d98298f29ac5a67e87b18559e5c2481179da9c0e8a0fc9f4ee20fb437989712f17f9fd4b8b48e6b2de76cc62138cebc0a6b5f67dfe30074ffe441c12327b9f819f3ad34584187bdf6bc9ab2e720d339cb24527e3f9f4a2c1a1da59160e9410201ad3cc9c62aacc55ba6670d5db7c01c3d9f47c448fe6bb48ec8b78d0b0c514bf943db0f10c3f0916fecc49f5abe4a7c632753b47afaeb1644be70684cbdd0fc3d6bc1ffee1fa88ed8029439b602e532d8c3b539dc8b985fccb73f2aaa025e0167199701826528f47ecb5e7319331ec8ac0dfdf6dbe6ad52dd8ac3c64b1ea97aafb52b1d9338c2fb5ce9b20490c1280a86befc7b31cf5c9e97d2645095d3b31378daa026a48d83a6718c0beed6dc404239df08549d21cdc6c9d80b7d56117272433ee8167dc1a9441ced3d3f27f3729d538e635982384887f9e9dc670c9d9a524b1510b23badaacdac4647964cf2aeb0a1c61613744593a5eca74d55b69697820e307539a90a65786449298030fef5c230dbba0f91b1dc39e4644857ebcfcb84c25ff9f5130775e30a638383b3105544c29bd45da5fa273f23d251718b4997e6a7ea3a205e0e71ccb9575c7ad0cdfc4e7f8aec64726137e672a24db91fc934650ef25d0bc26a09f90e7a4a10f7885e4cd2c580b1e3931a94e97b400485d185493a1b6de98f5f8b8570087976bb9593daeea698cfdf2cb597887859fa2c7babacca528bfa754bf2d88a86388c7de16478d617d4366988b46521a912094e754cac2eccda6da95cd5d76870c4f2fdda48d1bad9dfab05282286d82a5bf23d6d9e768c205ab81201ed5c92b8cca7677ece1a60defb9a5ed0</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>使用SQL的两个工具</title>
    <url>/posts/61cc3832.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Navicat15下载安装教程"><a href="#1-Navicat15下载安装教程" class="headerlink" title="1.Navicat15下载安装教程"></a>1.Navicat15下载安装教程</h2><p>这个实在太小白了，跟着教程一步一步来就行了。</p>
<span id="more"></span>

<p>安装教程：<a href="https://www.cnblogs.com/xuexianqi/p/12797170.html">https://www.cnblogs.com/xuexianqi/p/12797170.html</a></p>
<p>官方下载地址：<a href="http://www.navicat.com.cn/download/direct-download?product=navicat_premium_cs_x64.exe&amp;location=1">http://www.navicat.com.cn/download/direct-download?product=navicat_premium_cs_x64.exe&amp;location=1</a></p>
<h2 id="2-SQLyog13安装与使用教程"><a href="#2-SQLyog13安装与使用教程" class="headerlink" title="2.SQLyog13安装与使用教程"></a>2.SQLyog13安装与使用教程</h2><p>SQLyog13如下：（需要安装的Ultimate版本，应该是已经免激活的）</p>
<p>链接：<a href="https://pan.baidu.com/s/1HjkFYDpojuqANSXttGdL5Q">https://pan.baidu.com/s/1HjkFYDpojuqANSXttGdL5Q</a></p>
<p>提取码：myn9</p>
<p>安装完成后打开SQLyog界面，然后开始连接MySQL。</p>
<p>参考自：<a href="https://www.jianshu.com/p/ced6e0537444">https://www.jianshu.com/p/ced6e0537444</a></p>
<p>首先打开cmd输入命令：<code>mysql -u root -p</code>,</p>
<p>然后输入密码就进入了MySQL，exit退出。</p>
<p><img src="/posts/61cc3832/image-20210427230432635.png" alt="image-20210427230432635"></p>
<p>下一步，输入：<code>mysql -u用户名(root) -p密码</code>，</p>
<p>出现下图表示正确连接。</p>
<p><img src="/posts/61cc3832/image-20210427230514742.png" alt="image-20210427230514742"></p>
<p>最后将SQLyog连接MySQL。</p>
<p>文件–&gt;新建一个连接，名字随意。</p>
<p>一般会帮你把大部分地方都填好了，你只要输入MySQL的密码就行了。</p>
<p><img src="/posts/61cc3832/image-20210427230858468.png" alt="image-20210427230858468"></p>
<p>然后就可以看到服务器上的数据库，并进行图形化操作了。</p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>oj刷题注意事项</title>
    <url>/posts/5f4a89a.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-oj赛制介绍"><a href="#1-oj赛制介绍" class="headerlink" title="1.oj赛制介绍"></a>1.oj赛制介绍</h2><p>参考自：<a href="https://zhuanlan.zhihu.com/p/129311302">https://zhuanlan.zhihu.com/p/129311302</a></p>
<p>介绍一下编程比赛中最常见的三种赛制：ACM赛制、OI赛制、IOI赛制。</p>
<span id="more"></span>

<p><strong>ACM赛制</strong>：每道题提交之后都有反馈，可以看到“通过”、“运行错误”、“答案错误”等等结果，但看不到错误的测试样例（leetcode周赛可以看到），每道题都有多个测试点，每道题必须通过了所有的测试点才算通过。每道题不限制提交次数，但没通过的话会有罚时，仅以最后一次提交为准。比赛过程中一般可以看到实时排名，通过题数相同的情况下按照答题时间+罚时来排名。</p>
<p><strong>ACM赛制的比赛</strong>：ICPC、CCPC、codeforces比赛、leetcode周赛及全国编程大赛、牛客小白赛练习赛挑战赛、传智杯。</p>
<p><strong>OI赛制</strong>：每道题提交之后都没有任何反馈，每道题都有多个测试点，根据每道题通过的测试点的数量获得相应的分数。每道题不限制提交次数，如果提交错误没有任何惩罚，仅以最后一次提交为准。比赛过程中看不到实时排名，赛后按照总得分来排名。</p>
<p><strong>OI赛制的比赛</strong>：NOI全国青少年信息学奥林匹克竞赛、CCF CSP、考研机试、蓝桥杯、牛客OI赛、全国高校计算机能力挑战赛。</p>
<p><strong>IOI赛制</strong>：每道题提交之后都有反馈，可以看到“通过”、“运行错误”、“答案错误”等等结果，甚至可以实时看到自己每道题得了多少分，但看不到错误的测试样例。每道题都有多个测试点，根据每道题通过的测试点的数量获得相应的分数。每道题不限制提交次数，如果提交错误没有任何惩罚，仅以最后一次提交为准。比赛过程中一般可以看到实时排名（如果是考试，一般看不到排名），按照总得分来排名。可以说，IOI赛制是结合了OI赛制和ACM赛制的特点。</p>
<p><strong>IOI赛制的比赛</strong>：PAT、团体程序设计天梯赛、CCF CCSP、洛谷月赛。</p>
<h2 id="2-输出格式问题"><a href="#2-输出格式问题" class="headerlink" title="2.输出格式问题"></a>2.输出格式问题</h2><p>acwing对于输出格式非常宽松，末尾空格空行都能过，但有不少oj会卡输出格式，注意审题。</p>
<p>平时做题，最好控制一下输出格式，否则爆0就很难受。</p>
<p>末尾不要有空格做法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++).<span class="comment">//a[0]先输出了，故循环从1开始</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Java刷题注意事项"><a href="#3-Java刷题注意事项" class="headerlink" title="3.Java刷题注意事项"></a>3.Java刷题注意事项</h2><p>参考1：<a href="https://www.acwing.com/blog/content/431/">https://www.acwing.com/blog/content/431/</a></p>
<p>参考2：<a href="https://www.acwing.com/blog/content/593/">https://www.acwing.com/blog/content/593/</a></p>
<p>参考3：<a href="https://www.acwing.com/blog/content/2414/">https://www.acwing.com/blog/content/2414/</a></p>
<p>参考4：<a href="https://www.cnblogs.com/HardBass/p/11702918.html">https://www.cnblogs.com/HardBass/p/11702918.html</a></p>
<h2 id="4-Java与C-刷题的多方位对比"><a href="#4-Java与C-刷题的多方位对比" class="headerlink" title="4.Java与C++刷题的多方位对比"></a>4.Java与C++刷题的多方位对比</h2><p>参考1：<a href="https://www.cnblogs.com/hx97/p/12347699.html">https://www.cnblogs.com/hx97/p/12347699.html</a></p>
<p>参考2：我的转载文章<a href="https://www.grantdrew.top/posts/4c2b5dfd.html">C++ STL与Java util对比</a></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>关于VScode终端乱码问题的解决办法</title>
    <url>/posts/cfb19e20.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在Windows下使用VSCode编译运行，都出现中文乱码的问题，今天我就遇见了这种情况，上网搜了半天也没有找到正确的解决方法，现将我把我的方法晒一下。</p>
<span id="more"></span>

<p>中文的windows下的cmd默认使用GBK的编码, 每次需要的时候只要在VSCode终端输入命令:<code>chcp 65001</code>, 切换代码页到使用UTF-8就可以解决中文代码的问题，只不过这种方法太麻烦了，每次进入终端都要输入命令，那有没有永久性解决的呢？当然有了。</p>
<p>永久性地修改为VSCode的控制台代码页为65001:</p>
<p>在VSCode中通过打开“文件”–“首选项”–“设置”, 然后在setting.json中设置, 把下面三行复制到里面:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;editor.fontSize&quot;</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="string">&quot;terminal.integrated.shellArgs.windows&quot;</span>: [<span class="string">&quot;/K chcp 65001 &gt;nul&quot;</span>],</span><br><span class="line">  <span class="string">&quot;terminal.integrated.fontFamily&quot;</span>: <span class="string">&quot;Lucida Console&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>/K chcp 65001 &gt;nul的含义是在运行cmd的时候将编码设置为65001;</p>
<p>&gt;nul是避免在控制台输出修改编码的信息，否则会输出active code page: 65001;</p>
<p>同时，赠送两个彩蛋，例如:</p>
<p>editor.fontSize: 20(修改字体大小为 20);</p>
<p>terminal.integrated.fontFamily:”Courier New”(字体修改为 “Courier New”).</p>
<p>这个可以根据自己的需求填写，当然如果不需要的话，可以不写。</p>
<p>如果上述方法出错的话可以试一试下方评论区的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;terminal.integrated.shellArgs.windows&quot;: [&quot;-NoExit&quot;, &quot;&#x2F;c&quot;, &quot;chcp 65001&quot;]</span><br></pre></td></tr></table></figure>

<p>当然了，如果你能通过修改右下方的GBK或者UTF-8可以解决的话就没必要选择上面的两种方法：</p>
<p><img src="/posts/cfb19e20/2020080614045655.png" alt="img"></p>
<p>发现如果改成UTF-8的话，通过Run Code运行的话是正常的，但是到了F5调试，弹出的黑框是乱码的，如果改成GBK，那么F5调试是正常的，Run Code是乱码，反正二者不可兼得，大家自己选择。总结下来就是，Run Code运行改成UTF-8，F5调试运行改成GBK，当然这个不是绝对的，还要看一看”terminal.integrated.shellArgs.windows”修改的是什么，如果”terminal.integrated.shellArgs.windows”没有填，好像改成GBK就行了。</p>
<p>到此这篇关于永久解决VSCode终端中文乱码问题的文章就介绍到这了,更多相关VSCode终端中文乱码内容请搜索脚本之家以前的文章或继续浏览下面的相关文章希望大家以后多多支持脚本之家！</p>
<p>本文作者：ityanger  </p>
<p>转载自<a href="https://www.jb51.net/article/192736.htm">脚本之家</a></p>
<hr>
<p>补充：关于VScode出现卡顿、打字缓慢、滚动和选择延迟等问题的解决方法。</p>
<p>参考：<a href="https://www.codeprj.com/blog/bc42ba1.html">https://www.codeprj.com/blog/bc42ba1.html</a></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>VScode</tag>
      </tags>
  </entry>
  <entry>
    <title>声明与定义的区别详解</title>
    <url>/posts/2ecba42c.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>参考自：<a href="https://blog.csdn.net/gatieme/article/details/50640424">https://blog.csdn.net/gatieme/article/details/50640424</a></p>
<span id="more"></span>

<h2 id="变量声明和变量定义"><a href="#变量声明和变量定义" class="headerlink" title="变量声明和变量定义"></a>变量声明和变量定义</h2><p>在C/C++中：</p>
<ul>
<li>变量定义：用于为变量分配存储空间，还可为变量指定初始值。程序中，变量有且仅有一个定义。</li>
<li>变量声明：用于向程序表明变量的类型和名字。程序中，变量可以有多次声明。</li>
<li>定义也是声明，extern声明不是定义。</li>
</ul>
<blockquote>
<ul>
<li>定义也是声明：当定义变量时我们声明了它的类型和名字。</li>
<li>extern声明不是定义：通过使用extern关键字声明变量名而不定义它。<br><strong>[注意]</strong><br>变量在使用前就要被定义或者声明。<br>在一个程序中，变量只能定义一次，却可以声明多次。<br>定义分配存储空间，而声明不会。</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C++程序通常由许多文件组成，为了让多个文件访问相同的变量，C++区分了声明和定义。</span><br><span class="line"></span><br><span class="line">  变量的定义（definition）用于为变量分配存储空间，还可以为变量指定初始值。在程序中，变量有且仅有一个定义。</span><br><span class="line"></span><br><span class="line">  声明（declaration）用于向程序表明变量的类型和名字。定义也是声明：当定义变量的时候我们声明了它的类型和名字。可以通过使用extern声明变量名而不定义它。不定义变量的声明包括对象名、对象类型和对象类型前的关键字extern。</span><br><span class="line"></span><br><span class="line">  extern声明不是定义，也不分配存储空间。事实上它只是说明变量定义在程序的其他地方。程序中变量可以声明多次，但只能定义一次。</span><br><span class="line"></span><br><span class="line">  只有当声明也是定义时，声明才可以有初始化式，因为只有定义才分配存储空间。初始化式必须要有存储空间来进行初始化。如果声明有初始化式，那么它可被当作是定义，即使声明标记为extern。</span><br><span class="line"></span><br><span class="line">  任何在多文件中使用的变量都需要有与定义分离的声明。在这种情况下，一个文件含有变量的定义，使用该变量的其他文件则包含该变量的声明（而不是定义）。</span><br></pre></td></tr></table></figure>
<p>在Java中：</p>
<p>并不区分变量的声明和定义！</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>大话设计模式</title>
    <url>/posts/5e34e759.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="b7878fc58a4d3643596fc3c2bbbd2fd6fc1ea855807de7a95ff13b734b02ae95">fb26124e0d85f363a66baed35993e1a0948953cce3d484fb31660455b92ccb286ba4467b12dd2afdc0f8bd795964707216933c479f00faf5302337078027ef66e68c754bf0232403ae44399aa06a2cad741400e24549082709cdee4a1c1e38f29d8bb6993c43448bafc4543d636ea5bfe35062ad225c74a80f232ba51d9af45093f5220e616be2d57e02341ffad661bef2886dba249b54377d8b3961fd62e8e7033554e6a1a85b429bcdccd8e910eaca84c8e447cedd760cd76a16c64ec7f94ad050108487716cc544f1ca685285a120a1c590efd559bdca18a90707fae890221e2912f079f089d10fb816e69e85944586941b721161d200273028ce2f3cb2d1a6a47461dcfac58b4612622383de37911e7101936179b0ecfeb18f3600111afc0a3048b3a9bc8162408d2cdd766c056081be36f6984d0fc9924355cadc0cde3eb9b769df924e862815f18fb7ec6ae1a885d2f5311dc30919b08ce8c58219bf852297bb67d19bdfecbc815ed7a5f307c12d39be99d22238d60e7ddbd6ee16b6d5f0f5aa37490b7d5aa219044b4378eacaf57aedacf30b0f4570fd2e466257e1eb</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>常用STL速查手册</title>
    <url>/posts/a70a6c57.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>作者：自豪的澡巾QAQ<br>链接：<a href="https://www.acwing.com/blog/content/6096/">https://www.acwing.com/blog/content/6096/</a><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<span id="more"></span>

<p>这是我目前水平下能接触到的,如果有补充欢迎留言.<br>别抬杠,杠就是你对.</p>
<p><code>#include&lt;string&gt;:</code></p>
<p>常用操作:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">s.begin();</span><br><span class="line">s.end();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s.c_str()); <span class="comment">//使用scanf读入string类型的变量或者希望通过strcpy对字符串进行复制,请使用c_str();</span></span><br><span class="line">s[i] == s.at(i);        <span class="comment">//允许索引寻址</span></span><br><span class="line"><span class="keyword">int</span> indxe = s.find(<span class="keyword">char</span> ch);    <span class="comment">//返回ch在s中的索引</span></span><br><span class="line">s.size();</span><br><span class="line">s.append(<span class="built_in">string</span> post);      </span><br><span class="line">s.pop_back();</span><br><span class="line"><span class="comment">//返回s[begin,begin + len - 1],注意与java中的substring的区别,当len == -1时表示截取到最后</span></span><br><span class="line">s.substr(<span class="keyword">int</span> begin,<span class="keyword">int</span> len);</span><br><span class="line">insert(iterator iter,type val);</span><br><span class="line">erase(iterator iter);</span><br></pre></td></tr></table></figure>

<p><code>#include&lt;pair&gt;</code></p>
<p>常用操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; PII;<span class="comment">//常结合map和sort使用</span></span><br><span class="line">PII a;</span><br><span class="line">a = <span class="built_in">make_pair</span>(<span class="number">5</span>,<span class="string">&#x27;f&#x27;</span>);<span class="comment">//等价于a = &#123;5,&#x27;f&#x27;&#125;;</span></span><br><span class="line">a.first;a.second;<span class="comment">//返回第一和第二关键字</span></span><br></pre></td></tr></table></figure>

<p><code>#include&lt;vector&gt;：</code></p>
<p>vector的常用初始化操作:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vector支持比较运算</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; <span class="title">g</span><span class="params">(n,i)</span></span>;        <span class="comment">//创建一个长度为n初值为i的一维向量(数组)</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; <span class="title">f</span><span class="params">(g.begin() + [offset],g.end())</span></span>;       <span class="comment">//通过g来创建一个f向量,offset可有可无</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">c</span><span class="params">(v)</span></span>;        <span class="comment">//将v复制给c</span></span><br><span class="line">v.assign (<span class="number">7</span>,<span class="number">100</span>);             <span class="comment">// 7 ints with a value of 100</span></span><br></pre></td></tr></table></figure>

<p>vector的常用函数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">clear();</span><br><span class="line">begin();</span><br><span class="line">end();</span><br><span class="line">size();</span><br><span class="line">empty();</span><br><span class="line">front();</span><br><span class="line">back();</span><br><span class="line">push_back(member_type x);</span><br><span class="line">pop_back();</span><br><span class="line">erase(iterator l[,iterator r]);        <span class="comment">// 删除第l[到r]个值</span></span><br><span class="line">v.at[i] == v[i]</span><br></pre></td></tr></table></figure>

<p><code>#include&lt;stack&gt;:</code></p>
<p>常用操作:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">push(type x);   <span class="comment">//压栈</span></span><br><span class="line">pop()   <span class="comment">//出栈</span></span><br><span class="line">empty();    </span><br><span class="line">size();</span><br><span class="line">top();  <span class="comment">//返回栈顶</span></span><br></pre></td></tr></table></figure>

<p><code>#include&lt;queue&gt;</code></p>
<p>常用操作:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">queue&lt;int&gt; q;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">q.push(<span class="keyword">int</span> x);   <span class="comment">//入队</span></span><br><span class="line">q.pop();  <span class="comment">//出队</span></span><br><span class="line">q.empty();</span><br><span class="line">q.size();</span><br><span class="line">q.front();    <span class="comment">//队首</span></span><br><span class="line"></span><br><span class="line">q.back(); <span class="comment">//队尾</span></span><br><span class="line">-------------------</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">priority_queue&lt;int&gt; heap;   //优先队列,即堆,默认为大根堆</span></span><br><span class="line"><span class="comment">定义小根堆:</span></span><br><span class="line"><span class="comment">    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; tt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">heap.size();</span><br><span class="line">heap.empty();</span><br><span class="line">heap.push(<span class="keyword">int</span> x);</span><br><span class="line">heap.pop();     <span class="comment">//移除堆顶元素</span></span><br><span class="line">heap.top();     <span class="comment">//返回堆顶元素</span></span><br></pre></td></tr></table></figure>

<p><code>#include&lt;deque&gt;</code></p>
<p>常用操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">deque&lt;int&gt; q;//支持随机寻址,效率相较低</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">q.empty();</span><br><span class="line">q.size();</span><br><span class="line">q.front();</span><br><span class="line">q.back();</span><br><span class="line">q.push_back(<span class="keyword">int</span> x);</span><br><span class="line">q.push_front(<span class="keyword">int</span> x);</span><br><span class="line">q.pop_back();</span><br><span class="line">q.pop_front();</span><br></pre></td></tr></table></figure>

<p><code>#include&lt;map&gt;</code></p>
<p>常用操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//存储的类型为pair，因此可以通过类似dic.begin().first(second)来访问键值对</span></span><br><span class="line"><span class="comment">map&lt;string,int&gt; dic;//不可以有重复的键值,multimap可以有重复的键值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">dic.empty();</span><br><span class="line">dic.size();</span><br><span class="line">dic.insert(&#123;<span class="string">&quot;hello&quot;</span>,<span class="number">1</span>&#125;);    <span class="comment">//参数类型为pair,等价于dic[&quot;hello&quot;] = 1;</span></span><br><span class="line">dic.erase(&#123;<span class="string">&quot;hello&quot;</span>,<span class="number">1</span>&#125;);     <span class="comment">//参数类型为pair或者iterator</span></span><br><span class="line">dic.find(<span class="string">&quot;hello&quot;</span>);          <span class="comment">//注意返回的是迭代器</span></span><br><span class="line">dic.count(<span class="string">&quot;hello&quot;</span>);         <span class="comment">//返回0或者1</span></span><br></pre></td></tr></table></figure>

<p><code>#include&lt;set&gt;</code></p>
<p>常用操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">set的含义是集合,元素有序,支持插入,删除,查找等操作,所有的操作的都是严格在logn时间之内完成,效率非常高。</span></span><br><span class="line"><span class="comment">set和multiset的区别是：set插入的元素不能相同，但是multiset可以相同。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">set</span>/<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">s.insert(<span class="keyword">int</span> x);</span><br><span class="line">s.find(<span class="keyword">int</span> x);  <span class="comment">//返回迭代器</span></span><br><span class="line">s.erase(<span class="keyword">int</span> x/iterator);<span class="comment">//如果参数为整数,意为删除集合内所有x;如果是迭代器,则删除这个迭代器</span></span><br></pre></td></tr></table></figure>

<p><code>#include&lt;unordered_set/multiset/unordered_map/multimap&gt;</code></p>
<p>常用操作<br>带有unordered意味着底层为hash,与上面的操作类似,但时间复杂度为O(1)<br><code>#include&lt;algorithm&gt;</code></p>
<p>常用函数<br><strong>最大值,最小值,交换</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">max(max(a,b),c);</span><br><span class="line">min();</span><br><span class="line">swap(a,b);</span><br></pre></td></tr></table></figure>

<p><strong>快速排序,默认排序结果为升序;</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num[] = &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">2</span>&#125;;</span><br><span class="line">sort(num,num + <span class="number">6</span>,cmp);<span class="comment">//cmp可省略,可以手动实现cmp定义排序规则,通常与struct、pair形成combo</span></span><br></pre></td></tr></table></figure>

<p><strong>字符串反转</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;hello wolrd&quot;</span>;</span><br><span class="line">reverse(s.begin(),s.end());<span class="comment">//能够将string,vector等类型进行翻转,返回迭代器</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//    &quot;dlrow olleh&quot;;</span></span><br></pre></td></tr></table></figure>

<p><strong>去重</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(num,num + <span class="number">9</span>)</span></span>;</span><br><span class="line">sort(v.begin(),v.end());</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">删除重复出现的系列点,unique()函数将所有不重复的点放在数组前面,重复的点放在后面,</span></span><br><span class="line"><span class="comment">返回第一个起始重复元素的迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">v.erase(unique(v.begin(),v.end()),v.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> a : v) <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span>;      <span class="comment">//10 20 30</span></span><br></pre></td></tr></table></figure>

<p><strong>全排列</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">next_permutation()将按字母表顺序生成给定序列的下一个较大的排列,直到整个序列为降序为止。</span></span><br><span class="line"><span class="comment">prev_permutation()与之相反,是生成给定序列的上一个较小的排列。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> num[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (next_permutation(num,num + <span class="number">5</span>)) &#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : num) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cnt;<span class="comment">// cnt == 5! == 120</span></span><br></pre></td></tr></table></figure>

<p><strong>本内容仅用作STL简单使用字典</strong></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在Word2019中更好地使用数学公式</title>
    <url>/posts/9964d56c.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-为什么用Word"><a href="#1-为什么用Word" class="headerlink" title="1.为什么用Word"></a>1.为什么用Word</h2><p>关于该用Word还是用Latex的争论由来已久，这里就不再讨论，我们可以灵活使用这两种工具，它们可以在不同的场景发挥作用。</p>
<p>有时候，用Word会更加方便省事，我们接下来就讲一讲如何在Word2019中更好地使用数学公式。</p>
<span id="more"></span>

<p><strong>友情提示：本文仅仅针对Word2019！！！</strong></p>
<h2 id="2-Mathtype公式编辑器"><a href="#2-Mathtype公式编辑器" class="headerlink" title="2.Mathtype公式编辑器"></a>2.Mathtype公式编辑器</h2><p>Word2019虽然自带了公式插入功能，但是功能不是很强大，这里我们使用Mathtype公式编辑器。</p>
<p>Mathtype下载安装教程：<a href="https://www.bilibili.com/video/BV1cV41117SR?from=search&seid=6028489259985023645">MathType7.4安装、加载至word</a></p>
<p>视频讲解算是很详细了，跟着做就没什么大问题。</p>
<p>需要用到的工具：<a href="https://pan.baidu.com/s/1aeRHoUv3iS5x8mTLRr4m4Q">https://pan.baidu.com/s/1aeRHoUv3iS5x8mTLRr4m4Q</a> 提取码:hand</p>
<p>讲一讲会遇到的问题：</p>
<ol>
<li>出现Word2019的’53’错误：将破解包里的MathPage.wll文件复制到<br><code>&quot;C:\Program Files\Microsoft Office\root\Office16 &quot;</code>中</li>
<li>Word有两个mathtype选项卡：你需要去除没用的那一个，具体参照<a href="https://www.mathtype.cn/jiqiao/an-niu-shanchu.html">这里</a></li>
</ol>
<p>如果没什么问题了，你就可以开心地使用Mathtype编辑器了，效率杠杠滴！</p>
<p><strong>使用技巧：</strong>推荐一个<a href="https://www.mathtype.cn/">使用说明网站</a></p>
<p><img src="/posts/9964d56c/image-20210416141150533.png" alt="image-20210416141150533"></p>
<p>点击内联后会弹出公式编辑窗口，然后就能编辑公式了。</p>
<p><img src="/posts/9964d56c/image-20210416141119196.png" alt="image-20210416141119196"></p>
<p>编辑完成后，点击文件–&gt;更新 XXX就能看到公式已经显示出来了。</p>
<p> <strong>如何实现MathType公式转换LaTeX代码</strong></p>
<p>参考：<a href="https://www.mathtype.cn/jiqiao/gongshi-daima.html">https://www.mathtype.cn/jiqiao/gongshi-daima.html</a></p>
<p>这里介绍最简单的一种：点击切换Tex，再点一次就会再变回来。</p>
<p><img src="/posts/9964d56c/image-20210416141814068.png" alt="image-20210416141814068"></p>
<h2 id="3-原生插入Latex公式"><a href="#3-原生插入Latex公式" class="headerlink" title="3.原生插入Latex公式"></a>3.原生插入Latex公式</h2><p>参考：<a href="https://www.cnblogs.com/qq-757617012/p/12098279.html">https://www.cnblogs.com/qq-757617012/p/12098279.html</a></p>
<p>自带的公式编辑器也能转换成Latex公式。</p>
<h2 id="4-推荐一个Latex-OCR识别工具"><a href="#4-推荐一个Latex-OCR识别工具" class="headerlink" title="4.推荐一个Latex OCR识别工具"></a>4.推荐一个Latex OCR识别工具</h2><p>效果是非常不错的，亲身体验。</p>
<p><img src="/posts/9964d56c/image-20210416143919671.png" alt="image-20210416143919671"></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>Latex</tag>
        <tag>Word</tag>
      </tags>
  </entry>
  <entry>
    <title>寒假每日一题入门题（一）</title>
    <url>/posts/baabc5c0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Day-01-104-货仓选址"><a href="#Day-01-104-货仓选址" class="headerlink" title="Day_01 104.货仓选址"></a>Day_01 104.货仓选址</h2><p><strong>这题考察绝对值不等式</strong></p>
<p><a href="https://www.acwing.com/solution/content/36228/">参考题解</a></p>
<p><img src="/posts/baabc5c0/image-20210222105937470.png" alt="image-20210222105937470"></p>
<p>由绝对值不等式可证明：<br>将n个数两两分组，如果n是奇数，货仓取中位数时取到不等式的等号，此时为最小值；如果n是偶数，货仓取中间两个数的中间即可。<br><strong>结论：中位数就是此题的最优解。</strong></p>
<span id="more"></span>

<hr>
<h3 id="算法1：排序-中位数"><a href="#算法1：排序-中位数" class="headerlink" title="算法1：排序+中位数"></a><strong>算法1：排序+中位数</strong></h3><p><strong>时间复杂度</strong>：$O(nlogn)$</p>
<p>中位数有非常优秀的性质，比如说在这道题目中，每一个点到中位数的距离，都是满足全局的最有性，而不是局部最优性。</p>
<p>具体的来说，我们设在仓库左边的所有点，到仓库的距离之和为p,右边的距离之和则为q，那么我们就必须让p+q的值尽量小。</p>
<p>当仓库向左移动的话，p会减少x，但是q会增加n−x，所以说当为仓库中位数的时候,p+q最小。</p>
<p>还是同样的一句话，画图理解很重要。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    sort(a,a+n);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++) res += a[i] - a[i&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// ==&gt; res += abs(a[i] - a[n&gt;&gt;1])</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>将 abs(a[i] - a[n &gt;&gt; 1]) 改为 a[i] - a[i &gt;&gt; 1]也可以 AC（这样可以不用取绝对值）</p>
<p>证明如下：<br><img src="/posts/baabc5c0/image-20210222110203712.png" alt="image-20210222110203712"></p>
<h3 id="算法2：快速选择-中位数"><a href="#算法2：快速选择-中位数" class="headerlink" title="算法2：快速选择+中位数"></a><strong>算法2：快速选择+中位数</strong></h3><p>快速选择函数nth_element(数组初位置，寻找元素，数组末位置)（STL）</p>
<p>C++的STL库中的nth_element()方法，默认是求区间<strong>第k小</strong>的（划重点）。</p>
<p>举个栗子求第3小，对于 a[9]={4,7,6,9,1,8,2,3,5};</p>
<p>nth_element(a,a+2,a+9)，**将下标为2，也就是第3个数放在正确的位置，求的是第3小的数a[2]**。（下标从零开始）</p>
<p><strong>nth_element(a,a+k,a+n)，函数只是把下标为k的元素放在了正确位置，对其它元素并没有排序，当然k左边元素都小于等于它，右边元素都大于等于它，所以可以利用这个函数快速定位某个元素</strong>。</p>
<p>那求第k大时呢？我们可以转化成求第n-k+1小，此时下标应该是n - k。</p>
<p><strong>nth_element(a,a+n-k,a+n)，将下标为n-k，也就是第n-k+1个数放在正确的位置，求的是第k大的数a[n-k]。</strong></p>
<p><strong>时间复杂度</strong>：$O(n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,s=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;p[i];</span><br><span class="line">    nth_element(p,p+n/<span class="number">2</span>,p+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) s+=<span class="built_in">abs</span>(p[i]-p[n/<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>中位数</tag>
        <tag>绝对值不等式</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集详解</title>
    <url>/posts/ad6fe702.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集（Union-find Sets）是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。</p>
<p>并查集的思想是用一个数组表示了整片森林（parent），树的根节点唯一标识了一个集合，我们只要找到了某个元素的的树根，就能确定它在哪个集合里。</p>
<span id="more"></span>

<h2 id="yxc模板"><a href="#yxc模板" class="headerlink" title="yxc模板"></a>yxc模板</h2><p>链接：<a href="https://www.acwing.com/blog/content/404/">https://www.acwing.com/blog/content/404/</a></p>
<p>并查集 —— 模板题:AcWing 836. 合并集合, AcWing 837. 连通块中点的数量</p>
<p>(1)朴素并查集：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> p[N]; <span class="comment">//存储每个点的祖宗节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">// 路径压缩</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = find(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[find(a)] = find(b);  <span class="comment">// 不要写成p[a] = b;</span></span><br></pre></td></tr></table></figure>


<p>(2)维护size的并查集：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> p[N], size[N];</span><br><span class="line"><span class="comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = find(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    size[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">size[find(b)] += size[find(a)];</span><br><span class="line">p[find(a)] = find(b);</span><br></pre></td></tr></table></figure>


<p>(3)维护到祖宗节点距离的并查集：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> p[N], d[N];</span><br><span class="line"><span class="comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = find(p[x]);</span><br><span class="line">        d[x] += d[p[x]];</span><br><span class="line">        p[x] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    d[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[find(a)] = find(b);</span><br><span class="line">d[find(a)] = distance; <span class="comment">// 根据具体问题，初始化find(a)的偏移量</span></span><br></pre></td></tr></table></figure>

<h2 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h2><p>参考1：算法训练营进阶篇。</p>
<p>参考2：秦淮岸dalao的讲义，<a href="https://www.acwing.com/blog/content/197/%EF%BC%8C%E4%B8%BE%E7%9A%84%E4%BE%8B%E5%AD%90%E9%9D%9E%E5%B8%B8%E6%A3%92%EF%BC%81">https://www.acwing.com/blog/content/197/，举的例子非常棒！</a></p>
<p>参考3：<a href="https://zhuanlan.zhihu.com/p/93647900">https://zhuanlan.zhihu.com/p/93647900</a></p>
<p>假设存在一个庞大的部落，人数众多，我们需要判断给出的两人是否具有亲戚关系。</p>
<p>现给定亲戚关系的两条重要性质：</p>
<ol>
<li><strong>传递性</strong>：若x、y是亲戚，y、z是亲戚，那么x、z是亲戚；</li>
<li><strong>集合合并</strong>（连通集合）：若x、y是亲戚，则x的亲戚也是y的亲戚，y的亲戚也是x的亲戚。</li>
</ol>
<p>我们可以用<strong>并查集</strong>来处理具有这两种性质的亲戚关系的判定问题。</p>
<p>算法步骤：1.初始化；2.查找；3.合并。</p>
<p>y总的模板真的很不错，hh。</p>
<p>还是直接上例题。</p>
<p>初始化时并查集编号从1开始！</p>
<h2 id="洛谷P3367并查集（模板题）"><a href="#洛谷P3367并查集（模板题）" class="headerlink" title="洛谷P3367并查集（模板题）"></a>洛谷P3367并查集（模板题）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">题目描述</span><br><span class="line">如题，现在有一个并查集，你需要完成合并和查询操作。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含两个整数 N,M,表示共有 N 个元素和 M 个操作。</span><br><span class="line"></span><br><span class="line">接下来 M 行，每行包含三个整数 Z,X,Y</span><br><span class="line">当 Z=<span class="number">1</span> 时，将 X与Y所在的集合合并。</span><br><span class="line">当 Z=<span class="number">2</span> 时，输出 X与Y是否在同一集合内，是的输出 Y ；否则输出 N 。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">对于每一个 Z=<span class="number">2</span> 的操作，都有一行输出，每行包含一个大写字母，为 Y 或者 N 。</span><br><span class="line"></span><br><span class="line">输入输出样例</span><br><span class="line">输入</span><br><span class="line"><span class="number">4</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line">输出</span><br><span class="line">N</span><br><span class="line">Y</span><br><span class="line">N</span><br><span class="line">Y</span><br><span class="line"></span><br><span class="line">对于 <span class="number">100</span>\%<span class="number">100</span>% 的数据，<span class="number">1</span>≤N≤<span class="number">10</span>^<span class="number">4</span> ,<span class="number">1</span>≤M≤<span class="number">2</span>×<span class="number">10</span>^<span class="number">5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[N];<span class="comment">// 存储每个点的祖宗结点</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;<span class="comment">// 递归找到祖宗</span></span><br><span class="line">    <span class="keyword">if</span> (p[a] != a) p[a] = find(p[a]);</span><br><span class="line">    <span class="keyword">return</span> p[a];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="comment">// 初始化编号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> z,x,y;<span class="keyword">char</span> res;</span><br><span class="line">    <span class="keyword">while</span> (m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;z,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span> (z == <span class="number">1</span>) p[find(x)] = find(y);<span class="comment">// 合并集合操作</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res = find(x) == find(y) ? <span class="string">&#x27;Y&#x27;</span> : <span class="string">&#x27;N&#x27;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化：刚开始的时候每个点就是一个独立的集合,且这个集合树的树根就是本身。</p>
<p>查找：<strong>路径压缩</strong>，每次执行find操作的时候,把访问过的节点(也就是所有元素的父亲),都统统指向树根祖宗.这种方法可以避免出题人刻意卡掉链式结构。</p>
<p>N次合并M次查找的时间复杂度为：O(M*Alpha(N))，Alpha是Ackerman函数的某个反函数，在很大范围内它的值不超过4，接近线性，所以可以近似看成是：O(1)。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂算法</title>
    <url>/posts/50ce0ed6.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>我们首先来看一个问题：</p>
<blockquote>
<p>给定三个正整数a，b，m(a&lt;10^9, b&lt;10^18, 1&lt;m&lt;10^9)，求a^b%m。</p>
</blockquote>
<span id="more"></span>

<p>如果用循环来写，不断乘上a再取模，时间复杂度为O(b)。很容易超时。</p>
<p>所以我们考虑快速幂算法。它<strong>基于二分的思想</strong>，也被称为<strong>二分幂</strong>。</p>
<h2 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h2><p>1.如果b是奇数，那么有：$a^b = a*a^{b-1}$</p>
<p>2.如果b是偶数，那么有：$a^b = a^{b/2}*a^{b/2}$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="comment">// 递归求a^b%m</span></span><br><span class="line"><span class="function">LL <span class="title">binaryPow</span><span class="params">(LL a,LL b,LL m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b%<span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> a * binaryPow(a,b<span class="number">-1</span>,m) % m;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        LL mul = binaryPow(a,b &gt;&gt;<span class="number">1</span>,m);</span><br><span class="line">        <span class="keyword">return</span> mul * mul % m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果初始时a&gt;=m，需要执行函数时先对a%m。</li>
<li>如果m==1，直接在函数外部特判为0。</li>
</ul>
<h2 id="迭代写法"><a href="#迭代写法" class="headerlink" title="迭代写法"></a>迭代写法</h2><p>把b写成二进制的形式，那么b可以写成若干二次幂之和。</p>
<p>例如13的二进制形式为1101， $13=2^3+2^2+2^0,a^{13}=a^8\ *a^4\ *a^1$ 。</p>
<p>不难推出：当b的二进制的第i（从0开始）位是1时，初值ans=1要乘上$a^{2{^i}}$。由于我们每次迭代时令a平方</p>
<p>（$a=a^{2i}$），所以枚举当前第i位时，a已经迭代到初始a的$2^i$次方，如果是1，就令ans乘上a。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="comment">//  迭代求a^b%m</span></span><br><span class="line"><span class="function">LL <span class="title">binaryPow</span><span class="params">(LL a,LL b,LL m)</span></span>&#123;</span><br><span class="line">    LL ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 等价于b%2 == 1</span></span><br><span class="line">        <span class="keyword">if</span> (b&amp;<span class="number">1</span>) ans = ans*a%m;</span><br><span class="line">        a = a*a%m;</span><br><span class="line">        b &gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际应用场景，两种写法效率差不多。</p>
<p><strong>大数取模公式总结：</strong><br><img src="/posts/50ce0ed6/image-20210407222650012.png" alt="image-20210407222650012"></p>
<p><img src="/posts/50ce0ed6/image-20210706120626148.png" alt="image-20210706120626148"></p>
<p>参考资料1：<a href="https://www.cnblogs.com/llsq/p/5810262.html">博客园</a></p>
<p>参考资料2：《算法笔记》</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>二分</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法（C++实现）</title>
    <url>/posts/578803b6.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="初等排序算法"><a href="#初等排序算法" class="headerlink" title="初等排序算法"></a>初等排序算法</h1><p><strong>排序算法的稳定性</strong></p>
<p>仅仅用执行效率和内存消耗来衡量排序算法的好坏是不够的。针对排序算法，我们还有一个重要的度量指标，稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p>
<p>动态算法演示：<a href="https://visualgo.net/zh/sorting%E3%80%82">https://visualgo.net/zh/sorting。</a></p>
<span id="more"></span>

<p><strong>空间复杂度</strong></p>
<p>我们前面讲过，算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，<strong>原地排序</strong>（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。</p>
<p><strong>时间复杂度</strong></p>
<p>我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。为什么要区分这三种时间复杂度呢？第一，有些排序算法会区分，为了好对比，所以我们最好都做一下区分。第二，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。</p>
<h2 id="1-Bubble-Sort（冒泡排序）"><a href="#1-Bubble-Sort（冒泡排序）" class="headerlink" title="1.Bubble Sort（冒泡排序）"></a>1.Bubble Sort（冒泡排序）</h2><p>时间复杂度：$O(n^2)$.</p>
<p>稳定排序算法。</p>
<p>冒泡排序是最基础的排序算法之一。</p>
<p>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。</p>
<p>最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 $O(n^2)$，平均情况下的时间复杂度就是 $O(n^2)$。</p>
<p>冒泡排序的本质就是<strong>交换</strong>；第一层循环确定冒泡（交换）执行的趟数，n个数执行n趟，每一趟选出一个最大数或最小数；第二层循环进行相邻数的比较。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++板子</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[N];</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>;k &lt; N;k ++)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[k];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// k是元素个数</span></span><br><span class="line">	<span class="comment">// Bubble Sort</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k<span class="number">-1</span>;i ++)<span class="comment">// 循环k-1趟</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; k - i - <span class="number">1</span>;j ++)</span><br><span class="line">		&#123;</span><br><span class="line">            	<span class="comment">// 注意：这里加上等号会失去稳定性</span></span><br><span class="line">			<span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) swap(a[j],a[j+<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x : a) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="number">10</span>);<span class="comment">// 输出回车</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java板子，极客时间</span></span><br><span class="line"><span class="comment">// 冒泡排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="comment">// 提前退出冒泡循环的标志位，优化</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">        <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">        a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">        a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">        flag = <span class="keyword">true</span>;  <span class="comment">// 表示有数据交换      </span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;  <span class="comment">// 没有数据交换，说明已经是有序的，提前退出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Selection-Sort（选择排序）"><a href="#2-Selection-Sort（选择排序）" class="headerlink" title="2.Selection Sort（选择排序）"></a>2.Selection Sort（选择排序）</h2><p>时间复杂度：$O(n^2)$.</p>
<p><strong>不稳定</strong>排序算法。正是因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。</p>
<p>选择排序（据y总说）是最简单的排序算法。</p>
<p>首先，选择排序空间复杂度为 O(1)，是一种原地排序算法。选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 $O(n^2)$。你可以自己来分析看看。</p>
<p>第一层循环对n个数进行n-1趟选择，因为最后一个多出来的数不用再选择。第二层循环对待排序区域的数进行选择，选出最大（最小）的数。每一趟选择就会选出一个最大（最小）的数。</p>
<p><img src="/posts/578803b6/image-20210310165553787.png" alt="image-20210310165553787"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++板子</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[N];</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>;k &lt; N;k ++)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[k];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// k是元素个数</span></span><br><span class="line">	<span class="comment">// Selection Sort</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k<span class="number">-1</span>;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> min = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; k;j ++)<span class="comment">// 注意边界</span></span><br><span class="line">		<span class="comment">// 从a[i+1]到a[k-1]选出最小的数，下标为min</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j] &lt; a[min]) min = j;<span class="comment">//可以写成a[j] != a[k]</span></span><br><span class="line">		&#125;</span><br><span class="line">		swap(a[i],a[min]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x : a) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 $O(n^2)$ 的时间复杂度。所以用到它的时候，数据规模越小越好。好处可能就是不占用额外的内存空间了吧。</p>
<p>由于选择排序每一趟总是从无序区中选出全局最小（或最大）的元素，所以适用于从大量元素中选择一部分排序元素。例如，从10000个元素中选出最小的前10位元素。</p>
<h2 id="3-Insertion-Sort（插入排序）"><a href="#3-Insertion-Sort（插入排序）" class="headerlink" title="3.Insertion Sort（插入排序）"></a>3.Insertion Sort（插入排序）</h2><p>时间复杂度：$O(n^2)$.</p>
<p>稳定排序算法。</p>
<p>原地排序算法。</p>
<p>插入排序也是一种常见的简单算法。</p>
<p>输入数据的顺序能大幅度影响它的复杂度。</p>
<p>插入排序将数组分成已排序和未排序两个部分，过程就是将待插入元素插入如有序部分。这里的做法是<strong>从后往前枚举有序部分</strong>来确定插入位置。</p>
<p>如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为 O(n)。注意，这里是<strong>从尾到头遍历已经有序的数据</strong>。</p>
<p>如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为$O(n^2)$。</p>
<p>还记得我们在数组中插入一个数据的平均时间复杂度是多少吗？没错，是 O(n)。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为$O(n^2)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++板子</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[N];</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>;k &lt; N;k ++)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[k];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Insertion Sort</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; k;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//temp临时存放待插入元素，j是有序部分最后一个元素的下标</span></span><br><span class="line">        <span class="keyword">int</span> temp = a[i],j = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; a[j])<span class="comment">//j枚举完所有有序部分</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[j+<span class="number">1</span>] = a[j];<span class="comment">//元素后移</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j+<span class="number">1</span>] = temp;<span class="comment">//插入元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x : a) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java板子，极客时间</span></span><br><span class="line"><span class="comment">// 插入排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> value = a[i];</span><br><span class="line">    <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 查找插入的位置</span></span><br><span class="line">    <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">        a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[j+<span class="number">1</span>] = value; <span class="comment">// 插入数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><ul>
<li>以上三种都是原地排序算法。</li>
<li>虽然冒泡排序和插入排序在时间复杂度上是一样的，都是$O(n^2)$，但是如果我们希望把性能优化做到极致，那肯定首选插入排序。插入排序的算法思路也有很大的优化空间，我们只是讲了最基础的一种。</li>
<li>如果你对插入排序的优化感兴趣，可以自行学习一下希尔排序。</li>
<li>它们的时间复杂度都是 $O(n^2)$，比较高，适合<strong>小规模数据</strong>的排序。</li>
</ul>
<h2 id="5-补充"><a href="#5-补充" class="headerlink" title="5.补充"></a>5.补充</h2><ol>
<li><p>这里附上一份十大经典排序算法大梳理 (动图+代码)，这是经过系统整理过的！</p>
<p>链接奉上：<a href="https://mp.weixin.qq.com/s/ekGdneZrMa23ALxt5mvKpQ">https://mp.weixin.qq.com/s/ekGdneZrMa23ALxt5mvKpQ</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/zwtgyh/p/10631760.html">常见排序算法及其对应的时间复杂度和空间复杂度</a> （PS：部分分析不完整，请参照王争专栏）</p>
</li>
<li><p>帅地大佬的文章：<a href="https://www.iamshuaidi.com/608.html%EF%BC%88%E5%B0%8F%E7%A0%B4%E7%AB%99%E5%A5%BD%E4%B8%9C%E8%A5%BF%E4%B8%8D%E5%B0%91%EF%BC%89">https://www.iamshuaidi.com/608.html（小破站好东西不少）</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数学专业常用英语表达总结（二）</title>
    <url>/posts/78fe420d.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Mathematical-English-2"><a href="#Mathematical-English-2" class="headerlink" title="Mathematical English 2"></a>Mathematical English 2</h2><span id="more"></span>

<p>1.表达正数：positive number a</p>
<p>同样地，关于负数有：negative number a</p>
<p>2.绝对值的表达：$|x-x_0|$，the absolute value of the difference of $x$ and $x_0$</p>
<p>3.可微与可积：differentiable and integrable</p>
<p>导数与积分（名词）：derivative and integral</p>
<p>4.表达极限的两种方式：</p>
<ul>
<li><p>$\displaystyle\lim_{x \rightarrow x_0}f(x) = A$,the limit of <em>f</em> of <em>x</em> is equal to <em>A</em> as <em>x</em> approaches <em>x</em>0</p>
</li>
<li><p>${f(x) \rightarrow A} \ as\ {x\rightarrow x_0}$,<em>f</em> of <em>x</em> approaches <em>A</em> as <em>x</em> tends to <em>x</em>0</p>
</li>
</ul>
<p>5.表达某一定理等成立：with this one hold</p>
<p>6.常见希腊字母：</p>
<p><img src="/posts/78fe420d/image-20210311115529635.png" alt="image-20210311115529635"></p>
<p>7.分数（fraction），分母（denominator），分子（numerator）</p>
<p>8.微分与积分</p>
<p><img src="/posts/78fe420d/image-20210317230557415.png" alt="image-20210317230557415"></p>
<p><img src="/posts/78fe420d/image-20210317230606292.png" alt="image-20210317230606292"></p>
<p><img src="/posts/78fe420d/image-20210317230613942.png" alt="image-20210317230613942"></p>
<p><img src="/posts/78fe420d/image-20210317230622050.png" alt="image-20210317230622050"></p>
<p>修正：定积分改正为from a to b of f of x。</p>
<p>9.线性代数</p>
<p><img src="/posts/78fe420d/image-20210317230646313.png" alt="image-20210317230646313"></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学专业词汇</tag>
      </tags>
  </entry>
  <entry>
    <title>日期处理与进制转换问题</title>
    <url>/posts/f95a0d7f.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>这篇文章将介绍常见的日期处理与进制转换问题。</p>
</blockquote>
<span id="more"></span>

<h2 id="1-日期处理"><a href="#1-日期处理" class="headerlink" title="1.日期处理"></a>1.日期处理</h2><p>以题目为例：<a href="http://codeup.hustoj.com/problem.php?cid=100000578&amp;pid=0">http://codeup.hustoj.com/problem.php?cid=100000578&amp;pid=0</a></p>
<h3 id="问题-A-日期差值"><a href="#问题-A-日期差值" class="headerlink" title="问题 A: 日期差值"></a>问题 A: 日期差值</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>有两个日期，求两个日期之间的天数，如果两个日期是连续的我们规定他们之间的天数为两天。</p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>有多组数据，每组数据有两行，分别表示两个日期，形式为YYYYMMDD</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>每组数据输出一行，即日期差值</p>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20130101</span><br><span class="line">20130105</span><br></pre></td></tr></table></figure>
<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><p>我们需要处理平年和闰年，大月和小月的问题。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们不妨设第一个日期是早于第二个日期的（如果不是就交换顺序）。</p>
<p>求日期差值的问题很直接的一个思路就是让第一个日期不断加1天，直到和第二个日期相等为止。</p>
<p>为了存放平年和闰年每个月的天数，我们建立一个二维数组<code>int month[13][2]</code>，第一维存放月份，从1到12，第0位不用，第二维为0表示平年，为1表示闰年。</p>
<p>我们可以先让第一个日期的年份加到与第二个日期的年份相差1为止，这样可以加快速度。对于其中的年份，只要根据平年还是闰年加365或366天即可。之后再不断让天数加1就行。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeap</span><span class="params">(<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (y%<span class="number">4</span>==<span class="number">0</span> &amp;&amp;y%<span class="number">100</span>!=<span class="number">0</span>) || (y%<span class="number">400</span>==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> month[<span class="number">13</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">28</span>,<span class="number">29</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,</span><br><span class="line">	&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    <span class="keyword">int</span> time1,time2;</span><br><span class="line">    <span class="keyword">int</span> y1,m1,d1;</span><br><span class="line">    <span class="keyword">int</span> y2,m2,d2;     </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;time1,&amp;time2) != EOF)&#123;<span class="comment">// 有多组测试数据</span></span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (time1 &gt; time2) swap(time1,time2);</span><br><span class="line">    	<span class="keyword">if</span>(time1 == time2) &#123;<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">1</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">     </span><br><span class="line">    	y1 = time1/<span class="number">10000</span>,m1 = time1%<span class="number">10000</span>/<span class="number">100</span>,d1 = time1%<span class="number">100</span>;</span><br><span class="line">    	y2 = time2/<span class="number">10000</span>,m2 = time2%<span class="number">10000</span>/<span class="number">100</span>,d2 = time2%<span class="number">100</span>;</span><br><span class="line">		<span class="comment">////if (isLeap(y1)  &amp;&amp; m1 &lt;= 2) ans += 1;</span></span><br><span class="line">		<span class="keyword">while</span> (y1 &lt; y2 || m1 &lt; m2 || d1 &lt; d2)&#123;			</span><br><span class="line">			<span class="keyword">if</span> (y1 &lt; y2 <span class="number">-1</span>)&#123; <span class="comment">// 优化判断</span></span><br><span class="line">				y1 ++;</span><br><span class="line">				<span class="keyword">if</span> (isLeap(y1)) ans+=<span class="number">366</span>;</span><br><span class="line">				<span class="keyword">else</span> ans += <span class="number">365</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			d1++; <span class="comment">// 注意这里放优化判断之后</span></span><br><span class="line">			<span class="keyword">if</span> (d1==month[m1][isLeap(y1)]+<span class="number">1</span>)&#123;</span><br><span class="line">				d1 = <span class="number">1</span>;m1++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (m1 == <span class="number">13</span>)&#123;</span><br><span class="line">				m1 = <span class="number">1</span>;y1++;</span><br><span class="line">			&#125;</span><br><span class="line">			ans++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化代码参考：<a href="https://blog.csdn.net/numb123r/article/details/112722689">https://blog.csdn.net/numb123r/article/details/112722689</a></p>
<p>优化代码经过测试，存在漏洞，“20200229；20220301”这组数据会少一天，好像从闰年开始日期&lt;=2月都会少一天。</p>
<p>CODEUP的数据应该不完整，上面这组数据和优化前代码答案不一样，但都能过。</p>
<p>把25行代码解注释应该就是<strong>正确答案</strong>，但是AC不了（疑惑）。</p>
<p>直接硬算是最靠谱的，不需要对年数优化。</p>
<p>这题一般写法还是比较简单，但是优化时WA好几发，注意写法。</p>
<h2 id="2-进制转换"><a href="#2-进制转换" class="headerlink" title="2.进制转换"></a>2.进制转换</h2><p>以题目为例：</p>
<p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805299301433344">https://pintia.cn/problem-sets/994805260223102976/problems/994805299301433344</a></p>
<h3 id="1022-D进制的A-B-20-分"><a href="#1022-D进制的A-B-20-分" class="headerlink" title="1022 D进制的A+B (20 分)"></a>1022 D进制的A+B (20 分)</h3><p>输入两个非负 10 进制整数 <em>A</em> 和 <em>B</em> (≤230−1)，输出 <em>A</em>+<em>B</em> 的 <em>D</em> (1&lt;<em>D</em>≤10)进制数。</p>
<h4 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h4><p>输入在一行中依次给出 3 个整数 <em>A</em>、<em>B</em> 和 <em>D</em>。</p>
<h4 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h4><p>输出 <em>A</em>+<em>B</em> 的 <em>D</em> 进制数。</p>
<h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123 456 8</span><br></pre></td></tr></table></figure>

<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1103</span><br></pre></td></tr></table></figure>

<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>将一个P进制数转换为Q进制数，分两步：</p>
<ol>
<li>将P进制数x转换为10进制数y:</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> y = <span class="number">0</span>,product = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (x!=<span class="number">0</span>)&#123;</span><br><span class="line">    y += (x%<span class="number">10</span>)*product; <span class="comment">// x%10取最后一位数</span></span><br><span class="line">    x /= <span class="number">10</span>; <span class="comment">// 舍去x的最后一位数</span></span><br><span class="line">    product *= P; <span class="comment">// product作为权</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>搞不清楚的话，可以拿二进制数转换为十进制数作为参考。<br>2. 将10进制数y转换为Q进制数z:</p>
<p>除基取余法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> z[<span class="number">40</span>],num = <span class="number">0</span>; <span class="comment">// 数组z用于存放Q进制数y的每一位，num为位数</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    z[num++]  = y % Q;</span><br><span class="line">    y /= Q;</span><br><span class="line">&#125;<span class="keyword">while</span> (y != <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>最后将数组z从高位z[num-1]到低位z[0]输出，就是Q进制数z。</p>
<p>搞不清楚的话，可以拿十进制数转换为二进制数作为参考。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;d);</span><br><span class="line">    a  = a+b;</span><br><span class="line">    <span class="keyword">int</span> ans[<span class="number">31</span>],num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        ans[num++] = a%d;</span><br><span class="line">        a /= d;</span><br><span class="line">    &#125;<span class="keyword">while</span> (a != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=num<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提一点，PAT的编译器，如果按照scanf的一般写法可能会警告，将<code>scanf(&quot;%d&quot;,&amp;t);</code>改成<code>if(scanf(&quot;%d&quot;,&amp;t))&#123;&#125;;</code>就不会警告了。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>进制转换</tag>
        <tag>日期处理</tag>
      </tags>
  </entry>
  <entry>
    <title>数电讲义</title>
    <url>/posts/f0e8e866.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="0ca53eed74f4722422327235ea5ecd602444920ba5e9f6e2a6f113003e5dfc74">fb26124e0d85f363a66baed35993e1a0948953cce3d484fb31660455b92ccb286ba4467b12dd2afdc0f8bd795964707216933c479f00faf5302337078027ef66e68c754bf0232403ae44399aa06a2cad741400e24549082709cdee4a1c1e38f29d8bb6993c43448bafc4543d636ea5bfe35062ad225c74a80f232ba51d9af45093f5220e616be2d57e02341ffad661bef2886dba249b54377d8b3961fd62e8e7033554e6a1a85b429bcdccd8e910eaca84c8e447cedd760cd76a16c64ec7f94ad050108487716cc544f1ca685285a120a1c590efd559bdca18a90707fae890221e2912f079f089d10fb816e69e85944586941b721161d200273028ce2f3cb2d1a6a47461dcfac58b4612622383de37911e7101936179b0ecfeb18f3600111afc0a3048b3a9bc8162408d2cdd766c056081be36f6984d0fc9924355cadc0cde3eb9b769df924e862815f18fb7ec6ae1a824b820766f2a80f9a743380091f1d836c08256e7dacc4941cb961146932f273f9d4e0b2ed511ba1653c46f46ad8b8dd7e8a2e3b98165fa10b6cbb849542d9dc558879b7dfa59e04a90aa277683a1939f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>最大公因数与最小公倍数问题</title>
    <url>/posts/e808698d.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-最大公因数"><a href="#1-最大公因数" class="headerlink" title="1.最大公因数"></a>1.最大公因数</h2><p>最大公因数，也即最大公约数。</p>
<p>最大公约数即为 Greatest Common Divisor，常缩写为 gcd。</p>
<p>我们求出最大公因数可以用于分数的约分问题，只要分子、分母都除以最大公因数d。</p>
<span id="more"></span>

<p>最常用的求最大公因数的方法时欧几里得算法，也即辗转相除法。时间复杂度为$O(logn)$。</p>
<p>欧几里得算法基于下面的定理：</p>
<p>设a，b为均正整数，则<code>gcd(a,b) = gcd(b,a%b)</code>。</p>
<p><img src="/posts/e808698d/image-20210409151251806.png" alt="image-20210409151251806"><img src="/posts/e808698d/image-20210409151324778.png" alt="image-20210409151324778"></p>
<h3 id="1-1递归写法"><a href="#1-1递归写法" class="headerlink" title="1.1递归写法"></a>1.1递归写法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常规写法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a; <span class="comment">// 退出边界</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a % b);<span class="comment">//递归</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化写法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span>	</span>&#123;<span class="keyword">return</span> !b?a:gcd(b,a%b);&#125; <span class="comment">// 注意加上&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2循环写法"><a href="#1-2循环写法" class="headerlink" title="1.2循环写法"></a>1.2循环写法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>)&#123;</span><br><span class="line">        r = a%b,a = b,b = r; <span class="comment">// 辗转相除</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：循环写法相对代码多一点，但是递归写法内存消耗大一点。</p>
<p>个人还是推荐递归写法，毕竟码字快一点。</p>
<p>注意：这里要求a&gt;b，但是a&lt;b也能计算，会多递归一次，相当于交换。</p>
<h2 id="2-最小公倍数"><a href="#2-最小公倍数" class="headerlink" title="2.最小公倍数"></a>2.最小公倍数</h2><p>接下来我们介绍如何求解最小公倍数（Least Common Multiple, LCM）。</p>
<p>我们容易发现，对于两个正整数a和b，它们的最小公倍数是ab/d(d是最大公因数)。</p>
<p>注意：<code>为了避免a*b可能存在的溢出问题，我们可以改写为a/d*b</code>。</p>
<p>如果你对详细证明过程感兴趣的话，推荐食用文章：<a href="https://oi-wiki.org/math/gcd/%E3%80%82">https://oi-wiki.org/math/gcd/。</a></p>
<h2 id="3-例题"><a href="#3-例题" class="headerlink" title="3.例题"></a>3.例题</h2><p>题目链接：<a href="https://www.dotcpp.com/oj/problem2229.html">C语言网</a>。</p>
<p>题目描述</p>
<p>已知一个正整数N，问从1~N中任选出三个数，他们的最小公倍数最大可以为多少。</p>
<p>输入</p>
<p>输入一个正整数N。</p>
<p>1 &lt;= N &lt;= 10^6。</p>
<p>输出</p>
<p>输出一个整数，表示你找到的最小公倍数。</p>
<p><strong>思路：</strong>参考自<a href="https://blog.csdn.net/qq_36403227/article/details/88677874">CSDN</a>。</p>
<p>题目要求我们在1 ~ N之间任意选择三个数，使得它们的最小公倍数最大。<br> 要使得最小公倍数最大，那么思路可以是：</p>
<blockquote>
<p>1.这三个数要两两互质<br>        2.在满足1的前提下，使得三个整数取最大值</p>
</blockquote>
<p> 第一点已经在上面分析过了。而第2点也很好理解，其实就是贪心策略。</p>
<ol>
<li><p>N为奇数时<br> 当N为奇数时，N - 1为偶数，N - 2为奇数，显然，数学知识告诉我们，相邻的两个正整数互质。同样的，相邻的两个奇数也是互质的，那么此时题目要求的答案为N * (N - 1) * (N - 2)。</p>
</li>
<li><p>N为偶数时<br> 因为当N &gt;3时，N 和当N - 3是可能不是互质的，例如3和6。所以偶数时又分为两种可能性：</p>
</li>
</ol>
<p>  2.1 当3不能整除N时<br>    当N为偶数时，N - 2同样为偶数，那么就不能满足上面思路的第1点了。但是N和N - 1还是互质的，所以</p>
<p>在贪心策略下，我们优先考虑使用更小的值去替换N - 2，而不是替换N 和 N - 1。</p>
<p>​        经计算发现 N - 3满足要求，所以此时答案为N * (N - 1) * (N - 3)。</p>
<p>  2.2 当3能整除N时</p>
<p>​        因为N能够被3整除，所以N - 3同样能被3整除，为了不违反第1点，我们再次优先用更小的值替代 N -3（为什么又是换掉第三个？因为我贪心啊）。</p>
<p>  所以根据贪心策略，在放弃修改最小的数（在这里是N - 3）时，我们优先考虑换掉第中间大小的数（在这里是N - 2）。但是会发现，无论是使用N - 3、N - 4、N - 5……中的哪一个去替换N - 2，其结果都是跟替换最小的数（在这里是N - 3）的结果是一样的。</p>
<p>​        所以我们只能开始考虑使用更小的值去替换最大的数，也就是N。<br>    因为采用的是贪心策略，所以我们优先考虑使用N - 1去替换N，此时结果是：(N - 1) * (N - 2) * ( N - 3)。<br>  显然相邻的两个正整数是互质的，我们只要考虑N - 1和N - 3是否互质就可以了。</p>
<p>因为N - 1和 N - 3实际上等同于第1种情况，即N为奇数时，故 (N - 1) * (N - 2) * ( N - 3) 就是题目答案了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n%<span class="number">2</span> != <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; n*(n<span class="number">-1</span>)*(n<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n%<span class="number">3</span> != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n*(n<span class="number">-1</span>)*(n<span class="number">-3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; (n<span class="number">-1</span>)*(n<span class="number">-2</span>)*(n<span class="number">-3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>公因数</tag>
        <tag>公倍数</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编入门笔记（一）</title>
    <url>/posts/52680586.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="汇编语言的产生"><a href="#汇编语言的产生" class="headerlink" title="汇编语言的产生"></a>汇编语言的产生</h2><p>汇编语言的主体就是汇编指令，可以说汇编指令是机器指令便于记忆的书写格式。</p>
<p><a href="https://www.bilibili.com/video/BV1ni4y1G7B9?p=2">推荐配合食用视频</a></p>
<span id="more"></span>

<p>编译器：将汇编指令转换成机器指令的翻译程序。</p>
<p><img src="/posts/52680586/image-20210319191835269.png" alt="image-20210319191835269"></p>
<p>我们在不断向上学习的过程中，不应该忘掉基础的底层知识，汇编语言就是了解底层核心的重要内容之一。</p>
<p>向上学习是应用，向下学习是本质，这就是精髓。</p>
<p><img src="/posts/52680586/image-20210319191956762.png" alt="image-20210319191956762"></p>
<h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><ul>
<li>N进制：逢N进一。</li>
</ul>
<p><img src="/posts/52680586/image-20210319192751867.png" alt="image-20210319192751867"></p>
<ul>
<li>进制的计算：本质也就是查数进行运算。通过构建加法表、乘法表来快速运算。</li>
</ul>
<p>事实上，减法、乘法和除法本质上都是由加法实现的。</p>
<p><img src="/posts/52680586/image-20210319195853542.png" alt="image-20210319195853542"></p>
<ul>
<li>进制的应用：</li>
</ul>
<p>可以自己定义进制的符号，以此来加密解密。</p>
<ul>
<li>为什么要用十六进制？</li>
</ul>
<p>为了我们方便理解二进制。二进制与十六进制的转换很方便，最好不要混入十进制。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 二进制</span></span><br><span class="line">0 1 10 11 100 101 110 111 1000 1001 1010 1011 1100 1101 1110 1111</span><br><span class="line"><span class="meta">#</span><span class="bash"> 十六进制</span></span><br><span class="line">0 1 2 3 4 5 6 7 8 9 a b c d e f</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么要学习理解二进制？</li>
</ul>
<p>为了理解寄存器、内存、位。底层的每一个位都是有含义的。这是汇编入门理解的基础。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">十进制 二进制</span><br><span class="line">2     10</span><br><span class="line">4     100</span><br><span class="line">8     1000</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h2 id="数据宽度"><a href="#数据宽度" class="headerlink" title="数据宽度"></a>数据宽度</h2><p><img src="/posts/52680586/image-20210319204923167.png" alt="image-20210319204923167"></p>
<p>C等强类型语言之所以要定义数据的类型，是因为计算机底层需要给数据定义宽度。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">位 0 1</span><br><span class="line">字节 0~0xFF (一个F对应二进制的1111，四个位) 8位</span><br><span class="line">字 0~0xFFFF 16位</span><br><span class="line">双字 0~0xFFFFFFFF 32位</span><br></pre></td></tr></table></figure>

<p>在计算机中，每一个数据都需要给他定义类型，也就是定义宽度，在内存中的宽度。</p>
<h2 id="有符号数无符号数"><a href="#有符号数无符号数" class="headerlink" title="有符号数无符号数"></a>有符号数无符号数</h2><p>现在我们给二进制的解码增加一些规则。</p>
<p><strong>无符号规则</strong></p>
<p>数字原来是多少，就是多少。</p>
<p><strong>有符号规则</strong></p>
<p>最高位设定为符号位：1为负数，0为正数</p>
<h2 id="原码反码补码"><a href="#原码反码补码" class="headerlink" title="原码反码补码"></a>原码反码补码</h2><p><strong>有符号数的编码规则</strong></p>
<ol>
<li><p>原码：最高位是符号位，其余位是数值位，原码又称为带符号的绝对值。</p>
</li>
<li><p>反码：</p>
<ul>
<li>正数：它的反码与它的原码相同</li>
<li>负数：符号位一定是1，其余位对原码取反</li>
</ul>
</li>
<li><p>补码：</p>
<ul>
<li><p>在计算机中，所有数都是用补码表示</p>
</li>
<li><p>用到mod的概念，正数关于模的补数就是本身，负数加上关于模的补数就是模</p>
</li>
<li><p>正数：它的补码与它的原码相同</p>
</li>
<li><p>负数：符号位一定是1，反码+1</p>
</li>
</ul>
</li>
</ol>
<p><img src="/posts/52680586/image-20210319212114263.png" alt="image-20210319212114263"></p>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="1-与运算（and-amp-）"><a href="#1-与运算（and-amp-）" class="headerlink" title="1.与运算（and &amp;）"></a>1.与运算（and &amp;）</h3><p>两个都是1才是1.</p>
<h3 id="2-或运算（or-）"><a href="#2-或运算（or-）" class="headerlink" title="2.或运算（or |）"></a>2.或运算（or |）</h3><p>有一个是1就是1.</p>
<h3 id="3-异或运算（xor-）"><a href="#3-异或运算（xor-）" class="headerlink" title="3.异或运算（xor  ^）"></a>3.异或运算（xor  ^）</h3><p>两个不同就是1.</p>
<h3 id="4-非运算（not-）"><a href="#4-非运算（not-）" class="headerlink" title="4.非运算（not ~）"></a>4.非运算（not ~）</h3><p>取反.</p>
<p><img src="/posts/52680586/image-20210319215558791.png" alt="狂神的XOR电路"></p>
<h3 id="5-移位运算"><a href="#5-移位运算" class="headerlink" title="5.移位运算"></a>5.移位运算</h3><p><img src="/posts/52680586/image-20210319215902762.png" alt="image-20210319215902762"></p>
<h3 id="6-位运算的加减乘除（这是精华）"><a href="#6-位运算的加减乘除（这是精华）" class="headerlink" title="6.位运算的加减乘除（这是精华）"></a>6.位运算的加减乘除（这是精华）</h3><p>计算机只认识 0 1</p>
<p>基本数学是建立在 加减乘除。（加法）</p>
<p>4+5？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 计算机是怎么操作的！</span></span><br><span class="line">0000 0100</span><br><span class="line">0000 0101</span><br><span class="line">---------- （加法：计算机是不会直接加的）</span><br><span class="line">0000 1001</span><br><span class="line"><span class="meta">#</span><span class="bash"> 计算机的实现原理</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第一步：异或： 如果不考虑进位，异或就可以直接出结果。</span></span><br><span class="line">0000 0100</span><br><span class="line">0000 0101</span><br><span class="line">------------</span><br><span class="line">0000 0001</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二步：与运算（判断进位，如果与运算结果为0，没有进位。）</span></span><br><span class="line">0000 0100</span><br><span class="line">0000 0101</span><br><span class="line">------------</span><br><span class="line">0000 0100</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第三步：将与运算的结果，左移一位。 0000 1000 <span class="comment"># 进位的结果</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第四步：异或！</span></span><br><span class="line">0000 0001</span><br><span class="line">0000 1000</span><br><span class="line">-------------</span><br><span class="line">0000 1001</span><br><span class="line"><span class="meta">#</span><span class="bash"> 第五步：与运算（判断进位，如果与运算结果为0，没有进位。）</span></span><br><span class="line">0000 0001</span><br><span class="line">0000 1000</span><br><span class="line">-----------</span><br><span class="line">0000 0000</span><br><span class="line"><span class="meta">#</span><span class="bash"> 所以最终的结果就是与运算为0的结果的上一个异或运算。</span></span><br></pre></td></tr></table></figure>

<p>4-5?</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 计算机是怎么操作的！</span></span><br><span class="line">4+(-5)</span><br><span class="line">0000 0100</span><br><span class="line">1111 1011</span><br><span class="line">---------- （减法：计算机是不会直接减的）</span><br><span class="line">1111 1111</span><br><span class="line"></span><br><span class="line">0000 0100</span><br><span class="line">1111 1011</span><br><span class="line">----------- 异或(如果不考虑进位，异或就可以直接出结果。)</span><br><span class="line">1111 1111</span><br><span class="line"></span><br><span class="line">0000 0100</span><br><span class="line">1111 1011</span><br><span class="line">----------- 与（判断进位，如果与运算结果为0，没有进位。）</span><br><span class="line">0000 0000</span><br><span class="line"></span><br><span class="line">最终结果 1111 1111 (16) ff (10) -1</span><br></pre></td></tr></table></figure>

<p>乘：x*y， 就是 y 个 x 相加，还是加法</p>
<p>除：x/y， 本质就是减法，就是X 能减去多少个Y。</p>
<p><strong>计算机只会做加法！</strong></p>
<p><strong>机器语言就是位运算。都是电路来实现的。这就是计算机的最底层的本质。</strong></p>
<p>通过机器语言来实现加法计算器。设计电路。</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编入门笔记（二）</title>
    <url>/posts/627ee95e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>学汇编不是为了写代码，而是为了理解编程的本质。</p>
</blockquote>
<span id="more"></span>

<h2 id="如何学习汇编"><a href="#如何学习汇编" class="headerlink" title="如何学习汇编"></a>如何学习汇编</h2><p>《汇编语言》 16位的汇编 32位 64位（本质架构区别不大，寻址能力增加。）</p>
<p><strong>建议大家可以直接学习32位汇编！</strong></p>
<p><strong>汇编入门：了解汇编和程序的对应关系，程序的本质即可！</strong></p>
<h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p><img src="/posts/627ee95e/image-20210319223115888.png" alt="image-20210319223115888"></p>
<p>32位通用寄存器的存值的范围：0 ~ FFFFFFFF</p>
<p>32位通用寄存器只有8个</p>
<p>计算机如何向寄存器存值？</p>
<p>通过<strong>mov指令</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov 存的地址,存的数</span><br><span class="line">mov 存的地址1,存的地址2</span><br></pre></td></tr></table></figure>

<p>可以将数字写入寄存器，也可以将寄存器的值写到寄存器。</p>
<p><img src="/posts/627ee95e/image-20210319223856408.png" alt="image-20210319223856408"></p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>寄存器地址有限，不够用，所以将数据放到内存。</p>
<p><img src="/posts/627ee95e/image-20210319224440106.png" alt="image-20210319224440106"></p>
<p>32位操作系统的最大寻址能力就是$2^{32}$个字节，也就是4GB。</p>
<p><img src="/posts/627ee95e/image-20210319225424942.png" alt="image-20210319225424942"></p>
<p><img src="/posts/627ee95e/image-20210319225853237.png" alt="image-20210319225853237"></p>
<p>汇编向内存写入值。</p>
<p><img src="/posts/627ee95e/image-20210319230235118.png" alt="image-20210319230235118"></p>
<p><img src="/posts/627ee95e/image-20210319230803539.png" alt="image-20210319230803539"></p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出计算机组成原理（一）</title>
    <url>/posts/834810f8.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="e9d1bbb91098d585d474985106b6b9eb266ee40c98c1dfa905bbcba64388bf5a">fb26124e0d85f363a66baed35993e1a0948953cce3d484fb31660455b92ccb286ba4467b12dd2afdc0f8bd795964707216933c479f00faf5302337078027ef66e68c754bf0232403ae44399aa06a2cad741400e24549082709cdee4a1c1e38f29d8bb6993c43448bafc4543d636ea5bfe35062ad225c74a80f232ba51d9af45093f5220e616be2d57e02341ffad661bef2886dba249b54377d8b3961fd62e8e7033554e6a1a85b429bcdccd8e910eaca84c8e447cedd760cd76a16c64ec7f94ad050108487716cc544f1ca685285a120a1c590efd559bdca18a90707fae890221e2912f079f089d10fb816e69e85944586941b721161d200273028ce2f3cb2d1a6a47461dcfac58b4612622383de37911e7101936179b0ecfeb18f3600111afc775a9e1f79696dae92585891ef4dfac1aaf2a9d0fc19e94b650e91cb568da8d4e83c2090b77b0735bb47add509c35bde9bcb1d94fced9a7f0fcdea7466478437429a22787030f71f62c1b30f331be4dacfecc6d751a19dbefdb455b9e5161292bf96a88d37c84d0e5f8a7d18cc0d4f6afe1cf032af81a3f5f607d30d1e0b11bd789e794b47a35c64a4f1953e5a041bbcc6073a5a15c106a8e325075795e2089fbbec4dd947cc113a5f8179f4e37ee795d26fa45545a23d508cc050d4fb9402cf25f581f40951a6645336d3e8758cc9cd723666777ae6756b5de9837f0c2ea339f953cf76de70b252c368140071f7a3126b0e3ae640bae1c5965f86a98442fc5e66783e40b92b16c8dfe19a203548765d55fc12e3e40225d71214690a006837b7a59eb157f102fb15472c39a6b5e3afa95135c6957a8439733af1b1acb67070a5d82efde38ed25ac3ce3398ead9030c73b00cd59847af90e800a3f190b54077711f8dcac8b764fbc233a549bc66a30e0ad1179e37c9cbc115f842c6d00b139cd51e17b9ad35a5d593c3791b0ffd7191929fc8a236e72a5274990a6d8b19c0d17871fc9dc074cb88d4296bcb2d7fa1116be8b622561b7bc4fdaa15191939fcf2d421564274a3b0adc2164accdc91aa28e8f8d2ad030cca593d1068963567469b265d418839816ba5634a0904ea2c302efecaf660efad4ffb03433cae202e4abc7fa21173314cb37e40fb66e5336add5f493d17ffc3e48b943358cfa068fd95f767313feee8d73d13cb26f4a22c9aa452b735ceda46c15e1910bd0832cc1213d44369ae6abe15b1f0c803bc83c0f9eb56a200dfdb4d0a5edf2b7f6046b7c7820100859e244f93937aa67499bdefad11378bbacb181aed3dc92c02dbb4073bc5b51734b0ead3889088ca2682b24b352fdbce109f5a1c55e83cb7ae3ac6a53f6ab90b18d0da91bc3d3e7b4085c3211493356706164c489924d3be3a95edddaabc09bfc2924b072d1b74d90ca12902133ce27211eed7f5081926db4dd07533449cc5cbe8faf9ae15ded22874d82e9566c57e1587fba2b1cdb73a14d9d19c075d214fec58074e696839f6c33b7b9815a0cb8dd7cfa49ea223f8de4f1226203692948e946798698ec73726dc62d51fd76c28b3be2af994b3d9b31f794f4d7522e5098aeacc1047dc750574c03953462edf032512646c79dd69b6c6af015a55525bed9673b3a98c5141be00aa8c35bede3f97890a642d485a853ef9cac87d550a00299ae7b3aecfb612256be6fed6082b518001b5e79ef5757e0c4f88cd4a4bbc0eda0a47081c3d6b56916c49513af6cfd269bb94837e271b9020323935ac0fe99cc6c8096bca32a9d13a7bd219196c6c82de7c5f60601cb810bb860599ab96795458c14cbc6875b99d731d4072420c6815d0e3eb4afee917adf4c7ebeec6d87212112d557639109ed771779e5685689b2fd4e9b552d805b2a4753c55005a1d8ff53f0ed19d41eb2a4a1e85680b594728a73b806976ee4b36bad2432e5d7c396333828dfa9bde11432e048c20b36cdb322c2744d2121001d194161b0a100d3772b97d72e7eff1648f87ffc864d28c7b5d76497b556cc474365396e17a32cf1920b8f9cacfc866ab63b0e1e23d3564e3f87bf1ed15ba738cefdaf833811e9a3286e6442ea168d51ea2006fb4cbd3056fd8faa1f7671d534c3454c8645501d051cfe6bc303d23a3c15a06e2ad53cb657fd25803184c6f88afb1f36b0a6d8da85bf636f032b31fd226319f78caec4ffd8124a0b8becd32732b3e0432ae0d2d3afc3039ecc0b804fabf5248b95e39129cc4aa2286ec13cd26d33ce9fbf14ba8034506728f4895861067ebc8179036cc6b22ac1c637f86f50aa5d0898a879e27030ac3469a1ff1951b29105e6a4c481813a6fc871479cc45e4654c9ca048cda659fda95fe019e2f1c6e9c664568f306908fa4800982a121d59d106ba5d29c5f04e94f12bd769c3130f264f4c17238e750aef9ff6c94c00e8a88f90b83455bac46c1cbaf81a6e94254c27b68d26bf99cdfc088f454c543e0873abdeb8474891a7eedc743deca6984513be4a8e5b890f2b980a40a433821fef1791781be3c0a513093ab09137967c938f4c1009c71ab20ed1828fa7a92b7f16b532632fdd89bee521fd74028d979619a1ae3e4773e21876faafde646616c5a38a55252103a248fda3cd3ac04d264ed876d9187356b894a2a12e3a1ba5486940c47f9e2d954a6c97e758e24665aa2bcf3d72dded4216333bb7a8380cef1998c3ef732923f45e6fb5028d95e3be2823199f5fd3fd856e184ea1de41d05eaa1ef5844d610327fafb1bca11d338c3e75e8ed6c31a381c662b3d32f16647618c64553f5cb2e1724b57e12be45ee7efba341aa815d0c90aa33d288ea8f293e6bfddc64b70b40988dcc36292accb9f6bf218b5cb6d4f6d1e2989f7f669ae878d5e9a319678cfddafe86789abf1162c4db8d9c0b12b622ad2dcf570d4173757f368c07049e3c5b0838993515976fc3a6a5115db2e494ae52ccfe9411506362f4389433ffe79e05b719befdac3a3fc686fff7defeaf430bc2a232aadd11c1d1dfe8cc3994846655998766690a1fbda57778d3f0f50a9b9511780f4885b647d1dfc9e1f2404dea5ece0c57a3c6a31a67f24e5f340911ba6c112f5c7ecd4defff480054fbb5f4403801670fd1b6e7dd6766ee70c58abd851eceb030bacee9802286aae46b455ebb0264c7b9598acc032f807c90c8f01ed3fe39f3050e399755d89cfe6b39f94764a758ee841cf085b9346f634631b15434dbebfe0763ed3e7312271dfa9d64140563556fd008550494ccef23d9ce5ae62d61d47f262feb042e24d4d7d7b9eee3f0767a7fcae196011765057f5f43bb5a0c0ee071b6c937c6464f5cdaad20db71743ea010d8b2e08de545025bf044e45f0fabcdf9d62d21dbaf0e7c2e01e2d2bd09d88487633220f07ddedaf5858d24c08d12fa45fc54fd551c0de6d66647c5b22ff89db54a452e0da6bb035c43932b4fbd40117c41043526c7a4b811256908e9d632027e375e18027208904d17e2188bec5025cbf310dd88bf0ecffdb57bce40e39c14fd6623a109c434933805050f89a4812c37a49d3eddfa8c1077e6d41103f2c6bf2e88e94f6b2712001101629f64ebd0264d9393f7c3b1e2e8f4441645eeec73ce7471c8cedb57acb4a74ab85f36750f2cabfa908a21eb69cc27a68e3b57d402000bf62214751bb20d3c49ad8af5092fc0b1c0caaea3818564484b68563b67b71a869f9e6e68d40388f9dd61f54aa33ea052604119a54ccc9b9f0c61ca8c4e8a1c702efb4347fd8fc2ed0e84b8efb3edd13fe01cfc83277e35f639ad25d508429da083adaefc1a5369acd6e8024a8397791290550a98aa90cf0179d408f6c50b55778301719d3c971ddf7f6642ff0bac684ac590b3d6645fecf454c2f7e454684668c37addf1cbd6c06aa15fde57c944a824f7560460ed8176d95c27da663f80df06c14437e8ee2fc409fd9ba983edb7264359ff7a48eb83211c3256e3a333b9d51d057a11eb53b8974993f051beec152796dae0b8a7f481511d1c02b0587a4a94fb2d84cb0627c4647cc89e1916eb9709eedf50c286d76a5aa8059eb8b0d4ea32dfa71b445d2f7b67a43c854d68f6e45b905760e21e09b423c865a4ec2024f531197b4b81234e93750792824ecbef8e6396478419e39b28ce42b06092e968666d06fb715dec7a619191afa8c31e6c551be3ce16184787f53ca065fd3d7889266c658680048adaf4a0be3635f4d68a608871770cb21e8fe7b0668e518e967c29cfe6a041b655af8ccbf057556456e860ad3af7a714c4e0c6fa0b3d96a3c63e3fd2769177935ad08cb6f84215c1499f581df6223f8e67cf68525480d348fc640b107cf73f7f2ec02ad72eb4cba2ab704dbab45cb044247ca1cb98597e99d657a263869fa05cd7da99e01113458163357ea82d7d133f26129aaa37e6df0359f8fa34b6e7b29662a259489a9a5b5bf647d3eb5ea8e925ceba027df9c60a7879f49873d1ad2ea7e6a3f6df5e9632769e664ed068b58c06ce80c42cfceed754b2c2ae19dfd5b9d282ab3480bac86eb7f31a6cea8466ee73a88f0ae1037e984ec0e47592ef89c6487847ae46f1bb88aa437da723f25404d967ec1fcaad13984272de0cedd05068ff594ae7e3bbcd37342051dc8067910ddecbed002c6368776807b879e055bfeea372fe3d0ce657192709a1e1e2a44a7cfda51598f38d571342a13ab4a17c151d066a1e4571c7abe18b12fed9355f6b7277da7264573d4dc2779d99158ce8dad56e5da0d4512900ab6098b124f5b3a1a36af4d034068f1dce2aa868b25ee5596848d3822f4103fbfef792b013ffedddea4de74e3a6d072fde2954b17d87a24ec37d24a3fdbc87e86b59d69c5a01a092007f6904e34270ede8e802774404b3ccecf03e7ec78a34d46717ae43af25d972307e1e818cdcd86a17fb0b9eb057c78b206f4f533bb3f780815c06708ba7ab236e9f49fb20b867d6ce2b3bd4748349b3a2071ace6f19dd2947441391a03ebcec59e7d8f51a670cb603f97de8a8943e3d31cd98560ca05ee1df6c5be3c1c82bd3583f9ad84c8914f86966e2312c6d702e417c9a5ca45bb87251cc530b1df219e460653b347cebf0adbb6eaeccb23a3029960775392b9bf8659604f064b43cc9795f673d8994fdda534a08c0b3b1d576fe27678fdcff18f9726c7b820c8dad233d86232c60ae832d36facc8068f0e1905f6801b52640c5713f4a491a920034d31889a72fc86014f618aafde63085f0bb6611df5f8985df0c4a0bb05033778dc95509dbd7ceba68a74d76b52d2c3af657eae7bfc27b4917daa2bd221cc9b92bab422e3698ee712c11d8fc77045998489e3fae5a37f1a1f41ba709d52e249ca9bcedc7ed7a8071c494cd2744731514d9af917af189b903f445b854480db3ee160684c38723efb2aae982a1a31cc38835b61d3a8e6b4b1ddf98b151072c82d1c4948c431fe5fc2cb3296de27a9b3f496f941580ce2e16baac49b634369eb3c93ba40c9183dcaf1f2057b4003c1541aba17aecee29b59174622f6b333653a11103a4c19ef1196b23935b32594511f024adfd6dbbc5afafc19be96c7e5fd84237dd6e024caa6224055d346a63fea1407109342ebfae0f44832167e3bed816e23ca2bf5220ed3a10ce78e35480deb6644255ed4b103997b20aad361eeb914a4f190c3c8821d6a3c30b3163815a5f39f65bd5e5937453ba6c0c39ec7a82da7c41681bc94a40bf223b25309e8867d2af7a4f9370bc21e11ea257c62d638fb9d9968cd1fd33acbb79d65c18a30cf12cdee01c7b64dc590543cf7f535528216fd5cb737ce814dd135311c75824b253b460af124160cd5d50859b4dee6c67205c7e0a5930421dfc09222a2b44820c0ca026b2f596c997ac47ec8cf75fa1929a5315e51742e7f5c39621ac43f2735ead468e9ac267074c977f3f59a93dbdc4c192f00c60b2fd02b526c0143f90550e8a002cc85e5a2924870183daec7433ae9ca69ca7141bc78159a4046c7bcb395977f808eee8347b8aa0cde6b01609a9851a7be3ce089ce2dd51aee2ffcaf52da67f80b437b5706b732eec149d624515702d4c0cf814ff90b855ed1ce9fb35e63e84ed0e5f5097857152f864e05fbc1f02a8071dc0563cc2c8df98d9b4d2fa54024d4157f88d17fab618573cde81644d42bc2354dac6be16eb82e188cb0df52835a98004e6ebb7c5853b1ecd3ac832cdb2373865577fa8140516b657fdf32855c5fb843b46e953735a9e790c10e6e33beb7fa5f9e33ce0ca30056c245e33d5e5ca83a50cfa712b8a8951c8c596a4b4c081ffadd303615365c715e2fd33f5a590aba06ae591059b3fff02734196f38539bd9a8f4c95bbc499fef1b31603e744cca08a1f2d55dec8b10263c6ee910f2b74d204edb63a8ff25f082f126e910187f68019e62041e23316e537451c7b3b836aeae3fad1cc5747c2d95214ea9d274c69b3c36d226f6bf0cc06385e6648988068c2b0e4cb92f5686aaee255fd728b320a31a364f41df0fe9f67fa2c325a6cccbd28e0b3c772e740c6b23dae02a1113cd42b737af8a1e537e0f369aee66d6e6855cb81dd565106a60225e0c2c7ce2fe101347cf9e066f889efd6b07ee8f7c4a1d302ec831ecb409a4e5bbefcbac0285daab7553e246b0e4abe6a3b840ce4f46a3b069dfd946f7d919ba040479ba0fdee69f8b19c8840deb4121282559f4063de06eb9b31dd7bc9324a9d93a43907bbe09956f5ec54d3d8cf8b178737da09e35d74eb37dbb022c2be340ca400323809abb2653ea82e58f85259850ae0307ec8687ebeadd6e00c1ee92c57c15d90c029e3818c6fca8496df347632d48e049ec53235f50fea05a97cb777c6f8a3587bbc84cb7efd132487549bb68a9bf4b301bdf676acb83062305b3eb6046f751f5629751166714625a16f15238a1b9f328d246fe79f9b5f292624781287b8108c3ae14a6c916bc4b4eb794332908867c89b3d5c70a52d63af5d4233f675ba8709ba2d0e56b45ceea7421ecb2e37e83d81394b3864d151fec51653d411aa9116448801b746c39fb0a92c0e1bf1819c977a32f9780acec24ef82fa5e412cc9554b11822eaaa3780d69d9a5935d7a103a2e1354eceb52a31dea1fa513db239880e05501159babdbe36ec4011d49ae9b741a4da914da5ab57de56d36e12c9fd053de3f5ec934283f4ca858bbfb921771bd95b120c3f5f78eb0446e0284120b2ba1a4b437b858c5ca4cd3b278da7253a04765b9db3fe0e5dd31694d3bdb172fc177d1ff14d799ca2224f75435d16f7c35ffcad6e14abce848ed391f29f1d0d9f0ff9e7c35b8765591caa9f302a9af02b8249180713081f798ae7e18d5b20a9697aa287445e2ad6dcfc8b053a7c8367e06450f32ef03d8c131bb8dccad68c0e6cb772d2d1876889ceb47da95cb454155a5bb59d7f73e2d24e473e01341a8432c56f075dbc4d7658ae840c2c79fd12f3741cfaa1e4867c53eb2b45b085cf761c7852c79ae43e81c33c3b01a004e7a3424e92b958eedb07eca76b00695cd35b9ec84837ac78b6a03e8777af33146d0acc8c500e7d4eab497433abeb0df1408c5c2693ff94682501d4545390376dd1b8996d4da938ab1e82de7e06ef83b09aeabb5f80ab9e3c141a4227ef5363ac07612c9e1fe83e29b6fce718009b177b5da0899677bc88ff252eca0cc433235add890be886a7c9659d8faccfbd01e51b215841cb0cda77a2a47644062638866e8ab2c1536df82a42722ac533b2e4465a4dd26a74f1930007925ab0a244d3935e4059c657fe81885466519de9f5fd67a0594d95ba8d7584815bc8484eca082bd4319c89b404c223266cae91f22a4fa70712a47570d351c934272e5c7724f5e484277a883fda5e8935839db98da7190ede8088c64763b49761e9d0598f2a3afcca18aa3d7a84494689a6f1315edefd2acb3b9f46ce0491a0bd804c3e8d4dea080820562acffbc876c3e56ab6d6ceb129ad2ac746dacf0679135045007ace0fbdad6c60a5225a9faab873b5958acb5324c1e62cb03d5fee874e12fc6db88bc4cb4cc59cda42a2501fefd37969147d6b62602d0617bcee9213d34f8e87a3eec74c05a4253b438a824c9ccef197f5ff3f7ec93d204a40f5c67c3bf47cb159c8b7e6536eb8c8c480777fd53a9caa1edadf49bbed3750cd48099047cd08c79386be2b87e84f05c14c1ccff4d973b35e3cd52f015f06ba85ddb5088e14d054fea3cda2178bcb1b9f24e032af27258804ee23634e6d43792322c030e5d1e1b7dec7bfc1df48440f1813a870ffbd6fb80d321a84a0722ed70a5d421ef0433aecf31825bb7bd869cb1d907228ee23fe01be4cc58f49afe83cb3216fbc23fbcef6dd8aa8023b237e5c47ce48386bfa310d7341db5d1a670f1c12ad7e735795a07bfe869a3a7bcf3dcc748fc3074b66c37e26c8d8fe1adb3430c23af42dc34d369054e2cde6b6c21f0a5c9be9b14050515bf873106d2f37ca88990837128d17c6a624e8c7113901ee5e08c47844a5dc63765ee1a4afec1838098bc16b8ad282fec6a377e1d315850bf2df5f9592dace41bde43d14ab169542f44e89b39c893ed66c36f68eb33b45410ea7c1914b8726a926b0f4468753e6dbec97e75e0ad44d80bb963386eb4fcc72d60b75c248f1b564fe1aa16b5289cb6e3b011497a624ee32d2771dbd419b1137ea97030eb47e819cbacf75ae560926ae67c162c7b4f06897bd1c59503f205c08120ab5bd5e95a036dee2018e5f985feecd656c216d985915636cbc1ee499343cd32cb4ce8ad23a26f10027e24c2b296e6f9d5f64cdc9c4b606bfbed9499bc1aafa1af089dff8e8bbc3c9cefc58b61bc7ee9431b9acb28e4a5f4eafafd58505552a9b3fb57fe080f7751cbaf1fc3c0db447980927b42f8b88483e7223869fcc55e3e8529f7c9b51f403e03fd78c56ed408e692a67842661e11e8d7e5fe493a7e505b083c2cfaab1d795863756545647c868accb4f7c0f7a58912d5ae17fbbabb905bbea4e4fad4673a524c9b3f45df8dbb1ea55d0c4c23d081e6cd9cd00c927dec4a3fad93f50f9c497d2ee86cd6d2c010d6a57cf2562c76972ad36c146ec6a867cf1ab67c89f879305439117118b98bde565f2a89b0988a23868f5758d86725abeb2ca6e197a0222df6b824f77fc149cf284c640c5c6133ff0124862660e59046a34b44254c6126441f59a123873c5c7a0932bfacff823a0b0fbe7fafcc468ee394bbb4b04ab10c5fbeb957c5723fc50b48d5472611e4be9f12bc435aada0caf87279d669a99d6572d6224064882565041725dfdb4458fb022087bdc66c5069222ec29edb3b1b3bb8c147c4070e406586f7a888abae703368749fcbec4c3000cb779c672add02e1b48d9845ff907ce309ccd9c56c7788625d68ef8ceadb736f54b099dcf8566394e20a3e60876fc92c8927788b8361a9486834cde25b6cf1c52ae0ec6fd13f9ee90ac6a89c60ca166319e9e587f7cc2358e23b5608e859f513f33f478e8ad4ac4aa18a6869aa2fff93c5027f2b61a39845e27162faf3663506cb611bd153b914ed8f0547e9ebde337d5779847a145a0d9cc3f3682716632539a9c6630df02dcfb822d477675f93960316cbc4aec96358f10de52150d4e1cafb58017b97657feef964c7b49d68a34b78ec25a1b37d004d6420a6e8a40dd4e8d362e56723c8f18a3b70464a9063d5966d2a5f298968fd0bf7dab30b5f1d1d4bea28f80743501a171de673df9eba5a0ff0b860bd9910d21b22171b1fc0eaa9094d5c6a9947e3374d684524f9e8408dded4d30ab758a84a71cfcfde917a8ffd13655f9eb8e73433cc509fb905e136a9cd2b9daefb649442fc0216d46c1b3011a91883c12a8f13e0138208a08b4242a22c98e159039536b3d9cdd63ad8051ce42114dada15dafd2a39a8286d79f0df52097050f1fad254a9d2e2ac6d451e78e068c9c4b75efa62ec8a21c38f4c45bb58a32e491e4b64b9f5dfbe4a13ba8fd3deec84c0b20a3d6c753c05e42608a9aadd5005bf2965071ae04c2876c479bbbfc78568cb120e6f914820d12811f7ace2f17b5a2c120337c8fedcb369948ffab4678447245921b186563cf2291bf66e93946894bccf06f9eb932fce596e239502eca99d5caae87b83f5f95ba9ad030f58be3cff65944428af0faf9b63f720eb98d0b4337f9fa5dfd98b40419eff25f693b6ca54e891638a38799038f46784e3a56349912f571acd3c7f2d186cf44bfb8dd3f087f76aeae2a0bb2d86dad9cd3e5a75ad80b3dc9f3ac90a87f14f51a9228863319030555e731c9d7581e2f569dda7c444f472a13f66459ba3eb08433e771ad8d1155f82e41203c81bdbe85e954b091c1be34580f1ffdd530ae19f6ec10d4a73d818ab8452024ab9352975156be63e8b1a86de2e68f48114410f9162107ba23238bf01529d7b3916edaef3ba0525fdab091499d092ad60630d284962f3b5fdcf46fd4ce7466ff7e8d5db9fbbbbd2bc9a6e7b20e61fb909ed63c4b5f45c287c35a50598d98d75f22084970150b5d36433633cf601b5786901a600f27199c38ab1e681c6e0f3a4de17fe6a7bb619122d5099872b1e4832c03853f47a38db6a15d08ffe197be9ce6475075183744f53e85dc1ddab5effb831c61bf33ff3df0eff8b2a4e7087d2feaba2038f15c5a4d05ecf4b49c54574f7b4a6f55077b4a5b7bc3129e50a766c1a9a99d0b90cf43d07bcc1fec591abf1eced72bac97c156cd06dbe8a42c2a2dd0d88793591860a20953a931b0c32cf2eeb16de8424f5cd977914149ca96ac3723cbf8a5dd20736d49ad8ca7c2b4656ccb938f6dafd3b946e9e598412a7aabc84ecbaada42002a1050f8e75a779ae6a69cef9d4321cf56de239d6f087bb88114badf62c9dcd569764570fc9fb647c8e4ab119eff1e010f408645bad7cc794b4237d376efdbcd63e79b8e88c57cfa1659ba2bd69eadb21d0fadca46efcc82efcc175ab4f47e73c4e09696d50e7dd7a798d8ce545a602142d3035327574bf53ae69f903a1d8a20980feb63152ca8d00aec266b723a05af8ba0211138f9db708919e59504e0aa1ccdcba7286d03b3e591011a718209ffcb1b8ba1a8631f5674b031657465613f53cb0f91eeb9560c0d1fde183cd07ed11d5873f7d227d9749311dc8c17978fd64ed126894d3d52f6bbf6510cc2308def3cdc16c5240be307550bfccea19832d1078a78f3ea69cd4a56a5d61becc77a34d57b84d00c8c0167e397a0da8d5e90504ea6c3d8991c9d5e197ccc7f5d4a52d41b1306f4a6d1ce1de155eb6564bfea326889a3465976eb1bd92c0734a6b647a975061001562344449cf1b8b2038fed5789a63b42a140a6a12bae876a63c105d88581b8b43c372210d0fe950dc9e9b91817f7ac02790b5be9fd155e1493b5c17ed3f1ba3cf2290360e800a6a1b0464de2e814caf6f1cf039ce301b29fc65bd2969ead1b0ac9c7391d426dd5a99b0674e718b1c5d8d7c2dca0878244d97fee23e05164f75db0b569ed5d48a9023705ab00661c4b1108791f85f805469121f58c9d0331702ea48f537b95ed07eaf7dd0f1a57e8dbc7b202721f34cfda4d637616ae9d8575124056a9c079547de6b8af7fa7cf12c4522f713ac564ab1de707a706b970eecd413c245a943d37c8494c13fe479fe9b2bd17acfd891709f90087315dcc19fccd5b10545e961a1c001a2f3c3d1ca2430537dec1bedebf6c831dc7f42d723c134423e3fa652d31e90dc0e77d086b2801323b0f2cd915462dc642acf0a0e77d6488fefc39d04609e9d886276654ae146863fe0c5c171c6526cf99a74cf188695b781385deb2f236d98256bd0a53bdb43c657621657fdb0fdd09e2a5460d79c85c10bf7b88f4c5b0d2748f3b2d644ba2fd16baa04d3fb52f59a397a131407fc9530449bdf39760ff73e2b45a6d9e576b0db51478b9d26194008fe3e0f08505141190244ceeb91bf497ae249b0b6342b586eb7571c6cb440e2bec4ea0727e6e1a3238c817d6c524be6f2976e03244068c700503024779afa3a50503dd4ac56316e77617844f56e3a51deb9c70a6fe84773e5f268386bdfedd479c99915af13fd063d6342eb8f1f7146b478d78abbba3fe477667cd3d58dbd6067488dccbe39f211996d2a95f8876631a822153f202af89f63677e0cbdf3894325a481739b90bfd9919e1f17941a4a11ec043fff1e571905dd711d42109f61e067f8b7ad347a6f18b79b3bab977ddd8da9117524aac02d245fb00344d65d031a19fb5a6f460b8c7b0d53c447eff350935842b5a1ae39bc8ef4a6397d58219256d2add1f32573a4e8cd2187e0669e28e7237084c80fb0dc15c4c931b58aa3a472a7eb27ae70210089bbffb442ce2c5094d52403aa2b41e70a01ac27091e652c0e4e8c71fbbf54b5c550b3817cb7b3e553d7e873594cb07f441f097a0cf2f893387c851f3344e56b1a771d9d1d40c54289f46598a1a8941d22e02892256686f08891ba9bb0ca5c935313ebe3bd09d5c866da0d08efdac8a7db26bbd44b9733ca7934a78bffe629c1dd5272b9508a682d4861b5299d57b1febd9b833fbf4fcbd96384e92979ca4b8a6a8a0be4d426c20dd1150302e6712476bfd2da73713d0e8f8aac90c3a13b2d2866df9f5d5e100138c733388e6d762c4624f66c6a926e7eb21081d58d6aea381dfbcf5600ccabe80b6e1609a81b78cfeaf0002f29a1573747e8d5d421eb5a8fb8b2fc9b5a28b93b113d4f6e8f3c423a6811bb20432532b081ba5b7bf667ff2c6148819074f1fabf072ddae9b617a222e2ef5a12c6906c211b4024a2145e7a1cba6cc2181bc356556740d4873d5cc1d8a2b322a4596ffb6650b3795747ed6e2461cead6a71e77098a7504a9d8613a694d50a79f55fabbfb1a13ebe20c653463769bbb2367315e5abf693dd99704056995cd67d428d55b56b8f83acf7fda80ed39675f6cee90ea87082d27b4d0d9e149d8f44110b1dcd06c28cb8c97e9b41307e0c7e339879b077e564f3e06217b90b58bcd5ca22b228567fa3d7a8155d770897db096f0bcb1797bccdbc1d5dccb46efa0b4ab640791164eae5a5a733cbede5134b881552a0dcbd7bb924b82a6e3fc292b1fb32a25549c1644813cc6e28b24b51b9a310158a97d33c5e334b7d79083084602e3f0c8a0e2e2ad7df74216278140de152717eae6f0c44159643853edbaf4f767fcd37a29c4c13a12543508c19dfa41c0702e4e9176ffaf7e7f0529ed04cb57167ab9600694ed4b7e2a0e95ab1b4b14309dd7e72140b2e68b25c06dcb55c31e948cd9c65a1bbc4acd57f5defb9b81caf9b7336601d265167adb2aba4c4c2a7875743f16fdaa88767f6bc71fdc6d9749de588926b0837f7860d088fbf88f02e8ebd64ef6c67e6ff97357b12ca9e367718fd189fc073fdbeb7f7e2b57f764f672cf89ba544e00eb4cd17956656a31fb1f22e6b2bb9c2fd958c85fa9904977780dbe34e4b685e0d8d328c24874058e3e7b5000703334d27c7f51e226d07889dee482804876e9cd98f5fe656f38968680b6fc897f4bdeb472594c1e69bd7481637e63cb371d07402292a51f70e273ed12e556e1cccf99eab303fc3f34f6fd93bc4ef80e906dca86aae025d00bbb8f1819b09cb84833bd910c3f6c4aaa72a73d87fdbc6ce8a8f23249e269d7fbcac5c608e66d6527d9868a656f51b99749fec3d4c260b0359bb98b454638d9251cf90deb82b1c464f77537cad6369a3660760f9870ffabddd7bee9151c97faa8932c35ef2591827a668ee2cc9da8f3bf4a404849efbe284a73b12a7f0a8cd25996370cae263d7ef21b585cba18fd770752fa4d358004e52c3945c4ff688ec6ee58b0ec3c2ed0a12879e5e3ca3dd7c76534b3dcdd042af8c56bec7a77bce30b41e8f3ee7bedba584f35889df7308a46cc8717f1a48403e1fe0da828c280b825c43fd0b6eb8c046e982fb84fec0764ec4934a81450f3992b4638725a4624db30e6c488fe5805ba1349e53b9507d5b423b548c6ec5c2b318c229d41d88b39e8772e5877deaeb6ce1c23a8ac4441ff106b8b9c51ccbdfa2a79dec0ed01986df95002868aa8f4d50103345bac10e3946f44803abf59d58595fa0b0b6a01134c9cda725e0762c1f791469d9aafa3a9ed0db998248048417dcc4615ce627697d6961cae689116e5a61e56d783d578fabcbb8029a0299070c32f9b5fc0eac7927a3312aad114465b6cb19ef6f29ae1dffe7b66a88d776463ea98046ec159c6b0a9376ef03dd057479ebbcf758b2e74a97a39b130c6dab6c8d63f1de62a3ef3d66a60b4a55a109cd158b92e14bf279feecbc40dc7cd21ee4a8066fc554a874b91ae7354f6d86e74245a76c993dc15aa65241075281a95c2d91c6444195465c1b873e7e139a77cf80c59ca3e97b5d9f8fdf9d7dcf26986130b49dc06ac208e0733986a32189f0d2e3b35a695ade4a8e4c4bd600c144119a84fa89c7b9fbad7f948e45f835c4b51e1504c6889cea530534e3c4235f7964a646f7ab292cb0740434e2c5ab7c92b2aec24ae9005102b0b2f15faa08ef659b86a8d5f64bfb4031d5312bf00d870d8143189abfc08225ad9589d927bab9f4ccf404783a59f2ba8bbd6fcbb203ec3f5dfe89ca0a218a09007f773cc0243715f5b00240fc7fd3eb4ef398c5c514f2abad347e2a5eab60f00667667d982af90d5a588c8df0efb0ba41f1fda6ca8d2ae6118b6166f7d7299ea318f95c85eb535ed3863294925c60d82fb2a16f55c12931f4290b94152c92f7d2ec2501088ea0549540a20c4accbd1d74e8b4a80f50d113b76e90188a476bdbb8b2ef06445473f7aceb2d96a2aace2c3255a66a1e13b44d6b80938f6bc7a96b8fdff7fcc928a7e9f92af9e47233292a3ebda915a0d592743dbc41885ae141e6f17ec5576dccd18840e8baf63cfcf87201143c76cebb7954172203e8506d63d8ce0e4796030b5ea6a79f2a2c552ea43481746441941b9d19ffbd4d733b2cede4755fb4d139fc32cbcb56da675bef81804f44c1c82ddf745832ce6c3cfdeb749e2091e35961b03a291817ce6396c237e9a45e0ce1c32736787fbc58a8c7cce948bff115ba3e0ced1fe1dd922c03c314719a8d25e8a55a20ecb8bdb4381ce7b487038e1e8fbfdaa3d5b1088bc05e5074956e02e6375019d39d7bb43e528190cb69e87c2c49422082f3a1d4a6cdf24c542d08a18dbdcfefaa5fc2e6d0a28c32ae31b66aa40b49a8cf98d789e77f6df539cee917742c0afa83d66d653fd13ed3bbbf0aa41c6545b4bdb2b4b85ce9c65743cd2e38504a75592491adf2685893a61ab6dc394ac68b7273f58ff06037309280d2aa3e07659d39a85c58b578b7d757974fd8a9d37d2078ff87442a10557840d7fccf1f3ec64b8146a415044271fae452b1b0493a0483a8e5e639657c5a6f613dcf2dc6cde87451a0d085938d82036e64177b0920016ee5dc4da2088cb3d21a5cd5550e36c292cab919bbc299682dff25da696daa10bd6228ecd4b56c93ceb7fc2b12c6f525d2b9e00481f630295f31b351acd42b7cfc4b0bec81f7345f663c6335fa88427e4d4213e0ff33b75e3976c9b34d6034e77ae26f64fa9a99d5aa70facbf215c50a2e12ee8a317810c9a91544dcc9b7827036850a7372bd5eb12f023b5b10103f4d26e5e8eb23df5affbcac733a613cf3c4c3d7e1173bb75d525190a335e8bf9b1c9b9e3f232092c4b74c06ddcdddad882db586a2e61291405bd15e965c18691bebaa0770ba41c9465d730c889e792af5325fb98fab3db4353d878a3c35a0e2af0eccc6e056325bfa21842c038405b183ceafc6e666af287dacb83240accc110e5fa988d1652a5105bc9212a3b012243c72152f045c1651ac942e50b477b39dfd9edc66025b89d72aecc7f52c3a870aeba9d07cea2fb3074671cf0bc88690eeded3107ae6e1a097458b95ddbe16f8ce3abb663ea286c6569891489af557e00af557330def4acb2aa293f1603b7059de6d32b7aa091aed644b095c2e5198fdcd0f156116e52d1bdb95be596b5ac6501e592b00e8c15d4835b611ddfdc82833df1a003c0c4cf2dafdbec733a4ebe7926c9fbf9b0328e74f3845b105e522a2a230ae44e88b463cb70a1d21ed24d6d8968c416e75c180159081a88c7a5e4e50936093a6f40a245318a4cb5d3f98f89a23bb622090dbf6cbb0458d5bf03ac75451505631ad54d060416606ba44775f542d549ca40ad3127587873d99e050cef3cb1fee6d3512aa2e322ba5390dbdaef126cfe03bc5c26787966f905592ad238972e89ffe6820b7515936bc4d191f267c4ef17f7f673614774ae6c3d82f9e8e185407b7f265c5bda61c730463d75be372345ca43c308cf29d57f678b804b57cd22e37b50fbd087036a171ec95c44df74b61ec6b623784834166144bbf8ac28cdf0b604f04bcb56a7587d3357575cd21a1c98250bea5a4270c4e14562aaa3e032dae23b607ed742fc62675d40e6cd9cc716a5a254640228860dfb77187d0a66e9484ec2d75dea9a4fe9fce79cd9bd1065ff4ea6a1ccf84ffe9acb96c2772a5b15b78160ce4a6319747e02f4d536fab7c24e624429e5997d018006f26f46b393fbc38112643bb635ee31a0dbde9e271fa65b6ccf1610cbe87934342dc70122f6a4fbf55ebdefea126c9f5f1757a798534f3dc3d919ddda03ff876f81622fbea8489f997d9cfe984f17ecd776f026076fb4c157c850cd1c7ea6e6fcc68bb1c278e65</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出计算机组成原理（七）</title>
    <url>/posts/91fdbf16.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="a45079f0d31a1bacc7bf9497295147a2cc24f45813111bdbd5ad5dae08a9b7eb">fb26124e0d85f363a66baed35993e1a0948953cce3d484fb31660455b92ccb286ba4467b12dd2afdc0f8bd795964707216933c479f00faf5302337078027ef66e68c754bf0232403ae44399aa06a2cad741400e24549082709cdee4a1c1e38f29d8bb6993c43448bafc4543d636ea5bfe35062ad225c74a80f232ba51d9af45093f5220e616be2d57e02341ffad661bef2886dba249b54377d8b3961fd62e8e7033554e6a1a85b429bcdccd8e910eaca84c8e447cedd760cd76a16c64ec7f94ad050108487716cc544f1ca685285a120a1c590efd559bdca18a90707fae890221e2912f079f089d10fb816e69e85944586941b721161d200273028ce2f3cb2d1a6a47461dcfac58b4612622383de37911e7101936179b0ecfeb18f3600111afc775a9e1f79696dae92585891ef4dfac17b709f56fa1918fe7d21606a0c9ba6850a107e95f0c1ac67f7fcf7789bad268c254a2cce8a71abe145b29d96f16fe2abe9a26511de683b31b66ddc7bbc49adf7e534ec9a3b87319856b0d9444c024e085c17ea970a52a46061cfea23ebe4ad51371f8510512df7562c703de717acaa3d8909ab50eb153ab019a10ee67cc8aba613d96092754194fe7873bd37a643191f0c1fa0fe06edee310ff58276fabbb5757700471dc6eecfc5af3ec11b02cfee13b8783375b5114db0f11d8e41a4a157a6d3dff87e702fde5b2284481761fd67795629104cb51bd5034230dd6f8ceb8759f401607926900dc4f83a9dff1bea77bdc7d597d7b4e50739d29fd1ff278e77489257156c7e717b8dec38f13dc6dfe3b4e4958174aaad204c6dc8eb17e4362ad9bb6ec32910ca3f31b9b16fa92f4a3f9b5cae70093c9f68e492ecb6cf9233426020c18fdee4d9b2bc0a9b054e4300a9db9c2eb44dadda1f68c53bdf270e95e242ab30105bc15c38663bb6c6e39207639db6d522aedfbec78f2beb04f21523682692064a695dab6960aad53b45b816a8d56b81a0ab102d677f31f6261b0f3760b0dfc8f2ca2d7eee8498a3925914b97942f5719757ad1f15b343351b4ccb6faa82b8a1f298f26e5e8866b69afc2bc889a17ee8887d0f4950f19612c46ced6f4ee625fc9c070fdf228fdd2d049247d3497ea041982075805c02d42b74b53c37f8f9a8a4163fd0152d8fb5e066aabe39d2267ccec8cf80257ed7ac679ad218bd3f2a54a1d3a1c91230e592118e60dea87b5aa3e35c121655848a6b47cfc7fb815c0f575b9f5b966d13c041f1a58f60f2b7de62a433c0646ad362056667a76580c7731265d5e8d06f812955050406d440fed260caa470ef0a17d034155d531ee98ae2a2eca06beae6ae22a432d389e4705a9bd0b16d7251cc1edcf66762b0c568c4d36e7819a4a9bb52c544e0ce8b49d4278230798ef2cb1a0efe02b75ace9d449a1302bb0a065ef71392722cd237cdf7a5bd0d1101986faff1e276e3061cf3b231f5d8128c6caee7aad128d23e4cf566933a06e4b33b69ad0f48385899d579cefde64656e25f4b4fc6926c0449dfc6f4a8abdd85085bcc4510438411401eeb74dfaed452614d383a1824698c4b5e57f5f01b4f1d65370401e12814a78fc2575b94959bf6021325f9f9952d7895f149110df813085be6afb26058b9ec2ae813122230d88639e470fe2a629c9ce7e3b4f310b7e265e25378bf2c8956abd9cce73a42dc4daa3ed45d0cb3a28c810bea973ffd75c4a28f9ea06627f5aef4ba9cdc7d8f2554741aee18027053adc789774f7d716ed62ad9b8a7825b0fbe08e9e773506aa5384f7174743e9c1d8e8f02642657a9d38ceb067258c66314b5f3d4498d0de356d3043771cef670ecc7409171ca75e7bb0aafb2211d032dc0d7c74e37ba7ef3c43d24f2eb2a62d9f3b88e2bdfcd2d09e19e02b256eedd3b693b561b6b823781d51c2703350618547343667148707ab7aca5177d92dffd89d1aa4287297fd2a0eed9ffd7bb5be3271b617ccf48ab332324188a15d0f93fafc993f56d26e88076abf595c217e579f296aecf33289996c91508787f5a24b85b76136bee6063d59e1f3905bbcf1e3cbe9327929da830cd2449b060bebeb948747798b509128910b0f1cbd8fb9bfc453bf95e0555717fea3e0be53e66f24d719594e54fa067155dd2886cda197a5cac789f08b39db594869fe5d54da86c5e8bf59156019851deec8fe269f97e3816ee52f523000958dd816ad90aa988aaf74081b326df9df07d4ea275d1c6ad35b0d5e42c8012e669fc817ab366dfba293721ec1d0979dcbf6bd830ce3a13b8f769edd4578c100cb1db246354b3faa604230582c8528cf758d6387ba029e2e220b52a7e80e6b6161de66dc8ef475657588fcbedd0207dfe9758050aab95752327f31406f382b0ca88a764ef2b971d0f1f369ffa1070e21c4e3621d2bc25612709d45ae5569b6890c57946c8a6a0c98ccc3be6372ad7d41602faba22ed4881a13ceeb269427a218e649dfbbf8690f66cd12020d9f2b3ba1fee6d268b1949cb44271628290570d8b059e111cbfab2dd07a6d99bc6e18edb90b7cba7c9426bdc23a22fab44286ce00a451be7b0e5687d340a60b9f36e02500c9b12b1d458196058a9a1306c185004208b0998473237fda8ccf802fd9824209a6cc8522ccb82d4263af35e8e50d28a67b3acb0de9844c6f6029972973a1e49554a0683be32291045d8df858c38b2c7e19e813168ff480bffacdb8f0cc5e362f860564c67d8e0ea4cbbe31a60235bf367fe9353fce27a08de6758e6f64699650407ab7f83018a6187a38c3c2986b3982453ff180c1b57a68b6f728e430f7dcca71225c345c0ed37222bc6ad82aac65f8a93d01b955f168a3e27263b2e70c9db87d6c6b581b5d7064eed084820e7b8a8ba7dc88b5e6e444f0767245e1b8b5af644c6715903936a17f58362665ff8f6f7e6c6620fdb52da8a4678200cf41fd67955868934890edc41a7367d8beceed7c838a71a36e507df24d9a2e76f2c01a4634e8d0d14dfa70e3b28a2d200cca26effd9fc6e21fc801172d4208ace521bb0b9d2b5205161d25080b8ee3ed61e988fca82cbb8ea7398034969e69ea1ada3af6141e911a22cbf61b791c2ee102a599eff8057e267aee7548d2bcf80f1fabd6a1792410998a11124b28442fcca55a7c8a77cde3618f65b6442789e3fa90ddfa140a2a54b502b9d95a30370305d0d23afa2133d81f9b626547634cca19756437d1e6fe4aca0945ac6e2e66821beae261232b45a0b41282c573bd562c4f618e72347557412b70859091805339b211d9041aac6c2d4a933b10d238a75aa5ccc918a04fd8f576379d2b68d3d3030cb8230c2e2c35e0bbfd9f9d1caf2b2e8201d9553883bba044f9982881b882e40467aef04645adf667fa643f4755b40d7b04d405e2524fd46f6b4b775516518b03728fa4362bb2b64a6cbed766ce63ec3f0afd012fb00daec9ea06c5bc355bc699c562ab8545332f69046473184dfe70ff07ff99b7b2784200c24c0813e6c38979f20a8b4cb8c4baaa5ea9a2f1125cd09ed58054fd1b7ea16cf74fa378e8c99c8738e74c0b78cf09bb90e69d6fa8214dfdd2027bfb136bbfb9a60af783b469eff4a133d0c43f070944b2f91dfe8a4d1a27402d51500a7839ceaafd5e678e0d132677efaca28f36f2495d0297b424be643ddefebda4b3e5a02cade6ae52e0ffba9563c8cab3726cab2b57e54121473c7835e9f8eba5920683a9173c6481b8a5d60da73dcec332bf3a921b8ae6a8f4c4e6018f85d61cf2906ea3d573f444c68760cc235572290c480027b74d851cd3fd33b26d8ca238fd14a44c9281916130c6b0a48ebd23abe142f4e5570106b9c5c614d2d9a6644ce2aa5a39f3b0b334e2248dc339c97ba8a10018028b193d04fefd7a0014a6fac5df793868506448f1da650bf1ebf94c6b07e960f014a6de79ccda2f64accad91fc5447d394000ddb4bb08da1df76a4ecae9cffb7ed3348a72b2e6cb8666d6496afa110710d008448ac66a40e36b01649f9c5547002d8882281467ab55851ffc336c8d6de9e6868214d2b28952cc3c63d25f96ce2cdbd5d93305b9d0a6e37ea1df16200f5f9e488ae3a1f3b1188fdc4ef3c2e34220951c4a241329bad448a86969c8a9e095be6e4389030a3da6659af700c889762e15e4cd16076a2ff0194bb916c63b6b7bf3841966d5d96d1cf7963461b320337770e6d2eebb58f5eb2d577df2d5a608edf098ccbebad4802d1eddbfdda76d4e850fe9f4653c01fee4de4c9e312bc63e0626c660944d1e1a237892b40bbec8c3281e0fd6a4fdcd390cfb11bade9c6730700916552a19409d1b3001a15c414bff501f2e094ce738607791812c000f20fb670dff3f056f3f9a6af009ce2eab7d6d045570a972acbe7a1ca85b73250e85ad0168b26acf1dc4b95431ddf413f67c97b7754043bce4e0c67b0f1c4a4e5cccb1ab78fb78c0c0a19d1fa4af52cd9661ca8ba09723ee2082ad46f571707fbbeb931fcb59506421e3cf0bde88fcc9033b8ac72d78018ba815fa579e64f0b798983a1286ea0fc88000ef743fdd80cab35fcc19e68e0dda3337ad0253f5c055f858e882e5a67067bb6f31ee8107ea3b03b0daf33480871540500596d8e54e4dc7f63b66f9b79ed435ab982a3f58fa7a80efe496f793aaa19f01ec8834c1586f66565e47ff4391820683e5404dfdc38a86ccab14bfe759c5e09d505dc7cc07a1eb5a64d983af459b54dff7a5132753023ff5103aa70202f288482e50defc71b6b90c281e89f1e1aa68204057740f218785afd5b86b52065bb4324a2367aff23c38783563f4c7c319fb12e23c3e742553170a867cb3463f798a816b71dfced6c32a001b0d5fcfe76006139bc50484f578a7f3258da2470a506f218b7a746089eda5b3700655f88d59b939fa9907030f9446357e36b12486ffe40ad09d1340143d147d226846f3560a05d829313d94207ec8195923c5ecba65421b6aad9498b25dd586f88a33dde4e47d869ee01b2994341a75e2b49addcf15507e9b889292b2e71d802a7a3a8a55bf1faabd8a7b0935518a9a44d47201f8e32bfe6a26e994aa3121c6399b46ef19a398ee451f662beddc075768824a666eb0408c9e27b28987d547fcc9249b1af018b2c84db54bfb264f0495ac4051dced6d39283e592d9cf5167f1e0449b411d4ee305b845cdaf1f1947f6fd47d8d19bde65a0b3ae0fbefee57dbf9c02df2a73fad58db1ed2bc035bd0b21fd1a4e9eaa23860f373eb41ad7f7291b21aa62c219a4f90290086fad7d7685498c9145458fb4098aa4c9d3c17df884ef00633b3aabc7b0738894ca45b9ebe4aeb926e305a05ee4475e6bb02b0adbbb7b2f01a2b4ef36786b4da5bb7474fa514ae55a2d244c033706672d436b702be495585d1d164b0d321727198fe0195d05590384392726bd086e41d8c7f900d97566a0d0e26142d8e8867740754422dcf53fdbfe42eb456bf740a459b778e116bde3fa6ed573aaa85e53d8d8aca8746f30936701adc9be8bf62fffabd4ad38ec5bcaeea25c323f2b46d3ab59c067c73a7882360005e7f4590cd886560ca1287dec8c6689fc8ad2980466d621fa16c54c27fd3c5ef27b434f2026db95a8ead313ad63799d7796601ecf9b585c8fa3f3c2df4a157df40b205e459d681f397c21348507237e7e18c92e186985882c715e8401b8c35e6ab3a09ca814845bf661a466a9825dc95fe2b41cfc37de69ce11d4b042d86db4e9c708270cc41cb3d52c53e4ec4c7129192b6be60b8e676344b8ee0e4b53137511964226bbb17f6bea10aff805fb90e9c35d3a575b129861dc35b86eb26f9c3fb12f1a0c377c84f3034a5a3811d39ecb93020bd5ef879aa393e7c0007605db11edc8551b15e14d9c37dbd05a20c8b0a3c820297196bf6577b6f12e4f6d6d94a2c900027f71469fea04b5d11af41430bde9bc13600226cb60b7baf2a603f23731df31a3511b55d8f9e702fdce417f3b4ba65906825862078dc9bc0330166c63491005fe6d566cd9edb62aa9aec325052931097d456533553e4dfb9e95865a4dad6a2b6708372b6fade705780d365f739a458c13e6b8ae5f22497e5ad27e42682d305f5addc7438cca8ae7f41291763d299bf8c822456d7cd2795a5d21ea2bfbd089ac4896f5c7f87e121f70b336ee13f4332e7f5ea48b8bc43a6eaf889adb72faa12215873757f02f1d9ce026bf42cb66f2ee9e2233e66a8ff6981f519a754c2fdc1982f35f43de55612bbcf730d1cd7a73b269bf18c31fd532fc3e639bfe96f9e72d63cab251fbbd60da31d3d0621b451c2826fc6d52a0d4349ed40dba62697d1274a76c0c58f59f1f7140d0ac00625737d54a9e4c1084e6bb51b24d64b43546df7478c9c3d0f8575313fd566d7cc7daae9a81e358956b33a078b6ac6aee91b227dd30ec98dd33ceae9c4876acb345ca2951dda0f36243a166a11d33e5579e8a82a0ea4429123ac491212a01b8b3197d7c1fc899cc78cb18231e6eff440e2b58824b3734b9cdf4fbb5ac228d7fe6b5dd00c32158b669971aeb9d24e94af1c299d211d10d40a606f5ef273cbcfa1c1e4c92e9b2d5c2eef026f65043947928d4eb429a96f69a7bab26fcd68e215704cf97ec8b26606581c99a7b014176fe2a1179e35f4b5a433e447b862862b474dc0e24a08d8542fccf474f96e80e14d5161f5d49731a94000ef2c58bf18c6009d9746da70d0224746205f505b7edbd96216f00921b2eba2e7b2d4b89afddf4cc4e957234cff1e275ceaed570840c546c4587527a0075082c1333c8a833f311b95665a049ce1cee1cbc295b34f378d87620c8ba5e2cd4ea2c308588396260c69043fe43d7b7d964bc5431d71fc75c82233d496e79502d284841630a71c3c9383c338c161ac8869af91987f9133b94861e5cd5fb463ccb0f778def30211d14b4aff6b9f572ad979dc7abaf50041fd7003c0c4fa4d06fd1aaa96314b7b259bf3499cbff2a61f148b2bcd0ec83a852eed6aa70195662423b868efdb8f15bdf98aea359bc4c2d4405c0c30d1ec73f070686af54ad6ede214adbd21b88c791afa8dc2d5134c24a973767f993a6747de575277af9186eb3566d03df34586e9335dc77e7f41976bb375505f34e22c773ccae2cfe25035ce25e3dfdb43adff0a171ba3b5f2a92f39485f0e5f9a7a63fb218f6f2df89a269ad1d454de338decd702a58bf75287193880cb2d7f3578cf0a55b94b5a50c62d35029a05f9976643495078623bcd57afa7b70a2bff84eeef2e104fe5d07842db945d572ebd32009ffec805aa1667904a6fa62909ec739e31b6dc22aadc6b586b5531d181b77b23a5790e18af3e22397c44247707e15ff981641ff9919c92ac09fbe7f2f19b4fb6a306df23708cfd0b7cb2ce12182e97f904e0f54209198a66e8c8c675ef70d00107986a844bda88b49ed9cd3d469f3c448593aed85791db941000da140b4a413e716e8b3a1d92817fd91789c6f8cb76607f720b4ad42146a4e1391660dc94b75b0a3232dbe1877f32777809fe47858a53ac11903352518b605d474f39fb15ba47a99eaf9d33f8ed8ff87fb85923fc148616ef642e01424ed436bd8f7d59a68582f88a1010d9058508f99afc34660d4a2a04400f1a05f8dee299e2c6db8f8fa5eb9e4c81d70f23e92e82834a213cb66df35379bb086e09d9e7e546dbd3613aad278e122ba676b19d7fe409f2fcd677fbd1364bc89a4408a301153b0a6a2ef164cbb394f9fb71c6461bf32c198ec21f9aae0c89ba3466c469956da9e96ff6caa25fc3e62a604a241692b123c2fb6e501e64b6e6300f8a7f327f90eaecd98455cc187eb5467906cbd430ae01b6d4f760d4c2e2ccbbc1e00bd3f53e642276126af9f9cb106d891ba6b9e93d854271b37d70ce43e22a1270c56ec626e5ee525a5914ff953117e2b1115b7ffd0187b2ead0ade2ef01cb077b61e77de0c5009f79eeac18ac2ff80011175d3b043346a4a0dd857d63a03b1d4dd4cb7f535147a993a97a62cf1960950a27278ae5bca33e07edac92bb07255093afb6beda54fe3ab774a6fdf1deb4c2a5cead0b3c2928dc7a74b4d15eb980d19a20050f85ca3aed27ac291bf3bb9ad8c4a5a5fe291d5857556199d6dbbba5bf47095ec98b43868b52e6c1ee2c1d59b36eb8db57b00f468af09caef1b8eab738169117c669d339f6edebfa8693207de27a202493e936c56a4fb5d8fa7d7b016a1702c58d3efba27815cdd3977cfc25db4c09df9cc1c2d384a6f169e67cbeed736c143797e9381fcabe6f1ff935ecee7467fa52712c7d7ac5c9eff55e2301730d10db12ceefaf9fc4900078b778f39534f2363e4c22c1a1ef2ed60229838e79558af67fabd9ddca6637ddf9eecb1c295a7e236fd057cea32ca988fc8cc63f33c4750b1d403725bafba092df3df978c880e6ee518d0b43e8853eb6fae22c0f6b4736d56a66c7b99e6b70ec0c65b0bfc5e12c73f08f760e25e83f21b2549549287d77fce2587f2f13503ab754f027304edbdb7b7b4d4536300cc68b8039d9a3ae041b30f6254d62fa3732fe6d6f72f0fd1175e496f3d7d267a019e0b9c3718275387839c52879c93f86dfb678e335ed685e6fe73c65b8e089ee9dae73362c15f362da8118e3aa70518a8d27166426cd3c85d4ab68c7b41d7d79c1cd8cc5b096dfd8d050036eac9aaa9f9122cd0c72dbfe1d6bba3718e9f2c1b15678ab8d34c3c07c7da953741bbfc866231faf27f3f604e5475bb525fc112b4390124b647c4ed9c478f1389369731a9053ebcced461a4a541cf2238745db6d2de9066c77b0d68a8f724c6a0a455a1073c8e39cd0313454778e052cbe0ffd61704f5f65e82ff3f4c2354917a74ce7c5806393f830d86e1a058554f9d97e3aff4843c5bdfa1ce23dc5ffc8ccb83103edd60f5a6078816b73ea710016ea760ab3dd18ed4a918040f439994d08050dc34c96f8d9a5f32336e87ce6856157fbb0f70d874cce5583a32c7f8f477955b748428e34474fd57e32a42e76401780a179eb20ad37a7cc5878bba7a8f8df137122d9733a91cefe9584ad00a25182130374b01d3d26dfc6927646ef2052f9be13be10f4aaab46f5d2b68dd4e21f21a6728e14b2ea7b2830725f11019ae9bb10fc074d813981fa4937a2b57ea2eef391fda67ab2b696577ad4711bacdf71066486bf6ad4b52f3c34fff0fb29b9906255a4465fbced125e28d7d932dbb2ec49051ddfc6fbf56d11f42d9ee6df01666956ad9edc833019787de7d8ac048569d469319855a1b1ebf27fd1b123f387b5d7f415cb9704210b48d8968f1f4cdffddff927c019073d0a462bd68c7aac2ea7027d2cbe03768306823cec2defa1aa93d5e334694138b7d71e4ad92c761b49e0a2491e30ba63117003aa796d18a3a64d0dd4da765bfe0ac5a3badcf3be276a059dac2146418972d7d4623f1fded23242a240d6b6a9c3bba2f675d7d92657e270c8f6029a7b1f424130b6f43fe01cee3b3667407cc534f32ddbd51970c6f2a8bf0532029eca597cafe61a29ffa7c93f1549794622aa1166017542dc3d8be650da9a9ce29f412a3847696ea15dbbbb7eb424e32737a704a70105276b3d8d29a584869f4f108d1a29b63529e66e214a8e23b52f2c9c1635c40814a51fdbc23ed70aa1548a1e3cd219fe2e4b6d6298046993f13f0d38c0c8bafea45972dcfa18c180e84d2e699fd8d0a77e748031227858cecd522ca03731cc0b3a5999af0295c618d4430917d2b4b3ff75fa8e24892b686e6f9d6b10d11ac827b98969278cdd50e38cee0006cba9905d64ed28fa0ab5683cc674454aa94a1c5c9e541462baf987d88c98576cbbfcd3fec49a5d2af129c0d9d97d18f65d0fc9881e00c14d81e8633718d96cbc7645f9bd5e0e7f4b19b1950cd82869dd37d9e4b0a573005e2949d2310b785cc54d64bf2dea539cfd9c16f2841afe51c17dedb62b6b297d6f369730e80bbb8791e8ea82e6256502eeccb41cbf36e7c6e4f89edf1ae7adb977e4c6a5eb186591710b1f7837b6a6e234a409f98d2db2f69dfd78eca80d3b1a72abecc0c0b5e8d2bb3936846241d65232e63c9cf1398857a8f95a2281aa11ecfb6fafac8e6c4f7510826820d1a8c19e35d6943f0a460669feee1bdc7dd75fcd7250e0b0fb5eef1a5d67d95f791af6b5fff82978c8bc8fad60b2af54eecae24b140aa0a30d554d81d969e16d5884d53b17fe1d606dc384074e58a861e152906c8f9679e5a6db7ee1a2f133564939344e24e2abbf0b6487f56ae499b4594358812ec344ab294640563d0d39fcb63e7cc3ad01a17964548ad7b9f7d84a31b9f8de29cc7b7afdf319235a9e395890d8963a5ca1c26d3237cee31dbf0a9deb3437599af7fd1f8324ae4837955e68208f0f3cda78c5ac8ee507e7cb50539398c4166c78c180a3284dd05e684d6932f2140564b6af1c01fa71a74a0766e5d025ff653de6cef2b8a92afc142b07d32aa2cb3c9f6f0810a3869d55d7c47909c5e987fec86db85fe5a2692743f03132c493b3797df7317463167dcb4e1612d58e473e78d974598ebb8aee2c4f769567db2b45332118ea0294c0d65020f8c6dfbd6d0de237e0a127f13e892102007b5f01580f6b0fb5c871350e014475c2cc05ecdad1434b615d8b70547db02fabf8f32da39a063d8ee34700ae805170f0967b97bd9947a1a34398e8d702973c0dba15a75aecd78d998bfdc55fa1e795c6be66eef74c602c0366cf0028ec850a4fada58980abe125ff775828b9e680f03d9a4716261fe265e4c2f31ceb0880478d641e5f28b87e9acbd5b742f98a7189ac65812a99136703b7d5632a3d978d308b769e7b56335bcb51f847a7a1b4d5b7446fd777df74eca6da506df6d856f14cc65c6453f30de2249545ec694fea7506eb63b12343920fc370239bd58c4084d1d95702267f7485d6beeba720744f9af6e3e5b7ddc3413c44aa05fc9bac4a2fe78ad2c7499f01e7c4678c15224aea88f30c1529f8f10fc8fc516b84d0ff6af5daca6972c701612184327b9b9e8f7f2e11060e464bca2d7cc6db074e237424ff2d10f46770d22b8152b569f0ba4c98de26d3047f97c38f5541d4db90fe96ee6eab58001f747816648b70770ec6f18e878fd597d60aaf5b067d509edf0e45e630addefe1178869d19f5eecd55a46ba47deff25baba0ce835a816bb0a2eb813e3a6838f6fda8db7d8e53e9c66f3d39171c2f46771e6cab5a9f7fec3adb6158c63e4754314952edd67435bd8a3a6c91e7c3594e7eb5272d400c17f058f9bce300e096157b7d73b3dee0deab07e7fcdc977d3846205c2b8a0a8f1a845f5879eea54bcfa54a633c17635731223b53d4cb98212268f23f9795fc5777b59ea45ee29b2997e9fbecc397bd424ccbe56896b832f0035c13741227c4939b00e98eda20bd1dc6d9b88d968d2f5afacae4feb09661d3cfc75c91bb4ba1a548647ec6e36bc888ef100a13279f9daf611e92fa6483923234d45d1aeee50e42ef82b7c0cce743eabe522c60eb6af0efc9cbdc53be4637b95601d47cc9b21704f9590282e4492cc0d76e5a659b825ba292fff2ce0b5088c38ba3af7681cbbd4dd18eeb46b96e6455f9546c8771d4fb7ec3c53cec52b1b6e35840becb3e94b24d3fd4f8da8af17cdfe7b107b106178e115aa065de6982ccde75dc29f900214bf9564e25551c5abf68715611bb96470cc4d6d05eeadef4ce1871ebfb0ddb4015a6fb2a330c46c51c1cf55e5f8253a1c4622ea908fd7a051bf9f52336ff065e926eebcbcfe3bc6e251877a226ecd55433bb86b3262b8e54008980e88da7b140deee65ff4d37f798280b781b17fda18eff78833c34ca50d494740c6c632f556d905fa04217c2f78f40c760fd99f7cddf2e2ca15fceed2cef22d89a2043c8ae91d736164a904bda9955d26ba0c14bf26522e862a4632b25e14b0c3c64ecfd69b6773a9fe64b8b4b5552bb35ae30e81ec95bd868d183e348c48390fdacdaad4c6823eb4d4f886d044d90203a0ff81d7574954d6ae9670f76351f9476c33cd1ce254e7512f6cc68cea33f0d204f1aa78ac8be78d9492cf9994aa1bc4a290f53d786becf5691d4e15d7fe09df53cf8b90929a54d8501178d01df3365ed5b00a4464403e70e2761f068dbf35a14bd6a9b461ecd4da539c495cf4487c22fd868a6f2d76df59cd783cc0c3b899c6dc06431e1871f2c1b3591133aacb1fa8b2795a5a8a72376aa8d5f521a56cb96fdda1bd5c44f668767a9a811e6a5e31c34be7e0b379fdff674a36c5478dabc7b82aeae7218a370bb71f44418ea469299a146cc7f77664e2cdf0cdae9f796017168dc703e25953f98b6dfe6e41900d88a4402d6bc29c796ad04ae981d41385a37f41fba1c528939999f15b17f6eac73656691345d60401b5b68f2032d2d69dbe8322107e59f3d74f81d70cabec7292777830c1a7ad877a1390cab75b28f35ec0cedb3d2db37bb12eb88e498581b89a3786ddfcac7d05a7da30d64f486f1b60a4f112073c0a0d53b800742404248f9006afad6f9740119860d0eea59b5860669b44c44b4b1824a40b80effcfc8af1d845b9f43105e814f961fc752a115d374031c9ee6d97dbbfe1d74b9394ea4308491ef0df5f0e1d35d767cd6421d24d37387dcd8898c203c89a357444f5e73eb2e8bf9dcd528b62cee4d2ceddd855cfa6bf1fbf29aee9da9eedbc5efa726b72adf13fcb18230b04f6d7538e54aedbc245a9ec282f385643a65f1ad6c0160ec7feff5b27e2ac0fc676396286721c341725bfc2be3acbb1ea9a1cfd801f2f2e02d862eb761bac6ed381e6163864278307d800d383cb6dbea1bb2bf7d2696c6708f56992be1b96f876b74602b06d07d2ccd608eb055f3443929abe74ceb6e7b4005b47b72f30fdff1c53f2c6c9fad2359f63dd8dfb1bff73693a1ded9e7d0e70d35eea827a027e7b2ed24fde2157cad696adcc36c017345820f57c6a312ff9125a1b428f717625204ed54ed7c4355cb39296f5ec481f92b6100b3b0c4fc3a85d25a5e9925149f65a11f1daa5900e01ad6f3097b22e0f8c45b30efa99b4eb20ba4e40b2495e1bf69c1b0bdae1c3529d1b5fc73eebd58f6936da3ca52b1aea7bc2022ee3962ad6e4fad03456a7a38525073d82418a7c5ac937635b1634580182cd4fdb667ccbde4669e48bba6dd040212f18b2e960448535d620ea6bc17dae1d21f027a077de805b14e8d3959af16a49429daa3b5ff4ab17c3cb53c181fd8c77350b0f6cd94c4f29a4e78400bb104434f5791a03ceac81eb5da228bd55c291f7e14c00fcebb2ac83f2520c1186f561387bd4f61150d868fd3583421a7f580c670234c9e8ef153ef131ede570658685ae93ad12c6dc0a47ea514c93821da83b7c31fb5bb1f4021cab991fecc78681afff0ec843319af05616a3d0b05d43c65f6ee7bc852a4995f9df4fcbb31a3c445718c030a5b8385ee3c7c457a6a25e6182dbc6c11d7fc4bcd9173524b7e5f74f8e6c846897f7b91edd4e0ea0eabe0c4c332bff647345cce54cc37a3b1c73994fe47b4708eb1c1858227e3a58da0443c3165a2543d330775ba7c7e73741888942352171e184ad541a4502bf363a29821f71633bc28c76069b5f25df78f35105dec65bbdf42ab6b840f762867224513a139eca375fc8080290197bc5821a298a59510189d74a33025c8c3bcda3ed9b29cf04f6ad44c90a1821a0763cdaeff1ae9cb69257e6079372eb9eabb4f50d040d93a1d8a66110f41a8483bb5141ec33ea3b918757012e8258166a9d0b4824edcfa3ede983ea3095028d7b3c2dceb8521530e5a111db24e7403c34ed76efa9098eaca11248758d933a116a6ca98532bc022d38f6b8ccdce8fd6b56d4cf96900e7810b808f4062ffc842301c6b6b4283e757c3eab0bd449a68f8bfc64e47b524a407e0e2ab93463667d86fb9acede13ef24b776d2719de233900996f0cdf2075f1ddb0e32307858e36a8d4535249eacc79a35129def70bf9010a246d2722bd2ff219f56de49150747809653699338f97a27bbfe36e1750a0dee3c546145fb28d821174b0f643085a007ac0aa68b03379f25076e643f48bfde43dbd7f85d0e99e8c81e20027a35c6f2a8ffe044988fcac622cdb52053c1b14e2cb6b6df2ea7e1e98f259a9143acbc9d1fd3279ae423ca0bf7cb26b9954a9a7f0595a28a21d9a9d71808f74d4defa6cda1ed8dd60ff82e351825c7a95a014e50ceab101775344c682025b74a8932995e600276a33cf5d88ba5c68944d91be70c112116e24f7a4002b88b9e86617975bb94dc8451c81eb3d57323575787a0fac6bd9a80ac3408c26879fa076ece86bdeeb1655caf880c3c43f96b3bc67cd6b3d3e4fbda1c96bb5b24143779169a3d67cd5fc157b97586c9fed38c51068dfa3df4ac3f27efd5daca539676834b5099e299582e13a95fa1c57ea46bbb92c037407bbb8fd3cf39b20a4f4883abc250cb6e9ea94d0a2b7b2cd44c40f403198f141d8de584734261392c188f06c1a12900065c5a4518c8c7294b031df2df26f961b73afbbecb982405fbe7524c12011d13d6c6475a9c16bf752586a91654251fb13f256500fb411d297a357055ea466e2c3c30bfafb7394391f96def88743ce2703a0787b3acb2a9aa7f6b8d1d218e138bf0ad3c32413ea04e4744b166122242a96d1372116287ce10f9c000d12c14be43ccd9b7064615375de92dec7be9f32bc6356137d0a948f4a96e10f93047af718175a2cf95f4dca551c58860ce31b59fc8f606c6007aad8303cff0814a8c2d2f3cfe7ad4ad31860466ce8760252f14c28a7117b8fe44d0849ed5e0531d75c06ce72ac60d6fa905954665a0a9e101166b700300d9873397f7435a5385798abf17854da2d9ccda551c098737a8852bcf24bd8a5f0100b373c3c2fe8f1347707df8ae247036b0a751f76548bdb4071dbd02682012e46c9cd330e6058dd3b56b8afaa02cf537c772b66202b7a276437ad7be60047316559e8d6e4471af9a21b03556f36f7de3ce54f996cc8da5b434d58a7154820778799ccf641d6ddf9daa3ed38b993835f0c4cd22c0beb9a9dd044fe562bb18dd86e92b76af53f5f121221b44b15432aaaf845e6bf74ea4916d17252ee7afe44111dff2b392060d019e5b1f673b173fc888862e273c8a8320600892368406ce07a38eb630fe854ab47483ca4f45d0affbb862e4fdaf1d0d84542c7bdc71169b2ddac17a315f73f806c0e56862ed84edf87259e8ba99da5703bb34d13ecf330083c29589d1cc82ed859eeb1f9c9c9b13dc3e55473f8aa9f5190d623518e3e26cc7d4969896413d009e4f070f34a14783d05465d973e6222bc5f3c2f0f72fb1ee99922abf65b2cd46e36697889ea6e969161224af35499d6e4c2cb231e56f03e9935685548acd719205207f6bf659d025598aeb4b0c9148db86a922c44b98397ee5377852b4c1faf02b453d139fc30d1426cb4ca67dc424b80374c4801a7dafc3fbd037dcfcff5f023923714a4b7ed73b37970e469c44edf3a7d711e013f118e12388fc7c82ee5b18c3dc9281449393e850e3c3892b9a8b5e6aead0efe3d7fe559c1aaf4e61f044b09f5eea61f9ac0cfa71ee5a6410d8f6f36cc80c1fee723db1821a171884e779e362d467e719c6056e93c8fd6b11db27fabd53be38bf33711ed9a35bc7bdb99b8542e9ae137509d6bbeb11caf27ff5e909fa30f21718d9269329686f07f3e2ee334f0bc626e69e9620af2211825be5aae32a929245c683f619c7ccc24fac18f75b9059c0057fcab275531668b79e13406e0d352cbd2d4b8c0c3bbcf7842d894bbd5f90b97191346bec52d96363fad1f216a9e6b85b17cc2301fe20006780585f9199e0ddd8c7c28da0ac8fffc4866b9dbf0e4d9c011a0a1485e4dfb23b3ed20763a97d6d32cc5bb6890dfe23f8e2bbb5397bf320ed9b61000215f7170f63744b9e81bfa009746113d0ed8238eb958a57daf18ff090157099dd31d256b5b81e194e7b5bd776e36690e89ec12304504c5a6895d043920c69825296fe286b3b692d25b6347e8af5404469a4c8ba5ee263c0d2e40d7b176170e06b822b4339f2e5c155e077098ebc51ddf735fc67d747509505c4f6cbf63fb26d09d7b64cb7d975ea3abd7d71146d577b3bfd40c2599eb3445ef546c3b1f191c996e514c8e110682a768e45c99fdca23909a63cecf354354136eacaf09272e9f9c66a777a727bf31e73d30c5cbd24d98a5dd00e5392d14d5cfa2fb488d403ccd51c92560b85d15d3dcd96c233e5653adabf03851828b185d362288d03e956f5bd780b33eb7c55fb57e2a9333c54f4d31283aaba226666fbb32c6c9df33980c942c79336c0aacaea32b60a43e7aa53cefda17ccc1c378696f96a8d0ee1002cc17d1dffd036ad8a4fd8c3d86117137f3208cd2acf29887b704bafd5b757bb8731295d4b13948f51c8a067952b0f56e47f4bbac169af5ad8815f27a1f46f354bb9ba80beafbb59aaac5b9d8a3e2fad01aed3e7180cb2dbf6c9ca740a1232f9a3a248fc90cd1024420f559603bdc1a0ab13d0876189cc50db0de4c1d6bc4d2108eadcb3a1aa02e7bf84a27cf9eb11035c60bf2b3f782f0902f5b0fa6464549bd620f08dbd8486021c5bb0273fb8bc92231b512c38f7997969b3c9ba2731730729f59fa811e8aa6048f0988f0bb7513c2559df395e48118e267cc4b84cf2312bb20264c5f0f405e9b3a1286255f80bde8d74239e263ccb0e67e498cd3d4482ea29c303bc2d788c734d2d3dd303eb2a7fbd8861d6203386544e69f6585481e02c62ff77434526410680d39eaab0d0d0d966b142ee732a1e43ed7ab751f4bcd401e794f3feded5350c82c1db33efc559984b35db22140ec8b40762db00be870b9c9e2703523c652c5bcb36ece9c19241243ac811ec2a92b6ab7e470f66045a668c3c42a015732135aad0d139678415616dce33fca9212c3e431c44d4ce4b8b89328c7fce7dfca6d4f92ace63083d0e7a3935e9ea8e022242116b200dae840879e40219c4c971985b2680c765520a730796bdbeadd50c86b37aad502c07bb92fdb7641e704bfe90c5d75ad34832c70751ce0f968146097204fa18244a9478fa14b3ef8bd04101b3bb9ba71353bc86914c55f80854084425ed6dd005962bcb3065cf7e150cac808eec72b16af3dea2aad93857c7f82457bcb3c9742a64f31e1d189250ef21c0e7db209263930ceeaed61ef0b70800c5b2ddc32029be1f2c5b1db831e278fd8a1cbe9850c05923bf948da47f03f764fb4102562a0f74f45c7b1adf75f1846b432db5d1af0890071cdac158b25a044af8ad8b8b062ffa4f1ae49c0f09235db2ad247be0323b8f8cdd8af4f1436c01a1d83b6bc6bee8cfe38d2fe3c1ce4862081f28ef40e0074146f0e0b42c0966615af66b4bb7b74ba2f7cb1d1c431e0c46796214589de0ed1e09f063a8704825c5b0bebb655f5602dff8a319aeba361d395f6ceb21a762c7d48816ca77a4fc59cfc2096d1a3360587f24da71f281f02bc23dbc653a06424ab6cd2e285f8908b6660e1080f725016781decbea906b6fb231f5c1673cd185c104a4f272463c8d4853543ab89630a0624036f65ec2bb8c360231eb14154a3eb11dce809eb79786c5e73b8d3368c6b7dc979bb7b322dc28b0060c946019a6a1ff824c0f64a072a29e700daaa430cd9549be200331877a81df4e86ec03b07c8e20bf29687b437149d32636bf16f73064a93f30f5e78640c89a24b9388dee992957ec56c0695f8552951448dd7e0b5bd723802e695873b1f134742098076254a98abe95e809d470e16f00daea81bf57cdc0c2d6ae7f3fb356b3bc7c29438bec5f0efa3e85ff0f57230f097778aeec6e5c63a00f38ec1fcb0541f4646c0d2abb261f0e23d60a33103b2fbbb4358eb51c77501c61f5fedee4dda88d8e537b88dd329a94cf05c4d86aa48f03b32ac7519f1e8124726d1a5d99d69982bb66a4923b947da098d2175d9d6094d17ddf52a52659fe782512938becc4b020bb264144ed0bce97ee062b26581ab2b58cce1e746a0a6069471b98e56c808930984bdae2a44532cc98f0c712e77d01d83e219c82243e857bfc28150a3179872ec9350076ab17c30c92482d87da505cc3382e8a9bafe517a3e725815b78b6851c5e47a840c08a9cf3bb7bfeb00f0d8e2cbae4c5cb4a09d54b8b5535e1bc47d9a0b4232ea005b4d61a16682a46180128aec4c70325048b61d1d7e4b3eaa17b93c15f445cfd80bf459908e8c8a897b0200216178f53cce6c9626434d77a4174e4b5be1326622b0733d5235d9d717d357172ddd4cd76f894dccfc55a5065ec142c9e230f096e7773b235403807e92b16f7e8940803fca76d6036098cff16e7669f8601c0429064cc2b4e3624bd9ddd139e6d0aa278b18f28bca8f8da979bde3995559ba95fc5e70fa83b77ac8bc4c2e32dad98d15b98d2f73691d372e4cbbee6152c5424bc92b2471d8912b4fc0cfcd0805b3e63273707ed73b5fbf2190b7b7f51bed4c2064146d6edb4549ac12e6fc383bbb4b186d547548e8640d69f8c9da9eb679b279d1bd24b78767d242a28c18081c9ff02c9143fcda7c42b3467150fab84c1526292a01accd65cd650a207f97ab24b3b4f6e6d95892797895e01b79888e205216710a62f71a21f50e7de35ddc27db2bc334cfc351216efc3fd665c234939fff30ec8226434251441915868fa0fe6e31fc06f7bc95ca3e6cd694f83af0d55a5f7f99fed36cf4a74707b1e52b777cdf5cd5b98b34d673c2a75aa3e71443402a6daba237fb3dfe3f70900349f2e20e68f912bc481b0fd679f2d91f04d3c281cebd73efaf47d7ffbaa48a2b204c208fb24882aa9dae3fe2c89ef6a84547d2a46ec51de7105644d59ff28dcbb6c6edf4dcc7e4b4d56f471f92c18926b0833895640eac52f75ece0db1dee368dfef3e990ad87b592b44f9fcf7ffdd84134574c8db4eee96e618c017c2018be686046f92de1fc608273315fc6907339b0794f12b15a5d24a7add749b197c35d5f0b9a975adf18d4303e3d432d8e8dd8f442574465bbc8f90018b1378f5c74348094e6173e0f8673e6aa97311c56d7b2f7894e8dc6fe15a08c04c212f70b3e3e8bd1f358a8609eaaf22ba4261a9508b16ffbc018207b6cf43f0351e7e15c3b12f93c93cbe234961e49c62ea6c7d97bc9230fa5864c8c2990622cd79f07848150d88025c2326bc3da9e020e96c8624781d41588e168e2071574dce0aa5eba97847e8b4518a380c521ebefd0afa5496234a916dec68d72784e011f95faadce65096586b2ab32329ce94595621a5b621951cffa6ccbffea3410635b0e666c93debecd190df3e41f7266543eb612378f58ceab53252e4add7a064f6a0d1c0f773700ab53cad72ed814d73399699244f51a68a719660d2a83df0e68f4b446a88809202326b76fba8c77a432095bf9ae1348168c7f2ffdd6ac5856f36fcb8f702019535a1be9e393c1636d292f3a0b90bb65a579bec238e03d6b38a1df947cda7ca730f94db07d995745f6541dd0e5a9dada3872ef37f48f503b8be530a01171d41d139f2709522c30088d8d3877fcfa83c9b7ad4be220ccb46c0a63009ab7edf884f54e7f8ef9779812d789051701edda565c4786a3a7437de32dcd36214a6a9d896bd7af347317926081b3ee8c5e90ae674fb14e580499086e6333869ac9dd666dba774e3268ebb888cd0ec873de8839e25b0b6a59827c3d9e28d5b6245cdd3583a9b94c4db60386398b8195bd914621332a1dccd4050080fb233760dc1783a0efe1c79ed7c1f7ecc0b3ff39f1e04d1117a022fee80e7d79ae5e36ec8362f469eaf77f10cd7ef2329bf3845ee5f4fb556dea549227ea31892d049c900a319f99f5ed9f77a1abad43a3fad4bdd18d07df73e36f6cecc1ecd3f05399d6c8a0dc589454d6d612eb75e8fbf697783a327d0622796fc8645b76635cefa8f0e89c741d5f40e5aaf25e6e0086a06075517dc2564f24241109603504b914d05ff8470bbdac655c7af7cf0d7229bbc062dd50c13694f4171419d2f560f082fbc29c513ef015eba49bdb4f22c9da81be5110417ead60e15fdd61abbe6fce8e1df5408dab176a77254e20903c8ce740268c13fed695fd9de2ec543e0a314c7e2a15aa40a60db9a7c572737e17ca09aeb48cc3b38c43ffca01aca802531edd812dfaed5f7e3cb1197a0f3267bc31b1c5592b0ce878ec4398c188afedd7c062b6bc8781f4bd64606c0682e54e3cd12dd5dcd893fe5c467d8c2c656bf43da93507b8a86ecc069c28a219d227935a55590937dedd77fe78bf4e8fcd7f23c639604433a621f0c3c5dec4675747b02f7e5e7bb732c17ccbf8849806d0d9671007dedd170e026cded1a19dc169a079f54da94fe22ca2459792a6908eabca36dfbedebaeda28e99b2d2d11817fed98f0d90222ebe2c7061ca17b488c49018d6466b8ec5320c4e751cd4fae7c6069ecf5c7b58a4167dc787d196e505ba5f1422946d5aa7cc68b70abe0d7e580317038a2dc73d850676751b44dcb7d0e554757a33223c0c2d31a4c19f0aee505ad9fe90953c242827fe5453af781007d54dbe1aea263d5d83675310af1d2d96b99344598e28dfbb055a65f9f31e444bad3f5ca8859908c83aee6c7d64df6b07a1cb7886abc32d5e7c2ccce20591fe2b7c82718038d8a1f2130e31e977b5d10617a24ebf36e9302c720205c778b68800c10ab7af4441e5175eabb1c11843640daf02f752d3a6e4869886384b6341fde6d93c53187b8f77ae9a287327fb5d806626af2b8bd580fdc900dacfcad3904bedd9c1187800f9dfe8e1b68b4969a754d0576e02f9fe966040c5de3f9c7450f8b52fb80f9f6b3e610ebb461028a00ffedfc489dd03c523d591f4c2924f5ec72b322cf1368aed26ebcc7e2c3b46ae7cc1e2acb2d99c66f3d35501b591d94857af3f441d04e774a8029d1839ccafd72d7a2490c7338b87ef39b7509f53443b260a4ff32e40eddbdfbb30e2426a1ab07f513479af08fcf3dd485ab4543678b5a46537cdcd75602c5df176c8cf0d560b05c591b30dbaa7ef5e3a91a6b2336b8af5efaaf72f5f30b54600934fecf12971ee009a15958ee9f1a3651d6d5d3afe9b7d6e4e6c6ee63ee8729fd56b4b94501d78cc0138a23bafb4c4f166a7ae521a317faafcff60fa88507c8ad75c364bac45a0c98291b8c86641b23dbabeca4dd2f60b97b2cefa2d540bc2797a4d73c9df8f4e4b31291b430a1349306e1f2d49f79eade67e9ef5f163671037d4ef83ed2e06a454e1265a1b175b6ca903476c9aa02ca2cfe677ce1379a9714b786da301e066e2b710d8f72957593b4d336aa56a99d13b55aab3a12a1dffb500e21bc5f8aee50f2453d97774790aab4ffae436208d2518e305ca2c14fbbf015c5c08cec26ab44f03ee0b7bdb04f58a9580901c26595fe92709515412f05d6fba66d8045f91da50eaaaa7d540158b1f8659790b2d27978dc72b3271697a5d89f8a8f5c593e68c85733e57f6507c2602083aa8a100fcedca8f1df75eac66b0756051d87fe40e227c8f50c6295c3582819ca5037b259d04f12ed4fec0500ee8b766ae447390a042b34036d900618f6013f9da20bacba5a7f8c284b3ce2b167850795b8fb3707c645e0f328aabc618b69c02482babc75e5b2e8eb3963a121c317d4db095884a138edbe9e0914e650ac3b6e1a5d8c545aa87c32da4fbcb53505be58aa0611fe8226101272a22aa09ff077f4251959797e00352052262a93344c2fc5e27109c2e8886a0c8ff03d5f0ba6f1a580e860555ba14d6b0231b08402c3b37588fe390de88f2809a083c698e716cbb1faa026933b965c9cf2deb85eab2a376c2c46fe79e817f01f5acf4eb7e7db31ebf0ee3c197993aa4ac7b0472d1e4f3179af9e11abf1f8ef2fbe98a780373d80a1ae45328339c673add26b31c3c4a7bd3abe60c8400321113fb3293fd011dbd1a5b7d1c080ea92418517c5034fd15c2c84785faae8d40c69f96b3178f53cab03912963bceb9131582a646c9d61e2c2449e7f1e54edb96d87280a9a8e869adc83facb0789af0683796ff8d1145ea50f237d08e25a2c2b9c6c27497971cdc520a0e194dff0eef9d11f73f156a70ca82a1aff48594abf32cab716462c681b71dc25b1350a218ebd1d5978fd6ba4b9852d33bc785342429a7ce8122bcf724fe241d58eeca0f71f633cd5da33e24b945a5c69507f0948e43edcc0e001b10c92a8d0a85b147a68df501800d67847b966fceaff9cbb4ae22b19c2b9c0a9639d0dbea30eedb9a97064aa43c2101d02e6a00e8483bcc6c9e4359826aafa6d43feb1bb74b47bfc0eb8161bdffc1e70faa46145d2b9352e2863aa19dcfcdb394ab28786b671b35ef2988c4f403e7b47e1ff14817d10b43347560c0cd47272ea074fe17ef1f86afb3bbfcea255efc83307b8d9bbba9b90de75405499ef3a37fc143c0ec4dd1501b925e74f2ccf344281d68df6577f948504fc6aa5e6c761cdfe2efed39af7dd928674ab80e385d5a0124fad9cd951a4a7fa30bb954c1c9b655d9d01a2dbfbec1a559e7a91a76a9df2baf30772e6c2fc59177e7b302f6bae366f4f6b00dc497178bec803ef0bf7f5dbc1466f454ed733a3d9d6e44fa50e00b78bf18b7d7fb90cb27be48a30fe201f5ded18448e5fd19ba9127cf047d04c80baca96ab1332c5f22f892a64f30d18322ecc7a22c1c6e68f6b843c0256a157c47137f53152508a498067b618aca0061153400cd3340f3ec23b7f464f570f466a95d305e91f856a378f5ef94beab753cc521cdd027e36a6eb2754f3812d4c55290bc5f89e06936e541467579fa661b543fc674bf335406d232a933ff1768805fc8ac1fd0dfd5d19ea30eaee644fbfaa251aab2886e9cecb8a3fffbd1e361d8cfadd706e802a1dcc5d07c007360ed3019c20079e1a17f7bf5d77b181e88b6ca30b86f8e72bd78e9e404569c2af5a29d5fe0fd30e2cecd7e04621d222f103161fe90c377e2c547a17ccf1097bed4716ff964c0262ac328794ba953501c6a00f4df2b02c996e55cea3427a553cd861f9a559b3c910163de8ea2134c57e64902da0532b6e8ed1aaf90a3b9ba0c317c302752edb8e0e784bbc45ffe0554eb094bc6d11fc09cac798e678ce69428fd10affdd98d0a605d5310ee16f6a845ff3ff31388b529aedb450be28fdf87a803590cb76dc1ddfb14f6b7159bac63b2f0b8f1f28f221e569f001de322f78dfd1599faf344ac85742117f124e503c58d1b88be49ca2f6d1c1c2c4a00509ed6d8e9d5edd385fbad1342f98b28ef23aa8f1c53bd9bcc248757ec27e573b99977626a55f58cdbb8db0770cd6b50f4f67b26a7d52d750432337faf09fa14688f7446f0c9bd4f8329fb945f7e2645ae7530cb19efd0adc18c84aaa70fbc97e23adb52677e487e1e9575b5a5ddf0143c85f350e0de815cff51c13b6985b6265f32859bab69322f515bef806280b06e9cf63e70c3d9b58036086438a59b8b9c67be57a1ef4624eb6899692ed6a45a3ad70825cd40c718e7a61b75d9e371dd08f5fbd98a09d07bb81a6e5cf2f28e841866620e99a9f5494a9ec87ba4004cd59f6aae11267c15a30a49bc96625cd69a3c8b5d0a5d25fd874a0a5fb87b2fb2521d0c394501d88a2042eff519cf8762a60181d726fee0be170a360d7c5e9d4ab3b748802e8192768e47e5f97e56a6bea40f82a953903bc063f7ed4ca4781ce9fd5f65d8361b6cc8aa5c33a44c8002fabc08b058f2ccce8db70f9ddcc7359c46436217d1c2ae9e2427033c12047ef99262488e603276bdc5a2fadf0a934b69e6ca2c26acebd8b8b20b491e238b63d14b4c5c9f25671174dc26bfd7805862cc86d81b949277b7c61791d058be430fdc5aa927a2a9edfe60987fd79dd5a1c57608391b92cb7e181acdaa2702efee0fec89136377a31230e18708b21e5a0ff3cb85b288b14d8239e0a7c3541c21193c89a7d4e73502fda6e335b1d09151102e0f4533a51ef6c4e5a473ebf6cdb7eb0ff60d27ee5594fd2f84f7446c39636d5bccf247bf32a3155c2d09d94fd846759f63c3597cff06f7178ad4941585c4c381372fa74e7708df0c92248c06784d4e2160506a2e50e1321f982fbcd89931324691a0676a275f4feaf318ee670923b337e82e4d0a752033091a66f9daaeacf6894a208c49cff821b410d17c278134a6c7ed11b57aeec88e3a2f97f01eeef71566cf8cebc43138f7283b5a00ea033a2ba3d87c115d2a495f509157b337c259face42aaecec5f415628331961525e95c22c4856bcd5a0572686060715c5035cac0e67bf1d5444328b1d007e7be1bb8c1907120305e6be23c671e1ff1965083f73e61344a33deb09aa458d3677670a575641fed5108b6c1cebc9199e54c32c1e12f5e6242e893615b442d8c758f6ce025c63013caec43bb98d1d4904c4cb8d76290d2667d8e7b09d00b2dd300271b4f9d778aaa2f4990168d744e20256cab5ee874ff3f7903cf4a14bab84b50f5a052a8cbc69ee9f8e6341dfc5b4ec3889a5403661dac5e3de1e16164c45f37400a8c671f81a66f648495f87d0423f5bc2b2ebe93195b07f88b3c00ab4c6731c0966f22ea8a2306179f936f60343a7245ab04996ce60f3a3b43f6e55c817cbac989945c545d8026e1928a4cd629a194526dfccc914b0e80e161e4d8faff2053d2932232598376d0389f83c700e7b05f4e2b3ad03603f5bd3624f4b0d5dd3dcafe81b1618482a0d2db29a7a9105a59e4dd310a297c8b143a7d24bff8bd8eafcec771d2815e180d36354f06d75cd61a84f072548204102226f02b699dae72132869149c01e3504a31f09cef206544db28de8c8ac8ede33a5d01478f84da6bf25b729390874e2fb7fe5f4ac6cfc45f4b893f4a5ed2a6e3a9a19fd4e7965645a99a9bad57aa4053941a16f3b225814bbdb26789b866da98a31e038d7825085cf68bc36396d6d93e7e2980d38ca8ebdf5da44324f2ffd95ec8752be2859ed27a7aef22a37a41e7c49f5a9cc2aadb6e0cba1cbf9b253e0b752dcee5dfc5a852d041b4f5cef6a457dca3b7139bbdb7e44870bd2a01f11a3c44c0f41d7c85ef87f3997e152d037a1b6c236a0a55011bbf13ec5779ddfbfcea1cdb26bfb1b0bb22d0de247e7b76e894fa880fb88a2bd9a0366a8c4492641514c1e3bbd56effc51a34a8eddf42143c4fdb87aad3b05e0d70d5be9aef1ced945e8074c9ca9868d9d5990b2c877ea6717ec8357891e83c6dc26bd72deca562365dc8d1e6d5c9e584a8de7acbd167c800954e66d0f80c1c8dcdc45c55fdc394e3b1e01d6a4625dd3180212c738b20501b00300363ed931167bf8735c2a6d8bd1c9ee41f1d1d807a78c569e494191d21c0c769cf2b86167355e188b3e31b356c85b061c88efa093e54bd9b0135058f910f7f451f8bf0cb5f2f4ba06e458dc355f91fc493ba889843e3ac8b5b6291d89fe5e20bcbbd64f56ebcfba9c9f16e085dbf174b977450ca8708dd8682acc992ef05f5de505c975ff02d98c8c8692e846c43eb785532a091b8cb6fc88e3d04404fc43eab016f225b07d221e26044e913e3e310669f8ba21f81e6ab7eac91f24b2bf350ef3b572cc923f127deb15e6957bc7ecb36d1a1747bafc834f694f5392f48c20f691eb994a70588e60abc0a48554952d39fecb6f3d5f835024b50c4b3d120a50e53503bf07489c9148a71e3eb5b0da2b410cb507ea5fa63ce3fbf72e1e72cee5a829ea0f45cb46afa282f8f739d48e7e4d02ef22cbad8def66baef11943c17a62a3f9fb81baea693a40d405f52e7d792043be394db4f3d612e7ed6d2f6eb02f30a630723409d7a3a6b8d06146a356265cef7c9fe92d90e9283479c73c0214e348ebb6a6ea23d69b0b6cd311de35ae5c102df69d2bdd2bcd1557b341d2cc51be8a1c3fff932c9a8241c84616f6cc806d6d48f0e39909ebd9f8fd93e0a6259a57269c18546ea51a6397d79a704099a0ee1c9687f0a601d4d8c07b086e98971eec943180f2e555470ef72021f111580ab4eb4e70de8711e563a2751dda4bad675a5544af3bea62717a43bfd5403104eb4d4b869c31fda42c1df160f1e97505b61fa77321dd931787a009176908bea207b58ce3f25727e8981bfd598d8a52bb861d26d1d2daabb51dd632103eafb7bab821199774b4017a829962300971979d994f36fa02d83adb771ef773966859bfad856c1e4e11807c3688f8b449f7ced8391ab38321f764dc4ab8f66919359365bed1969c78457cb9be5c5d4ce33c6fb5f44f0d4f703cc55786ecaaae5a0122dda91e3c133e3c0ca4ee7f7720bf0514d1277c01a94168b2c2c23df325d1aeab88319d9c3ec47ec9bf1604edd69759dc584f57a60913cc651bcf286c2a93e650ba7fa2c830096c18e9d06997fe7e6a6d96ca974e5d4b305e3e8e4e74411e15a70149b4643dda364e6d37fde4c05ce2813e4e198ff5c29bff9950ab31e4cdcfe27a1e72605f86c4013db4a3cf4b7f710add8de1bba64eb45d173a6b7483314e8de9d200bf2287d41d83161839a018d0fcf6ec3ae3edf1d918dc7fe77dd27925e7b194fdce7769a6f44f9695a9f62c5699a5aa787d9bc1fb666137e9847dba18bc1f26afbe0c30b2af29fcab6060384c3bd91210077729b7d82f5715cbc91019e77737f0a35711d00da335414ec7d7d116512ded7c11140acf9443a26cd47668159a56aac3faef31cb38c4827e834a61f2efd40dce404becc74ca8d67befbfa77c14ca6d9072deb025f61bd78dae0848495a10c890823c3a34e0c2eed89941c32b6f4feb5386c0499b72f8e4951305bdbca6ddfc5d6038d93566deb9629ccea7f4a6f9a46a80e28b16caf47c0a6395cd37b7517c363d9aad5012f67edc199b93f2174e9eedd1186f83936e07f682ca4cc1d7c7b22064d6079f47fcd9cdca43b9bab76c873f7f4a5a6b46767196133e43442f95c486c03ebe4c31466d81a5d8a2411a5430267ecb315b9694fd380e10892605f35a4181b5a34b405eacb3813c38e8b16e0db946ca4c0d488a7aaddeb55cb8cbb05fc733f7f298ba2b49458363bb142719a48f76087bf21749b170dae4af065d810645da344f0b148e57b199bb904237f858991d9d6f10b52037912c4975bda491d0126528289a5bfbcd9cf37203163a251840eb2fc94fd0b44f979673a2a59fa2e69936fc6dd85a45d3cdec6b2e5c7e7bbb03d87ce278f49d6dc377a14037281f466111d9ca6376c60cafcfa81ef171bb02c9486b9ee5e998739ea3fe5aa3584987d6533b07402d40fa11bc4112890425233310aa29dc0124309f852c209764c75a05699b834f031b7b9a7df73e427a5904aa1d817d33b9539d49a28f04eaaf05e683d9b730e5c62b2ae532134b5c71aa4ef4c813ab110c0e9a6db85b948b6de3f408bfd11313aa5b1caff29eee33c39b9e2762593847596019588b3a40ed116dcaad88b779cd14092d68b03fc980dae3394e1f5eb6cd542f612be2a30ade9b45b513eab857b93d09c302b0f00a2979c4a48187dd54b4a83d18916048ba994d14f11d142d84f2e6ae286b83592dd9c42f0e4865679303a8a9a00bcb34340dbc7dabdb7a2e359a65eb4353325364e41cdce1ebcfc626d1a0def895460ac78bf6568d0dc2b02b169c36cac28f499308d98342881cf4b09872c2aa23b47b9ebbdd41949446e72b5a132566bff755ee0dfed0dd604adcc2315beedcd7885717f71a99e6a6ea9c4ec169bcc8712a5df435687ae3d3519457310826a42bc1d680db868c9776efa8af298cc0212dd9261c1db6876aa153f0671fa9286ec30fdd33e773f72df5ddeb0f96efc1cce73ecccdcbf6b04273a960522a3eb508ce51d2dbc635db2b279604178df1e0f621fa25a6b5869de8c19eca57f5a088f90b104c799d66ce7edbe966e5ff2120328c605a7788abeae27188e44de800c40c2839964f9cccca22724e9c61ebdd09f6272f75f6edf86658702fac41987d314fb4183e49a036d05da1da5fa25ef8b0647bf7ab772fe2488fe88367de5b56174d6b860943dde97d73a5ac5ea0cbdadd7ed0063a64a40278556a7dfa26b4dbd9cc0d4d146fe874045088cdb5208e9384e74be2350793b410b186d509aa2808c6cff131a529d75a0330e4e1b6fd928f1795a303aa3b86a2040ed12761910d66475f9aac11923e97fb545819ff36b9d6304d14b13fb62704a21de12388299468edff025cc817d901a41f7faf07d479eaf4a56f287ac2bfaff5ba2619bbeeb4bc0c3cd0a1667cebc1a472cedc00b5891d2972e2094314c8eb8e0630cd8ccceb51b5503268bd317d9ffb5efe10e0369af364d59746b7fe33a3d054e56daf8e4b9c24b47e98ea3097d6ee758ce78ed98cc72bcfd227c9cff53b36b08ebd25e17bce3138b356729457d10ecf6ae7b879db7b3280c9f067deba892975a46cd1a1dc74e5b89920566427100ffccbb6be2a6f8564af0ba4dade5acf8cebd61888f3df12dae39f32dde2fc57b8ae7510b3150cf70a2a3cdc343ba01376791cbba528b6b700a27365e12013e79898be5f98589aaff47e69fc65d4d154a24dd</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出计算机组成原理（三）</title>
    <url>/posts/fe405f72.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="59184d832dbcdf4a79f7f1a77ce8c35553a0808867dfe79f566c3047a7ec52d1">fb26124e0d85f363a66baed35993e1a0948953cce3d484fb31660455b92ccb286ba4467b12dd2afdc0f8bd795964707216933c479f00faf5302337078027ef66e68c754bf0232403ae44399aa06a2cad741400e24549082709cdee4a1c1e38f29d8bb6993c43448bafc4543d636ea5bfe35062ad225c74a80f232ba51d9af45093f5220e616be2d57e02341ffad661bef2886dba249b54377d8b3961fd62e8e7033554e6a1a85b429bcdccd8e910eaca84c8e447cedd760cd76a16c64ec7f94ad050108487716cc544f1ca685285a120a1c590efd559bdca18a90707fae890221e2912f079f089d10fb816e69e85944586941b721161d200273028ce2f3cb2d1a6a47461dcfac58b4612622383de37911e7101936179b0ecfeb18f3600111afc775a9e1f79696dae92585891ef4dfac1cc1282c5bb3ef3e90306432243e5e5c5c4aea0a5dd465ede189c8503b2f58e1318cc7824fca0f1e0355a21aee173f2e0556a253da08b3547d56b79efef105780bc961759e34d761ed2eec97f116c6be78a7eb4c8e58e14ffe48cce063dec217dda30c5208a95497c79f4b82947fe5f246dc8611413dfeebba47291607b7b16e769d9e3d6871f680d1a4758bbafbe46b465a8aa47e4f2ff5bb80c249b12021f98bc98421e20d893321089ad48560f94b30eb3cc02c6796652eb1e4bed8f57c57c40aa1d1ed469e96a464c8be32497d7ae11753fe9644168d1a56f70a989ffb33527ebb63c95818d455560d7032089527f59d1ce537b33994b7f92d85f84f1754bac8b5e33c6af6a54e894ca6bd58ff964a4e32e7faec7b3f834703ab12db2bc2adec71e86a0dacb8971916b5ba0c71f296cd51cbe809ed8d4654590279dd7e8b4c3f106fb08e3b998eb249835c73bbc27624020ef12a46ad9a7d863e0113b36ddef43eb149268e02055c0d41784a03403777469bbe2f3a76d70bd56a2a22e244d401d7f47723a2161691e0a30bb090f7e74e8ae89125f2cf876c475615161e5a0d34bcc04143f8bbabdc262dde3dd9c1a50d6f171e29d3ecfd20fef0bac16e9e871c7da7b2a71292b92fdbe3870887362283574d3b115a947d740d4bf2a3561b2e1b0e838c6d0e655a18b99166868211a1c4dec236f325acb623e7cd12f556ebaf946db29b449e21195ac026c15d1f23459d9ff2473c7ccbba8d0076c907ebca25084a8df3ead33ffc12a728e6633017d7662107b036a76c5ecbda42d36ca6cbec139d436272dfc2a85c8ca427a314a897be20318952d9004086c98a8f87c7163cc098e0f4af23ea2b968728154a55f5d5467bc38f6192bec33fffe6769fc5902105237f6415b50934ff1d235700e6afa2c3caad27d949ee3280b9b99f777707e6038bb4087abd5de8279c6b65d9e26ebed3b5dbba16c4e3e91061de11bbb8b42cbb53385d1525754e99d6c28600ca4bedb04552cbb6a09accac90ff772e7b842f70f83ecd44306d3a358dabaffa5489d66bca6f515c02bd13ace5a424d9a68e6889411bbcd394012b21c29a30690105f7e3c67f5b11269269ade318a343950112c43b14360aa07d85cb2511855a124bc5c090237e390a65a094b818b6c5ea02fa0f35dca21e5d610cfbe86eea31a262ac2ce6d4a427fd2bfbdc810cbdd7c45d3b746256d00db5d5d19cd98bce1b36299f7d6aa774a88dd6cecb744dfec0ceea9cfaac45e8fc299272aa53d84319df05ca11ff9cada676eb39da73e92af273e4f165817e3a91b398c0af762754240e38eaecdcc99b3acd49a9c993aeeb53cab7b9718a01a12aa9858518f0d8af1dd841e6065a3589815887cebb0329ec376726a8c63ad08c86240853a3053fc4a7f7b9a9f37ae3b28acef5dfedb4b79cf559dfb63cc4ebe5292127698b0c80088edb0d4cfdb90c09f75cdaf37a7180b0b2b4bed7a8d05cf3c810d2760d5e71a168a7c9bafd42c3653ef5d5a4cb944da8b8d1d107ff8afea62cb828565b2531e47810c84f7dab194448e97cde57171ebfa60d432de2d382d050750b2a83599708b442d975362c2329cb7ad17939e6b79bd15e7f97e5ff96a89971a7c5f055d2dfb757358e1a697f294a36829b0eba2782f60fe05831e80beab57eb8cf77d16c6b22792e35859f3cfdfb8a3528b839648cb1b26e7d8c8f292ac246661cd854bbb8fcf7c70ed502f27ded09e03964c453f2a7ef927aad7c6271c51e9b889e855b5a748a5478f2e6cffcea25ef688a0bd8f6b181731c181e9ac6690bd93594d20687fda934a3541301cfbc0a9bca09e25d421ad1e441b201fc55a662b9d00c006c2bc1d63ffbfcb0754084e1feae881854849d1346e450324ef12ea97a18aa1df1c6db9ac9f397495ce3ab4f8ccb131c07f415e1f49d0c5b7152ec4f75117ecaeb32b9d5d0c75f9047adc277d2567406f297af13d7f9bf30bdeb04f13c6c1fc12f7a5c42ab4e32be2d1ea4253f213b9cbdda49eeb33334b9909eac05b1574e60249470a73394d72c346f655b85c0273adeaf74cb5b11646bfbdc22b80d535cba4c014aef3b1916da2a5a6987ed58b051d984ebdf334d9d3ffe32d250d0e97a6c48b4d4c25013c4b7dd0e8787faea876c331f436ff0d3d731b46562abf8f17a500df392632d21f5d7f57fab7e58c83a9b40c6950af53863d868b085f04410b24c41b5d861e2ab71e052c9fa7b41f98dc56bd1c6038d4f8d2cd398536b11bd98a0dfe1e44a1f7f8a076ae5f619847072ce2aabca4c08a990e0d5f2449646bacdee98a1b29edf76bc9b455b5a9588dbebef3aa7bbaa821c126209abd1bde50e58119999662005531bf3660c740b05d3ec744c7c35ad40022ad4b872408cca61e7dfd4031c8f66a6c7acc941a4a437cbf4594182aa5084627987c0d2a9884f2ff44bf612846557f2aa71fcbad27c975b7ff79ca17bebc524a3868011c2588ebe4f51dd4263fb4c8b0822f6d645d02254721378a9e98fe6ba2ce04b5a714ec02dc1f89f3b7fd00fd0f0ab7c4d8dc8a0b3f77ebf928857bf525385ccb2b73bf9e0cdef33a6b92720c6e9316aa669870e0dcce06429c89132f8b4f90e558193f3b1a29630289e851c220148256f12459474b07a1af48359c875cd000ba267a54d7c902128ddd486c5e2e5ba28750e416eeb1afd6baa9af0c78d5353a9ed81de415d5ddb355787e94a37d44ad897553f28add7117bda9dbbd10093d7997df25dd82b9ebc2509666589333e7fe4d9b9a27d57aaf426cf64f8eb6f1d0e797e57d02a005a86f2b9995273a5abef9455e44d2377d16733a76067eefd0fed53492527bdde90a3bd308bd054ad07c6bd431cd4eb72ffde27e11bed7251afac2ce35c9071c0b699a108796a2ee4e5ffcecab9a26148384b8ec63b50f1f90db7b8145f5edd47ac6f8162010461c033ea2dc0ab7bee348f54408d9ea48a4635c65dffdf7be6cac0f6b59ff423cb78c2f1261745de0f96ad84e7b11874f63341050db5d757a90fb269ae0cc7451cfecc3f928a2f09aacaab096dfcbdfd358ea914e021a8a6c136be88a85f5007c5fd1e175b1d3a52cb2505d47010e173be8c94d51eca9f850858142a3e969fe161b0470785b93807c74825932f4a0c772580d2001de7229c1e0eb2862f77535ada63f7811d57da821e539b09a652923540424c1f10103079d064a9af479b71f4bf4ec38b6219fb689288646385b6b486a9a38a700eece169c41b5b3b23e6ab3332345bf95d1fa3bd1a5dd421b8c5f8d0fff393964f560527e3308aec6427172df1fb4c0d86113f719c38c49b52e66067426094d9a5d7361401044a48f1e105d0e5eceb30f5351beb05bdd39a9f6ce500286a0fcbd8e2fd1a38df1e79b395e0506e544c89ca996db1ea733dd57387c843ec655571064038648d86ba8d4fb75ff593d827b89c07754def4fdf57e07783e5618bf1db11cc58b41fd209d5e3238dfdadb0ca85ab08b367a2c1ed5c68f7e1cf4d52c8a40225836c863c6e372169ceaabf81d2aac5a9eb8faf20c134c539a7bec25636034228b0eb0ef34f00830d245996e2b534b5b6e396c20b185491dad45e547775d02e1785d504dbb460761e688bcbcf8d03afa1a48251b9b5b6954f3bf95111372149b24b0da6b2c495741aae68f4f61ab576812ca57b5024f6a8f564a9c26d39afc41681350c8dbb863acb483187e9d7891507e03c4191a3221e0064ef70d82ff40517408b278784f7b36a27cf39c2799ed3b553b8201cca4735d5f661a1f70afcb49ddffd3294808fe07496ade30b341d173e3d44fcb930d6d0574df4bd5799d0202d70cbf04177d954eb2e9598526ec86fb9c9dd5d5809e9df6604ba92968953876c75b01d89f2a6deef8d8566594d43889c393e20762222f96828c9a17fdb605723cc50748ed89d84e52ff476848a2d4d1aefe24859c45baeca39fb336079f3d05d55ebd60b9c59c066dd75453728bb76e794c9d07e145bea1ff769d7d8fb03ae3f1ff68ccb1428bb4860c133d0216af99f52fe699621b244345d7307e35b4ed59556920e63f09c514d32523784abddcb630bdc54c4b4a49c89babeff71e2da1de86422f443c88a32fca7923f15bfdd3adac718e8de4b2f41717cfdb38bb2659de1ed7fb04f72a4ce5ca837a5a6ac974ac117a6467935687edc40054ccf1f7eaa5319066f6c7d87dad28ff52e0ecc6357e7ec5db52884c44ca5823ee0e7fa18b1b27b363fa68e09d9b6d9bfc985c5326272835a4f4eb8c589e66c9e67af45dbe67cc3903b096b978ce504e09f80ab4603e00f68833b2ff684f246af9db75cdfbffe33e847b33196a9404db459297a58bc6f96114635021fa03e99bbc2afc8aac44980da0e76420d424a179431fca0e03478eff904fc52abde2e51651325182c3acb66369c11511e9d7190ba17b8518ddf23f34e1a4e8e68a3cc74df4411a9eee0ac6d762bf273cbb78754bd9c01fcc97c3bfc032cb54ff2b33136918e181a0e154efc19be7eb2b82f8b41ff6a7c82a55471e525ddd6d661e7e46930f8f723b1ec33998b4e33d9221d1b7c7dc9c84cd4947e4c34fdcde02d9cfe14481de96e52fed3ad5fcb2029eda0fbb085e09340878956721679b73f2b2402ec0ae20ff4bf7f260ebf51eda9d145ab5851bc74824953513f8cbf384478196fdc562767d5e9bfe42aaa3e055e1153b63bd82f6ff20d1eedb8940cec9a858efd11351e3a71cd8a2dc198ffac90b8fd17a7c22b488780868bb130b21c943514bf0ffaaa987998354c1daa78edca9c0c774c8e2f74c9c2245eaacca5a4babb0de2891f349b7964a7207f8a407d43e52ab478b9c2fd6fb4e8260e40e7ecfa9e416053bd3f57cff873571877e46abf6961a22a88f729aa8b3ea081ca738098289d60c24ee5e3b640cb9f6d99635dd063dc2ddfbb2ef8c75a028249cacffad61954a012aa0e2e1ba8d57ba7c72a2b1577b78d0cba82791ccf1277363c73684b30e81972f288ed5ca1d07d5ee2d9cf28a2bc100c85bc6833e673e9133e82434f74184ac09f8fdcb86eb8227d031085df74712e31ece7e61667a4cca4e392f8d905c82cbdecb981ec8634bcab6a0e8573dc0a55c68de0b0a8df1629af38b4eba06a9dc3bee2756309095d9ad68b84767f09855e032b696261d9c7b66eca5860bf8ba2748c501f5c85634a8917887c37045557c9f0545eeff85b5b107c0d992373121c39445afd5d9e7ad4b60f44c1000fd60736481bf2d4f8e1bdcb1d2ca37e51f3e8c0862525cb02f56015fc0d6922e6f9bfd51997a0dd567de929a9d290ea06401a49996555163017ec365a1ffc187889f451d619c6b477cc0cf492f1110c91be56dafa4b3130feec09ff9562513c784db709762012cf694a20f9a358317046e8692e4b5d0d07798c9838a7799859f28d019771ce3425a43b23904e4d06f0bf0123358d77be6b0bd4be875cc0eb373fd3bb4d8bd4c9120059669ad5540a824092fa1310ac936b34fc02614fcf81a9fa816ef333e4d2ffcca13044cb1dac0897efa9d1fea041a434ee06b05086cc87cc4c1bbbff4a3b2c99afc12ff34d28814520c5e9015f7594bc91220ade3b959b1185a6819654010d3b5a7359014cccd96e341d0c8266fa309349a194bdbdef4efc52ed68a034e7a5cf349bbca3807edbdcebb43b79a618b53f08ed59dbb1610ac069018b31bcae1d125a23cb482819582e9523c539e867f3c0d9743f244fe38d980f2bd5bcef35a48032fab429073be40e7ce182ac0a3dd593bc7e679f1db2fcbb69c8563eae31aa8805c21ae6e3e20963413f504f73ebacc56051181ae17c463b8a7472404f1ebc5779f428e5c6c5635c177d04a4035d5d4991f75da4efc7c4dacafcd73792443ca59269411d87139e90ac6d914225deb949ebd5846e74f7e99e8bd41be34ab652e3a674e2432811073b466253f361305eaf47f4048be89046be0c0b01c12f8f35775aa8a69d0a010fedd98fa785f646ed0823f7a2fdf0a1b6e3c51a1d7d485b64c2cbb8ee080c8e3d24d048b8e4c0d87d9cf3a482496e7c01bde27450912cac9883cb293647883e2b258ce24456de65d23625ca83f81808c4bc3179cd52ab750501988b77977020140074c8424dc92c614118533fb56a788d41ecc1f639dc6354fba0f616a0ab684afe35bc8f31f5117313940f4e9e3c4aeb8bf0863b0863450469d31f7b0a02152f12ef9c91bca7b1a53ee4b8906a46df7de3d8888f42d94ac0bffb948549c126fd1554d1b5f1577068b918b01996e2fb6f7d1012f28f31bcb3c692e6127d22ee5fb2ad55565f76af0a5fff71b4e10475e0b96c1d9151de8ba9b828e2621d379cca99b6ae75249110de597f4951fb73fe350ea5a628a5b73bdb05ca2782f27f7090f70e6d43f168ad4f54a6aae1498f093d944ddcaec80ca19babcd338ab6368e1e32873ef4105526e2730d02b3c196836b15204680e5c83f94fa14c41a9498d7f1ae61b5c87193993a0267ee4c1c6dde4aef17735f7a9832ed86992b441bf713f9b6e94e17f9f853fd839c65ba1aca1f2ec2ed00db5cee6007f1a2e44a93d3eb6766aae84a1eaf71ebff1ddfa605f6bc5b1acd9d848474fb5afa126c0334c65a86d1abfa76014dcfbd89a63e9abba56be006041d0fa440b432df34bd0b10bf60f3abc1d49f918b3810b7411363296284c50166df870b8edb5c43148e48e789994dec8100691cdb27d732337ed738ba3f59104b3dfb91e8f0e85c1805dfc5cbd75a4aa2c52301d28023ce6512bca6bab2b123238bb86717c72e5ce27d8b46792e25cfccbd28b73279e6b2381a73c326ff73f31356d1fe4b59f15fef24a106e29ed42e35f708dd528c8d8447d0d3ed98feb0a6aac54a3578766a5195a2377c40aff07a9d0fcc9f3eb9ba5b4c8c3bd4c027616c16c605e741b8ef4dc3889cc7009b4baed811ffd8b7a849c61596494e806269249553692e4d4e34a5bc15e464b3d13f9e447d13e966eaaed4a5c2be5dd76517c4bd778de293ad1eb2b372a79b2f41f508e6d214efe25f5db572c2a8b18842aec5d899415834df77ea5ffc0337882ddfd9d45153d9c30f2b98d46301376a6f878fbe80a4369f6fe8f43275e89c222a69578f9ccf90ca2f4b213b614e87771e8c968948528890f2f9ac3ef0f474d11bc940be877d6c720f073f1217df23ea06c13ad0254d040e8c211d82136ee1287c54f7a3e459e0771e88ff1d819ffac5bb3dbda48e4bf479688120481e6921e0a6669b7b0a935530168eae89b6bd071ecb76f21ecdccf1cac96dfdb2c695f3f95e53588ba70bb93aded6542e5a86b880df0af8b63acca82c7930ed6695b6341e0d0c6f94d5dc17b79906bbf6189db9ef182b6709ec90b68c72d94d0c1eda2dd606c63e2609435712499e03ac2d0d4e0b44da25efb5d513245be8bb390b7e71b25ed17bb9ca8f84a90b37ab757448e42a2098dc9ab5c051f202978db69955f9a2bc62add964c7baedab65934370ab8d3317916011892085acdf21d8da9d30236fba27e93530ab3a3c019fa6a2fe484fd4a941f5c4cdad4d8bb0e565ab382dd16f4ecbc79aa27c075965f09c1bb9cb94f572f3438c588ee6e931831f4c112a61847acc9dd49f03600284e1981c5353135f83d244ded1b706d83a30c0385fd0bf1ca8848ba22e7edabbb407b8daaf5dadf55ff5912db975ec96073c6e87185cc7c8ae90d667b605e77247028f3a013234723d0ea814380d4e43b59285cb20bde8dae9c82c51c64833edfe69519d66c28c7414ae949a5f44dff4a3d2cee4dc886fcabd8eb21dc81c40dd7515ffecfe9db5a7fc293b3a2c6bc43e96a6c2b8f350dc0b11d69fab14132eb8717899ce8dca7e3dfa43fc0d5a599cb194ccb516ba197f94f58d5eaae20794d6f1e429b916eb25ddbec33e5c276370d8d6c84c1dcc20b1a110ddbac19969f5e5b5879f8da9dd52afe112b4b69ea72336617765cfe859ee1118d0f5bb0131a26c505c5d3d693862b640f1d393612170c1186b162d4b121045470d75fee36e6c811860a70b5b9f141289f889d6949fba78c36e9d24a8e7146b2f33e6837b5b49967da65d73e8e95f5aeab8bded555fa9d8262c00552278a4b2a57e1c14f3998a743ed777819a31e0520de7a9d93af69ffc5fcbc3b6bee9895d22838ea1bef771aa1a4c7f899718857ac6ded5f03c8f0b9d6462cf0cc2708b3d0693ab0f13e9c706b5acc0d242d84bccedf605522823a89566244eb8ba81aae13ab888f3a2c93e87ff64a3d4ee709255c65458ee3dcdb1d4a893eb6ada58f839a41f19382556c3625be53e2c9bed037bf5e87056393cc21130831850ba01c93c40aa7ae1d40b3deb49f64ee692cf5ddaf9158deaed1acbfde71570817d98d80f5ff398991a3de1dc72254b8098391193b1244691157e1777fff09fd905aa1993f59a7cda10594d251082b225bc17c8b2e30bfe935afe38d94ed68be25791043dbe3642a50d691c8ed6919fa78f16c18dc8b96fff07bc4ac51144d0628aeb39a42788cda7949de29813319b03e56ec1059f1445dcab62b4786b9471ad67beb5f7f08b39451d42cf3a944b371544d54335330f2cc2ae8759c94bcf74cf31c0c006821488db432e1a8256fd8ba252b8bcdb9df7e0a37248d9ed2cd74c6f36729a1d2d9a1a7d453e77aae634237dbf01bb4753048ca7fae41128ddb29d9ff0efdd4bcfdde8be54e53616f34c172c4d953b1deb11fcffb7d87ae697557cb6a80ae9c84df993ebd4c4c6b4128651d161b8928ec4c90bc46da0f7c9e91561fc183d5426654a9c0ef8d7531d3279f6a25e2e5ae9ba65d91d72997df721403b39e1ce47d439e1d13a4323251e9873a9c1802e286be22bcf453cd14ad9efc4ad6a43e415dc248bde773180ffd99686c2fd9a32f56d20f46f06b56684f6460baf18b4b4632060ed1faf1c8a4f16472250eb9a0cbe7a13120bc2e78d89be1953933c07aa6de7091e5d4e84fdeb69832556de1681d724ca5e8e69d6a412d31cb7c16f590d280df330d9ac50934bb445b6c6f1f403221c6b37bd43ecbd2390fa0e7e515cf77a957cdc3ca0f3be40efb995eea483a2e7a32f10adb0d541e30bb53c280d2926f483b5d347612a17916ce731a7cd4c415473c42604c265ddbe8f588ef04724a3d12d019e7f0a84e3919598c3491684dd9d39eeff7ef65c839929c4be4266c765cd51c9f90ea5d80d99d0bc3bad50a603c2c1d53fcddd7489845316f086702692fe0072f4dbd75cfed65d020d7c59c77fdf8ef19b421f1811ce737c2a5aa48daa52b6cae38cb9533317d631b225c04f43ae6c466c10adc908d53930fea77f85e1bbf9cfced0a34aa8904f428281eb1c9a07a82552c70df7d0a26a1834fa072395c7c17c247b0b38e722e21a31874e24d05589460569f5ef2b7f10662edec178e89dcb19620a59140f38e511a57afcb7e73611e022a46284d498089fb22b45e181df80e944c806353bbb03721bac1a3ef1a59bb0e2dafbe27db3e1b60a85ffe53668ca70a4b0a5b8b87dc3d1257f390fe8a373a436553e8c7e80341b4468f5069a1b174c4a3c070901518c9b070f34860f97e6e3715d28fdaeca2356ee9d15df15eb387615a303c46cb17eab552b8a58cbcb8c1aabcd7e2acad02e7b8d97c65ef2278bbed9a90b8bb1d7bb6777f23d0a4e7e704c4cfdf0237b97e69265dbf447142505f2b667dfff151ba3ecee93c01446d635493b87a0fb0de7a275aece6648920d0e177b353d26b3b39cf39be735e6aec24c6c8ba93fb187fe8293ec22c732aea0595344213024d5f9905b984fc84d215a5ad807b4136f6e6b3debd770d9c303cb44026d896f30de09775a8cc28eaf131f6c40b62cda241a85f96d1ec291257b8b90c7e59633dc71bb1474de6ea2e8c3ffaa32e73ddd9bb07123821743662a7e6485403f2eff8e54f8e3aab706bca74867ff2a64b92199f5a80feda236d8a9769b67241713018cc959b9da14f59793933f420adbc0426077dd2bf98d0f270c949f54e3ce9c06dc9c2b728863ce6d1c7f6ecf4fee3e6aae749de1e020142b0a640e5f81ed2e856b73e5d34f5404bdc5cc5632d1fd9ef6cc0754916d10771bc0411042fd1a9a233f1f15f549ea605ae9136af6bad550be830336430ca3b4426df778372754cafafda854d46bbc78820fc24cae3807dc4c107d7b85885a2dafa2ada587a2a231dd3c83618ffb0f9fbc737980a557a4135a51639e517cb0a357beefff308fb2762e3303b886a55a97c1edae1d01199061e7917dd3f39b6ec5cc6e5f426244078ae9e0912e2d6a1b1621d5713fa4d65e37362bf51d1dd2de07248a67a8b6381e4e872349239252fc5e3e6cbe20b02b2b56ede345d1bdf9dd7fd87f85425d2e4c7aa872b809ff9dc5ea5a67aaf50a66bd167d6d438cef550ef4b1a8fa2433df9eec7aad05dfe17b32f2fd084a6d720e0da7c54f6656dfd19ecf50a9c6490b90431e97f33061550c4961d718f62221dfbc4c8985688e8ba4a178b65201d01879189f235d65dc69742b9e67ac5f00ea873b9fbf5b7f9647f5128e1c02abd42d9498efd3118370d9b102e1e61d35a288cce943f82d403de2da9275499722354d3551cc14d19e64b26d3aba86589ac5625f3db0edbf1892d953929d4c83094e61456c091c44a0b6b79b530593f1d1ff7e6bc6aafb2e2a454314be4f4a3ddc1cad1025dc36a09d65c1292f3f8df1a273c4e50056512789b8c9ae4d8d4340060cbf7d31149476134cc1089847042b4042f764319f50fce29a9a5da2733a40d02476ae6353568a50fe78ecf45f5ef2e121c2984db1f1192ad73e06e2b41333f1ed8ab08163c6f9468a1d7837a2cb6a19a2726c1a4ea835e92dae2767caecc41ae0f6cf714ba5f0cb85ea47f041e1e996081fc46a3019a788904e51ef347e4493593d36b17413447c6e4847d12e166eb7f0f8d1c0b30940108a8a001da3a52e3045ccf143f8e468042064f989dc2051ae37e1b451ffe3a2d1b3407a5164c4eb1b65aedf0efd50092d878ff7f2e18e73abb83c517fb01eeb23bda84207d4925a44dcc3d5ce1ed41e0307d195beebd9b7a5052bc6f8582af57cf34aeef42172ee415a163d4c6c31054513235605756c1bfab80523315054228d97b2e86d1d280d74867d0770fd561db496ce86f780ebffed1047b1074ff676c8e502d996e2fafe70cc0c7b73f066d3676458d51c59447ab4c9b10828d2895099b1d3e2c609a0b6ff44c88c85ba9f4b92885601a386e1decd428b2ae0baad7f9ec1017d5889e9d19a5222710a9e2f4da1236a4561f2aedc9d5de0d6faafdf42e79bdd195f568b2f6dc2c36ff18549fb873fd2fa7a88d691b45a58b397c50ce3edb588cff12a01edd2336ccf71b6e4e370871f48ed5ad157f334164063d66da3c6110af727ddee67539bf33f33f7c169e0c4f4b665a14ac59fc43b5d212cb7ae3696368a6344f6358854aafad0bf93d5a759bec8f3d9a822f42f9517cee0b8a3024cf3ed9fd309ee05b9c7c39987905d4ead6d33168c30072f7672fbcf8b711ce894d4b0b963a72f4adc4bd2a8ea33e28734e4600cf55224e91b4bdbf229848e776430e8d44f7c446a7467ebb2317e58b9bb0a0ce35c7a835581666406e7784d76fb4675a8df93c69048d53933c933b90725b4c517977016df926f6c247a8c1bcd200f7e5abecc7a51a0b01a9f0b129e5a7441a7b5cd139783d936bbf90ffeb5617beb8e7b32e5cfab7889bab3ac5360f918977a05751405a4206c38363b7d71b04c59ca13c9395c1196f4600a0c9358e4ce6cbf879fc164c33af04b66e3e89d44b7844fd7a31268d866eebcab69292a7bda1d2d18d8597b851bf00e09f9a80c26d23b1a68a2db74e1ed0effaaadae03cf1d988df672d4285648d3addaff3b4c0abe67122360384d716db1fe42401d4198e21e73d356cf8ed5fe693aef98d72b99d1e174b2c1a3d0f899378cf0238ab550fce283b77393f5b1fa0c1b65adaf6a7a170036d5d45ee57cc9ca7c418e0886adae5a0e05adb5c4cae1a03d71c7e7515ebc3e4c83f7e34859c89d3d29e221d466ac86d55ec3d90eb3e3ea2aff4089039a3d729ae4856754c3f4304694fe689aa8343dbca601d1d35eea89399e6a7a2208c0ee962653a4733f35ffd43a948e1b8053852067c394535723d317005d40d1878784759816567e5fa26f13091c28b92d86394092a1e77d6ef7352baaa1a7c3d96b33d8939d726821d932c682d24dbf960bce7688923b9e1cb953f53ebf1a3b85c810fd8d9aa83d56ad51e1937341579fa4c2e1af809855bd4b60250c60a0c76205830625cd365518efa81122f894d102b9e31f0de2223371fb21cfb5e9d19b11bdea47f5b04f7e08c6414cd6e7698e15db54c8fe7f88313dd2687c5c6e248c3ac57d9676b44b49d9a273e59c7b4bc3244c0decd251d6750fc1d87c996c404224d921e51bd6a0cadeb2027b3f85ca15ea868f37f7048cacbb05774ee5799b6d4fe6416f28f27307f61d7d47e7238c1d695602a299acd3306148a043a2272a1f8f5c405e35d689c9d79f1d6dd789b403edf4830adf3124ced61afc50073af4944439a2bd94683a247916696d5f3bd82b70f200b283dffd98e73b396538938fe36b195d003cd2f010b4b38f555c98e070112d0404fb37727a577fdc065fcdf0adbfb810a1b09570e414ccfb23e3afd12e444a41c213f5bb7f3df3904908ee88e442d6d89f78f27b38e046cf45c24eae20d6286a14c7debf630459e90df7d0ac00bf9fd08f59ba0ca35e9f101e32ace44a6051c022c6bc874e26468d7e10bbc6f04d7d3228b268ff3184c448950dd1efc1fd3efe8256cf9e7c12de575ea9fa3dd89ebecb6b63f00a63fd4f116ddb40cba4af694f6ba4613827c182ac7ee8010bc90c7f5fae02cb8e358de18f9e6f122b8d1afbb87ac8ddc54079d83f7c97fa0723b8677dafd48efb7e5928a150dd78ae23919d94992bc3e8e2567388fc2e9c1eac9d36412d4581b398747177a38840d812551f539d3399b24f2ff16f077b865d0cb2629b96d363e7fea7b3a4a10e605c0c712da3701adf068cc0da35e8c4bada88b232138fae6226c82f2c9e15d149ab5d35d0a3faede11697664f87d51921da7f730d1042d329e149f9e543ffae3b25e12f39a32b9262eadec7c6e7fd8bdd161d2bb34960a642ad7de90e020d475530813b24b49ec3b80613b9e262e19b044c7537c2061fe7f21b005e9633ead05d208782bcb9f1c41df26d03d272d2ae38589fb4ed008d8bf8087ab7a77673896946b534fc0f47266668e011a8d66e86837fe621ab73de9065863e4e4e039d3603c8445478f1a60f65a5e8104b9d28b03c282017b58380f73fc377e29cf4fa5de3e4b24a50450b6befb305b150c7b5d59569efcaa7deea2b66e4e936bdc1f2a7c9ce803ae6c104d0418f078922acf4d161dd7dbaad966cef0ceb4b4ffd85e3885c8a406127ff64b0d639b7a174d643ed38effc896d18ab07db61ea447542cba2700c8c05c4cae9a9b5121c16e5023bd1c64b48e8c7a81fc8b54cc78f60c254e3dc1f01692fa579f98c65bc3d8f20f9b994ceb272534b831a5d2b5a6ed9ec0b99f92bfa531170a228669570405fdda7aed5e1889ce2d2b21e1cc38f0074dbd9f1227411f4fd9ad4611035b1d491d7316751f87dbebb60e5e80ad189d8742f52a5ebc10cdc2cee020643863ab0a5d2c5f6703726eede22501ee9a86ecfa2a52e114af9389026e01336dbfcc2a68edf1d3efcb0e9767d078c608f1b06802370dabdfe7c7ae993cdabb03862cf9864814f5b637681c19becbd874f781cda1d614c5d98ed08c67ec7ba35b3a69c3f82fd2c61260bcb521f828336aa95113c3e4c00e69b24f215c0ae137764c8385a5f283530313ca0831e527eed664cfb3be6bd7d6bb091272c2e442b790c4844ef63cf9f155d242162b3ebd9ded670aba23f69491ee396b796a3b5adef9c7a7ced5ff2574e133fb69a39be7b91dd6b85e7671ce1ad6d474639a53cf406e95eb3e6a3cc826a81f4406ed7e85d4416cb3ac6a24c244c41885658766bf9730801c6371ec169b53786dca848a18f4163198daf4f0251752e7b86027150261955750f6cf9d21bee4261f194c78ebb82d82fbdcb0a3962d633f2865c9dccd3c4ebe9a62658021cc1fe4fb05e7fb1a546b2aefa9d8f53c3ff89349abce67829642c11bec60e2679996f7f32bd51a1e50f1c527b789704c40bfcc17a7d0291ac01252c29b516df171890350e6ddc88bc2a89a540b64acae4fcf1073a38f5c60a4ebea0a5e3575e7642f2ee358fb47eba83e74e342518c7beeff1e88cca09c7ddd036bf3fffb965f567552ec68b405aaa4f64e10ba890c63e1c543944c2aeba770220aa3f74614fa0e449f2c7052a4fe89ae5df8e418a9917a4bc8b8d2ec239ed0075521914fb12207ea547ec1e487998fb8811f8c269726aa8f3c00ea0087fcf8d18ba54a0d198cfbc1afbda77ef008c179955ab8e84d40bd720626665200f85cf1ffd519057962b08fe79d01f9019605612a6f475ca7d089a51a23237bad68160482afd70fce6086fade32e92115fa001c70aa00a78c95c2283a4a0aca7d78391b4969ee4b46ca92667134ccf0cdcfdbb496be782418c829ae11b53452b7e5996a9e1d467ed38669066647fd85101e58eb59d8ed7e441970c293d5552d9b983a88b3ae78e9aa5ca7f21750fef2719e75ac6314f75fd7423e3be78dd2f667a09ccf5836d5fff94240990968d3f1b76b43be01b20121b13c597ba762f26e422c984998af517272b96008af7b99d5b226fddafdd0041dcf2444cba4b9773a56d346bbc8c562d824f5ef61b0d8d0e653d3976d8cf6fb350f85c271a7c35260038e3082689bb3778a26259c1add6b4ba9b0a8edb2f5738252186db21b8f6db2fa342c6a90870e81a10b9297add1cccb34b3346e08af9fa9085eef586653a990566f04d809fd17fa2d10d8ef2bff86f6035efd1b74df2bbd2f15ddc483cc67fb753d8e2f8914c4288e76829cd6a209b70eaa67</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>求解线性方程组的三种迭代法</title>
    <url>/posts/23cd5066.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在Matlab快速入门笔记（二）中已经提到了两种迭代法，但是并没有对敛散性进行判断。</p>
<p>参考：</p>
<ul>
<li><p>《Numerical Analysis》(Seventh Edition)–Richard L. Burden</p>
</li>
<li><p>《数值分析及其MATLAB实现》–任玉杰</p>
</li>
</ul>
<p>这里根据其书加上对敛散性的判断。</p>
<span id="more"></span>

<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 用Jacobi迭代法求解AX=b，X0为初始向量，p为范数名称(1,2,inf)，error为误差，t为迭代次数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">X</span> = <span class="title">Jacobi</span><span class="params">(A,b,X0,p,error,t)</span></span></span><br><span class="line">[n,m] = <span class="built_in">size</span>(A);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:m</span><br><span class="line">        a(<span class="built_in">j</span>) = sum(<span class="built_in">abs</span>(A(:,<span class="built_in">j</span>))) - <span class="number">2</span>*(<span class="built_in">abs</span>(A(<span class="built_in">j</span>,<span class="built_in">j</span>)));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">        <span class="keyword">if</span> a(<span class="built_in">i</span>) &gt;= <span class="number">0</span></span><br><span class="line">            <span class="built_in">disp</span>(<span class="string">&#x27;系数矩阵A不是严格对角占优阵，Jacobi迭代不一定收敛&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> a(<span class="built_in">i</span>) &lt; <span class="number">0</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;系数矩阵A是严格对角占优阵，Jacobi迭代一定收敛&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:t</span><br><span class="line">    k;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:m</span><br><span class="line">        X(<span class="built_in">j</span>) = (b(<span class="built_in">j</span>)-A(<span class="built_in">j</span>,[<span class="number">1</span>:<span class="built_in">j</span><span class="number">-1</span>,<span class="built_in">j</span>+<span class="number">1</span>:m])*X0([<span class="number">1</span>:<span class="built_in">j</span><span class="number">-1</span>,<span class="built_in">j</span>+<span class="number">1</span>:m]))/A(<span class="built_in">j</span>,<span class="built_in">j</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    djwcx = norm(X&#x27;-X0,p);xdwcx = djwcx/(norm(X&#x27;,p)+<span class="built_in">eps</span>);</span><br><span class="line">    X0 = X&#x27;;X1 = A\b;</span><br><span class="line">    <span class="keyword">if</span> (djwcx&lt;error)&amp;(xdwcx&lt;error)</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;Jacobi迭代收敛，方程组的精确解jX和近似解X如下：&#x27;</span>)</span><br><span class="line">        k</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span>(djwcx&gt;error)&amp;(xdwcx&gt;error)</span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;Jacobi迭代次数超过上限次数 t &#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">a,X = X;jX = X1&#x27;,</span><br><span class="line"><span class="comment">% A = [2 -1 1;1 1 1;-1 -1 2]</span></span><br><span class="line"><span class="comment">% b = [1 ;2 ;-5]</span></span><br><span class="line"><span class="comment">% X0 = [0 0 0]&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/23cd5066/image-20210423184726484.png" alt="image-20210423184726484"></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 用Gauss迭代法求解AX=b，X0为初始向量，p为范数名称(1,2,inf)，error为误差，t为迭代次数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">X</span> = <span class="title">Gauss</span><span class="params">(A,b,X0,p,error,t)</span></span></span><br><span class="line">D = <span class="built_in">diag</span>(<span class="built_in">diag</span>(A));U = -<span class="built_in">triu</span>(A,<span class="number">1</span>);</span><br><span class="line">L = -<span class="built_in">tril</span>(A,<span class="number">-1</span>);dD = det(D);</span><br><span class="line"><span class="keyword">if</span> dD == <span class="number">0</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;因为对角矩阵D奇异，方程组无解&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;因为对角矩阵D非奇异，方程组有解&#x27;</span>)</span><br><span class="line">    iD = inv(D-L);B2 = iD*U;f2 = iD*b;jX = A\b;</span><br><span class="line">    X = X0;[n m] = <span class="built_in">size</span>(A);</span><br><span class="line">    <span class="keyword">for</span> k = <span class="number">1</span>:t</span><br><span class="line">        X1 = B2*X+f2;djwcx = norm(X1-X,p);</span><br><span class="line">        xdwcx = djwcx/(norm(X,p)+<span class="built_in">eps</span>);</span><br><span class="line">        <span class="keyword">if</span> (djwcx&lt;error) | (xdwcx&lt;error)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            K = k+<span class="number">1</span>;X= X1;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> (djwcx&lt;error) | (xdwcx&lt;error)</span><br><span class="line">        k</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;Gauss迭代法收敛,方程组的精确解jX和近似解X如下：&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;Gauss迭代法没有达到给定精度，迭代次数超过上限t，方程组的精确解jX和迭代向量X如下：&#x27;</span>)</span><br><span class="line">        X = X&#x27;;jX = jX&#x27;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">X = X&#x27;;D,U,L,jX = jX&#x27;</span><br><span class="line"><span class="comment">% A = [10 -1 -2;-1 10 -2;-1 -1 0.5]</span></span><br><span class="line"><span class="comment">% b = [7.2;8.3;4.2]</span></span><br><span class="line"><span class="comment">% X0 = [0 0 0]&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/23cd5066/image-20210423190047226.png" alt="image-20210423190047226"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">% 用SOR迭代法求解AX=b，X为初始向量，om为松弛因子，error为误差，t为迭代次数</span><br><span class="line">function X = SOR(A,b,X,om,error,t)</span><br><span class="line">D = diag(diag(A));U = -triu(A,<span class="number">1</span>);</span><br><span class="line">L = -tril(A,<span class="number">-1</span>);jX = A\b;[n m] = size(A);</span><br><span class="line">iD = inv(D-om*L);B2= iD*(om*U + (<span class="number">1</span>-om)*D);</span><br><span class="line">H = eig(B2);mH = norm(H,inf);</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:t</span><br><span class="line">    iD = inv(D-om*L);B2= iD*(om*U + (<span class="number">1</span>-om)*D);</span><br><span class="line">    f2 = om*iD*b;X1 = B2*X+f2;</span><br><span class="line">    X = X1;djwcx = norm(X1-jX,inf);xdwcx = djwcx/(norm(X,inf)+eps);</span><br><span class="line">end</span><br><span class="line"><span class="keyword">if</span> mH &gt;= <span class="number">1</span></span><br><span class="line">    disp(&#x27;因为谱半径不小于1，SOR序列发散&#x27;)</span><br><span class="line">    disp(&#x27;谱半径mH，A的分解矩阵D，U，L和方程组的精确解jX和近似解X如下：&#x27;)</span><br><span class="line">    mH,D,U,L,jX,</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    disp(&#x27;因为谱半径小于1，SOR序列收敛&#x27;)</span><br><span class="line">    <span class="keyword">if</span> (djwcx&lt;error)|(xdwcx&lt;error)</span><br><span class="line">        disp(&#x27;谱半径mH，A的分解矩阵D，U，L和方程组的精确解jX和近似解X如下：&#x27;)</span><br><span class="line">        mH,D,U,L,jX = jX<span class="number">&#x27;</span>,</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        disp(&#x27;迭代次数已经超过上限t，谱半径mH，方程组的精确解jX和迭代向量X如下：&#x27;)</span><br><span class="line">        mH,D,U,L,X = X1<span class="number">&#x27;</span>;jX = jX<span class="number">&#x27;</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">% A = [<span class="number">5</span> <span class="number">1</span> <span class="number">-1</span> <span class="number">-2</span>;<span class="number">2</span> <span class="number">8</span> <span class="number">1</span> <span class="number">3</span>;<span class="number">1</span> <span class="number">-2</span> <span class="number">-4</span> <span class="number">-1</span>;<span class="number">-1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">7</span>;]</span><br><span class="line">% b = [<span class="number">4</span>;<span class="number">1</span>;<span class="number">6</span>;<span class="number">-3</span>]</span><br><span class="line">% X = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]&#x27;</span><br><span class="line">% X = SOR(A,b,X,<span class="number">1.15</span>,<span class="number">0.001</span>,<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/posts/23cd5066/image-20210423191102860.png" alt="image-20210423191102860"></p>
]]></content>
      <categories>
        <category>Matlab</category>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title>数学专业常用英语表达总结</title>
    <url>/posts/1773bf6f.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Mathematical-English-1"><a href="#Mathematical-English-1" class="headerlink" title="Mathematical English 1"></a>Mathematical English 1</h2><span id="more"></span>

<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><p><img src="/posts/1773bf6f/image-20210308193302431.png" alt="image-20210308193302431"></p>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><p><img src="/posts/1773bf6f/image-20210308193353557.png" alt="image-20210308193353557"></p>
<h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a>Example 3:</h3><p><img src="/posts/1773bf6f/image-20210308193518529.png" alt="image-20210308193518529"></p>
<h3 id="Example-4"><a href="#Example-4" class="headerlink" title="Example 4:"></a>Example 4:</h3><p><img src="/posts/1773bf6f/image-20210308193555454.png" alt="image-20210308193555454"></p>
<h3 id="Example-5"><a href="#Example-5" class="headerlink" title="Example 5:"></a>Example 5:</h3><p><img src="/posts/1773bf6f/image-20210308193635558.png" alt="image-20210308193635558"></p>
<h3 id="Example-6"><a href="#Example-6" class="headerlink" title="Example 6:"></a>Example 6:</h3><p><img src="/posts/1773bf6f/image-20210308193713986.png" alt="image-20210308193713986"></p>
<h3 id="Example-7"><a href="#Example-7" class="headerlink" title="Example 7:"></a>Example 7:</h3><p><img src="/posts/1773bf6f/image-20210308195015812.png" alt="image-20210308195015812"></p>
<h3 id="Example-8"><a href="#Example-8" class="headerlink" title="Example 8:"></a>Example 8:</h3><p><img src="/posts/1773bf6f/image-20210308195119005.png" alt="image-20210308195119005"></p>
<h3 id="Example-9"><a href="#Example-9" class="headerlink" title="Example 9:"></a>Example 9:</h3><p><img src="/posts/1773bf6f/image-20210308195215619.png" alt="image-20210308195215619"></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学专业词汇</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出计算机组成原理（九）</title>
    <url>/posts/1c5bb60a.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="cd4164763f7a117ae19a95616ec780f91970b2ac2f351208516f16b71b403233">fb26124e0d85f363a66baed35993e1a0948953cce3d484fb31660455b92ccb286ba4467b12dd2afdc0f8bd795964707216933c479f00faf5302337078027ef66e68c754bf0232403ae44399aa06a2cad741400e24549082709cdee4a1c1e38f29d8bb6993c43448bafc4543d636ea5bfe35062ad225c74a80f232ba51d9af45093f5220e616be2d57e02341ffad661bef2886dba249b54377d8b3961fd62e8e7033554e6a1a85b429bcdccd8e910eaca84c8e447cedd760cd76a16c64ec7f94ad050108487716cc544f1ca685285a120a1c590efd559bdca18a90707fae890221e2912f079f089d10fb816e69e85944586941b721161d200273028ce2f3cb2d1a6a47461dcfac58b4612622383de37911e7101936179b0ecfeb18f3600111afc775a9e1f79696dae92585891ef4dfac1be939702081f153184d14edae8ef10de124a7d1edf21615d02cf31e96634ae29d068525b3eb695ead0e61dad2a7eec2a8003680c8939a5ba2c65c25372b823d6a47460f72d896ea6e2dd4e7e11cc040ae782502f001ca2d0dfc67faa7252e849ebf5d92e61c573dad0809bfaa533b8dbda3c135cb740fbd83eb6ad0f6eddd6298df4ef5f3afca092d40afff36be958ae5c74e1000721e9ac53768bb47597a7400f653c3c04aba8c6160835339ee4217354f27c3ae26f84181565acc4817c060334d6309a29698da118b8b0960ca0c3feb1b610a7c99c0f692889868fb3714577825925e1ecfcaebe6a3c2471052d73516a8013b52615c49fe11bd3b9ed437ad958699243f6e1f23853a75dbf1e9f03b6c2e71367b49e376dac0744efc123767d9ce6762613664f2560c6338caa28020eeb8835005e28a6395cb21db64ae7bc29d7ee9c89fe25d2fb0b35fcf9d9c034178bffe91cc9183f2821a83e41aa0e045677383119ed93939e3d776498963af59b834057d21998f64c9c6c96f1dacd6b311c20f965653adb70b1b827e5746ec4fcc689d1dd29c7b879c0c34d0f32d1704d267b06cf9da56fdbc95d86fbdea34833b7ba2ecf4bd551563b93d1fbf503b6e7787e382501d00b3e1fb6cc33cf5939e8d09883000e7cee11b2faa471d9dbe2410f59519010b33db33cdc314c27c0e9435126f99309b0210e732f42662a89c308c3372cb14b36cbdb403fbe1663ddb0cbfd03130b07ee85f5d49d6e95c99ed90fd74f0e199fb3378bf93d1e7edba3fefa67a7e5496828e72098ba4110e1e2c98ee10ba48743307056406ab7598db545f93f3e35c7ae0fa5779afd8610b2b932c1213a2a8396658616630d73aa0060fd18c666a18d2a0e01fd36d919af4eac8e852b70a5f7215e36fcac30d9e1f7d9e8598569874ad130b8e2ca626f758eee75b1ba776e2fc5cb345e976dd998a7e1acba7a698fad21da87396c5251cec9e227b99c0b17e1b9c6f7d20f37f85a6bc47fc370f14bfc394fcbbbe2efa45057d6d16f4786c24fe3a9238f16fb73211be1acb5f11314e1d17817677b9f0ff2d86a349c331f89b4477e6071454201db8468adcb6414429d0a64e54646a1627fdd8d0086cc094746e90655da5da173d134472d0aa4c15df61fddf1bf1dcef9695715e8a7649fbe3ea340c9634fd265e2893f47128b0ace88435cb4654d64ba3a4a5d91608ae45e05eb118735229b04c39f7bc40d085171c2cfdbcd763dc7fb5d213d7819d1809da2eff0ed41588d1c356fa4539820d984cf2920e151a36b82818439f53a1b693f128e0d51eaf9fc1a353888864d29ebb5342bf1435528e98077f0ce22faea6d961e3f2b555080a5febad332b4d6548c75bae3734477cf5906b2a6f91fa997373d8c7810be3402534e2f69eb634f3ded49c50c1bc2fa5aab675a451053f2a7f0bf173ba1994c004a8032d914d64e2ed5b064e096f2e85a386d6bbdf14c1a855a1c39092d34f980a4d1ae58208992f60da367f9e07fbf123cd74bccf885eb351a6104321263cf4e6d80e746d17a8adf48de5281cfc2dc7bc5aa41bfa2d9d2eda1f36bccdab7d6e1b958fdf410da3770561503d667aabf1c9632e7c9725dd65f7e45218775600b6485581cb57dd034b943742d7a9aaa93000f1cbca0575f8e2fef86b2d314077397d18bd4bd13b08e6d4d63bbdb29d090608f53f2d17ffe2a5bad1440006b739acfa494b88f872b8082e256d81c96eec0be902f78087374169d1c1a25011ac0cb07b107643c2c3958856eaf5b1734ce3bea85e0517ea141c238e6e97765a887a974221ed40ff4909e12bf342e622bf5a619e83c65e058e7324d59b4284de3be354e9bef3d8cf7965fe0fecac3977c0a01d05b76e3b7636efafc2fa0cf851572b37f17c6c137ba479ed5df411c22d13254844ced3a0f51d74959bd59c8f4672970e54429f262f9079fc1dea125902b5144abffad8dae6ada70a7d8e124843352291f1ed1e8d135a402f3ed9d4c4e05d069abe44972a6ac9624067a99ef0b0774e36a1efcafcdfd6ebe9b3d6ca4aa93b859f97c8c54d92233a467d14e1e77cb533a16a36f4dd073bb76725c8e7498d067a0662c07edbe4c28d8239dbce1c78f7d6a1a9caa16453614cfef8f2663e6f4c0d59549730fb0185b5ded7fea55e640923b0f643fddfe0b961396e50e9d78ad7dd7de4fac91f147132171117929c95db2e0dc74a2933645f2a6cb6295c256ae55329278b57a869f072923c5ec5e67a75d639204bd6fcfb4466419e15c4abccb75f9f02b9f859bc877d6ad45eb8809c6bf78a902a97a6134e4e4e42c4f9c32698934e02381e0b0892feae7fffb4d88e0aea4cdde8fcf0b8dfc1a4fb8348215ba89910780d3df6cce4f13d75613c3910f81d7ec181a3ba8bd210c5755fadc1dd6cef188fe0193205a0cbfa4c3847571fc173e17de563f9042169c66d46e44c5188cae074dffa647b8031c3b37d361198de45b8cf073d6d01393f668d2bafd031b618abe42b49bcbe26d983910be7eaf67ca933e9e9d80160d7c0c6d21ae5d41707270c0d636bc5e96fcd4ef771f3d6552b08aec20a175c709c8b822d59e6a76d34fc1cc7360e0f79399039551e8d1c48444f4d14ff562d2925e4f74885c223bdb55e4f20f324db35142e013f84a42aec29edfb5c30fc628da96516d9311263e27a9a6dc5cd852fcd4666ec3611d60be9272ff00bf43a08dd11f8456d8413e07131241577e1b745550cb2af38d45045f67e7688a4afec1cd6dc7cf76d5472daf1b6ac63f974734206da5f79bcc1621e211bc5b6fd7a5f79d82f4a18fef94d9316c5be02a7e343bf3079150311cfbe0d5e0c21b646ef75d8c6cfd47e007253ac15e72091a011705bb706bce55e8eba601da575f49ef52cc6f5660c4a482fac4f79598fdc0196fa77164a348c0e1df5aeb73e69a02d76954f98909dc4c4df68fff2303826b77b75cca460098368d2e2ca75d4aea337ef4719ef0323982ec18f59def6b7093273e97bbeea8bedf07bdb73f57ade50beda5b4723547c4b67c72c92c1d7f70030765b6bde27dc7845a074e85d8e395f5df830f509c98714c07b47792fc30b92fb3ff7b0b378b54db3a05874fea11b80c40bd70a42487df9598318a759ca6198699765086b34b7d1bd17249a60053a959f86df7a2063ebfb2ce35acc7a066d9c04b887c0d286005d54bdb04800b0fb9ef0c2a5f5ca4a271b4bc560a58f0777bb40bbe14ed40c485e5cf838253cea60f950bfefb3ce8dfa4448f1fe5d0997d10640fcb517ec464c995a7683fb6eb0b9847c189ed195d36c3f105f4458a95ddd5443fdf5be204e6d489530724056485e75c3b163e5ce9d5f0cc2d4d25ca61eea15da4cfbc7ccf0b72b48baf063a693d723b5e836ad8ad44ce9891c89018e7672b4b5b3a2fed50ad314b6fe8a05a87b4fe217a208c374fbfc2827cb36f642a31258d4bc2ee767cc083d84c2e68a861f48b749c0153883bb405afeef00899d391296b377681350e06f328aed27ea12394d1b22d357759564672165f074f5fa0922d3ef37917fb92009d65b57b38bf1347557a088ad28de22ca98bd39dcfbdc260374ed033ca4e0fc0b468cf744862375cb45e2d86616ce3668edae294fbb447414eabb577018c129c075d03fa4488bdae6851115f744ec2977df2019741abf448b1f2d4ca12e6d6dda48f7fbd175e8bc4a022f472b80d6a0938c321755e37a6a41f1aac85c746222d09d85be2aa40a5dddef516cc411b882dc81debd5e328af52a87e5cc0d6b05e883c5e779e12357bfd796646f6fef337be9343d0f9adc2e9d9264549b2be9e9a8b6bc1cf734db130fd76ab8dc4c3802e776b57c2551b0fcc8feb0dd98856b861778b8aa1fd69ac6ce78a0952eb3f81c5c409ba647ec4f46bcad499ca62f0700fff77a2ee9edd39bb4e64035c600cc783f747f4308d16ace4d4df8f6acf3183687dac65d174fdd4021d622bb8240eb62a0f23252df4f0048c8ad0fe72385863f05da3baafc9558a7fef813760c59aa442bce08f41998dd42b535082369f705d658c519bde3332d0c6738e5186faa605d02280c595482975a6d25316626bbc9990218bc4e4ccd26cf839b49b27ff8d231fb6c9a0a327f79deb4cd422716dc2f70f6e26d3e3c0d3ae1bdc3db8b5c07af75361604f7d7e7b8e6a7f967cd248241cc48e4574a79e070b50c8b1a7c5d620ca13cb2e94252b53d909befd30051fcd941e2d64c57f9aad63151d7fcfa48295011f6dfac1c39f6b3514ebd755fe9e50e93f3dae8008fd106277b0e1b520953c14cda4077f73bfd4fd3ed0c80b94bce90f2e347c772c98eca5c2299328b9b1db7ba676dda4351592d07c749e49f8bca1570d31103b6af3a0be93198f408aa22f313b6a1058026b4e3da17706d240736ce4fdce9ec3fbea6a31bc994bcee54bb02ed448b96712a770ec0c396277ea203955861b07357141f5a09b1cff817d5ce1513b751f9d9dd565e82557e43175134aa6c995683b418ba345a4fb6b8b10ecdedab0bbdbe2b47758a5c685d59a8f6f8d0d11e091e24be752dac0a3438c8a0e863f04bfabc99a932254a56a1301abbe4696594ba86e6cbabe683c9862b7aa68a30f8935a76c06db622df706cf1f8b39e2a50453f4a1a099284bc60990f453a51c6b57baca0d6a060a8aa94e555b4e537e273bfe387027167503a3804d0b82ee1306b087c89490a8953432746d253a20cb8ac23c0e49f99643e1a426a76711c04e676f6427dda9d3bcbb63c7cb144380a440a63f98c9df1db67cce64dddba7a8888286f12cde75f090c6b1825508b04ad282d0f3333d79477b0ad8b9ffb57af4ce21754f0d14e5ac4a620c69ed293bec6924a0131d3a5f05f0df9af4aa1a64544eacf8afabc998126f0558a67a6b4699494bca64b279c89ec139c9ea886ef2084f29caed439205f67887db11fbfab39be2e9e14d7d4ee6deca3f6a53145219fa3b9e5bffafdfaca5cb1543738fce6f70fbab88dcd75e75dd80aa762e7895a0df25f14f42a23cb2f56bdb66d0c5af1f74c3ae31740fdcca304681ba30f1de3e157a0c62a9b861332795f3f242d5fa942b4dd78a7a8313e886f79661de053c9dc2e410dd46fc0985ea49cac59b340e198c6dfaa3f01c3493c91afd86531436f766732a15715f6b150f3214f7499b23bedfbbff45cff9dd7ee0b5a0b1bbbc38136397d09b3f8c920db56a688601912fb228ccfc5b2e73d2ab6fa0c6300d460a7a1056dc3929ae872af0f2ff912c042f73bd8268717b802718294c40835bcc0ab1a7f12968cb64ec5219df520c718b15370542dab0e33a5edef05a1ad2c9149a2240a1bee736d79211faf1bacbd5a06cc2fbb1ce887c9c7c2061810f0ca320f138862e11acc72f579629f6c516b727f7b988ff332bea3fb200e6c1d1c196a0a2de9a10f40be03a507889b90c78601cf92076b51984aaebcefa1d33d28fe676bf251c4a7f45366495321f00759687e36b808a0a3d67739d161390af13c6289d0189cb87dec40ae3c5bdb8b1fa0f74cbd208ec9fe1483460a9926b4db036cca3350898bbd65bff003f085f54bd0d1876e8138b5b181c5ebc6ae36108073c683b5b4df7d177df4565c7b477ca98665e9cc99fb6ecaf6a2dd46914dd21872b26d8e140246f67bbd837510aa5167638e23190835e5fab44dc2587aa8e2f42a95dfbfc623c4d75fb1faf792adacce2a806396837d12f83a31b7d2185707361b4cf833d44baa02b71ea1070ccf991c980cc54fed9bd8604ffdad205a114395f2aa0edcb78f49e3f835947255ac2e10c2be7267ca79fe7095b88691c6fcd086ba26adeea8501627c10a8256f18b7ffd3988d9398853125bfc3680f1767c717cc19a3583607134b80907f2f4285d8896652bb19f1f0c9355885264755f3051aeee53918a9b6be8f14db7420d9cc08ac9da3a78e2ae826c97bc542f711db80a6cf1df19f86c1b59a99c3895128b865ee77215ef0c7586926f77e269080a0758a63cfde43ab0eceb3967c9bc7b772c14e637dc3d90f4d9ecf6d193ef2958e37c74339059dec974ecb9e74899b0b7ad4ac024feb301a02d965030eb87091403f682af9d74b69c4cc263ad703129311b46a88535aa8f9c7a2e97168bdf1e33f0ff2249d53e36375b5307e2819f2a5429a7b05241c6b068486e5b0e0687738ca7a2595931944060e5cc3addd9aa1bfa9fcd13e09c043a1e3ff3c7ab64d1f67d1f6b6794a34f38a0e4c1d357aba1c2539be4a1a9c18bfea2397fb2be61357a9080dc7a45bdc0079c6fc2d891424696fffa3995d5e6d4c4b6cf5dfb00a0571d99a65e50d3eb5e10edb8ab670337ec78915e9e59dd346bf1bff948329d59d854dcf93bdcd45dcf1df84ee757b0657d2fcb6ac58109e04a84961c5cd828bb07e9da9ff3be3a619dc405a3820ec261faee2c7eb476422ba5123a47c0f8dc39f95f2331441b70ed2f912c3ef9095fcc87c318bc1efe7f39173f7e113ef33d14ceb8b9458083acdb1090cb5c49c838f79aa855499276ee7b6590c64a5fe60c5b3a6dcdc6a7f796871d043c30dbd6100247599f2a1f47eeec66148610ac31e64f682245a6c53483af1fd50c951f5929b245da686c92b3e05edeb39675b563da86f3169058f58802d447d31075f7836af50bb32e1dd8f677ff374335975a7709c1a14fc983279402dd98ed5d4b931189b1b6c4dda7f24a983ac1fec1b36d059d5d4ae986fc7f6c12a8bd874ad5cb995f4358fc4c5388964a8fd6738b1860605a2e3c2b37ee20c4a2e618f264cc70393e15c199fbe9355883be217ddb5dd3fcd36f3b3b53f3c595f477ab6a4de29c31674e47095d4b03b32f43de85494d6ef6209e5f102a5528d44f4e0a81bbb6983915ea06381bcdb65514e11e0445cdaca801477f265a62b5e072d0f01ac6dcf200977d20979ad63422d3465619439b8e681f06a1d3b35d41a4ab6e56923c256ef72a9ce3693c655c9b2b12d5cd36b6ab7dc7e8b7343f463561c9e1a4d936c55df7088d283c205d2bcb77fef2b28f5e0b7b9f664d61b0489481c0720e8f275908bec28aca6f1bea35c22049d0c8a848729513a3103472f912c8495b90a60e43377017a61dc8c1436a5262ba36273270e66930fd1aa1ec21921e47b44574242492ab2a9b0a0737ffd6a7eb43f9d6a9f351b5ffe4fe86f7360c6b284d977e503f92c9244cc42e7d45e2c4c96cac00e1a37962a332bba4da770e2ea0ce447a537404fd74f7113365bfafaaa8b99fbef1f999372046e41b2393f7b81a1c32f3819ad33d6dbb5ea5a2df8dad1e1ee1cb72865c011ba110f0d10fd93832c980e1102ceade60387de5c4e4f3b67c276fe0334594861cf55f059f3bb4042cac02c8a6fc747606351b78b7329b03a18581f1c57c82a6d7c4f48deca98734ff2963994ffd5de25eae44ce3f7b114dddbacada3c6cda2f1db6fde24caba066c39825e333fcd8438be5bdcdcce59bdb796a0e5193290d24a8e5eadf8cb0df6fe405fa79b895725e1fc746f1c26756c89e094007f0819352161d7516eaafbe21d814aa15bcfe636bc6e73b3d31c5d7eba277763eb1177bb7585255879298756e1abd73fb26ed0b87ce5c5deb024628206fb78b99317907267b9b1d8cd13e752261d1554f96ae718e1ddb8caa29f0f30e643a17479c06dbf555e4a3f6c8f69c746b35ffe0ed6bc3bfef9def1664b427e10b4f791c2ded35b7c53172e8b9666ea853f303d0b9e10fd237959e89e576609d2ef0c653eae5edbfa7f89da0bff4ae66586182a123a62f89210ebf1bfa49ac049154c43ffc0fe20e7f6781c2168deaee5e28842f4a9aa20beb732377fe6ffb5397cca70bff0bb8452d229b74337de87d2e5207e59c4fcfc2934bebb7d3f080110a0948a9f0bc322511d524a5a7340611ad56d6d9edd4e6f66a6ae2a3cc1690d8b5e6a4b6170c1a96221d5d0865612f998648c89a0e176806e9b0e6a461bcc0feca6aaa4a8a2b441e3c849d33105ae384bda560157c935dd1cfb0dad95eac00f08642e214d41e618d39ab002b84d43c5b734ec67082da520ac11bd08d7f999fc9a69536e1d7be3008c0dc3ec1fd1d2659d6cd34d394cb3ed2e0d8d1b37cbbdf2845d9e034c70a9245b88867e65c3c155ecdda9061c25fbb2c5ab6e52504eea3d12c5c3a6c9bad276adc591fdae43eaaee0296f16c620577a0acfca273925873e3ad58d876da2fbc162409420d2ae55aa55079fd118f74a24b7d41df44759cd356714e8904cfc58220de74eaf0c8daa5e0215e7ea67652635529993ca149eea039e4a75745f6e6f04f52d202768dcb17f39f1dc2da838b9809b4ae90df5b109353044b8d12aec2460bd7ee17f40368bb51fbd0bea5679e6a0719785c1194d572e1ba14d7ce543b16443cb53ad2e35f166a42051f2516a6a1679b55619823673a64eed4310b83bc5727ae2ffffe58fa39c2d16a5713c2495b9801e81041245fe81a646f9f6b0fc49bbb535d5c8ce23128b311cf3c836adfaeae5c09766a7fcc60b9512f592407144901569345b9850dff65c7da1b030b25ead6a06ce0e62e944eba229b176977b609de835586e6cf6f990d581fe4cce44fec96b96786b77f6e98baf51b9eddc7a4c6dae58b4bef5c4f32cfa2c75fd820ed488b57d2dfd7dec303f7be18c1af9d3a869199d0c4cbfe8f6b4bdd6de1e57c50ae588a118b9b8280240d40fd37a6a9c2207c45fd71386cc08ddd267c963894204a18983029a6850f1b04d2a5402e09ac703a5dd0cd5f482ea7794bdbacd917fc193098941901ba561c66fa8ee521a44f76820c31f99de5b641a555210d9e9e9790672f7f4dfc776489a04c67c73cbf5eb0de78d9c8c9a908e2fd53dc82b9da9948fd42ce6f4cd89bfc4d0ba7949c57219c2f5f8f441f923eb5ce2b11cd10056a3b3cd39b1358d9949da0031af18ba703c50f701c7180591d7eda1f9eedd71c6b992396834793e7e4c82a42a52dbabb18fe0b792d0f01afcd210a53bd09327128812304e79b62a03a172ce98c07e38bf73bf37324e09f7c26f09851f0e3877da98e5ed16a9219a6bfe9838cc2889a55488b7f78c41baa882d4090e285c443abc743973b70bcc07b004cefd5b6f239a86e3b79a196d14e54691d120eef1a2af824d6c234ed4c98da83d518d87591852f13da8d070e8f2dbe154abfb0e5e79a5c128a657cd19dba29b98f2282d939f85fd8e26f5adc4d9ed16bdc825a5367f3fbf6a0bd3fa13e08decd729692531e889030488e447aab763732940adea8346240384ff369e7f871525d1b371d3ab8c25fa1a6f1e87c260628edeea4b8b2b3718bff1101eac8786de40424fe927246f53cae331518e5075aab0c537281f14cf6d71dd662b9401c41a0dcd74850a15f0c0740d1fdbb535256f28e84a8d88ed65d0baf44e20552350ff758ae5b1fecfb01182dc544b63d8f0e3c0c2930d2298a39506585c9f39e59e542cd6061555511fd564e6a16a33bd55eed1ee32f3d907b05780325cf7867e42c6d6a547815a33633980bcfda842dfa9d4f8e0e36f1709c297c0669599ad227fbaf3bb0950e61d50567034734e89be40a2c64a71e229cb7968fce664370b07701e5b7afb1905f98ac78df65c52d8aaf20714305f04820b08fe041e29963450c864a45245277533d9b3783f5cfa6336e22e51290f134536205146c6b2864034ad0efc24626999ef195ceba894b8104acf34bbcdf13abdda52e8b9a29243b8e01f64689a7d7dbb41a8d08eb679adc52176e63cd657e110c70be725e59ce77b3d8b49410104284781cf8af060e39592b0c72705fb04fd50a40567e3b97145d56a3a29b9a6bf804121c6b91a47ab1e6c5350cb4d52f883462ebcda4340aacac58765844b4e6c94a1a463116b137ccf7edb5692381b1edbf2a48f81b1c1bfc24b73fd68842a19ca77e9622b280ac8f8948b88977310cf9c8990b9a1b6ce81aa935e5b49187647101e6a10093710f838375325f34b4d402f246e1580ad5d273ca125035a53559477d8370f11148e08883844f50a36c6b359d3c954822019e56f1945f2ccb86c74eefa2c4a079ec301a7ccca9eeb5807be2fc024a915f14e7a6e5556ab12ad6e9629ac93331ff38548f6bf025cbb5986061cfaa128a9903abf1fc104c7584e34a0c69f14b9e69d7fd7c3255583a7c4775316262d110452f86c71ef11bf0d0ee184a550ef61982302c6496b66ad43d0514ec43c6d9a6a5b706537c4f2af8c35eb737dd6fc7c38f4140ea0c4ccb0b747189bd83182e8ac667fc66ad016c033589ba62128842e92dae08942862d2c2dade13479332014033af84e28a7a18ad8e40f72862e67a4c0881beee6484dc62a58cbe9f1346ce6ebd0be7429eff906eb5d4a0498c2e1652e82f99dddef44b6616ce2169025c76f4ad17e1dfd43b5d056482e73c0385b7e59184ef4282d92e406a4e95d70699038e94b53b57412c82d72e26845b441a581dadf8fc392b133f68ab2191e5b873cf08bff658d05d44f3e950f168eb1b211aec665560611db836386bc641b51bb329b060958ad57bc07d5d8308a53de604268a070a2b728baeae7149228d32c78c7955f16b0eb9f5b67b1ea9394b69092fa2b21468ba7f36426d6d917397c21f386e577b9d9a48417ae90bc69e42150986594bd749538b3ef7fef3c88993fc81105a65286b4bc7466098dab579e96003aeade6d0c24e2f17f68690c7253c609518ddcfe2a5e8a01df0069251955b5097cd862c8167e2e4f01cbfe70f454fa1a93c8a8ef2bebe0fd83dd1c11a5dc95244ef36761ebc4f556775aa3a28a2e52c4900d0e3f8246d06145ccf6e38c2ed205d7df2b3cb7da7151bdafb16db28c7e913760c5c6590fc32a19f1a190c3d5a581296f590ffa0e5cb147b0e8eaf3cd3b64c0fc6ca0ccddf5c52987dbfea744cc7e668325411ccebecb1a433970dc43cc2597230e3cf55b34dc3bd344291c9c1eaaeef4af8498144bb55749a295842b290b84a8c5941331e28a6b06f7afd0efa40404b47d3ddcd1ae1ef305775cc1f4d5532548150002c93e67b905556774eb264cd2a4c7ec1656d5b8dd2fbb245ccaa0bc3a346a853b0016e6feb7e4b07930f56a32000ddbd79aaadf72a35db566d6b8d27d31e5a746c6ed9e256828931d95375f5fa5feb4ea6c43da4d7c04761fc5836b4381ab308e8a2daf563412192116043ecfe4dc4e0e107954a9634d637c94cde0065cc7a0ada9645fb7d4275bc16b1a73be8f5874e344f830c774055a1038e4315a6a1438ef0e381d905c7b5547ae144ec238d1d2ca8744ed3ca47baad0447f9be4b63c03c90296001fe1786c5d8f84e3c9acb2a6d81b37b3ff62bb4234dd362ea517c748be478390cc1061877712f5f18d5963966d874b38ba77beb2ed9f236a547e39b9ca5602a4c1f067c8d5ce44d1fd28d2c68a53fd688c2ddcf7bcaeb161860ad3a2cd56685be08c9d947124b2440e4e4a25e935ed6dc7aba72efab6cdbfb753e5e520ac93365f6165cc652e85c421d857a560e6ae92676b3839dfde9ef0f17cab3f7364c7657db2bd9c40e8630ba98f75422f56016a921c830c5249f68a24ccf9910296f020a44694468cf6928a142ec1010e671d1a92e91bb5d40fd1281d5c90e50910388af58c9c99cab4e6785c559966953b780c3d07cbca2a7b280108613cb1adcf95e3736d4a2d832a556fb5ab9090935f6b9065b973068f241cc5f5013b13c1a611e499bae68808d550e52cc1e9e57c7ea47bf284ef93177f9c93ca337491c37c308354bc7f88ad7a1451561f651efe574555e5a44dba0779788e1162b1b0805be7dada6c295455c1819091ee660bc9b78614711e971124d7f97452f9535fbac03f21ef125b8a38ae469cf479ac4d290b6d4add611f869342f54c98af4c50f30f05fc5f3896b0150a0d51d90016658c1378783c3b23bbd2984e4ff60943c2562dc859677c626e9dc7ceea7e21f71670fe603da3deda50c556ca453d634cbb48f25c018633dca45580b4fb5c36a58ecc6e9f1108311b192e24c9ca0c79dabcdf1828cb856d94491b7cc4e76acb4e7d9a031b63b0dabc2e528e4a058acc2bec5bde2d46dda1a29a7112a831d60dd71d16a78bf7748186692fd2dbe42f1e81ce2663ffab2af519dfc9f26c0f5175af00abd0101df4101a162e33c2c97e4b22a7820062a63b1e9f3b7914ac33b61167d2b13b5f6d8d0f652a4c8bd7f3715011495a480ef82883e6e701e7fd89a0988436e43d7ba456b1a82123568f8143c05f08370d433414c4b39820e33336a487b944c9f310164e4c512edffac806ce7745fb6aac40bda6774cabe7948831c3602b0f9456ca89a31fe10bf85acdc5ff8800ec314c3230d62d6efd493cf815e896eee1cae2f26263eca22d82d3ea48b7371de5a5f909e3defe0da2e06869fe1118d89654474a703bc625784059c7ab4f86a9af944e55dfcaa1e1ca59b38a737f8f7bfbbb710f4de1764faa83ee69a223c46201be932263014bba9f314471e037a511dd726151422e4c533876d2c27be539c31cd8f08437559f83f8c6c1ab99c4ff55f7dd1ee31e721c4ef2bacc0ab135ad0431acb4cb789290c9631070b187a0ccc8ff993d32c044f6131b123175cc0a008354b67fcda003a727b1c93fea83186ff9af0a1e9177d7df9011f24d1c1b650444d10a49fb35c0897fb9c025f35d61f73ff8651e1cb74c6190e83a017e4e741bcbfe675bc16ce472542a06ec9e33f573ab331201bb1f450fde2b75a5e04e5f8610d87ef16b029a71f0e068ebecfcaa5e910083ca35fee8a7b0a3d5f0fd5bf9c80f6a423c2b396c34a96e7eeba693a5f911d04163c41b47b37213cad3bef52415cfe719a6109c4eaae07b7321f42b0a3b586a8639a7ac60419a3e38f98b406399e3a1690f72ecebdb69515e0d501f2254212cfb78d841a7ec5840c95588eb1ae2243eaed4fe5e31b6333d33d58dd62207a5773e7786e17575f3ab15018fb4f761d2aa9e795a584224acecda9b54264f756ee353bbceaf719eb5fd3f64b6bf1b3b99447dc17954aff317062543adde39e8971d2f0c8ba7d38cb8999584abbc700ab1b5f6dd33f4b6c8caf1618f2f9fe1c1f03abe71cd046a8b730ac49844ee5124a609624606caaf6400df5317129f061a176eb26ab4186273238a7c6f831f111f619984a4a2b974a31f6e04cf4308136629afc398555b5b5e00e33f134bb14fa4b5a2c5aa8d4938311868d3e3b6bc15c8e16ec469ef71bb866775b5f7876c5960034823cabf593b2471d5c9c3e2c87319529732c4675a0142f09c5ee699f667862e6073083195337563d491addaeb081e654e7f1ab15c16739d22e343d1b019c6e933ccc5a93f31ba840889ef657e130e75884f8c5951bb15b570f9ed77d8be179452a595c89795f2c9bb5a1a378c3a318405edb80f4aadd32c811b9953c9375eea2d128cfa4f80beb7ce991c65e2ed8cd458c7e4f0f4cb86e5d3ccbe7c54e7f4d815952487ba27a01322dc0eeff5a06d43bc421cec52c102f8ec523eb646415d0eacfaf5a596f8e44f8e0f919320aecc64037d9faf504eb71e975f5bc1242ac30240c5ec9d031bef42e3ea5e244173b4c79c4a5ecfc7ab127d259520855f4f441a16cc70282dbb89603000260535ab4d9cc7391497604c6b56d5be2cc7ffdc0cf0a46e7ee4d4fa22af9d5619cfa7cd3ef3d4d2af4ab2b7d64fc6791e7f342eb626dcc432551e1f145fa36226ba39233cc88ef728654d7086f2c2d3eb94f80d7f08b988a64b845b42012f97e5eb5e091be5c631f024bf99c83550b5b395c9e9488acff2617a03e148005da673ae1338fdae5da5cb0946863fb9aeeb8d91e87fd66021a6dc79b19a5bbe6866e10f66c6671606696f76a9eae08bf966e0e6ab235f05703cf72c1341fc38130f32d182e2297b5a273f8d7b6a33a7c08ba012aafba205c77ac76349c919658ed4886fa48a749d96b3d7b7694a18e94f95e53a62d36eaf498b9f1f1c8ebc03ffbc8da8f6631ace54d23b85fa790a57c6fed39f6e419fb1d5148efd9e4b66282b29075b3f5356751a6cfb227024ac54d28a250fe8c621be7c2088e278c788255c19c220fb1e530aa9232edbb9b90ee76f802c632f0307409831cd553cb558513763e0723abee1aadd1966b4d3916e896c77744d62bf5c4578226a3744a750c5333ef8a4a2c5bb1c7de946394de2e52088e54016bc6bc8118c87379c4a581976ee480b0e0bbfa91a403b5544a6d76c96fb2fbbdd7106d7fc36b874dc7b074a9e693ee0d8c7aebaca786fdf69e7298d734057f54007b672b7780adbb38d9791cbfdda6e2a82da33e43d07c1bf56cfafaaa4ad5e68512b76cd5efd5fc95896f22b718b2d9fa620621bf08fd0a562025d259415feb3f05582ae993985c6f61869c92457294ea0ff196740c68694dc3f012e36faf7a7cd5eb454c873aef2f70a575b45bd71c148ff4597e8dffaf911dd0b456fc5fa4c6db612bbee18485435e0b5c0bbc43250d666655cca664e2fe4f33b0555f3c786dd0603edf02ff9a6490a95922df6e7ac8093450dfd25eb1408953a6926db5769856f8eca962a534557f014ecf9aa3066a52b49f86ac9784d31d0385af7a2f2dc0288cf16fdcd26c2f2a7a904f90ff6ea1dd0a80d282cb9e7ab6e7f74e7a194990b714d432587ae163c18b3ebae893ed993958165f20acd0e2568231c0ddd3dc3aaea954f98a3ad44c88b3a8b920bd4fc1c0d3cc4b2a39366032e7f2fc633fb873ef260a5a72fd91fb184c738ad425b2dae566344731f1a0d9c2eb6b5a147831382b5b275dde8249ac09f58fe33016470a25f5b41e3a17a9ff733fc29af2f6371c4dfa7c74a2c1dc1233cecdc0f1d139f5ec2d09355a465e0cad38fed4cfa348fb7533c44ab88bb7fee4c5116531242b7aaa7faf056cdceb087ed1b63e8e53a726ea79de81ed97e129720756926ed8eff8b7403dd7141ea954b3af5e4b9a0db51124f4b4249255b3ce31cc1cf620971a0d025a48c3dad97c75f57bd03914f94beb96d6b0951b528024d121ac55589e66d212382ec637787bd73ae5753f2bfc21aed063c8ddde115ee343b4ba674c8f61186e788c428675205d617bb349c83af037184b5b0df351e2a18ad7778c9eaaa13fc85108aacb59ac51bcce814364ff9346b9c982a73ab3de75ec77713f59aa9e473e2923448a97035986ce8514352196a5e95769cdeeddb3f60e0dd45e8fb08bba987e4331a45bd96222aedeed2f6fd84dc95493f7a927afb62fcc58219b6f32f1163bb50df515ba8bfd884747e45756b896640d486946d42ce79675951336d923590df43e7af3c91cc9959ee67724e731a616cf286f9d6fea202adcf83f529363a992f6cacc0ba735ed0a1c704a8393b4b5150cfe4fab3b04e6639bdc4c44baf6f84e1e066c7c782d0aede2a509a5372c4d713b70185adeb2f2a48b70a54c2040f6a27c76bc5eb7f391ed985a47fdcbe6c72873e0199f0f1b60a88cbcbc5ad4f6aceefc22403e8c726c97a7614998d22d659a0afdbc49e9611efb6bbd10e42545b7ee3c8f9a003d624aeb255bb10ad5483d00059b2e3f5df8ffb4fb245288596ea814682ecb6829843318bf73f1b2b4fcbf877e2ab5c5aaceb4dcc4a1870eb2d6a985965b06b8cab1024e858da78cb1d1c5ed28d3c838aa342aa367d9e312397765b332d8457d359bd17c23f2a9182892f74bc7990105455577b0d567246bfe99bd146dcc5b9864b2aa4a038fe45ee5b0380f1baf5e56f36756d3575bcedef81df1771daa7357167a46a15c51dceea7fe7ac79be7d430fd0dd12716a0c1feff6b578a8e3a2c40fd274f2ad536e52721d86dc57dab9d7e3d4e69f1622e563fa844cdf337f51665ec027e8e4189c9e58fd668472f37bbc3d4923469931b935c10fda0a2edddd4ad258606633cf8c50c0422659d6e2d2c2e271a7a0bbb28a59c105787b5f80fdfb5ecb937cd0defc66603c945829fdc4b6da616693f21957408d9222736a029fb6f585d6ade5efc7c10551963a4479a2648a0e34f1774312cb462f74e7835a79858f03abeeab7c76901bd37ed862ddf7dcdaa2c1409d7ff30fbdcea7197bcf935cd479294c21f047ad886448016ae1302332f3e52c543989f9f853ce22cf202c1a74a2220b9bf8d539693a520fe5c62ebd43650919ddf7b4d165cef8a359cee06dc142d7d4fedf9d0db795e4c47e57517a4f5b8ef5913dc01295f9be5e54c1cc4dbdc4871ff97375e5c470b270d6c3781d945c83e155a8bd5bdd3a744caf87d2cb0df02a29e0f6658fe2a40ed9525761a1dca936e00ab6c52e866ded3ff6bb1120afe3b5d1f15ec37fd139922ef7f1b9c5d40d8dab98855cb16e198ae36d8bf0b322cfde1fae43573aab859ba734a7ca1041baa377869d553d9cf36b98f8fd5d75ef980b3d5cdc05197b860227380f2fda1f045192584b77f80f014653576c0cf99559f6989e7c22e879b536425266fa3c41fccf7d733684e44f1f7d1b2e8da918e2910cf452e3c024546272c9ed0759bafb120e11781597c748459b0c96448950a5d960f755f1018d0d64bdf5c08774c78abcdc0086d33c4df57b5b18ac3683bd9bdde1252b8b127fb418a81aea3500ceaa7f0c580ec952406f19e44485cd7fffd18ca721f750eebfbb673c545439b73e3b8901483a45cd9bb5790ac848c21982c398c3c8d89d5432998011c0cff6e95afeb9552a3767cace717fb8139abe7a14721838f18ecfb08c7f610a8e0d20cd3863c2ce224c596dbd0f22e818b0754d8399a5cc2abb0d371cd22eaa268834a444a9915520bec8ce299d2a6ed9165870686d6003cf0064a38e923ff509757e109a2c61b7f8dd971bd1e55ade839e0f36f91a4eeff22612d8b74919ee40e87abba63add5e1650b07010309657f2007527d6fa42535f6647daa6892fea6819a8d53bbe027405869e1b07b3faf87f35351160656b6afb885f8c92ec3fa0c199f1bc60b336c43427ec6da8a1abeebec857634213900a3bb84f6aa401c9d42218abb3927b6cfc79eb9519de2121b3a60f1ab07d2dc97fa6ec141db013d4614ec5b114ef0a556aef7532a6ba2d2ff89465ab24e5d9d2ee39854be66d764bcd10f6b05f32dac9dd1f88f7a951a9bea5101946e9201734ce58f55efb3226e1d97a6ba4c0a1b72bc1ae095ef087f0191c652358d4988aca33439dc1c5df22ac2a5d03b28d7be9b5e50d84b8f809aebf01a0412c7069c4da7f8e29ea8645391fe43961a06ae2df8eb69b78be2ed0d8f112ff2451ecfb12f86eba0bf2180fe3e03866746833e9ad183303471353d2579ec946e2e80977cf54448ccca54370dce12135263d94e0fdc852d276b7ac2148730350bc7899b9bbaeacbefed455f4f13a1fbed3162bc9e29564e3155592c43b4b06ec68b6e6cb63aa2e453f19e516d8b6ca11e209d2c7c6dd304e658f3c42e163a51d0838f126906d3a2944708ecec5884ec88ee3a37368937285d221f28318287ad3fa7bc3335e59ec61f444b0f6f2aaaf3614e800e5d60e6b2c23a45c71f3877578b61277678c44a04714f2038d2fd416f353800f4a59a49a9fb67778c71f1a380bf213c9d1bdb19e126cc8bdaa06bd1fe33847a11db4a04eb3ef92f88492a61dcd32afd2ef85c68f89969fa927e35ffcd17b57016972b15c1240bca846dc0ce737a93034371269532f8f8cc17cb91cd01585073c10c4be0f0df09fd784e31756963d75b0fa48775352ca2ddc17461ee32d78e1b0ed8d9e94552918c9790b58cde96bb4fcfd02c9f5a9f1fccd55e20fd6e371b7d8f44f9f6eaff1d91fe98003fbec5c6050d902988b1de2337a56decd4921d707c0d357b5c5cfb47459c738f25ad389633c5612898692cec7b8b99656fbd788f8fd1e40b81f61e4d733fbf5d1cda67d55e555ecdf8ced5dc076ff81ec60b78934f75fe1e0568bbd3f4f6b80b14236df4b0844d8e66ffe143b484db8a7d6940ffe315702912ac1d567d0a938437cb37022c4d27338f063e05686ec54fe6499d4021de039c8f6c66d63bf5947f401244a3169365fe97d9559372dacd259a3cae71f4b7158490f947f432b558e4348864c5f8252be6f22559ac9e876c76a69d07a1668d9770c3245654cd1b4250a99910b8154a4041ffc8d1d729894cad28c6217d235f1519a83304acd30a3815ea9605bf10ed0a1fb5f048c34f20e767cca2320100badbaae43767689e67c8481424d3003140667783de603a97094237342d8fa783a8956ebcf5f57e515f1c2e622a20bfc98b9c5d015f950d0f623afdfac82bcb9786acca0b7d2d740bb8e0ca91ddf41f1d4ad654919e26ce96e9547d779dedd83cdfb4ee7e3727ecdde366f8a157c63e4c27af45e6080eef6fdf2680203f06d800e4e67307f0dfedfbf366155b9455d4a0390a21e53aa6c7496a369bab9c4d763dc7d6b40c43a6e98c8f7a72ad1bd3eba06af70c64dd29182757a28ac5c6c0eb80bb9225c8fbc21492bf19fe378d19bd39b51f13f8d0a31772a96e81532c690f78e08f5a801923d69799940ef86403acf354bc32ec298818f1debc252b5c738fdfc523a18db044ded288c5129bb49bb47bbb04049f1459183d438a27da5a3668c0d1e3a6a8e108252c4546263eb18403bec2e155733db0c28c1277dc13274922050406cc6c2ba9129143b0244e4d2fb2f0081d1b03c48ca57fb827ebd56fd1519f25a85572c5041e0e0f955b3bce7dde66a28b8724ae089de55e1c67bbf5562e89de1bec8bff049e8579df417547bb6c323fb5729633f377b853dcf2c96faa9ab9d3b59c8f146f934a6b545c64b408955af0d48c23aab2add2636449b2ef3b8889164667e9c9089237b6cdc0eb78e5b81e1a03fd72b31009654aa8e9b5cf98e1fa8576441084e0e9303eaaaa2a22b3f3e934e1307830a9000a97c4dc20412074df6bcd0afc71596f139e2c966da0c59739eb11219d9015b67ce073cf1236114ef96cd105a32b1289b967da22a8fa76acb4b13098e49061ebfe36f5131a6e65816e5ecd17c40c072e274866dd4a71cfabb31ad8f34eae54738cdec239c1757acff1d444d5144f4ce7d6ec049eaf72e187e5078c5a59eab5c7bdb89373e5987941e6f52c770ef79b12b88ec12d1627bcbbe4c845b98e96693a4aa627e49967cebae457c643673449b387d4db0d500fc1e348818267f5c751e2ba1741cc04eee9012be06b03e5a4924b5052a1514a7ec7dce305532dabaa06228a6f8907e3958351d83523e96550422d0aafb39598f3bf3136d98c22df0a6a58373c60d924d2ed95d237498cf30185e920d9f243aa771f988fe9f4ca43a7a75204a9b5326db336c7de2659d39981c1a5a00a52f95d8a830bd11b2883faa8a5d1719f6f7a2311d329ee6499c2501bd0e187b3f96a2cb8bda916c3f342ff44c0f32231f7785c9e9960f4299e8cbf294e0eacfdb780a4959e48dfa0dcda55a9d60ef11ce145a9d750cbe1791547121d07f15e78ffed712147224a1182eec9c8be1f60cd7d27169d066b6c168847b1f300bd5ad676daf322085a5dde0d5de4ecc4e71edb5eee40b223fdbb82950f9bda832187bb2cbae44a1d3c35bb9a978e4a76075ea3e30562df12307d99d8b9ea6a3b0c208e7512c981306fb4d19cbbdb16874b3145b77e653c23cb93d04f65b9e5639c009cd997181fa7865bec878cdaf0cdd0d6c093aa5e225e00e13958ef95dffea79595399cfa32f24d09db8941a720a335004850645a88747cc287e1c0ea13fabcdddabd1fce63e3026c8f923737dc746974626296d44876aa6bf6748ba344243ceedd589cb06364f896dc4c47636d219b1bf3867429711f9841b9a62bce98448dd83351105b5bdbf2d77bf1af3303127cce21a605b7e1ec4b2844f5383b8719ec3b497133fbdc765809190381b9d048f7a0e2208847b45bfb36e28140ee1fafdde838ffae9e6efca0f3d822ec9a011ab1d89ed0fd007375aa411036ae75eeb75d08acde0b17b494267ca30f97076fdb6b83594bf354a2dc7236606ae1509c902740fda7ce6de399fb50abd098e09293dc097cd66e7e9b90ddd4fd99074788d5a7801fbc2b080bb3e007ceb46ebef59e7cea7d0e4d95719b048583187a19c77c6c3c3c7a395dcde5120cd1b4dff18a0db01db74f98d9b2e63fec6a1a89836fc983af40666bc3c56fe216319c82059738bde05d6c7bf64ed568233b02cb27af24afd86ef97985fbf807dc9d9319a2ebdc0d0d3a9ab3c5f6e2f419a9ac17978528b8789e1f3a0d7489ad451ea8cbcc4a00c1ac6c6697cedbd89dc432786170b02e484920ce66c578d8b53d96a8dc472543c88592c3ce6047367e689e1f1ac622629b4b4e3a45a961963c6a55f17c797bbbed9c64b220ac822af503c56ac3fd7fc870b71f877748ac4a8dd03d257593a2b2ced854070d499e72c4aacb20ba5e884e6efd7a02a75f2a326d2a597f0509f0c5c596ad6c6979340a6178455c0fc1476d696718b74043ca30f6eac2c51aa0cb855206a8dce5b84c1e3538c2b15d8670c11dbd63ff6cb23be15c0ede5df842650bb67772adff08e58818d95a6c2cdb1a4d34bcff6c0375a882822f0a004cae80fa41cbeb58ff611cda73c7d86eb41b9e6749bdc2ebb38f1f978d4b9f0fac0c92c666c4e057aa65365cd4ddba1775894ef7749ea5ed27fcfd44c95aae193ea2a1aa1d83f62018d87f62d59c1cf441b5c173b33d1a6a9d083671d21c5ed3704c85841e539345272f5939171f1d35b31e293cd1225408876e47f06f85b4bbc7b58cbb6ef8f8ea263773ef7b6878567ae477c6bbca0e09a3bd79de3f06d18102ff5ef44bfc3e3e17dca68a175f35821404270610c65e911965779d09a2f9d485bfa87537f2ecfe281b57892d838bc1825243d44bb17aeba22d4b8fafe9f378ebdc2b81117cdac5afd26bdd67cb22b74667ff23eeaf5eee64c55366648b00a68fd331ca79a4bf4aad77e1e4902a573b224d1ade2f8246ae6c98a873a5d7e6dc0eb4d10a64794d5486a88366c725444e34db70370c0ecbbecec258d2e23f5974b6dd3af8ee5c7480eb5dc54f677a01026e63c55cd64b5594ca6d7ef1978e478d42a78914448700b3b97d711756b7dce48f229e36696aa29b4768dc9f276871a6959d6c913ababadd7a2026031ccc88aa7579d213000253f13eab02d5a7a48d6ba78a74cd11bd4da8da196aaeecc34debde0dbf73c1491b62724782ae98a99ce9cdb64a40d8ae51b7e8197f24891b2f46916c007c6d1cc6495217656994baee582148bba1e328580f782135218d53f0be62b20ab61198087ec159778cff2295429ac56198a4e6704d8371dc10d5b63a84f3baf3957c9ec805e114efda5368b7f0707cb4460efb799e93baee1ba5f7287bb885f89e645e02dc95e028e3e72d341e8661ea45700967a78685f95078963fdd7d1ef541875a2fb709684502e15ff9ed68fa4a5c3689c90e5d22becaab800e935660bbf8756352e7b66581f9c6798bf8761f457f3f1d4dcd04e2fd89c2dbdbfb84c1f789e089105b4b90630c6117498946c153325fe9d3127f87ffde40809af0a850ce42a648d289909e40b218808b6566b06f56cb9c6c7df6e33c21f86dbfa73039263fac6ba7a5ef8a45e470c77baf3c0bafaec9031d38ddf4b31d5429e96d1a61b522fdfdb54cff2b86e6032f04596643a43e52349e198e9197e4951ba38149e501dcf82f431af5d003961c4c434629de7c44b95ffc31270e5b5ca6c828dfad46483522bb3852fa7177bee5d43e0a218c638051614ef7279807f3efefc72722fdbdb7871105cdbbaef9171af608b16ca52ff63f9c3a4f919cb557ce1a9588896dfb30a98c02718213384998c1e8e2dd4cfdbebe265d8d290c0c6214d917f85a19149eacf41846dc573d2e984bafb997bf1c2cb69cf35b766dfb6e01c0ca9b946617d5e77175f8145a072389dec1d2105d580343369ba34a5c423cea18a782092c19f7e36020d0b5f174e0a93075012111363cc168bf90e227386d9d2cc67b468158a72e2618cc2fd68653a89a981d4ff77082b2fc00b02bcf286077685e8f70f17773cf40bc1a34a234c05acd2f9eaea04bcf7216b52fee283e5441743784adae81bc65969fb282bb8a84461b9fc8986a2129b2de2da3445c8a10a15569d608eb7f69404717c628a1696b2c1ff8a7949f540379c66597af0394d5add08fba35afa351704d590a4c6de4a23beee7005b568f8253fada608790c517c35cc35b68dbfeb9c381a2b006d9888ac27115b3bd1785b3ec6fb7ffec3e4cdcf9475a5f1efa0e4a97053a25cc87f9bf0e089c67ac3b9788710bec495e465a47b7cf43f0987c4cfa867cfac976866be195ea8a37739a13af0307f94c2cc867b321efa9214a7d27d8a9ac8d4db603e76fae413670582b8220d1a0476aae2b7ebe14bbb3036664f6b9f11d9fe305df835d262cbd78bd19c4befef80b72a18ad106ed53693a31d857e254dc364eb03ced198b512c8e5dc8cb8659397c5f53f5ead38f237925a75cdcccb4a4fff1a9fc05f27af6f7eb6a7ec84573fb38e1d273d6843d3c36558aa936d8fefc9275576793c0ac67234a56c11dacf85835c769faa9b042a887d6b7b63df66f2f23ee5061f685f6f1024be67d1b7000c4e012176ffd4d62efd07cf40dbb31cd3f43aa54d6a7f9f9c9a45a337a46d791493477aef47e0f97d23c46e62ebc70eb3adc50dfd5061f888e613fbfddfcfb84c1aaad7d27416aa4b736c87ca67baf5fecf973ff746d119db1f741e792f0d365f8e45796cf8c48d13edbe330f0aaeb4f46e84dd1e5f068d38f575f1583e3490203f04ccb0ec290f43b59364437ed26164c4ef141094c306e222faf27aba3efd53cd77be960bfb26bd6e96edbfdc466e289b611e30132a683436c196b75ac16e4c61e641bee3dc99c2d01478cc59b9e786b53d365cd598b1ad156218b5d271db19e4feef569e19cb60b1e8237f8a76a1b593600931e5ddbfe35bb0121da66686fdc06ab6277ad38de03b8477230e1d5cb35bb637e8ad485444b6d4fda3628dbc79490d60a25c492b1560b54431238661a0d73fae0a2a25336aa286067af2fb4dd53996b61a42d77c7466ca4dfc38f63914597d1ac4ab407a0f49a200c841eb2df06b81f901b2f38dbccaadc49c51752fa35ec4fbd9cc8a1fa49ac46b05b92ac0c3e93dd4d21b0a0f6e1cd7a03173045215bcfd5d8e6baf45e082f25dce14d5aeaf8b3278a028c0e962a17e220dd296324fdf46fdfb72f4987b1e6e1aef8d38ea4d8e15d1b28c2c58e043da024f0e4e959a3da79685a2e93b45cc5d7a8448e08f7c8e21960f6f13f35ccba5ab1cb4b96eba78f03ce5c535fe451f0bac0cfd803f9aca72d339f5bd5952f1116c5ebdf33e49ac56c6e02ffcaf790f356fbb6c1d0cc2a786ead272bd882e4ca7e8ebc6802392089e66f1b2f101b8f3b8429bd407fb226c601008c486c2cbdfaa74407f2f7dad8a0549a95f17c66c330491c25a72ffeec2012387b3cc77f4132b9011251899ebdf1e043bd26fb1381fd71252d5f850bc8fd59685da4a255714223bce55ee53812904688a81763a9af5233b183ed4cc394302fc3c2039ff030036781d547ac6d6b59764e78731ece7ff17bc4650045b284a1f62ec28ee9e6236d87d079f288eaf0d5cefb9fb2cd3b0351ddbaf0c27b528b3c20892c4c9d3f7f5dbbbdc492cb5c836194be5961f0ca18737c40aca7aea5950b2a1dcc5aa63a192234240334780bf0360de8218da3e50a58d686d0c595281c5ca88eb9b4389be298a881883db092d50ef5f64101e63a36ab43a4a4b6ab5cc75680805e31b3e71ba05564795dc0f82a51900044f4c1b6debfc565f50c5678247552c30c1085ae348f4185b5ff2dec639f668220a396a7b668ce188a59d72da23bbb9a40e447e05e241bd33df2eaafe2769c86249895774e5affb1267cc3c0eed44a57679c5ab63fbbe77e4e8ab1dcebf8bb6cbbd27cb9b48a4527eb99abe660e8f18ecec3728072c2da28dc0b49303f3430f2e9e7aa2f9ec5292a958bd63d5c5b2e2398c8a8450c1296f930336629319df56e0da97a8bb764b9e7ed3b362997807e38462ccbf78d461b5b9fb46a9fd537c35a3c7f688f4328257695f74a602a9c33b9cd48e262e4a3bb395e6845e1d70e60973fdb65a86c26588891c415c471b92b8d88ea0f3b51d0a8b0818c70cd295980ed51751d5b4531d50a144a4a06ede24f24462e531e37ca23fb69458b7859d1b8119264b4d95e5288b5fb34084e9de84a3191f7762c2e6db43c3f1d91aeec27872253ea5c1ec743f562e067dbf10daa8250ea0873eb1c9fdc53604af16bd9d69ce4732fa354ae26bb0a4158138b4d1b564d93642513365908ee5d53dd30e9152f5e6e001dfc913b9092578e5ce312dd0880f8d09948be5c75d9d04a14e2d6f169a7ac105e6268e74e8cbbf36c71c60e7a290f80ef0eff1ccf8f5b20dfa86f99f643d8e36144d3fd3c25561cfb66282bc00da9e2288b50a348c338eeaaa8d8448a2445c8919db3cd3f4c53065772cbf242e47a97f263ff285d4a95eee2e345b0262d8a1c07093f071e31e77be1f5077d0480f4f1d4d5433301ac40a7c7d7b4b7e57223f8d360a307e33fe9dc52f2ab8c31698be29ca8561868e22cbfffad6818a4aca8a38035071bd935df22359c064da04300b30e2d364a2ac2b46084e64b487031229b7078ed9a68a125ae9d415e98be75cdbb288d4b40e64452445afdef6f16605d31fc5ba884bb0153ac3111098a6657dfbcde5bdaba280160c275e8b2987a636c11f5734a552cf3fae87f036bbf52220a305785fedb6d53ed0a9f0a3e9236756aabac300fb07946c010079c7caa94d45e7505fa85ca7e4dbf8442a79447e153744006fa1ccd6afcb09ad0b66f10abecd40316a4dff919f6daa3220e2ed07a6c5867cb752c316a3716193582fba6823536e725a527176a3aaf6d27955fbd7414d2bd38bb3aa4fe92defdf16a57369218118d3794677591313817bdfa00895bbe17f0e6902e74a4c934d93db9943d5d2a939aadcc4b17f97d370febb08ae152c64571bed1f72bfa79da2f5a10f5189da738e6579462fcd8ff577ceba55382983c912b0ff24a502e783bc50b2dc690037d2ddf18e40138e8a514f474dc76d26bdb6c1be068d38318eb3410ef633e282fcdef87c7a0d7d5b8d921e8aaff0f3f4048e1a0a8c693ed2f6c95c3d5cfb58497a16dd32c13a759dd635603d4c01fb847d323902b639cb27d0942dac53cb7575d019e02fce804dfe56f514f91c959b8b5c5b48a478a62bc46c44e2a1d6b0a86f4da411f14527ba2f7158dd898cdbd8752e81997c0ca0076f41bde690400f716025eb44fecbe8595613302fe14eaee32883b2849d331810b23d5bd7f9ccaadfaf1f88d775c38801565bdcc39787392c76fe244d63bae3a9651275939ffc7d52c33dbe018476b49e24ea405916c5d047491da767c1e96f3bb80a33bd00de1fee5656b35ce6d99e150ad665c73ea107456449bf1bc92a8530c478b5bf08e28f8d91acd3db01741c646e4c4d7ddfd09aae28246d7ea453f019109289a7ee973cd44adcf7fbef0b903bc11e0231c23f3756d66d4e38d56a60b51d377fbc51da6ac4d68530453111bc9fb2c2226fb9087ff1e1e8c68061eca4ea58af4566885221ef7f96d542f20412ab7c32b1e6b49f0870d72a02be6a136f814ab06db8f6db0d34faf97a9df0f8693d7e4330fcbdae1f1e40b50f076d37c782fb7619bd178e7ba54e150cf6aa0702d461208e7d0070ba9874978afe849e47b5d59c4ae0c12694d33210ba3dd57ac8dab9c1723e25805dc9a55251ab82fb121f5d193ba16ca4f86bb9028c811b5c13ccad39e5c2d800ffe3a7b9f721be99aaf938c4f7dc2b00b827f2e87f67a94a34a8d3dc5aa15efd3382aa244049b1577dc7893ef328bfea010317f9bbacbb7e565b29dae0e7e754675a8f83e3235568d05c96dabc21fc84da238bfd562cc13ba6d6fd02170ac5175e64ff71545404b461f8949ea717b762c783814c3c44f961c3b78f348f29a47a0b911489d7d66a416ba57ee5538a8c98c762ff4aa052d307474f172b46634e268e6dac4c186fe95b1e350e4957804c7f008c06688340cb91caf1992b891d48e73428b92bcce0f20b16029042d06fb4b011b03848f0c3e98db185ad59de04deb97e1d07c2678df426d8f6e8702f5f792bdc0f23d97a6b3236594a250a9b8b4639f2bf2fc1f3b2e270e96da5b1e14e0e92a0ac09348e262e41ec3ce995c721c7913f66aa86dcac985ddc103169778c412aa13de3213f963bc5e7445e54c801a2d2d1225ce2a2f4df0441f80f5ac78f48b74d2f1b245d45ef6b06adee35f7ca3f43d36a4ad33a877162021000ca1b85956981e790e94c5ecd40e8f5ff189eeeafe9e1e919bf36accdf62229e1f0560d26f4b36085d192e19bdf3a5bc8ca8bb97f5121f15df7b9d971231a2de9e6a8c1cf4997b012dd29a7f769089765328d8c065c0148858c675ba6d1a231283f16b9b15c45</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出计算机组成原理（二）</title>
    <url>/posts/b35efc20.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="66f661bbb4820fc0dc3729361b74f0192d4415444653b14c47b35c3ff60c0699">fb26124e0d85f363a66baed35993e1a0948953cce3d484fb31660455b92ccb286ba4467b12dd2afdc0f8bd795964707216933c479f00faf5302337078027ef66e68c754bf0232403ae44399aa06a2cad741400e24549082709cdee4a1c1e38f29d8bb6993c43448bafc4543d636ea5bfe35062ad225c74a80f232ba51d9af45093f5220e616be2d57e02341ffad661bef2886dba249b54377d8b3961fd62e8e7033554e6a1a85b429bcdccd8e910eaca84c8e447cedd760cd76a16c64ec7f94ad050108487716cc544f1ca685285a120a1c590efd559bdca18a90707fae890221e2912f079f089d10fb816e69e85944586941b721161d200273028ce2f3cb2d1a6a47461dcfac58b4612622383de37911e7101936179b0ecfeb18f3600111afc775a9e1f79696dae92585891ef4dfac1e1b894108384aec95e2bf78dd2b2903eddb16a8abdc89f8032eb2fb161cd8d390eb48889d97226355369904dbffaff6d81b8dd0127d1a67dcf2c91b806e8e09ce3ad3177ea90bc0fb010e6ec61cc74b2f7d44bc870e48fe3005b2acdd7fa1d949dfac31513556ddd1624d45bc450c3fe630578d1e0f34fe9a3ee75d48dd27c2fc39ca2f045b3be02ac459c49e67e8b796659b719a198c09f3868f190f293c69dfe5f0f1b79bc93dc38837719d20cf4dec03c89c57956a4e50a244b2101818ceb41c84c0653cdd2c056a4c17d7321ef8e4a3c8c41f977c76e1d1df800b9d2a5b5f0baa51325d01052a234171c70587628cbc8f2fb3d9e749a876b5bbb19282cbf240a16cdb5875a6a07b03171c1ec8fb26b863ecf244dcd89d4265aa30064ab6eb32d879119e5fb46af6a9226d4e148315be1f4ca63a0471c4380a4528653c767a964368a2d5ba4b20232bc4be94ae9dbad738a5541a2afa24c80324e3aa6148c790a7d8ca0f2abc0b1db76579e58dc9131ea35de61915e3a492d0aab65340c820837257f3d3c9a87ba45770e393bd53eb3625868ffb2f823d77556d32bd0957801478ada6dc1eef25c7ceb1376f0b26c04d3e6cd1573578a4a27dea65c28eac435696d5ea838a2c32b0fa9a74871035c392eab4431d94c7ae23d4bbbbe1e3cd3a219044c12cd19c9ae6b08223b28c47badf892b1aa927d7f67afa1ddcdbd8c5e7ca0624a60953d2de06e2790f820de0ddada7499bfd8b3ea53b5de185362efb9624fd0c5c2981b3379f575e34422b55d0409fb2097d94603767e08fd7d0b8c78d6d894b070cc6f1fe73d21570ae9a549bb7767b18c4d858d65ff417a7b00b12ebfc91402c21a03ffd5b0be7dce93459e2334efaa907085059ceeef4c40a078f71910a2ca3eff6b87017db92942e3d6a4b761a11df70c8bf821d642f329f291c917b74359d14f0981ddaebec78b1bc23be9eb575df20fa22ed1d999aa7a11e5dd4dc7e7f6ddfdf175f5d651f3fc38853d803a53d362621c49a4d7f3a45e136477a2f2108c9d706cf4a56e2160d0ae061ee391f3fe5b6953fb4185aa2da42c629700f06b90ca6ee32743703c67c8bc1c8a6f8f9c0f39223d55dfd57a7c4b74efc6e910ba23fb175f6fa955328c5640f319985590bd7dd6334503e197050158fa49a13fcaf61a8a96a8bbdb0284e557b3939de830fb22ef0a499aa315c9606d760818f45f06899ba0cd22e99f9e15167b1dca3c8f01fba25f0ddc5ca075fa8b1c11c9d548adbc3029bb4bbf535c77c12ef0ceca745a9648bddca3b35385be31477a59338e19cfd1ce44ed5567787956a9a7309a6bc5d464592106da95e7497ab879b7873febda35ff1df3cdfa73aea14ebca454ba9c812ddd61aebb87f67d6089354a0b129036fe2d602fcecbdbde4a6b59c6f8228e4cea3e6a36c347617ed4a9142f138b4815bb5706f62c223be0ee21b63e00d542dd93b322006c7f1ccbab9eaf408e3300b3ee90588c119bd66566d4615afbb894032889e9324a2f2611727c71cb6dcab5a31d12e316894384de2dafa8a58eb497d349f5b751cc09232a936560c423a1bd50e4ab1b1fd366c80790aa1113acb4434bdd0f58f600465d49e550ec289ba23964c2b578e349c674f855fd289a3b9a0bd855d7b0ceb41842b0bcd4ecd45b3a875b7bf8ec2b3737a09287c1fdbd5667579e243e6d4140e2b6e63a6ff1d3814b247eb0f03bb3a33d7874afeaf783f807aa7c35c8609f792929f299fa91cd90fb533cfd3808908d6f3d4cf462999468428e3550808f016c3a4f2c9df8f7c3723cc9f61c1b99203a21f7916b6584eea5248723f7c195cdb1b1f93453653520bfe73aad9d5f0bd76720d5cf6c6aaecb6a1a0d1b2b99909f49c374f446952e045bbd33ddb9791d8065726e15aa51241de7af721d8abc550919de7ab8992475ff2ff7c0e1bd1e6f8e04132a0d6d7e525f68eec21bf2bb9752d5af4860d7df5e60e65f29417f58bce0d7b685766c21fc449ecd0c55758f2e988c5af5ec0ba50640b8661c532a990a10a8766893bea06578dee9b5c6ab7017e24022cabc7e771c10f4408c35742677e2fa9dde4e6f90b6f562b3f4252ab025426c96fb756e88af1286e6053ea62508a603edaaffca9a03ae1c81ccc064c42343876316e0014634ebd3dd11d42fe1c9f6587b261bcf3f0a2ce171bd579bbcfc93c5c79e450035abcbda25e5247993a6e109c07207e89b5cd308f15781f979c7ccf7f768a200a7727f1f7adb3be36c05fdeec1de0e5b24aba6b629c8929c633587066ddabba2ffeadcb0e58338d4d42ee76c2e15be8040d35f81d0568987f4093ef6be9eae7e2bce060d1b7741154f7032445ebef3a17f4b733f8c4880438fbfd9cf9509656b8adab676abc20f9db007363932b4944a014b8e9dc97ff8d112e3adc392e380c01d5355ce1060ddc848c4dca4374815e0ae2739749c3f9722043bd29a224795e77ef4dc2b875fc0432b7806960939460929e1f8864c3957b7f928a290916f1e6655eb840d9cd8dfb089d6050419172788e82d73b730263a8e11fe073ebb7e623aa0c0ba779d9d7290d0ba300958084b2dbbdc44ace528084ab35cad2d6a3fba49c21e6408224206032fa6ce492c6473d96d02b5103fcc6cb944acfa19c23596590a642ff77408396a4f4e6d4fc88a7356e06d6e897f0aa974282145a48f00f8bf18e466012e972b3b99e11cd95be863c43d704c6818499f8053bdb04dd6d50f4a998e2c08a74538703acc0ef44ec0264a1243a3592955edded0f6933e06b3fd9022213676d749679564661417ca2033aa569de66c515388c1db4d1b45e887272fa855373bf3368568746e801fe04938f8923f34148cff58bc7bee454346c55fa2d75ea207a622ce62b567cf9ea051a0dd3dd9f904b3c0479fb40a8ad60cf34fba73758bffcc0e4d6edcf4340fe7b705eb0be51961ea80c67310d4c9a4415e6b165d5220ce87278a43fb3b83fccda45af5e9ab8fd8aa04b34a4ac9ed209fa22d664c2119464c77154ad4a9f512f3baa469adb31960c70a0d605cc2a3935b47c0f9c31284da1ec4d92e2d32a2da716616a7d01d93e3c577ca2a557b8fcb7e32016c8ecc50316e44792c0b1092708494c5cf9869576206245f46967ea89237383d5e0ba1bad9e7eb55e20041f307ed8f9bd90ffc28165667838f991db272b5c204a92ab9d36f15eddd5537c3b9ae7e297c61dfd8dc49e3e3e9b3afcefb058fea2f45f66268f022fe2db5ba0e950d85c91fc34e23221a60e84bf8812d627254e07aea5d2b640f5f286fcfed201863ba4361c57e59b109a13d1ae90f51087008062d5850a17589805f14c0da0be584bf5a2af1201c5513e51b570b93aeef0b9daf94333dc20fcf91ed167ddf803af80006947b0387f4ac13e715f42fa37bc9749af11f54d5ed6319647151e46f875ae3a6bff708f15726900e9d441d8c881e9539197ec852abfe908d3f10500d29b7f569c45a81d3ed6c6933433e522846c3236732a7cfd84a485e277c221b87ee14e6fb8c6a71781cc62fcb2a770936138812ef50a1795d2fbf6b155c52e0d60b52ade3fda3c86222c82c7daa94bbb526d118040c91fc3e0594feba7d7623ea8c016ae97e54d8be6b45e151163898ac70dd74b85c1008efc52501332a647a7bcd8ccbb1a4830bb0ab4985bde72339f689b38461e33fa4337f77df51a06953e8c45e5f230b0960af947285856b27051e829ba09819e9ef8295c8db958d4ca82124e91b80a054a20be104c331bedc170f6387541c891d534caa1bbe47b691cf439e4978a2dd268965548a49bbc928f30bb5b037680e04fdf45eb442b593128eefa15220335b0af0eb8483f4478be96eda352357eb15e35160e554f3b7838e445879a6fb7179d7de24fe3e3ad99d5fd475155817482e142cc62246a1658644720bf4a7cdb46ba3f1eb1f54afbe8e87f4bda5d60475077344ba06b775ea6528b438a0579ff7f722612fe65c45b5694d6e4d77ccc7c1d704655fc7a4a0c392bf01c1714035856d478bead648104a40685f44ddf522a1d94e9d9868c61374b66df1ac471379d735ce42146b6b4f0e3770ab21f0c4f2a540b1861b997aea36a9cbdfeed565b57693e17f5056b670c5671705b6d555da811fbd0d905a92ffcc0edb61c3fe7cf8400e227349cd5c6c723cccca888f3383e1ee0885e51379b01a6115d20eb2f0fd74448d5f0a26029838cef03de0c379291212bb6d73f1bceab227f16efa800f9ad2dbb46c6b11c15b3bb349bb67d798be8b8d89c2e5b6a666621fe280797907252638436206e9b4ff747a785c3ee3372d88774ff96674d823e7bb96093cb4932983f76443af0a8869eb6e8f0defdd1b3101fde10a00f363d5a4af07de1d9ec7a8d35d989f3bb2fef563f0ac2c5c778e9bb6e458bfc1489fe94b1a7c859cc69cef07748171600a6356bc0d5c01f5a5c8096afe2f0eb44c90e5dc253ba48af890df05fe9737395d182158c8236ed42476e3d385bff77a3a134a914d170add11686f92b98a87547f7c252d8c9d622736a2199b751b68adf1c518f111f1543330ecfc9d8d0fd6ac8506e35e0d3dc4152afee6839893b2cfd4c573099d2a2e785e0419e0aadee2edae4820026e0765c79b900b384e7e990f9b14f4176557aa855fe3101b9781e091b8a0407a385738cc39687d77458f03e91467bd31df4c19aeb44368d1836885fe2229b86ff6a09a01278c03dd1cb0fe8b4c699b3750241f391e7ab5546e06346392ff191b65e245687a0498604366594cb159078fd7306e31dccb83816340cbbcccef0d2785ba6c6797d44c9be1e22cfac86c6b88e0ca1d33d5be3c6c1fe5c7b38e2be2d27188d6f464c87b7f66063abc45a41414b2f53e3b424f65d6dd109a18689d36cc133f748175fbe090e2db30d34ccb3e627dd5e78fa2f3a45bfe3fd183a7c770511aa7281371dac192ef0862f60c8295b3c03e188dcfbdb8be837124aa110d903935bff155baf17451bdf798c17f9213be6409ae78bb21c90372cede719717391ac7caa619bcbd0eaf0e605f11860383e68d2ea2c94bd7d85a352507316526bbb83180da30ac6f9406b24893f13aad69b6c038d73f513c4e0b01c7e9728b12a25815a1b133c568aa5d650321d4341d5e96c39d8222ec904339ac9dc69dfbbd1cdfebbf6b67988dccf58c69eda04f7d391fd4e443035f4e0fa27cc3a0a697dc38df56a456f0cc50bf6deb2e5dfd529e0e9dfd3b2a98cfe869ba2b186d6384b40fa9b0b219a3ebf82971b73fc8bb87324bcc74ad842d0306064d959de2ecfb3ae3fa1be94d86e24bc845769b2760e2e15b06bdd2e85cd679744de8ecc7b17a9031a13d1b8c46e066732e678401cd536d84e0fef4ae74e70bd5b9f947cdabd7ad503c3603bf579d343e3897162cfc6189c26b3ffccc09bd83d1aeb71cb6f80eb31a063eab23aa3cb890b0c1f65672b8f3cec037ea14274ec9c5028b9513b758f1c003d230b296cd766e3d22e7c8cbbf0b39f8d64be4b6a9c401bdc6b99204f461ccdbb41c072fea856ed50ed628113b4ec21cfcd17195185d08c9016c712e20f1b26b24973b12a12622b84ab5c63578ddad82a9ba117f3b2a9b15ef70c27de419d51d56357932680c05f98fe1309073a4f7f524cfba55155fda1f0d97c4da066f43a56b6eaff3e4495b736f69d9349908f70230c4026e3e031148bb2ca434f6f3ad627fd91ebba762ca9c948210e14222169261fa83e8fb70fd0517f7ec509b7e4413c5eec79d1ea0d19235323dd4d2f3d9130a2527f210408c69ec5952e5b94a358d0a5cffad96fb5043b2bbc044ae818bbdbf6420026660c102e69a4d3f90fc3825ea65c56244b3eaa7c4cb08f79a431315f4b4c073ab0da1659c882ec147987299dc4c2484922be599c890335328ed915c5cb0e69564d2076259d18ed24f6eaa920ee0ab8fa802a3efff557e7252e867d6e00b2d76cdda69bfaeedfa87dab1ca792478604416e5018226cfb3d6ca54d5cdf4c0c402b7d3b081806597210c5005580e27e3b330d7ee57c24e6a2310f80cded4021ed1744ec9d4cedc2303a8aa128b1c17ab5fdf62c654971ddd38af55781203f10083e4520d36e6d3dbd108369c082690fd787c8d58cf8919135eb6e21b7f50b4629fb4b1c2e00834df634572c54db8bba39eeab60ed87f017ce57a5ed730576cb3004e6e3e536c73378c1e00c65b88843ee47f67a183f8017259a2aafa976e3b6f8cf949124d1aed4f6c1fd484dcda35ca15e069cd297b53e2420ac7e99613c923ff398382c6fd8b777893a4df177aca97d8fa53d63eec98f1b985960d0646ee46924ee66e43a958451a0ab434e5c7b22bfa40429fd31bb0dc68f71909465b2b2becd4fc415ed6ce55903acaaba5e3d04585e07c2dcc5a6a6bf90fffb74c806ab9d9f27ef32d6fe76db58d39ba10cf0072941eb9f86835d19345e53241f86002fa6e7594d5bcf0ffe145d885989d492d2e5479bc1dcf21edb6b0bcdebb23b425c81bc0facc77b29158d8694cb5515d20f9e4cc1db965cef1cd6ce4483fc984d12c0bdae040d0158d2d3c28888f3780691c502f9c4b8e422e91bc61b3a8f3980c48a443559d46a198f1c0d5086febfcb15031c45663dd5bb7c74e5ba68ac58f1f64bc1085def0a0a02fe704dd36cb83d5abefb1fb39789ddba15f8d52c8fd2853f12730957a5e54f8f4690a812004091ba88d0cdee05c6e322f418a69fa0023e8897983bc9baa9f8bc4e94b33380fcad2a73942a86a81bd2e4352f597363acf5a2d692e5ffc1a607045a915f3aac3d4967f6d2018c5e70ceb35ba9ec74924489096dbd86325b53d002383a33553c141596a0ca6b6914d577a636b4df930e5e61107f52a14174a8ecdea3f78b83c3e31d43b269f5f98071f63abc43cdd3ecb844cb8c61a2f5deebea5d5efe189094945de965af2a0b1a85ff0dea8c49450fc8122c913e0e004cbe64c41b0a190787dc4529c0a2f9aabd15975294637ddda4eeddebffbc2a3585f16b5429418369b35cd1ea6cec928dc56781cf2b543cf62bf6d02ed115ce1ec735ef46ecfdbe486afcf80b537ebc5719a53d90302c855dd3c34d412aa4bead2c81a66f0ace6d0325d08c14663c3d80e5a82193e66c28314f26439972b218caaa98d962a9ff059a39c2cfa54c5bb75f51aeac0337825e40a486d8207a2b7b0ed0c580dbbfae5b8ba45543c01ff1b24d462874cef23bfa19e5abf4fb19e700e0575e1fcded1c2ef52a356b3d478e567ec92ac945ed86434a3dc9f09b8d1b5cc40fa222dc4ebda17209cbb8b60ddac7d18b00466e4fe042e6a15cc443d52bca53f9bac9299b5709d54576430fa31350ba5e759834b529e75ef7fa0aeec2ce2192bfd4ab0f9b1c3bb4659e34adb2471c86299621684e14bc23757e77e14b369f35e622114ee90b903726754df9fad143d812312986f9aa2fddd654ed1d4445c882046e27d0634b7087d6340aa53d9ecf5b95a57ba19c55f3d20e6f12c2ceb7f55743e07c866cd9da26db06a2bd808abff1fb6118ff56f9c49cb068f4fd53266259db28e84b48df207561de0915155e01100fea7ac13472a7600505e47b1b0416a81aaa708fb6eaec92c2b67c4931d5b596f01cbc048d52f97ec114429b53bc96d9ef4135182736048d3a3c02c378d8d6cb5d682d6861dd6258115b3c0b69980fefbbbd4a9a182701ce581705cac5c352ec103a0eb5f71c5d1b0e96f72d3524cb0a0fb820c8cef42b623a71520e74348fdfbad4752899fc725d3734c5430098c1d6cfd0a7808b3911dc535662ed334a565edc13ad28fa0563549bd3de80b743769c0283e323f356139ecae4280d4fbe626b63ff01fd68b0ed0f1c7e2fad5686acca11267744486159d94c3d4c769c9e8a2343ba1d8ca99a49e763f2122826614f9d1bcd4e831a0aa230f00a89c109ff0c94f2828fb29a4fe0826aea40eb6fcdd0a89d0d80bdccd4845d11794728ade794c69e94d8af6a99ac50d2ca7b3a1bb21e552e890db686db14d3c2346fc5028789dc0a3eb4d4b599a299d82c21e23ce3e7d3765428b59b2917b5e094177e4bea3690f36731ba722411ebeacdb582dc180b5233c81dfcef397349208866a0a950494bf0533b90831b9748b2b83ae8993f970a428da77569cdf411e51a1372217a8ecd7f0d59f24379e4f265b335cf5ed0d9aaf8677cb2a655e34528b43a83c5bd3f70d21e7a43baa76f995d5f364483df39d11e058bb8a80e1212f2883ead16b530a938a9f914b44656a6eae5d20ed9d968c7957d035665435879990fc5fe0a201b497feb65024dc680a2c3eeb1eed0795aec8a0242ec63af70bbe9364e72c7c7ca1714e80f877458f5a812e32c57cf47b2b61066ea8cea1ccf94a2560b7df65360d973dbee70ea04264173125ab25d9eb722f3132f7b77b26d0e18869fcc8ee9b20ff70aa2d12a106a22444220330f92539bc0a62f6ea66cac73b2a0bb641902aa5052e3af7b96911e7a0e09505392d85e62f11e910e42cfd1f67897e15d7dc318def257c5f23becae60668b469bf2f1f6148b264a1d9f07009498808951e3b1a31f1bf5c2926c3e1aca94a84011a7d4fc513b23eb5c4de709e9a4bee50ec55323c49b13892ea5a5400dfca4c6cc69fb41d5bf2b0a16ff4765cc02f3717730dd34a80b1138c7fa1fc5fd4eaa7eb2f4748662f788c88bdc3afade914bde70a2c3ae86d29215f6bb5e40145c76991554f3069901b4687bdc1c9e8de1749185fdf4aba24d611cf4a78e75fe04970ca4f8ecdb6f91f0a2a7765aff4864a50bd3a9dafa4ecbefec2e2a2937586b347633c342e48601f5438c278f322ef385d7669e02e4bef178df5d6141259cbb3d75508e781c512ac891df0140558f23ff8d28328c9a3ce951b30b1c3c199a6c0b351f22091123670c6d52c4b24e5d892f7c7c897afd64ce3b0c25d043738e4f714724aef575d1a12ea44b7acbd22728e0234437509f453bbf36e7631a577ff6560b197586afd270c59b32a5c6d3136035120a5b5d56016a66df0a3130ffa72956682c76a5fc040748ba82f417d2f1a2c24b9c35e2633258142bcc6decee49a8056872d3ea4b74161eeafcc12f6cb96f4799c9b32890f123bf21b841c5449d1bd89570ec3b137f0270246555ac304f4274a331cb7b76a2251757a9de2ef6873bdf2906e91c9cdfa99f025681b12ce69cdbdb77396198de6ae1de920ac99cbc1b5e3eaa96994d905092d2de02edde55ae2748a325faf047b2bd9cb65c638abee6b76868588acd7f06f8d4cdd5516657271702d44c9c382fe5027bf6fb9425fefe999b1354e30417e9540e89ca83668524413529c206e6d4fe363618f8e84e22923cab083b8362537e0c65fbb1363b3b8536faffb97e53bba98f65cf25eda4f6a693c610acc5951332be93f905bce269dd7ceffaa18d0f4dc127c3a2536d3db7c0daed9c9cec7175736afb94e30de524d42a7d470649b8bdc9bb35f76d1a5f60409a04453a738dd78c214a7ed9a0a97eccdd3c4037daed6e82f6d0df89448495b38ffbd6d7d2a64a0cde0e95fc5dabf4c87a793f7b901cf0d879504a5301803a95861d37f7fca21fdb8a509cb245d418915409b2bee5cae02ebb693200695fadf1c11d7f3e5ec51c5c9d809daa2e2c053e2bc87957980e29004fda32d8c4de3c019b4054d5adece5f02bb0a3eb3c70f5fe64d0802621c1a60036a7fd984eaf8a29e2d7e0945ea74d30806683ca0812bd3a5c95f1675243617ae1511b4dbb8b6d1ecbc11904dc7395457b865aac146e8f8d725f9242fa3e8e6d8676711ffe40988e455079298a3cc1e26aea49601ac616b6bef660743b3e269eb35c4666a6dec35190b3766462a1f244284d13815178c7635b5f890410316e1c9b11eeda912cabd0e9da9792e8a93ab89ed903c365f3af01e2a13fb670119a36c1fccc77622ddbba6c4498a3f27db59d094417187c68fb3dfc7d72f461003d1a3bf3797b525ad3b9f3fd68a40d305a8f3b8563c70da0899ff3dbea4247932b05410e39d7ff061940a29ea0c1bb090fcb6e5e0a93941b7ff01746aa63dbc0431816e2254f784ce13b0f32cab94a1958fb7c4f8b975bfe49a3da35834d9d62d67c295c0d7d9d4e49e1eee5df4cc4fb0f8f1c3583eab37d55a08f022dcf5465294f282bf8683725707fa20e0e704415cab6291b07c59aac5893e122dfb6d7fad77eb822d1928e6f7e4b3f98abf9483c42d40e0d5dfcfc446684aab801461a296b3a9cd77d11dc90341c59de41e9c8c16f4e812c9c06bc9c2e7deaf4a31c8caad2018da9ef09a6ea5b02407b774fd4134c2689e704e0fc0421d31587d00199b6cc209292e517e414e8dfc31d932c04c6ff3b3cb5d815ef087e0c398faace3765ede9417654e869328e28104396dc33c18f93569501fe056c4758074b54e67c512a176c5fdfda3bbfeac424a818e440f835f81a3ede4918c2073bc8b527c435d5c0c66aaeaffb040cdd5d155fd0adccae211581b27c1f86b8cdcfdfda343611438f4e78cf46eb455f2e8639d6ba2df7b0722c64a1be467c1a171100a52825760636e0759a9f267dbf95b41e4ab3e4f6379992d12f8a48e87d943d28eacbe1ed226c8c14b4a646a4f570a66646811d6c8e596bec5a0ff6c6c595527c01066508cf18127aaeaaedef7db45d77ad80519fccaeb3a261cf335279a0eea51b6b820961f77e3ee78a8a43dd95bad3aad2e06a2197751567045a37a752b92c0158e95516869162bde1757bfcecaeb91dec548a911b420c975b86ebfe79327ec42478a8ee3878f134c81a953f673be46646b8f4b142df49e91c6767c32a15476d0427f0655684d6fccf62b54766abca704d1b1212f8d35640c94de9842404c775e07485874066776cf2837d97c7cbaccb110d9cf8983232e4f8c808c1cfa023a3ba41ae162fc517f2c1d894ebaa5663f9ada7d8429f4fc4740fe814c88d859f842975f662783c6cdff12d8a5afac41a73a7a1459e701b93d36efb862e339309dc61a7516e821d8901a9ca9d7e3daeca185bd97a867fc44dbcd482369f56995ab1b78236012814eb7160fac0868940faa61668c8db23f65bac198c4ec41a10e55df8f199ed121bd6b8367510fb90d2ccec54f6d758426f68c88277ec4f648c7beef64b7d05e0844009fc1a605c9ddfebe6c022e5dd739ec5df0604b1953cda77979b691dbf75be4fd29580db372484ed876e5cabe9cd0c77521ebf1eca738cf3c624c7d57cb50670918420a98585f2455ed4f63745f1bccf578d6458dd9cb5fc48a95a620626e117dad458ed17f98f7b0f6a5cbd740725fcc253015da0c32a8350ebaa6aee9f623965b163187e0df51f3a1df036c6bdaa7e064636e8a16c799731d67ac0ee1d2f83ce9db8297d58d0d20ed31d6783489b8d2fd8d183925c152cd013d63d9697f7a6dfcf05c3180d15f9d3ed670ab5539972208c0d51d42c6ee40d32517308b9df2f4a56a462d50efa3b0985d502deae78d95797c2e7f0109d85b0b9ce87d715cbdfa38bc9aab0d084d57da27adfc02f060dfdad050343f71ca45928a65371a78c3193171ccda9661098ee280423cdb75a9c8f95bc01c8760f2e3af2bdbff4180171e2d5070a990257241017a6c26a34fc5080277c18e32b6d4d971d572ccabfe49ff51b4ead224f1e784ab8b33f5f9d043e3cc2570a75f63b3a45754b140dfaaadc6d798766fd6381333a175497ecbb497dcad675a9559934ce8e0ea20d098157b2c6193aa427178086c0f04c18621a7a965454a3e3a70cbe5122a6246fa1e2ac3209e0ec76a113a5e8c313c2d70aa895842a78221864d921a598fbe6802c38b5215ac0c1207537e93f40c3ddd18cafda95eee2b249b93190b7bae6f03245e15b7a38396f48590a417e50a42e8595a1f04904f08cd6105f843ecd8120e749c1be3b440416a494f4931cb803b290ffcd0cfedf81dee09a30c3a76fed5a6f1745f67bd2fae9f84da6416a250c096c10dc7f568eafddfac8d181d81213e79a3556df3f229d9b576e277f38d1d425ef001fe254b4246e3fe380dfda7a5af2d00dad66e3c093864b8e2f327f43d8758395b98affc0fb76c556c44fd5722f31915a8a0edaf510e7eb3b5d32b18981375b9769e2c36950660abe5fb74826a77303f5b3076821f86aa7601260752c941ea6866deb0624efe54ae6ab9acf8e0d9724dcc44abcdb8e44e7d423e3b21599f7effc65eab3e2c68d39bdd32085ce56eee1576824a0eeed731697b9f18f3cce5901358ca043630cfd923d2f94c3d310f2510236ec06da675984933da83438a257bbcaa77f980bd1fe99921a2425516d95910ac217bb5240f2d538954b828defb3948aec2856de1e13fd8009b85be54951932ae93f52f5b669b3217981f1b53a8ff3eb00cb7d5fea675014c94980770f1f4905c0cfffccc839b22b811000978169b82a432c22f8b1246d79f262450a1e4a49774ca81d23ac5c50d3adcf456b03314bbadcec5d7b434edbeb9e6a4f11345b2d803674cd47884e14104824cb6632e4f10334e4c68aafd500ff4b7c9151eddbdeca9b06dfe916e2bf038c4732af1472ec87cbf12f7fce50d5d07a8c607b811aaa06c7f38abc69cb33b3f7472d491759cd31d2a9e3eca43d470e246158e18d4efa2a9412f0196ba02bca03c8850c0a91882c824fd5c1ff39659bafaa8ad30b233bf23f623bbbd644126f4563834e5fa81ce32741c53af44e458617c8476fdfb8c78759dec1a595b9df9e37eda48848b7fab26d414e7c0876e0d53036bb3b0dc7b2eecc251e8dd0af7fe98358c08a438d32cd189b0b3ed05e8326aaaab088d211c00ee3b98c37c19d537385e856b4264a4de76cef132a71d04adee1f5121066e68df917a31bdba14177934f59762c961b775adc69558da19d1e95d4c78e97bf1031a922d73d413946e61cd229ace7fa71a559f80a7131b8d76dfcf4179e444b1eb7633bb46490cf426b87a8c75c70cc6777c0eeefcbac50f464c1e14a95e881e7a46393133b01a7accada8dc859551d01eee1ed58b369b2542ca5860a9ec35007c8fda9bedda611f655c7dfbfd630adf5b18ce57c520b5cb9c90faf079604f2b39424e86fb38fc89bfe8c29ca46787dc643f4f5d46cdff2e26473a174eb49a98f4dbf286360c02333f6a764f85f193dd0a686b0ea8e9d0e23da059fba36d0b801806d3506ef5c84755e994203d936ed783e5ae0c5a344093daef1be1998962fb1a7bd97ddfb0e7bebe7dc6b834814cd49c919da182bd8bcc461b3e98a8047b6a530e9a18ee638470bb4e0e53e03bb8217132e02c4189a0cb33da24f56917aa85ea70093cb5f12afdf07ab942d3be3c8059cf73dd352b5002b98f0588205fbf798905b0b9b92ac8c07cff491d626973f70a419cabbd68e15637595dcc24e615d896fb0c83bda6cdb633dc3b486474be9b4454d773bdbc844b7e0f6bc9d085b749371ebdcde252234d13210b1d85115b0aa884c697f973cb36229db2040778153f86e8cff7a0e662e4d01a27516593b64e886b14566f8ad481050c5447b743eeb1c9e3b2db737cf233e1ea978332426e8fc774442ec5ef33c356061292849941146edf7356ecd3e39cdfb29555eab9ac9b3f4955e8d0a5c9e1871863d7611c54dde85cabb985e89b9c7ba17fb99b4b99977da2d81a44731b12f318886989b9f3cadab303908e185628c2982b69b623db037f6f95e1e9634713ea8d063d498a9ddbc20d322336348b23c20dabeafa229b478c2e7d3ca3a84e486503280c35cc5263e7c38e8ca5b19db721294cee2c1b370823f6ec72e50c73c1828e77efbdc659bc7171bee4503eb224ac48614454be0cc8c6763546392034097342e6765cbaf0b9195bae6466a636a38d9643f24daefa990cb3c409b7b50ee9705304beab14df01d436c2a816328f6b427e78d06ce45dbf742807e109589a34e9b1108351031e1307bd2d650760a05cbe2f9c05ac7c279fc7df996af0c063ecb3fdd2ca8b4e9ed91a73702daf8cae4f84c5a7dee752f0e2edd66985c410e769b515d07afedf260d20191db82d86f5d0523ed1a9c6b5f9160d03001d78aadf4c18e69fd744f54c4c28b1c6b99f469f5bcbf4f266a881b02f98b4f4284714f3513e4fac1baca5ed621043810fee1d7fcdd2dbe39ea47e1bc6031e03690caf34849a691fb539fa7f0c3889b70b2483f9f80c98d5732b37b1686d34791bcb16b8a4f2ce917329b81e85a0d3ab112b4dfe187b5ae748ca81121add5f81320546c9a27a613c49e27f927970879a3c3844dd7cb15baace26bc607b8a16304fc61471d40f3b89d0c3419d4c8ba2ba2219aed83a1bc0f12ca6b9928be231155175050cd1002f860df9b5f9588af5a90f4e5e1ae84e61720d65bd75f7d0e5041bc8e20c009fa22780963d9985c189987d83d00085be104f96b47fb96600193591a67789549df2ffbed650293211709fcc2d72b5275f77e63f999371c68f5f3e634b02f9521a2d46d8394657780c30701488e45511f688e6adcecfae3dce5ebaf97a3f7aead9d7a833397e7fb05057cba5498b166f928bbb0dd6e926f73225ee6c09ef464a740cf2ffc9a2534c412c75bc7b5110e8b8da9d9789bc130b30823c88b1d90762ccd8c33f053c8846c3e33b718c96dfc7b4f2e1aea4c194f45668c8d7c5caa2f7a22dfa0825963028399024700829a90f4a517d33e67240eb2ce0fa6fcf7139cdd7932d3f410d8994aeb5cecdffc7c2025ab23c34804eaa269ee3607450914a5606b184c592cf13ed715bb81728019920ebbf0bd7b111426a836d52c43c0f07d99f1e86191eda81acc160a887f7c3ae2bc9033b9eaea390a1e9226f879ca5a1d728a28d400cef4d4326097d6c8777ab75c11584ff71759a04db5b9e68828b3c1db4300918aa610475524f0eeb5936be20c6f98d3613dfdbbe5940a0dbd7d9df824eacdea2570fe680e643226972c35f632a3da63bdd4f7ff5a3c4655ac7750e024898ed4f2f5140586463a1d01f10db5ca9be54641d40f4de86f9969a96fe4f626e1b77c2325d8ecb81d52f53e3d616b76fea60455c9bf1558ce348d1adef4a47110ac4ea40ec8d02f93e845559f7dd07e7f28c2c695203c3e300aeb5b5018c38282183b74e01dfcda0462c9df4a6d073748ef0f265e6d2eb3eaa14b6866cc18f1472ef5f00950e78d18fc0939e713184dba0029e2cc634ab77e621a4a87a151f27f6fbd0a43cf3497ba34546c1cc11845e80b91f0567f63634eb8c1dd3d020e8628a17d7911d93d2f283e67a5cd01d4fb97dc15fdca27008dab8ef46e7cec479db63e4ac070dad45b3591f97d161b67bd0ca4e2593ba3d4f591086f019c6facff30aee7d12d4b6f899748934f57d95140f7a2fe536df38fa6c956b2d593773f0b0da8d61c23a1dbed3a5f8151d8b0bd3f1ec1fd946633e32f87da2bc9934332005babd836e5d7d0d662d606a9f87a46875398d2a41e9ab613b7392be477306dbe53799e7b1a8316eac225ad0f7e05946eeed8a4143182b99b986d9e78dcd33e072</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出计算机组成原理（五）</title>
    <url>/posts/26f38350.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="bf1c3c453dea89b40a1a15c45d9c96197b324c266e286f82d50d9dbec880c38f">fb26124e0d85f363a66baed35993e1a0948953cce3d484fb31660455b92ccb286ba4467b12dd2afdc0f8bd795964707216933c479f00faf5302337078027ef66e68c754bf0232403ae44399aa06a2cad741400e24549082709cdee4a1c1e38f29d8bb6993c43448bafc4543d636ea5bfe35062ad225c74a80f232ba51d9af45093f5220e616be2d57e02341ffad661bef2886dba249b54377d8b3961fd62e8e7033554e6a1a85b429bcdccd8e910eaca84c8e447cedd760cd76a16c64ec7f94ad050108487716cc544f1ca685285a120a1c590efd559bdca18a90707fae890221e2912f079f089d10fb816e69e85944586941b721161d200273028ce2f3cb2d1a6a47461dcfac58b4612622383de37911e7101936179b0ecfeb18f3600111afc775a9e1f79696dae92585891ef4dfac16d1efbbac2c81cb4a05c9508d47faea6bb9408004153c5f25bb2d10c54a6719f8f15d70639d543d42d56e95360f0d2c79bb6d74da93ac3edce79af8b2f3766b89f0335bc35e41480466a1ca608f2268b10ab0ed06052511eba2d46df90129e3b7c83069b0b7e479bf2d39340a695d3c3f6dec0acb9863b311a3c2ecdd3c72e6069c5faab684b90da7c7b46d929a16911ab82bcdf8f508ab774a88e46e6c607c6e620849af11063361fb76bfef7660a85a9a6fce6adee2c7547c32a4b0d387a74054be922a35bfb6b963b7d386148d2098a1a4b1ecffbb16a2b96d73171d8647fbacff483973a273ee7ed20c9fff618ad24279e4bc5fe4ee91628f0ed8d3252469e5704ecbb72b82671329618d078ae02bbc3b1139573b2f38e3a1d42338489aff4e629bea1bd12a2fcc44dfb6e7da0c98475b150b06ff2857f1aecaf39e5528488b959a8a6e2bb16738f1f44ae07ec1efbe6f8f3f442e301914823d6209bfadf86c4362b8cda0099420d4d4f3ff0de9d62033ee5625a3bb8be2aa613cbff65dc675b8eb7284cf0261325dda3259f2e66d5dd18885bce63682d713a54873d15623c005e1b28ea8d08c4e5fd27d18dd46bf537331543824b2dc4383264162f427747606351719e7db25a6bb6926ea51f8b6606d72b7514b8e11b79bfc01ac69f51d18588d8288209c2d38100571b59c6811edb4fa5422e8202a7abf426aebbd48ab3d0debad601bc4906f3e2f96020962ef2212a91a7c3c9bf22e3badc8f06f65acef274da42c8ae877ce29318265f16999a7334a932f65ef83345d1e0ef4b7d6fa6d6804bdd4912b4ab168a7a1c8741f9963a7c628932a373e89fbceb26ef48218b90c6cbf2f8d6808d4fa5cd6396f90488f4e843a9120f1aee3d7da4591ae3f8b88ab1a243e84da7b6ce049278cac741b910d9d723363b67e52963eefccca79b069d152e5b06ac06c38999b246371c17e7c517252b1332b1682197b40d9d3981f45e3019cf8b7cce1bad92da1fb4b4b6d860b23e64082207513e6e96f04ad255b07b922ec9eb469e0d8ccbfd4f3655b0f6a614e18e60438082034d5070be385f83e189810b5c6d7d9c9f54e7b76736aadac0fd0483409064db5f1a37f7536f2aa7158c0b42c60730b42cd7e3bd089ea96b21a2476c0d6ab8dd39735d397b14f25e95489cf94bfc8d6d9b5a0cf542397df1b3c12d262c6578657e4380735e4c19870acc982e22674caa589bd6bd45c38f770ffef3d6ba522ecb80b29cebf71b459161c20330fa18b548e3d9191a394a5d574e7727ebc65c27da758b9fd860885fedb071558c27cdde00fa9f802c5c46d21215a90b09d55347005cbd0df671bcff4f05180af4f484e87a9ada3c33889b98456fb286962fb0efd127da3356459198362190809b44825a41743cbc81837b850e014a65fbfa3b7b99514d85f7dae9903ca3c6f08a08b3f3669555fc87a4e6032a1b6d78a2a38effa1a0b7c7cb70c7816d7cc0869ce4b9087c63b5e9c504df3dc29e379b7456b211e25b78e6afda66e3019c569dedcf8c69136b7470850967353b341cdbd644acff69859b803723badf842d25f90d678f68edbc01ab01b2168fb123ad5d8fedcf801346dcc2fa8ba2dcc3a0d8c11b225d6a93ed01c6efd5b4b7125c71aaa183b189d401ded3cda4cfdbfb39627dd93ba1651f7e707c55ee370147aaaed3813457a4aeb6926d1001fc43707fd0fe8fd4d46684d861bc80e822eb80133a095653208bfa909b6eb4e098dee10ccf3a65e398f399100eba13a6941e31bfc08a521b5568fdf33e9343a89028242a4a404caa51b18555b33eb42db1a07d1601061eb235c0a70b9218476768ce406cd0fa460505503c72af2a685b7bc5807a3da04cb6d682c73fea1f660ed1e0b81c3d7af075b47eec1fab2e1eb0660a002ab8a3857931957445fb15af2da8299810617254af637455b14377a94a1ba21424268b1848f6373519159069477cd2f4a1f0441664584c93a2e54b1ab14704a96a5eae426de59eac1b9e98143c83ea9c70884c4caf8d127f0fcd8640f15165cc1110a37494f59e21b2bce762f97d8e9e1661f9e75a978f7db0a2d021a43aef25dfeefbf4ca95f57ddb08a74d0a21f22929103522eab59406e576748a21d778fff5fa6366f8e4b5708b9dd186f80f8926d7b274a2fd5d41b8c5da61d9f84a0c734e83d33c4c910ae5f290b869d2aaa6daf19df0ea6fa47e4995ccbd51fa49107286d51f3af88c50c99fa6e1b17a71eb747b8368ac56e13c306eb57f802d684481f3da9e7d001a578c2a3804e3ab495c6b4aabda9ecf35672e90fcc98a458fff24d448a0ed4b7332ee3eb7c1b047dad38dec0c482786a7d1986f0d140f5058b77c679239acab2af4f125da482a3881f1ae5878794bc4d7c42deb84615e5d2164535c9a6b0f2000dbf91d6f3b5dc38b217447f59735b28c7e8118b58a84f1f8eb3f2ca9f33beff88518a1c8fb14333b07420cd0ccdf0dc82c9ef1a30b16062d09ec9786f1fc56fa5b8eb5fa8b06f4b214df3c27e15f76e836af30a38b82929f90b011f6045b02ac10e5fd4da4848676dfd7dd4100e70623e1b48ec22d179db142bb19a01ade658d166065ca5783a7f202f8126935ac912897495311c974c58c119edd0c593a91dac0a5b2b7a7488f4be63ec879a0f9f55faa95bcaf9925c6b46529ac85fbb6d4babe2c9fa020b0820365c9b9463ce46c29287920809f46ee4d2dc98585de66efbeb915c92845ee043e3a687cd3f40d87f98841b3bcd4583d8541dca274029d0421196c849c224b35264421722e2474307fae11b14705780df676bfdd6a56fd9b89709637322caa9548d9d974fbdfd213d23d438830c9c8a7387e7aa2ac6faa3b0a417e674fcce0208f8b9f17f11ec1ff16d0ae5b779cb7a4cf1f1558d76c9e6c5607633eb5e08ae5423e6d78e91297c72cdcf16219b1204636764e7280ed32656a5998790d583c50863fdde868664587b2e1dd920de624ed954ca55b848e1e2bc26eaa7fc20b968cbbcaf042fd64766a0083267f2478a0e55db0d9759131d5b55128e73662cf64492a8e4da81e9b09edf9145603efdc7ca8536d49c4011d6a96427baa06618e3eae9d7212925ed7b3f07df2ed5f19747c2a7589e160e5204800c8b2dd92f0f23a7cebd1cea8986566f4f25525273718a82c0cdd8fc423ff0eaf1ae092ce009a5597bac584e3083eb0c14675dce395893d5068b32980409e19fe94aaff41680b9246e046369371444e90a15cf5ac2fa0d3fa86a46d14102b192307b21b80ea4f88a05b79d924428bb29f5c85db5873cf13e3f19427c7b9e2ce36f5d46dc8966dab7a1a0d063ece75d41dd2b04568425e289faa3eab14d93bf680eecdd3bacf2653b2fe40b9d219151b7738e3212daa6f61d9a3d0a7df6f990b311d0a9c36295eaec7e0bd8f89a1f0b92c64d11c96e8e6cf913bed12d8c1f4b05c71ed86c9e772822489e037244cf831280f7c9f6b867fa88d9a83c0021574d7c8d72b8c9d6789e555601f68d68e181f1a93d11bc47acd5d22327b50ba17141730aa580e3b30f5dee307e72ed4ad305a8ae637d571aa3b1ba3386a446514b08f88e277043964869a5e28dbe842365e85b8985a5096a48d070da86aa550c2037a872a2cad9a0ed246f5e1ccffcab9c14a9f00ccb4ee4e23dc4cb812534bd8d937e920c80ae1fe7bbc11b2e4367197d3daaaef9ea69ec1af467310e009ef42116db061306469c3a52d078f596757f417c6d15b3374514bbcde569b5cffa5bec2b1c26d8d441daa377b312be3e6329a1299e8557f239232283db706327ff70881d2158aa7cd69be49be7b04ddf8120d776a29550caa0667601a161c8e7828f062d9fa7a42802c0b542c7a8ba8344f4e0a25e02daf97b26183a5d5d3f774caa2358a2941c5e95590bcb5f9e762175c87969414fde4c70eecb6d2c05e5e1921c7b37136bf58afbbfdc1d438ba1bddff60313e9198ab558014ecfa091829c9d0d8d735495a9bdc546e3cd0bc3f42f7fd1576c8e7ccbcfba92b492355d410e954b17ba336bb72da35d38fb1915d5810d3b4b20a35fe9907dbb307612bb8ada6d0075cf599d423c23818757141e8940d97b2d144af08d922008da7052ee61a064d1d8ae30332ed56628293d521dd92c82269b217c2d3d11a7b785075a1e556074913f3d2bb90742e246f06414c484b362e764ec144a0413a443993a68d7300c8fa096441cfa35b5263aeed0ad005de5f286454dd9c37ceb914f221e8590b27034d197c90d2bfc462ed560964b6958ed106857899addc3b8b54134d4789ae6c6ec24aac484739a78a75b426b6238dfc953131e237f7397c74643d0ecc55b5d3b488c57717771ace1398ead60d1bcdd9a1947811e2a0da7ce7b026b450a72f9efd0f2387eb4c49606d64acbbfe6681315425658fbd7de82e507aef02faf033b3b05da2da77dad69071e0314d04f6e50b6714b2703f544cd693bb33348b7f6c3eca27a3fd373d9a8accba99d32829cd08e973733d29e308f08f3723482376ca2f6556bc4ab515c4185afd9365df3ceb19b03eadc2900cf9107f2c490c3414395e5fa89a4f14a9a4974bd1971033f17cbfdf30b900383bd3d612034d70f907ca45f6158b237db30944b49941aba236f42af4aed3c9128efb7f287138340dd55149624520c5d4c8a13dfb1defcb617f561e7c43139cefa5d32a67e87619c15e90daa14aac2b2fe393a33889b23539d13cb4853912dac08ca1b485f82de44973e4e10a9ff488f50fb8c8ecd3c50acf39e20211a26ae78cf932ff707e1b2b482031ad49216c3bad4d99dcda12146fb629a1b8c43df53cb6d8abd95a80afc9a3769be009c7d0c89ecffd226d32a68a1a44fea94153969fb71ee462225157ef53c75a423abc4caae915058dddcc57eea5dcc2432c15c8b1dc1bd39c146c3544e9c4ac8e6696ba7101f2d983c03175a95e5a8734169f373124fae15e13e1c369b5f6d9ef3fd2a5b90edd6977d588801ad655e77d782de912f957285267947464fe17f76ee8835f4bf94305645bf7c8f586d6bf98b03c4ea2dd3f86a4cabf5bb9f9371fd2b350cac754b024485bee7f3c34f5144e6934341ed74f5477580e944a1bd123389aaac0c86450b1fd4952776ae595a90e1dc368ac7692643d61b05f53b4e6ac1180b7b453c67f0af41a03b439674e5a2293ca2120386714bf7d15a7b00f903ce0674a48bd3e047c051275746da79acb726632e57fbcede136e130b72089c0ca99e897e523c66077eb9fa89cae8ba806fd8135626ce5d0e6b5900828319cfed4450484345632279186f1285d6a1ebd8790018c1d46ec70799b55ec24b1bb2ef505607c48e708f8161cff76686e96c7b704150965506c953ee9d8253d52f98d66ac9315516589ff000a02faf3aeaa411ce0a2d2799b8069edacee347320faba4b14809750916c8d7dfeb02173f99d6ebeb003a77324d4c37d67ade9b7dc5b206730e4f548063e9bf5689f69ae293158471ad850d5adf19eee304d431b7f638a386aaf1e015fe0bdd41bc57059728dd269f2ebfea0bdc76e99ca6bc6b221ba84c2aea7769b4dd8859369b020869e1ddde774ae1a9123c43eba5592e1da7a04659ae5418ec3d51f075f929b07ce2c694b66a446a3880134b9836d01bc8f3be83eff7c9d5ead8951f185cc5458df09d0da40d3dc2b18d06f46bbd689354207c79c0658ba05ff01dc37ab785e255bca97fd5bb51bae07f44c22228df7c5de65f26d5cf360e513d258cf7cd85686652d9252a710b0b72a8f08a6ea8220008d941a8d22c6c181f6b1099e7f141d2182264a8f4dc1a75efcf35bafb5dab3068b98c8d3e8d6cd4794c3fb087430a19c69dbbc84b4cce71f37ccce5d5c8da0093da064c1fd3a1aa06e8a8e71a1ef112c37b982f70f9a14a73e5685a4d034808e1c0256e8214909d55794ea9dd103ea9f004e1df51095636d47a0089d8f0ef44f46d1be7dc0612aa193f0ecb7a1e5cd9235128ad07f7d1e8bf082f1063eaaf3fc7699f0fac862a3283754891f003401c13243f99486ae2d0ad6369c12c945c6375973f52bcc1878091a61d66d210cd4bd1f09db384fb679979d26b97ddddefe6caf177445a8eda61134d6e2982007b95b48dd4836b6926527f344fe63d95c17279264e5c7a82a7a6223f941e739f712c8848fee8a9780e42dc07e1bebb98f9bc7a203df416228c954d9266c3468a9d7f3e7fc5523058d2579ba055260798a995714fa92d95e400b0a938ce475f2d3f7c2cda577b6ebe4162fb2f55abeedf776138dee76d450e8362b841155ea57861e04b6e077dfa4e118759f77581cf946800d1473e191b63ea26676aa2726a32e6b8d2eb3fe5caff14e5f395b743b07009d41a928b5aeb919285089bd4c004caee95a2933993597bd5670688d63e22bea02adadda2578cd77248b007e31357896538ba7def45f0ff3e39d07a13597045a7619657815ff777e1fbfcbfad84c11542069567fb2045678a77041848c9ee9f1b2fe9f6446bfe0590bfcb4ce3a1d85a331df5d4ec05b2f003f06626292f2973fb5401e5e59988aec17646dce2ab5c2bef3247e68eccbb39f5fa9011da2c80c58b095676f69910f8040e68125fd88bfe5c9c7cde9269ab3645106c2a00ae4ceed1981ee0726f549bb108454c266001f01ca99fd98c9a2bbc5bed6db44e24bc65ab63333f89f74609bb6e1d5aa1097ef7671d97c23549fa0e071acc59d88e8aae50f2319a1e24c8ae8a0f656cedbbde69e078bd91c4d49830a044400a24494731dff47c3f2fdd96d7d8a756aa17d40ad57f7c3a2dbf3e2eeb5ce8822d3f0d67ac486028b75c676a510e70f49a35e5a4cedd2d54ebbcc3683163b24c169b86b745c0b359396e61e0cd91dcb91a1eff676c90fa33d8ee5bd3d2644b759ce6e4c31c4609132cd6b4a8589fe2504cc1d9e69910e1100aff0a83c0e8ba858f5aedc8943adca14004a3ac30fde1d5ede9c8093b1321ddd0565eed004943c7781b887de8cc5d6763bcf46e75a45eebe98b3340b2bc36bda5e30dc48df2163ace08aaaa7c84686e19e219febd157db478fc6bd3e1baffa67c04fb7eaeaee5d1c3a154426b85c92de4f54516ffe6e5c3d8d60cf5c847bb53247d2212ddfae21a6b45b11c29440e89d7128b296df4dd1c52a127a7d29c187e905552f314c5e43b23329b76a1f8444e754c4bd8dfa18ff26c4a38db69a4d832136375c58db23eda57717525285af08464fbc5a159d1f909948b365ef9d9c97f194aaeb686e2853f2d3124c1f9ed3215abc8fb24b93620888a6f0a45ad8550c8ebf2b59149156de4424cc0b272b4bce2fdf186cad1e56fb6160ea8cb8a4ac085fe2faccde841883a6c1111b9e71eef873b64528bf5bdf205c22fe3d60711c7836004afc3fe82a8d131c240d318b94ccba78b10ef33dc4b8e1f078b7152c1346aeb30ae6a984ae7db15f69fec8d99691f94908f727b3c84d3c300c77ce68e039eb075950be0ddd209ed4ebb1c27b38acb9b22ad3e00032b2dec7121f64ae9851376afcb654ac1bf70afae45143cabc6756bb0a905ca6d2f41da73fcb8ef89a334fe99221404203e5dd0b558aa541be5972955a96e3e5459e2dc5131213ba50c533dec565451079871120d5b8119fdd4c63a478aff8b3b3d9042279e7087d36c781dd1f78addbe8f05483999798aa0d52b52b461a1c725d20f590913ed7c6a4e8fde2dfda2dd584c087e0b72a472a4ec199c78712ab789cbc541899bf18ce7655f1e9a64c0275e04f76d9ff05d1d66ec4f3d99afb1d2000f44caa872e3bca7a21b3117419380f1f5c129262e7c639da0dc348028f9d64770bc68e9e126878c0415083880ff20cf0e308cf497c38ee34e41afc05ee2cd4f683130c4c332a73acbbe19308dc163cfb45138a03ffbd06f6abb2ef13c6a443407562f544082942663d6825909dfee512898bf33162201e50d9f7b85ce69ac041a011d757a8d5cffdcd368c934d8ddf41554c77868e684884a21ae06f69a50100fac04e2cb5d0c6b2ed35730c8ef5d14178ad66e912ea61d672b4041d1e91f6e4890fca15ad10f91176eedf4e640439fee9d732cb9dfaa54f791942a57df598afe7dfb57d3a046364d76a5cde7f8e2e8c5fc72b46ed9a7b917a8d8841ff2c7bc8bcfccaa51c0b432744dd66a0c123cde9a0517f03ebccc9240b321cfc53153b6600d0e0bc5b964c1aeb2a87473f2bf7a7fef4e56f1779b6b5ea947874a0404268911388bf3484c19c3f86d5feea3e0295d2be7324be07d48ed0787a5faebc9271138a272d14a1e7f152a58ec6514681e09e35875cdec96ba645531e8f00e0800ba3f292f6a93955c1e6ad2daace9abb7e124564de90d013de6f39aa1b89c3b2b273e7becc35a84b81d3246b1717d2d65471a3facdef836a7483939adad37b7cb1c1fc16597bd7ebbbe4c1d8442e3d610bab6a6ecf210b1fc633d661c14a026097802dcf73031eb4cd8b734448135ac38422ed597ada0f5e7e04aee722a0d46812cfb02c9f4e3b0454fdf5dea3a1b7dc2b1a10d38e309f05ac11f4290251f2fa473b7b0548e3299274b999384edce58bd3d1f84f4c51589b6e292cfc6c9306db0d182fdd703469fa8c52409cfdee5013e56664ccc99efa1fbcb912570a8a1eb2b645149cc6e7368c826fd47efcfcaa6c13bb29d383ce3dc3f8e437492c7d269cfa1132815b65cbbe3a16b082c38a292dca0a4870c7e4be1a1f4036bed83001494f4ac5f6bea4391815908fc7ec381f42c801361376db93a994eb1b905c77ad1561457e7e17e07ea17b44021c546ef9e8f9f7957d10f396906dbdba4a4c5e43cb55f7db67eef71e67bf9c3e91f5aefcf105b40f4e0ac7d85216668b8978b379adbe6e4cd630073369aff6411215fcbd3880c9ea69a26a7672876018820410e65af376e0a9de89a47a47a71645b4ffa278c40e509460646b50c652a13e75f3111793a9e52a5bdfdccecacb031efe97db85ef0d503e0608846a1dd23fd6482ef09c1bec9e6a05f30451a14d75d931df8264a87fb786cebf1b4015cb87a93a4e00a96668b089be3c6a3105fb2b60d67d2732bba477fbffa49cbb7e9d511fcac2fca14f72a9ed732fd5615a608c988270e254539cc4175706493ff09b0a8cc6cf61a488a9dfd454f483326249e3a6e427356442199a6e668e09f265a24d1fbf445f907300cf0a7e571fa625e98148b4278a5b67376bb96b37761fa2de53729d5fe6b9273cbfd690dd2bfcfdc1dece1791ca9f9790bcab095cf991060c10db8ab81d1284c9c17febd682c70060a667741cbc7c6854ffa9407689bc5ad30ea7fc518f2fbcd0b9e936b1f95346048c1085a7fb28d638cc8d6d5617c7f155de34b3af0e8e52613e5cb18337b75d5b421ebf98b7d493df347328de8c5d0b1cc5d27a7c2f1ddbff7e8bce71b56db2f824e1ddb730f512637e0fc67cae67c823f8342a21c55cbc53af181622c08ccaac01768bab4c90d629189698fea78560b59180b5066baedca3259fe8eda5fb92f4e1946f82d8d2b2ad0e13cd245b9b781110c843bb260aeaaf31106df6dd36fbb4a0a446b152e3cc15d7b5ea185910441c797f7429c91533d3380e9da56cf1e382a0a433e43c7519a1b8d10175d5d26f3d96d2e62189b0543330939fcded1640e71790476600cd7df34583d08ff3bb1e667ffd23a7d1535ffc46b21f7e00fe3950e5c51dac071bd4f2d780a408deb88935d7769e105c9d647cd64e47299aeda6d271dcaecfd938a72113eac5c1e665e5d92bfce7e79041198b1821bbe37393d6f2b2cd7c6c1ccb6a51a2e075d901596c0a8bd6aab7f5baedefffaf4ad9b64251bda41499325b6453645f7e6aefb8232adde1b3a489125005c33c8a1f370f25855e8f0be5996b0784ba172b8e6e4b8e06e8140062bb0db73dbac8113086141a54afbc100b7f1ae0265fa64710f512c9b0cd6323b8ba094b14c34b5249cf7c3fb3b300fd70567b616f6410a77598cb36868e1294c795cc7bf21bb6330c395e6854bafcc5b9d7cf812a0f5ac5fd80fd562e8c49a503a9766a8154122d52f5f968937dc13615fb5b7e4265f1e30c69939abce7078d297bcdeb1f4a4a3cd579db5f7dd47e21f8daddde7a11578c2370f6a06211403577b9cd4f5c66c34ab60c99bb0657609ae1d79583ff0a6bc01fdd5840cc1dc020d04741a14c8f58ab97e03b43208d3034d638890f1793491597a762ecea9404276ce1a3e8921c14f25d2f5d024954f36ac83e361ff7cb1bd8319eb77e07802486efcf29e46530f5b9977a0d67b94a1b5142a9f1a7de1d79b827c3794dcd6b95707c8477ce28cc875341e310d250e22afcf065e2c7dd5c72fdb18797e5ef9f03ae9750a715a4acf009229d57a7984872611503791c1df78477679588dd5bd9138e6727b4af69c70bfcff0a985eab89864e062c28c49bc95ed27bc06b26b6d0aaace24350e4b0d3a7a69336fb68ceb4f5aa2e8ad32752035b32204c49a008f9333e44dc98e2da1834155ec2860a0b1c41ee27c41cee613196c580053192e2a22585a060f05bfa1af76b9116f5e3da7ccf4ba8e623bf46062b59e703c4b266ed6714c20ee9f6ce045c5812adcb650dbaab96a75e38ca5ed1ddb2ceda76eb117a9daa925547ca664892a398497f38e8f1dc83cc1b658c8cdf319fabb03642b9c8bfeefc4edd0a4f63c29140e187cff5c21e57970736974fc8c0ccedbff28216244cd09e6e160c7f59ac592ea5db7b33ff13f91ab93fc19ea88a75d23f8bc8a4aa84f64caa5944a28e7f14579b9ac14aefee59b55b6497fd1f7f3fcdf0741f06aeebde3c6a285d72604afed8b38430c569daa20fe4793c051835c80b672fc9fdc687d79ac8af93ab275e5c0a82e7803c5c832843d84f9bc066b4af03d1b87dfb8579d17c7ac22c421274c5f018e82b75a5df7731367fb2bb22b6683a475c90f0378079aa4fd9bddc95c3cf5b4afa6438a75a6b94244da1282760bdc6ebba60d85167da23a80f6e5f266b7569ef9dc8492440b3b0a287b940e7a9ab40258f5e59086ab325cddddbd643df0fd2007604f51b6dd49cf5ce97bee5f801aea54bd267594bc6eab120030dede08de45f37a7c29c109f74849ce7db677912e2119f41840cafa9960b9510b8d76bffc20a3189fb39d91fcfe4e465231af62b960ce8d3146e8c1914e29182d9a1087bc4b53c6df47f6a7469068133ec2b947d4680d108ec02a73ded299540c1ba701453e85e85b0bba1500f78ad53afa992425b26bab6de79b855c1b4bc0d5095cb9f02044ae7c0ba02c0359b08e5f52b7238f21f00d92871c3cfa77a71ed0ee2bb14e56a5990a81c71ed2f0ccbeefc6cd4173e6d93a3d17330bb79811565562d3ed5aeae72e71e866b5c3c8bf729a84ea21a453082959a9006ad20364daffa206fb81654779d029ca585b35b49d8cce72c2300fabff8d2f5527773b764eb1376065f9efbc8c6e716be4cf8a3b7db909e3a2e50e29869b07aaac844c1d861889e26d31635cb552f8450287311b2d56973563280909527c56bbea6ef5e5ec6c5063560a881520b968098be7e2c0cde2cce7f0b4bf7bb9ce3bcb86952a24f808c5c4ec93629992e72e3c129596e3a86db448f953363faf0911e0156d78ad60a6aaff491ce178e29b3016e8acfb50ff1349f9d8db8522223ba0cd52af65d29399552cbc768562dbc74689ab33320ecf6a981d4e3d16285e51cdf718a0b211400863db1e3c0e95c07c9d4eeae2fca1b924bc7ecbf4ea0d400ddcf1c756246a48dece7d936408f5c884a3f26cf176e0d81922265444b6267ac54e6e8533ecbe3dd8fbc4235a264429b4ae3b3ea485eef9dfa0de7a2abcd565fc3859f45a2ce1b5884dfb53b418b16222ceeaec1469d0447b265d96e6461fd83d2e1584a4d750b3ae6871d2908638bf6e9e53a35ccce7d269cfcea7110c7480e6699eb77745f11b67ced5eb87020b4d20675e144ae644acc0fc46cb33f6946e61d902fe61d9943ff41ba8d7ede3fd76b00d0d15894697b064c9371121e40e7a8aa0bac71788a57e353d71ae31c30f4ad0978fbd6d45bdd3e951e5ebdffff38d4a718b4d2b0c1370aa76c789dd7c4100514d75c59d4afdbc150bcf668639fc6aebf124220e18ad068da65c45b768fe8e2ba7ed2d778a00e36cf07d16eb65179500002c98bd36b488935753fa784da410480a714d6880d51b929f5f4f82385efa135d802f2ea49d716f5ef02f46bd19dad55a9e6a941376a999811627b439796b2a1886dc29e22cd500efd07d061875844a797d8ff5d0342445e4db16a6d239e9726b7ddb44aebdc4a56c550d268317e325a0221e876494ce2239c14f2addf47c397d52d3b56081f13a9d196047988b5e9f54e16de683f22df71518173e0a100a0623c94311e052bbb67d495a4fe851ca5e3481494cbb911e45afe03a43ba7dd4425a9b30e70e34ca10ec1babeb8cae69471f4e92da9faa7c45acd0f7c531e43ebe40e55b73cc755325e4d711499b3f328913bc82acc0c54d219f8bd46005f46b134e1a221bf0f0119d5831a6a66ff5bce992527d7c8ac2896d6bf283ba58e7016489d0b63adcf2ecd6f2f19dc5236232de7eeeeb420588e548bb97c46ad16a33c85a2288e9638508b31c80c9eb60c5963f964a936e99e504a60c37746ff7e4233d53845dbe7a354657311ea50a8b27d144e5ddb66178a8ac5bf76c8ab9bd912bb947f1d2a1123bb7a0206099fc1f2dda8b697c6099421b367e509a337604b9810694a15c6aeea1a413bc983803b6627a33a5d8eabbde4f13c4015a7e703244d70b876fe611caaf3364cd54d06316c27244be41960c8e3a9846cea126b935a5be75772cc694e15d44c70a424b9e70814f4b1a3b1a401ce5b1758402718a1619d8d9cdb0cf278c551096620d8fe700196e3f96a6cc4188fe10d5d10dc22a25a8383a5855585b60194ed94dd492b4053f08459ba0cfe0b3ae5f51318e013b52b4bd8f78f6f4fce2b23b38b5a1e71fce07499ee940eddcb876fdbe143ce5dc31c140f4a08b531e6f71a5bfe46a96bb0c89a5c343dc33244106418b7d97c90cdc03f76a3e8482876eb8ee529f73f56869965826134c1627429f7678f29d01b7f13f8cb935e33374b7d4ee8377be52960477a244ecb5363997a92077ddeb147f7442b09b1fc3f257e14adf70dafb7c392be8f20adc38b8e513bab51ec0645aa299d49648dfaf0fd27962a5df0d8501cb4198b1b0ac194bbdcb90a35d2a0ff0f20dde4fbb580ca8ea3b2c7b69c5fd34a51f44fd0d16bd4c88ddeae28ce7ee0be7e4ab5a25adfa66bc4b7e773b7408568918b4e64c1ab015400f8e82b3f6ce7684b1dafd69b8a8293a2af09aac981d4940581a92f397e4ebd882cbc6f31fb866a226dd3a9c79ed957bd648b07e3fe9088c34860795df5352720ec3ceb559b14dc192594ed80c4bb04ad91013b1455e5ff3000ef3c2911ee5c7b84e464a475d0f23a894c8a8b071d95660ff0f9c1d6232d9b23786b18ab966e0b05e842cd15815362be4d4682553c76108e04d9621b8010f15494d8392ba9bc4d6a53a3c8cd630c54d86bdc7a69a77fe079871a990a3e216cd9c58054bff033417645910f47ed8cc001bf55e2f8f9456859a8dcff68cbff8f8cb5dc61c0c899c2ba3d660c5334c833b0a15de1a92dcf8d7e057c7d4723a9500dfad18a5e4d9674fd9283500dcde07091f592fc3f1e32a71172754a790711b724284ca9ea122868dbf3312c636afd6c5a9ab14123ed3dbb05dacdd5215834dbc7fbb02044c8e3088a355f715839a024f0bcce8adf67318fcb554d29b5d7597df82e153b54ac4c10e8ce5bb217aff75c64036852b983fc933d6e970d10aba02785d30ff9bc07094dc2a89f26dbd2dc12852ae91347d740752cce412b3673ccd753216030fea5a09bc05d410b8f2c687d8dfd032a1db1ed542a4fb4385e0057f9c014a4a54e9fbed04521a92305a68da002d46cc0b60eede991e29772023d7dae25328788b4dc62410d504c43a0fd685548b891dbd6653f7cc120c1a85e9611d9b6f2ed2521d630cbcd24faa1e5b60d43e1824a723cc959c4aae7d919a2c80e4482711bbb0a9c799a709147666be5de34d73045bd83112d430f11b7a371333c2cde860f6ce29242d95f2388d994c2cd180c996153659bcf8fde28119df3d52fbfe9c37a67f1d0333228fa9059adcc35f6914320ff7d2db0ff2822c484a98fcb1853d31fda6b1f4fa6e8e8aa4b2fe7677639254050cfd041e2a1c940ada9f33870acdd33ee8fe20b3bc88254a568ddb28d5ee24a116ac9de0c8f1f6d63985947b50c897ff38144199283b396038406a49082698ab505a63704f0e21769da5cbc73d0b297960a4f64f4629a2e194fc19b4323ad70b5e071ba9ed393a1a13489f06181ee29a837e294c0a03b958a3f294c1b0c63130120fbdcf6c01066e36e46c338b98865a5b9a4c58fa7f90eb511270d3cef3a7192a8a5383d9a9c967f2699ce79175731e2ca6631a8c80786377f712a6ba360a3429e37955c686eeaf00083677429666c85c7aa692604e0633499f8e910bb43ad84630b82fadc9d1a205670f3c59ab386326075211f0581a3b7d8c4e89bfe35d137adc6e9a02c19965f27f4b492ee5d82dcd02cf6a98ce8bc215776d9ece3d1e01c4feb0005edb65556b87978da78e7376b3ba6d4dd30c8c65b5b00baa810b5b43bc812db34bef4ae81589de897330dc85ed857b17ca58a470f0bd109447eacf3a47d31baace7498120210cc9e78ab1914b1da6ae271742372be20bd5005a175588ec814f84a25efeae9a4b48b3476e8bf41ca4ce3bf922f0cdf9a24407cdfd584fc0fe169072c718e9a0ca0ce39ceee9ea262e439657956a8b7bb2d5f17752af0f7dbb90d661aaca4116d2fa63d87a126e720204178cc764158c5030671d684220154e389f2c8d4895bd2826fcb24f77949b0fa86d627d37897efacd1bfa5be6f2783368b6e31815bd4eac931d3fa2e522b708b8016e0a97e2d0dfa7309812a273e05185db3ff66a4fe789ed53bbdf87c21cf6ef34fbabad4ecf1315d9546ea691e7a1edae529406b2ef8994312897ebe4df1a79eaeab86fee4a2a9bd6113b32ebed6a82b541aac2a6cee27effa9b52c77bbd166b153711218af807044ab85e84071e8f2c20a31a147948b0b853e879cb9631a45d8e0f5859ed19f14e90392e093013aa3faea3ef0b09dd23e30f9171715c967b491fa065b7830b0d39adbe81e4642a3a941e47b29789eb6077e491c81b470bca66a4b46d783f52e20c08e0cbb3844341b97c702545fa2b974cdd5214bb59e0575424306ec58490d5efcda0a7ce4483767a6aa0de048d525f46ac6e1c080e8fef430c7c6813b33e76a57a92852444fc0693b149fbb0ee47a82f5af7ca2ddb87ca028c4e0d4a4575d294fcf4d00bd52832e5d18da6fffecd7bc302ca604e93dcba9dc0729252e97ca0a92342999b4521e47abb9d6ef3f34c9299a65a6b890be1ee83e99fe4329f6b5d650c86793da2580a74d704cabcfe8faada074f38d3d4ade33ab359b5813df741e84a34817a908927a7aff9d3b1d4f05f92d742319dcfe99689f7206e7c3a21f9ba4958abf56edabe0025ff6102ea965d8966e757d54a4ac3475672aa714490002c7a05eab4c0bf9d54d88973ff752e603d4ba3383f558c577f90952895d8e5f0dffb995aff89aed36a220cf4363915ce89f12c59697dbc3d7823838059465a6038d0f1153b45eae6ec29849f153c68244e8f26665d63ab4378a1090b1d9e564a34f44f391b7b51a9b5d828da7ae364ec3689d0eba53db5d5e83fa13c29563d7566ffa59eb0d843bcf957c24aa0bf776944041c369cdfe435a927e279f97ad926b2c794d6c3247d17239a30187c212c7f436e62a1dd43603ebaca50703f76d8a2b91b09460895b0becc7dff973c950e91678b8475f659f200d8866c2ebff068a7ae936f6c6668df718f5bb950b977c4c52cdb4a1b1dd3766a05eb9487e3a7d7c8922cd8761e3502d4c6a220737f5848ba42b105056fc1f8e3bdbea959452adf7c54b87a782c572af5acda52ce4e263b997fa9c866b5ea2043bb2b50cd9ab29bbce791efa9ab320fb30bb25b4a9de8aa1bd6cdfef5e9775026565ec4827ca194b0fdbfe71261dfdf6db8fe92949c577407a9a05dd35b75cda2546de69eeefde92b5af3dfce0af8dc625204e3f540d0dceb8be61be1d1ab67f4a80e0c2c654048f89908410eb0189414f95dd8d8bda9cf093e3c5989cd92e08690b657392cc7862e181cf6905fbc579e883d9632b1ee83897d4b221b352dbd8b8168737f101b4521c6047f8706c0030e91d61768dc8dc7dace462fcaf4fc76d0dd4b3d73b7bff46d2e0099286fcc60ffb5c4d75d334c53b8edcd4c218f6efb3bff928f3a08d106d8737fabe1524591c9ed6be4da6328d1c354d668c90c4003cc17862082789c992d5f69ea8293b42310fabfb3eb9e04ec5be4582bcf4ac3377a9c970b2394a8da36f7ea2cb5b96b6af449058b86d9b451b8373e3d356fbb9f0574c27a57fc65de6aeedae8f48a2b48e9c6c21950783072fdc164003c0f79983e20f217e00c3b93004bf464ebfccfaf588da5448f80869f88f3885b296ac8bc2e6939901d8449081ebf10953f23bce241e613f67a11717edae4a20d392cba12d92fad0cf17821609d12d8295d79a8488914127c1849fb80c4d3497f32818f217b1361153703002840589ca4d0a7b6c5908003d6c54032202036daf1d66c6f1b854fe1c27684b6869576e577531eca34c5c905828909c2068e38f48123109c520e00b445f803d5a0a62ac52ef7100e2de2d9ad12f2a664fd999de0b25812ffb864853baf4e95b807ca025fc13840d8b639da15d748a65491d48ca191ce4a8df82616f99c23c534d6e352fef808ccdc18fe294a2638d1bae3cdcae9e4857879a911486c42ec1e1e4342037a6c6a0937bf8fe5ac5d011db685f70353707244e6a9258c2babc27aa8d7bf61f52e325dac1da73e7d6c2009677857cec6c3c3be764fa22c2cc65d664866210b2df1caeb2ac5857b44d1415825320fdca4c11c186714e7fd3303ae8801197802ee3197abcc4edce8baf57efb355a95e3a462ffae2e4346d4a94c4749e5c31a84523a86a71262fbc9e2397766e3104db63a21259ac4fce5a231af82cea75ea5c19e501ab463097eabf675527081e09b7f4ba3f1fa324195906502f3e10385d2e146c5ac16abc4f001aee305ac637b45273913769e80ad9c4e062dca79fc24673b7f7da8c7d6f5355d4a0a7a1e79fa8fe752c0ea548ccd3f396a32815d51136d36a22aa3e10c1d65d28887c92253d15b695bd3085e8fd1e516e930c7e0c987c8d66185f69c6d858d4321780785da363411f0ce1adb4169eb4159bda295f257eba7a42b115c9aa881868bee80e424718bf59730d27534c0fa9754022190a8bfaea12a6837e8861ad3cedceea877b54bc48dd82f3b79a5ef219092a7ac48eb99dc779a53891fcd40bda5a379eedd5ad89ea56e7f050b3ea0e02ba23fe2a7253785b079b3fc5fe5142d3db6dc39c59e273a132c34a152f6d9c20cb01f9cefba27b1189ce3818f4783cd9e191d1f60bdba7f05b4570e241de578c858d4fc99bb8a731b229cc48a051980bbd1ee34e32844d6f4074bce0a04174df681c1344a2c477bc3b242009afdeb1b5966cefdd2035506cb9244a237885e7252d2ede28252e2e2b3659efb3abc5b55b3969c793aa4754853e932813ac64c062618f32d6d660995c844f2b00f543b59a12c68a69475d2449f187ec6e504000d669e0c00b02628270e3b31a6e79b124d1bc1331fde13e58da94944a440c8e0cc5bbbffe32f555405581f9f970c21f61d3d1a2aad0365036220994ddeb386602d78ef9981187e2ceadb1f2949ea12d56feb90b3be10aacdba672a30f355a30bc91d3457bd95fcac227de975950a8badafb6059a8e538ade90adabb293df59403e993aa9e0a73eca48da70f28b76a12fa24da192f7702b9cb24ab130bbc9975dfaea1204fa02f865ec565134153f17f1b57f7b2f08804b0a2a60179960c25aacefe9e605aa5f3ac0f134911f379505e3f2fb536877eaf68e6751b8f65ca6febb652941dc16d560222ea54311067622cb0df6bbab0792594eae3d5c21b2b4d0d7b01b3eeb1ff8986dceb7149ad2a84943a3bae805eedc511e61a35cd1c7c9dfe88f31f53567a434f59563c7735fc98794de9988e8406700baaeca7dad63582f5b8cdbda774c50c9ae93e4d7830c1c8c5273b871120391a7b48804f5a7ad669af62eaf9095d55aea3884bcbb600d4d24703bdd5e34a7426a0ebc8a00fce53f8540b07dea81040b56e90cf4674533d7ff7a0ab9b3d318ff611d33dae2967938a9640556c5e4b53a91073ca145405e53c47145172a50177b0ff6b08985f6f65847a32b378929f820dfafbc453163976579e723af326f8703109cddd15d6e3641cc2053b76e86102ef3d071b7e78b4a1c9f53419ae39bd820b11057858693ff21b72622e78028dd4798053127be16107af96a1bb0f7912784aa1c0ebd5acfa775c2e93ac433933577f1ebd888a03068a156fc1a22086797db0832eccaed069b6b9b776a5fda84f63e86e7b15e78311e3bdf504680f6ce6f7e6a8fcf1ced74984efefdd56807c1918c1a14bf9a8997728ca0cb6c5e78483c903d35a6a0cff994d867a772f6d08c23f0f71eb0dd8b420eda046ed69c6f7fad4dea85320ce3f9aba277f3866cb596866124b674225c71d7cf954eb2b9ce1dd38433bbd3d7a737eb01f048305bc090b0921b5c631b62899473a6dbbeb0492dfff89f33fd85fb7b4d3e5b52dd253a866fe668b75b7f1b5f76831f533e64d8489eda9c5171d546a85835079a134d1e729ede7997682fffdf68d2321da1ff00cd8a2f499629d8c9d367f76d3f04eda12a032b8732b7f8c45305121dea69f28afd451a7c9c9c1b1784032052dcf7e01fef5c03d0771fa3be893c0ffff4f5c99a162fd1cc9746a649cbc7f70a898cf8c5af6acee5e5f318d988ae3303e2b74507b60890eee3ca8e7dca5efbafe6b3f161419a3844bc4c5492ad62cf5362a78edfdcbc2a1a91e3c3dbae1687481f41efb8617445a3484896c72522a1286ba91b8df0e9014622f57d3e4a0ec7cd93ab51705c36160cb3680a8aeb46390048ff625a85527f779659b457da6eb8480950efc2dd6a55309aab4afa5b95a9037e47ed68137e59073480f31c278dc0b3cb1e3caf81d5a74fcbd6cbd8143ec20176cb79da5533e3060af81082b720eb491e1ea388438d92f5b80021344be5415b5eab75c60359b7622f3486a2901651a0c0b83c15cf63e17db643b6ff18bf41a6c0f462a1656ffcf2ac06a2381c64f7cf8c65c03cd753a3e0d344e41f7da45e3c7c5c3354506f67b0ba767cf4ca12cf96c4898150c08305f9c8e6e8689db140856f56e799cc661b7eaf2ec8616fcf4071733e832b05a75def5ca9ee9614e80878923bb359bd796c29e1bde9ca9ee8fe4ea4381372820699749d681a938628393db13ab50826bfd42d7babc372b5c6d47bff7b67afadb2dc6f712b0e81e221b1022656f03fe9a44d1c6a6dc8994edd1d28737fe687e4980ccd2b83b7638be715961394ccab07969087bd170eb0c9d17c7d3f6eaf06d7f2b6e35b04111d6d624f702be98a3289df117fb40e1e07b3182816e0303bcec442c69130bf6e4a79ede2c37a70849a193d46e595dbbbbcefcccd416f294850f39f0a5ab1c1e0974462b9fd27c4fd4ae22532261e9144a66ca9eb96491557aa3ce4cb7fd3ec141c06385124921c28d899386d542b3e29b80f6837e6ce9f6479545b38e6e991ee86ad8e6e58247cf1230c57672812051b20f2950dda14ff194665646e59d7202bff0b0593dfd37c5a7c967ee4e95389802c2e432666c8333f518069bc58e11f6b7d8a59f79ee647e9c5b4485cad2ab3aca5187bd00ecd06d9703f2c3fafc115f2d93b831c555a03440ec84caab4a168c3b79881db4aa31a370b5b3b5b14513d51b3207d3cc5fb4fafddb54eb9bf6e3244eac7fcb0e06afff8b5fe0ef999c6e0b720d74d06d42b9e8acffe43aef8b3f2ccb8bea6297bca1ff8cbd22616a82b2c53f2dab1fe06a757d14405899cd0ec5f92662233bf4aa941c25c3d84218de0949571476fe5161f03fbb06a2ad2d57ec0b6422d74a88e953f0953ad24a18da6ec36c799b1739de9d50506c108fa72792a0ef302913049f7623b916e4dfc8b30fa6de086f1b9119d78dce945cb0</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出计算机组成原理（八）</title>
    <url>/posts/66969755.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="5a99fd0fbe4aa7772c448db3f7934a4ad624a6b99700f1239880d1c5ba6f0efe">fb26124e0d85f363a66baed35993e1a0948953cce3d484fb31660455b92ccb286ba4467b12dd2afdc0f8bd795964707216933c479f00faf5302337078027ef66e68c754bf0232403ae44399aa06a2cad741400e24549082709cdee4a1c1e38f29d8bb6993c43448bafc4543d636ea5bfe35062ad225c74a80f232ba51d9af45093f5220e616be2d57e02341ffad661bef2886dba249b54377d8b3961fd62e8e7033554e6a1a85b429bcdccd8e910eaca84c8e447cedd760cd76a16c64ec7f94ad050108487716cc544f1ca685285a120a1c590efd559bdca18a90707fae890221e2912f079f089d10fb816e69e85944586941b721161d200273028ce2f3cb2d1a6a47461dcfac58b4612622383de37911e7101936179b0ecfeb18f3600111afc775a9e1f79696dae92585891ef4dfac1786314943451bcb820d90a8180f78d6c08f6f2a34cf2c781788e710bbd9c2fc04cba981758233791222b500185a95562e319a2c6fbe7cfe8f9c33dab48c845a117315f032dc0aabe8b3534c86dbe436cefc3dd4d9527b173b4712c729b3e580ecfdb4c1b19e90a5091fb4aa5bbcc9732537f6643f8397bf204ce0859ec9b85a9e7215cc4349dcc2fcc412a804e4173c99fc2a652a7287933b9d25536b54ee22f82efc496a87ebb70ee1621b9b2402555c81dabd8d91ac62556986534ec7aa8e354532a4f8b3172e3df59f11d93bdc44aae8e4484d2b5d527589acb1dacf57da0652628868a2556b80980e039da6bc18689f76d517e6d0253909ab577941fba1327da5886a924f89630a841e722053b2c2b2aaa38ee6fa5d35e34900423f4a40c3ebe7ebfff945f10313364e7de3154eb66622ba713d4e2c2074cd8645c2a5a351fd40f878bb4346c8738667a2d2f9750b7cbffbbb40dd9189df6964e019fec2b4a7cd2a411e193cefa0b768182ad6fd5b3accb7d9e45c3b11586507566d0e40ae1825750a1be114362a8d7b2e2219030b2c4aa8b8ec7e3d9bad72b4a3669560b5028a099b4a103add287ded166f32c211b9d7026c77aa8750f5439e2f9d5283fcd6b2fdb8c20b3540d191c93b378131b3443f057eaca22044429558e7098c839ac59d8b2065534d785ce87c2cf725098f248760676cf0d2eee6e8b3861d75689de1685ff4da084f3bac9badfdee43d8ec31a442af947bfef884afd6af457cc8f21e01a98ecaeff88e40afd88f437001a47ad18079b9cf42fb8c117d43dd3751085b4e1020b90f49cff42d90cf75be999564ec368e21addab4ff27a1cede3726d1f92c7d59f8bc0d16d9d64dae9bcfb2b15d0cf50a0d469af2058c3970bc07b0ec86e09c53edebc3a96938dd0483db458e1feed5b505b7be5a8ff6f89fca385ca193bb8c1e667ea09652ed85b9b386ee65ff9d3a7d27a0266497613f59961ecc4a91ccaa1a0874dbdac9ca6b4d40de158f85c88bfd340e6563c9fdf4ea711c3af17642f56ac083ddbb61dca552a6c3cd0d46df4cf02cd6b22357fc77847e36169f8e1ea259bbea9864ce7a88cf95d57b061c297c0b9a41d1002fabffe2c414281e0a74fc44882f519a72873d148a73042f068b767a52eb1661bdb117dded1f43381ca4f9912659c7ecd0e7d5ed4a0fecdfbfb24026b35972a9b25b2f045aa3f2e388078265d57be9afd015565183f49a1d6bbbcc8362206981d69eea63ed0ed91fffe4249adca044df54961d31db82d7f68e3944518683a91ef0e5266ba53d9a5542f1d3975401b43d4103802d89a2eb33e50b08e3462bbb58be84ab6158a7f6887238b46a2f31a4295c72aa5569b2d8a96b8f5bce24e12e33070e3c80f81e622354b6374a8532912f22f67bc5d194c2471abf494f7f65b5ecda732bf11a06a91341c56446acf058f068ef5c13f9200cd6dbe2ccd54f6b627baa06c7aae6f3f9931a88213f4b67e98b29922e9d8b31a7a5d9c84cb00eafb7a34a2d09b28c4df34e5e572c0c12183ab940235145e071dfadac27aff00c25e185ce0c221604b04d3b4798d4ea7c83135e4aff47f243e6378e2696bd2694e97f2532bb64600bf24ed16fe1bbcb0cd2da0b2eca34667d89a7f4d96e50fd3bfec756248712d3b2235378670862d52c878866a145f511185a2722056c613aa92c65b55d3de5e410074a8b9319a943548b6323f506993f0a5d24cd8ffddab26e226f4155b85322a01533503ac44dea91da1cef10c863b03ef5213ce156c12a5ec656f9ef48e4b1dd8285aae06c2378a9b290883039251d9c1be8cf9651a5bf8b6800a4d99e13f1f61e701323a4c20b5936bd6e8e36325ec8d35f2f385fa1feabe4bc9d3f682cd0e2d9e1947a56e3f94f2b3a64a6a62e3f240afeff402ccd6972050cebcffe52e2a5aba3febb4487827a984323c28a11c1bd41fbf499a94ae48135239e00afaca43656145fa64e11f9a04b74bd55b70ca3afdcef160c94f0f83ee16f99222e576fbbd852414b017732ab47b2b2def923dd2f2ebddfd8e37488bc9e214e00d693358d5a6399c17d17e94eb86bd69c5205fafde5c2cb9345f76ef65e827563ea46c2015c1e293c6eef5eb34b73c4ca60b24862424d045fc16e4c27ce17c18743762c90832a09d483c63407227e9f51ee2333248b145812c473aa15ff9600881bb269ebf704d3fe9b82adf182385f8f58a915f906c2d9c80faf4d6fd73efba43f0f97a8c6c1e46a53713643bc22f3979b5b6feb7a396af6a8a6ed9b6e5b35b5e994d37c563e063904286d9c858c40c87be12f579ca9a27ed477b3738bc91e4c01a1cc4370cbd3dc5f8f9f205dca348dfe22aba016f28b227cf57a83b1e978ee6837d5f37c93169b725dfd20b82d2671fdf9e50d39113001e4e547f7623521c1224448c8c31653029f2f81f90756fe063f71451afbe34eadc333b024c757c24608be6aebe8351cce92a6bc8ce523860e8c71933c91f0240d19ee66dca49420cb5ca752f5bb1688124de1c05ef8d5b996fa84a2339a9eb7e7752ba46b7f4b56bd7c257c09b746c635df9270c7676649e5a6b99e48c0a998bbe394e1057ea5e90b7d05fc57d295015960d141ed0cb70e4b1f019370fa83cbd140555b9fb0fcdb4f577a0ef6ec93bc354dfd1b375acda2ed6aced61b235534db66359c457ff59e3a4a420d3230987b9b1c019106e35e7f83c47f289607506a339b1d8cebbac69d5be374b4f60710030ba18a2c9d8b967a0f0556619e56df19c513eb9fe1cd39352f39f764019f04c668a6be8fcb61e17178a0c099fe93e3df9eb59db0fb272279e8cd0d71a88a104ae82a12695952bf4746375c24573cf0fb3ad69ca0fd82a77329278b04e59cd51de6de5222cb1f25978748ac901a4b9589df93843312d36ff0538d2b3e3c8fb3ba5ce239e62648d8b78877ff99341648d281edf5b566d024d68e0b15644700981d0c3177fd12bfc094ca6283e933a6534519cd853558caca9d1ec72604db9f971dd300e10ffe8a40e566635db210b96d935cc1579fb0f577c8cbf16e9ea32dc9341c1ae8c2603b9027c91aa2ab9a6cc3717cebd79e862606cda3c375230833ca07fac5e0f2372d8ab32f8ee09a0ba4b5722d65cc5dbbfb8ef0a025b97a7d50db9697c8f762ff3d1630a9f78b678aed1e030cda51c8f3d754e6d46a0cc601579e8c5b586a51ca8d9de911a00d1184010066c3c5b75f9a5e928b31859afab95140379b9311260df03bfeda63c357329b4306827044a1608868f93851ad85afb59eec2ddbc431d01a344a5c2ca4a77909129e12ad11b92dfa5b18159414f704fb1d513c345b4dcf784fef0438857e8a485f7486baa27f88aa7bb9f776661c7d65e2c87cf29e7e40c359cfba17183f405786c58813bfdfc4a2870695a56be478a4e255cd7208d1c3ab9a33f3c3ad9a1ba5852f0c8f1ae39d65f49e04578caf7f03c881a074689f110ac906e60b29cc122e104c157efcb13948d27f6fe0888026fb77fa4eeabe78dbd7295942ad95b820f47d5139639c4a163248c03730608384c8efa8d6ab7b27c84fa95825d4e953a2121829b19493ece58ae0bb23e648dcff8ef4fbfbc11d89001b29703f545c03467ecd4941310cbf7c1a593a102543b8a3c6a03e6cdc83a7ca283514741bc60e66e4c7076d21b2c3fcd3e36a0034c571e5babb0771d93f3f30015ae9c87e81e6d1720b1785723492b3e9714fe1591a654a43c31df78823b95ee564e6cca9c54d0051aa53eadf78ab2eb00bdf1e9fd66cc95147d1c0a1f4c2dcc787a1451fdc9ff7b1cce6e28105e94e771e6c9d146ee5747928f2b89eee3bee232739fe2909ae54166d0d0fa318b7af6e260a508f3801102b4e2b6e6cb7dd147a2c6272ac2d00e2a475f132dcbef79fb1cb7a70bce9128f08c0571c2a5652c457f0dff3957f820889e2315babd780e48a03c95e4034ef0eafc922da963dedaaf9fd0c190643cae5af025f88860a003b7f9d20a7a774a46da551e0719de324ae33116bf082aa341ce878f1614dfe5093f540c1ee048e834ad856b8fe887a2df8c432fc55c57175860cc423d8fee5f30964b152f31ed04b3417a4458c1d0a493a438a8d1c48193d272f8b2ead5b25d652978eae581831faa17f2fa33b29debedf4c1071e072ceb299ea2eb4259329581eba273b5f36cf6921ec67e5bc7aa8f415c14b2679eaee52cbf8bae94d23dd63f380cdb089deadaabb11b51b002372a594ed7aa26b4a68227d7645f8c9bf2024dc9f948cbcd3439311155048a911fa676973d693b3f60c3818f4117cbf1b132709b115f469b7e5e2e70286e46bf19a240d8c05ac36dc7254c643b83b18d5efb785beca6846b5c11b0bf020c773f6fb4dcb1cb38514ecf9714a1775061513e98c76be40de06c03fc80377eddf022c1d1a1e64e6fda240e08677a590e66714a0c55bf8d8cf8b0f34742f0633edf85ad225d97e036b78b1c8bda401fa3da76be419d716e2b4dc2c2e803ddc6671bde6ac16ccc8a4cbaeada5a6829bb804f76d47a651c071fce9ea63c776b24b288f326cacba1bfe82125b40ae607ddf8fedeee6d4e9b1fcf5fd9617692b31099a97b60c89523285821971592be11003ecff663e8da3276473acd7811f3eb9fa0f5cb76150284778d58bbe84f7fd48ccb1acf06c0bcd0e4d21336baea75cc00dfcff15af09444606203a8dc78ab25daec200461a163c394ade4b42ed280c2aa9412ba62e9f57e3973e703dfd5c27aa453d45bf629809bed9b7ce32e3fec4acac551b982b774696425e975ebbebd118b1d4cb0876acc344f046d030f3365790d7299b385a7127b433883c9344bb6b7cd91f20d9663aa67d80265ad836072100d07ce313d2c2d495d00e10c7e4ab07d0c7e44e51c1369313dfe8f9234ad5868df814ec3ac60a2ba51e619c42eb5279000b0310bdfdf816246d1c12a6c77e98dfe92fa4959e3cf4227179366e805c94e18da464cd9b4f90e4347a6e6886cd929f528b03d6955530fb9f03b0180ef726eb38a8c599a9aec7d191795b7b79fb0d428e88670538beb7060755166e61fc22023ed3ccc6d964c4c3d660dd52d9ea09080a72531a6a2b8b22ff72892512345375958140cb828cf11a3dcc1986aa69f5cfdf0828c174d82a85924633f58eb05cc975f3c37874a61dce0c3f76330d5915185bbd6989bae7f02e069995450dbf384bc00c08578cba967536dd4d3b82d877cbb0a50caae41ad66d7a9f15f526762714282a1a6bcbfde0edf96552ee38eed133e644a1b5867606f7927d1c268e33ac6b840ef8768c6dd7871912100bb10caebe0ecf0d23984ce3634818bf1aacbcec720c0f46fb09af0871c0d59ebe66bd3e9a2c080b9fdf97c285e0cdcaf21c79677e5c46e3b4618f86e03c2997d63521d1c873bf2fa55fcae5b0fb9f7b28cc29d5647dc11eefdce363d53e4e2ca462afa7021defd9be6143a99ba64ed3e25a6c51c4ec32b87ea1c1f833596911cbf0109642a6112d0936201c80caf7b7bcf3c2dc798120fa88e238df4a21da99ce6831c30d391a96bc2d9037143d90b127ab6da624b02cd58ba503615695508facabbf69f83f1bdc8e5ca31cf4c8c21fa2a5648b6393f4e7404d603224946ca840e60ac7cfb86eb5952be2e76d3d1281db18fc21aa5397771f6e4e27eec834b18a5f3f2c3ec5d37b0ed67cdbeed3f143baa79e4658b1fd25bb1a0b27251f719d6327dff0e281e226c18dcb8fa31044c47c12f72e8254608aabdd717385526bb66f40bacdfee82c87ce4f54eff84beb2501ffe67876df1c56adecf9defd1fda568cc77a6fe332bb3cc16ce8ac36ad57446df9b4a8b150d2622eb94048a75541fdc1fb1abff1bbbf1935853af9faf9bb2aa7d5ae702c806d9bc45e20722dfb2de8a8af916c1a424d853a486f2fdc38b7a81ca8d170b74719e80e442103cd5c7ef56f4ad5cf53d1276610ae0decf847e63737e3c033796b2d9f22aed4521b7a3ed07fa3cbf5e5326c57b90f02a8341d321c4c7c1ef675dcbdcd58ff78dab9ef2a15c104f5652e02cd43099f74e968e0675a5c3f6cf31be3000340d3837a0ae6a9a893280b6d9af313fb0c006f2fc95691cf445d48b9dca728ee72c2fefb99da81252a5b357404045aafccbcf12dab999ecea1778c1f1eefb6f1f770d6dbcf19ac8b58eaa73289fb0d4b955349af24e5e3063dae681d65f7de9143e50209e2248446eb83b30202764b94ed55b9c78c9f201095baa5599e45580dfc6afa9e53829c69ebf99adcf06331550f0aa4c4115b4018e06c5769a35c61b36466ad0188f681bd900612003e826a741103ef59b56abb69be40259febfac4edeb874c49e204f4e62a04b5954092d7b04bc29f612ed49f9eb254c258c97c355b33051b37cfe8b0e8f5b920224627e0c2a5bb95275069338184a4d211084c774e37bcfc22046b471bfd692b3a84ec125518bff96d4960ae389bb1fb64677e9a21b088caeef360204f34faf676b331cc719706cd14cac635f02876b9e255d9dc1f846ac2ba5866a4e24de26f575f1cebd1f703d3c0102607923ac8b8fbdea5716179b36116878554e166d5ab7d976c9ee3f781795a3c751bcf3add99e75de9c051afbe0e1963bf7c2eaeb15e9e6aac41af77153d1506fe3afd292da9ad14cd89e8969e17585c00147ac22ae938ef43d5cabda1db16f1a00fe08dd43189468f8dceb3c56244bffdcea73761a490e7234706b6bafe3cfcfa36cc982349b6f2c92f7cb2d32d2125b4045439c233fee5107e577d712fb43a9013430c303684ad43de0e1f8b72f283d6e65f083c0087a564607d4ebc2691519a887204a4d624d2f9aa3ddf3c2c431048d79b0136cba6e23c2fec64bd7219eddab67d5eeac4bc4f89d0c31d408531a3af8a56049038aa7602e2b1c36a8acffae1b8872d0805019f74a0b4d8fc1f04fcd38d0972bcd130fb2d8096b3bc7a21236be8320c5ab11b3afb8078c636439c82a87501bb5209608338a70942530943b1ccf32884f4f2915358f26c0ff35722943e0079c87bc03fd745442246174619bb067e4b1001ff9f4bfac199bf3b733d7051d5c17071ec7d0bb588520ac1bc9394ec1a8977b40814b3ee5ddc9f235f1093716b730254fd6836dfb63f33a8e24c02b675a5e497af89f1481692af5176cda995195705f92274244f88e9256083a6bac35081b1fa2e58088abff98a306075a269df2c9862c65fd2e64b4974d38e3f6fa6f3e7f0b620865c4b2b1bdd3bd13bc9085004020d9080b5862ce3ffec1c8a2fb3e33ebad3419a8cdc4506cf0ab7cc2acc24ca9bc0ce20c93c99af0fb324b49bafdbefb3b96f3147c8cf4e0d481e9423cc52ddd9f7a83ccde2f859a59e892eaec7bdf03221f4b3f98645de98c900c18430be571bf1af9c1d40f9114a361b2e596a3d17f4a1466a2fdc91adbea1ca2e7bcf55518dd2dbfb2ddf95f39be312416eb9be4d907b2238bfe70ad02c70430cfe7c541141a261ae64a66102996ec8ef6d8950502b3a4f7e861810be4840a21867baa8cc5798eadcf4a695f59cc7070fb7a74a084a039e4a8b17c94abbcb8f84fd6661560bda94cf8f06e7494938f8b252d84d9ca02d53df06e1f9f19d906e4b05c5952fc30ea98e685a58f0c4b06691c935c693f426835407e9a1689992b581c56c3d75f7d0a9638096b9704ce93d81b9a3b8a9e0cd2b42792e797e77fdc5513c8450e720544e2e702b358d2a785a98ead52d22fb107f613e3291182bcef28c6f2352f2d2267efde4f5f3ceef75faef35bfeabd1afbc2a5a9b2c1a70ac5c9e4cfe79b247b86c643672593ae5704ccdfefe6c5cc6142a8b1275f182c58b39a067c24ad26cc0f90fd578d3a5e6fc5fc7e19f1ae3c0baf22387beaac30c4caf22ed92324aa905ebd217df124041a6934a2dde48bb430d2a56efb0047d78079cd2449edfd0504ab15501de866c895840b2528e8104bbb4d9e85a8389446dc618d955b7f75ca03538b14cc22dd0fd1bb0685163d7f50cb961d7cd1394391e6bdaab5b8a8a0fdf50eba090dc3b3965de4fecf332e57527d318af9aebf25d8cc77ed13bf351746587b2eb2136838b30da6412ec43969f44e300612891b5e472033b6a5e62d81110c3229d59c30201eb90bf07c43eb287b9658e0fb9515f3cc59723b03dfe8fce22a2bfdc365a1a14fb21fc0d645f2109ddc30c0f193cde16a0c6fd2cc51561e16316698b7b265832e7fc61fadbf73170e4670f0a7b887d3de8d15d87a466426b59853db0ca54a237e5ea917b0555e1642295eca8288110438ada894e810acdad202f5e8af38e8c408b557088f8d2590214261a79068807d0903543ab83965a94757d2000f3fcf00254a5f35e198f5790c88011749200a4e7eab3c1eece141e05f371ba3d4f203cffecc9bcc821988c10ddfdbb36145ec160004f34c7c6a3ee4be820e5924551b7c082cd7cb151432a259c47062e46a2dff9e37c1caed88b5da850073bf45db629fab5de493b08eccc0337f005b0e18dca8f8f8523e855be9437a4e12f6a6c76115e21599a2b9579f18b147048f5cb5574a763553b78bcea39a6548e54ba514da29b878d42e38281b377f75cd3920d36f5f3b4016f6c3607237a3cea0d4b6bd7f1c31797817198dfa48fa206043faea0b30904f835eab6b506370c0c0b23eeefc2f81f30b71b5b5769835f6ee5f3f9b2c86f3592c89b650fef844ed89b79e08ee585d4b50cd220ee43d496532396c8aa02d627c63c390e1e7509014603a33837b4edfbe825a61eb982ba7ab6ec981f205f9d3bb2f4f67d1af627c823fcd74fa94486bb2fc1c8bffb981c10e9054d6d8c47f168dd316ff7940854a4d6209128566495316c142c5840d7077c4ff2119c377084ef012e8639764dea07cb43c3c949d654a3b1710e12f30b6bea49959fc6134f3f6784bebbec580a57a8bbba1fe4789b777d8dbe6f06256d4646894f256821ade55f8961f199fa40a4834f8c8927fe1d2a65fd42590ea790075a2cfa910dd0a3c9a53f7ba434c5365c9a83886de41c5f4ee15140d91eddde8d87cecb1c8539b6ab2175bab72ae7846cc1855228d7b37776c9ddcb8a5abc34926c4abcc3c2692734d7e6243275d7c626f2564abf43429aee4ec2264195c83616621f37663810b8a5e387a8f9153b4fb06c7e05067b94f3ed490585fd438fc5d70134882e0571882b1707252f181e879871126aaebd4afc0197ca5b222548c3be5ec3758cd6b853c87274bb42351486aa1fbdccefed9705060289c5556a0f8fa779aeb57cfdcd179df984af7451ada0e1733b68a8ae8833866bfa772d2bb020aba37937cec06fccc506175b68bede0076fcee7dc59d160b885f500da7d8461f4a22d5e8b5cd9d76dad398873dc4ec96b2e6f884fe0fceb2e39367646c7d9f5a49c484ee8e6993f87f2a61ca4c8489d7fa6b7eaa7b130d32fc90d2d9d1bc13936685b9de943ef0cea56c68b0e6767364d02051f76ddc7996fd627a0a0088e255506180f1b13468ed436168c45a5c07d4f0a4295583bc6bc3415cfc1504c3fce67ad1d6eb6ef60d3c733b60cf2263ad6ea5efcaa427f93c91680d476572f43a8e0804f5c06c1be4525fd3dd21a63785e74b6b6c1df86e8d38042e254014037bce11a1486a25f509b350b9529211b540385913e98a9419991850832a0c71bf2d8b2ca6cd37ee1946c14cd1dcf4647e55eefa45ba00d6dbc1934b5f7502ec474f9aca17b718484945eda24109dec37e7f425d5733e2b29af042909b28317d9b371bc472347d90d032ccfa2472a0e7980f79a194ed90c096202b26c079be1c9b527f16b8bf2b4a3f7c5b07e6c6628d0bd7c697dcc87c37c4aec7889450dcc1da9d8ec58236cc3a0df524f2280e8618348469cd4dd1804234eeab9ee394a3ca093ba7efce9748ae050593dd2685d9967eb01b1949bcab60c7ee5df5ce016d0365644631b3bafa8844d628d05a037dcff0e9eba764d495144efe1a7803a4447d72e686728d173348871d9c0f54e2b5ab42c0f99e29ca9c2a02dd6910d769c59a851d3681ce4a0f5bc878ee67d7d805e3412ad7a3c5a0a84645909ea11a1ba6a7841dd46d3844f5effebe25e62fae066538e42f837faa591f5369f2bf03224a31147e597c0c06ea6e17e419a0c6ae17cb620c306a04a1fd3df548bf3382671710e949113c832d469839e1841d101863b08e3c664e156bbb58d6b6bab97d4f8f35def53ce3f580c7953971d11ba45f77a09c7bb36e2d7fad48fd27edef26542c9f51832824572305647efe0c760353a315912de73a49beba3190471edf5a318117115aa49e586ee1118a12439a54fb0fbc52351c9f0b15217397176fb66fc9b5315f47fa35b4cadec6f825cb5883db22521aea79722a11315814e435ec254bdb1860b2f8097321d895557f120acd8825b4e8ff8123f24a0b9887c1fe29c2aca5fe7907168e7d2c51b4b8e7e41cd11b8d1b66567806b02ae08cc0cd687e1014d15b6731376f8d23fd37623dfdee267c146f94a9d93248d40fa4801c84a890d607a7d73d8bafbd2dc5f6acc8728931d6c779dff9b008d759feb2c615cb45d7b79bee278ad1dbc77d5b72bd4bd3b61dcd69e0d89cda124f92bcf94bbcfc42bbe55d9f48097b86907d620c004817996859479d16ff00f3e6bd04d1cd894bf8dd4e77332a6ed69fc1567571fb2eaf9f399f29db0f25b451ed455654d45c07509af89893fa02d5830c75ee7799d1ba76929a673240fa51b88bc9b39d5f5388284eee7fd3addc3b39595cf5d28949e9b2c26ebe04a64a50beddbe19dcecae3cbc4cf0b4bb0d2a10ceea4ab2d4f0add6430042f1ca8a06307485771a6b73f0c378624daa0fd77db11371a6235cc920384e5ecbe18c539caf3d44d1ac7e8a2aab41683e327f69b657514b6eee3caf877e1a9264c1664c8d3fa51006ae3d0b8aff62fc8cac468dca6cc18d429686eb69fc480419cb2275b2f10ae19e584440ae771784ec8a6d3ccb2ebbe6f3707d55e352876246618cd64616a8c5c5f16c27db12a8ab44a3edf51718b48e8515f62e2881a515b73f416b4580375b6cf65f2c902675f511f039ef35b600ce52be8984e1c0a0bc608b065bf3e3a272233d7482d0a219b9da0d47239c8615eb3f9fae61de728e55b60da5807bbc29b913f8253030461f30ee41268b3a081855fbdc795b7855116702633950507d321ab252f494dfe88b988dd9749cc42a9ea770c42b59084d6dd628364087367e4b72623e34a683818be51968b4df35121ad3687f6fa76cf2546b489ed6fde751d9ee8006b6c7688161c02177bb1184aff7c9a95c5bae5a16b03f986add242c50ffa9a58b0fcdcc4a4aba0a9411178b62c67fcfa1d1cff222953c72572cba0f14821d68b110a3a9d94d5587a3517eb2a2268fe8b946e66e4f9711ba61e780b33f878dd308422c81a51cf3302c4ada6c271a357bf337d259c99e1b956170911238b6e80ff59dc9111eecfb2bb88efded2a6f229bafcacbc2a7d20d5c72cd6159ea194a56696207f809d4cd5c078839bcc30bc5cfbab5631a3b8ff4b489d25c9d970c9e2bd6f8055d7b6be19d1cba2642778941e38a506ee8f581e243dfc02c3d895be1f47f127d713b5931bce67584332251b5d0b134b35eb55e7c53dd66483159b782a43827c3c8fc879bba3545a25eed8894df9e289639f59aee0af3b1b2f928fb7c54240464c492cce3b92d0781fb15752ea8fb84c3afd065543b6c343536c81d86d0190df4d9ea0fcbb872952264289f8f6b72b83ad32b94ffb3a6bba19330b86dcda8a7cf6f43b56067e1cb5eddd0487a276626a37e6556a220b56cf5862ffc75960c49ef4555584ac44839e7c363cfa1fbef4cb626f5afe555581bc05c382b0fc4dc49a5222de93343abd8d120f4333bec3fec92b1269b60f760553b651c14d4083b9174c2187909fe98b1fc4ac4ecd3d1cc6657e359a768084785c3163e3faad9240cece8a5fac3ad135567f7fc8a46d75faab8517ecae95776b1e97162686eddb05b536148527cd5ddd56fde3d36f4d6968dcd452a098f417c650578776fe7e7c5a9a081b98d054ee3e86b93f20d258353a07350912d4ca49e7cb7fdaf18109ba1dc1e38b92725fc958a736f9372440ffa74d7dc535bb8c2729e4689736ae41e6c722131ff</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出计算机组成原理（六）</title>
    <url>/posts/43fdc889.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="d69a1abcca915b9f15858d85201fb6a2c046008e3cdd8a5e9beef2462b64a981">fb26124e0d85f363a66baed35993e1a0948953cce3d484fb31660455b92ccb286ba4467b12dd2afdc0f8bd795964707216933c479f00faf5302337078027ef66e68c754bf0232403ae44399aa06a2cad741400e24549082709cdee4a1c1e38f29d8bb6993c43448bafc4543d636ea5bfe35062ad225c74a80f232ba51d9af45093f5220e616be2d57e02341ffad661bef2886dba249b54377d8b3961fd62e8e7033554e6a1a85b429bcdccd8e910eaca84c8e447cedd760cd76a16c64ec7f94ad050108487716cc544f1ca685285a120a1c590efd559bdca18a90707fae890221e2912f079f089d10fb816e69e85944586941b721161d200273028ce2f3cb2d1a6a47461dcfac58b4612622383de37911e7101936179b0ecfeb18f3600111afcff5eef91c920affce375f735b057ed41bd0a613309597b6131823f664ef8de2d91e4bf3032f29d5fe2061dcc4945eb89559fef664c4a29cd780b068437928e74005cfc6a2a6ffdfc9df6d2172d7cff633c967e4e747721d417b7aa5dd4c77482b0fc62a1fd26944c14fc289c6edbbd29023d3520cd70025640fb27d12e2c6fdaceb8f634e43869d228e0b30a6d3a1d21fcd4338fcd4ef2f3efc3466e6af524bfda917d51b1965b4a1701fe371fd8241090cfce64bfd15a664d7b44fb6b67da5b2cd663f0fb6e978448290a816c021cb6c40efe183ba84647a678dffe0b6a750957f228370395a431849f1f1e261e23dbf9c2dfff05b723878f613386a48774741c58ed642f4b863abeaa7c77e29acc867e37c1f1dc48e3dddcc12c6faf14f9b2a00a503feae875d32e2bda3f9c01df74c38fc952ae9d5b735965f21eaad736920b1c1e1704b0a439b350b05a90ffaebe31a12fb58ac70a28000c1563441291e17a37e6a302f922ba0e0db72a33b0927c0deb3bce8d745b2cf176715d5c00058576b1fc0d81536832f82b8ce1cbf82b4a96cc093b394cf92dd3e8bc15a94ffc48c150e41d23bdb147bc49c0b36008847184a90981c005fe13c3e6082170d9bbf291c18edb6bcf9a1fcbce5581cc221a16cbfe7c7df273b6b0d9be38462ed9e7881962300c2fe51d0b5e641a63a3ddaac1772ec0d09fc1f7b7dd30db31c5ea8b79aeb583d0a0b99399b11b67b2f7da1d99e898010632afcf1bef8fab471880f5611d70fe4aabf0af0cc61dbfa33e107699b1fc3915a6ff2852387e878b98ceefb6b9e5ec54deac4dd45fe981b36d37f3011ac64620798dd9fde23667a1a037e83c3d0b23fc9eac5ac727c268cf8d6bc88e8b680c2e50194f356157e8c59c8122ecef7b8cd4b48e47def86297dddb8a5ca2f4b8ed68e2e313a19732e3019a9312e48f3bc54a4e6412db94563713ce30a3986d2632396b6707a12404ba15f4d5c9fb2c6c1ae2331c89bd15544fbffac561c77a8a9b8dd520122779520888311f06e1847963fba0eb8fe616158b3876338feed0fc1aec241ec0d4dea5b51620e3ab25a6f4800732d02b0ec9e7648be241b55f3bf3e9332f821f4e5a6d251c6054e89cdee82dd185ce3e38f456b3bb7513af5d2323d8034d1b69f3b2317b5080f312919862fb4bfa23c4fbcc5c338c08c369cd40a27fed66c7aad617a77a62d70507b1340581bec5e15f67cab9493e6d278f9283a93cffbf6248c0617d1b56bcd702b4dabee2a082a87c589a0a4f0c80c440672bc03f2f46178eae46d31e25c9886783f866f6c2307ac4a57be7054623db2d28e61b98cce3e00f922ff1dff67bd21a781e7715bd921589b4ab1907739be870978aae517d8b5f9239057dd43ab246d538d5bca9f149377794c4c64f9d79b993be1bcfd6b1627b55c3f59f8b4e65e79d0ba0cb8ade27e1f0eca50ba2db8592cdb1d451c395d5d37ab0520e1bf6676196a5396c73732f9c55923d66ec23ddf4db62d30f371252cad69c287e6f610b92859fd05b1f4b1bb25b8e0c7bf1e2abd38e2c1a97fe72e10643188b2778749faf58ceb0c0adaece424d800a382ebdd6c37d9bbe7c00e9194cc111dfdd6b81b8ae62c0a2bed1a5199b5feb34527c709324e2cd9a5ed611d9ad4245516b677b884d0eb4141363ddfefd2e72046f8f14c81b50bcc6edff18aac2ceae09a52505f2969fb0b791d25a8c78e4b3c8a0e82754bb59a160f897ee8af17c2c0d241892e964a522ec3bbca96663524ff33296ae644daf60ffc93bbcd9f712c8464233fea1fd50088a6383fb223da79b2eca5bb89688e4554b387b714808ce6a467abe5227d6f09f7e9d5eedcf1c31e66e47075e521b79812370bfe81015a2a6955656ff69e653ef9b66aa61d25e91ae7e5ce6e91e27cfd8e19d5213024e30fb7c36d8e4cd898880ecd86e5327c4b08e496c22241b6330a04976484a6e46dbbdf1f5c63dde8fda0e79c0e59c45f830e54ff7704e9417bb15d490f05cfdb1729a44d44501a7afa9c0d3a7f84f4f7d150ea0a8307dab566b94e6c80ea98abfb918ca2daf1dd780bfe0cb658aa9d88a0a8ba7b2a4297257770ff512d916af1cb37d5827e0704ea7f4c61faa81213dd39e6e9d3a366ea639cde53a825ff0bf160aad480ecc4b02c5cc4c4232e0412890344ee63f90f38b7237a3409445ab7c4290adcdcf02613f9b472611290a01eaa7e533ae785e4aa8ef928496df3048791717530c72e1834e3cc884fc9d91ddc2e2dc3b7619f5d8bbb7e2c6385143b15ae6778d2e94f63c3e9c754b26ae594a79dc5987548191ecb1579ff273de9f5f27a1f35f321d9f16a2a85b563558a3447844809ab71f55087466e57bf13336cdf2a13d094d78be8b5cdd0306df3d48047be0c3e0db6ff3de87c652b8b966025786dabe82bf7b8ddc03e11e0b86b272267882109742f667c1282450ab9e1520f417afabf5451284fa742b9318db94ee17902de5cd439ccc2c099f16e127580ebae52b0cdf9364d811daf0723a47b4c6dc40803114ac062998d6bcd03d5cc913b2f1d4899e4e087c344d953777cfdd6518b42d0f579b7af719344c03b2432b7b6cea945921d9381061cbad9dfc4046c6ce02ecc3fc6a102b77f2b9b5a49b0ca88f7d7bf97db8deb65be73a0b831306b00e6676c6e26561f1af6b54a95bf3eb88f3e9cc01db765500312e2cecb737d2448140058dcebf097d8518ad8b72c7e646dcb71ed21d5056fe1d4a6f82639b87aa5ec553201e50b96a70e5efb0555a533518534fda1335636a976094d5d112bca9751c929e49e48f5c2907b3077a7e79d7c3759bc343ca0d5ed38d3e05b2e3b8fa32a9d30ce5d521ad4da63013efda357c8c625d660c421f810e740b32c7b7c5912d1b239f1141058a994a92da15031be029045b2f54aa430df570c310620c510d15699ecbcb8c3adda8b49202d81e6dd055232d38720765d4e188665ceb97e93f08dd23376477a91c96c1f32c8a9e98ae2a4beeb7a85c9ac32a3b99a5e694d09a23d9e66a7c9c952130fc367dfec4fcaee1043f2da2d1d167c362898fbff4f86bfaa8fc4c247dd60122c09641e5c76fcbafee4ad6229c60a878e56e8d1eec62c7cacb1758a873b4aa75ffa562b2675a6a22c4d43dedc8fa4e2a43bc8e9d8b1e322bffe6abf152a7591049945faa08adc2a1c643844c185db0db4bfdb8e442a5a47521bd8d1ed98c44c1294911a73658ff2fb9e90dbb32f46f783e87b351b8cc6da102c4db39f73c67c549ca22ed9d55087824d380d60705f8bfb8084f6f0b05a8599b82b989654dabe83f5ab095360ec12fd8eec29eb478374f436a3c9f7da49d3b24159344948ccec8f6b11baecaeaf327f2665f881ad3bd283182424026f3c98bd7670427124e991faa06f7698b04a37a7fb4a140feb3a67ec16f4261670d7dfad7c4a0d748b01f7b8af25eebb9ab76d8b2b6feefc1bcf4d3d77605c26ac5dcb4efd90fd8977d3bbc853da460b0843a00b58fe53928d0bfa39246683d772f9aefcd8e5828320d13829113ca3b97cec662040e4608d1439e0ae5cfa9274773e98ee9b9a153b0d2630c6bbe648463711af1fa5d16c70e2ab5ffe7ac057529c5d0350885c220dc2a64fea81e06330a279bb8a22bebd90b72a1cf93a434329caf8b57b462a9c1852bd06c9dd08ed082ff456a6751cc2beb9d378dbb2c1ba92d317b79507ad0a585859da2fda89147bb9a22a876693ff99768b4eb19bb130409b9f1bfe62e23b7a7424f8b55a47cc1bc95ee04146bf3457fe8861dc0433ee63004c87dca5f0be410273da22ef49971e7a45b16ec43e529a57561d543f3733db3d426c7aa0119a9c4aa9e9c1c67f766a39982ad337b88a4e2e2cee958c81fcfff2d336f304f04e587c4a35d211d51e912621ab47f82d47b7054504082cb0c8c5f2abe58be8731584535256b5cc8d6489da71110866213ffbb0b03ebffcb674cbe026b25d80c7eb5598b833a9926841b183879d6593197bd9e1103a14dfe817f200e336bdce22fd6aaf81df0837cf3d03b95553e0b6685f1f1114131d4933057f56802998799c9eb357db7b250a513189ec647df6fc80d1b1eba6f2a150e94e208e1d2bd071b6ce83d19d7a069becb75ab994177383960148d12a262cecb3a5d992ae1677459669023ecded4e9b4aeac81683e71a780fd701aedf4f724149998e30df288fcdef2616bd586afd35246490c2120296376e12c4b74e6db81dbe321c1e5cb3c2efccba92f7b26443e33726fcd8132a3c08883f0788de2e165f31b7874ed00046186b22c9cfe985abc50835fb1b87d5a5469aa69a7bc3f8529e08c60a2af727fa9bea65c437276473af960a8e91e5c1dd21193f72f919b883aa3798c3c5231577babf676b58291ba1bcc8e85ee506af09b82ef7d104d145199f44863314a5c038a80a74c4cf61d993da0976b2feff9251c3c4faf1b0df0da1dc7629c3a75388468dfecb1ea3a65aaf9bc334cc674b42d8a5be1f824cfbd9b971f9a320fffa66326e5cef66f22f6bf00824a802785d09cd378c256d380fe5a760c6c2e366fe4540ca2d8d9fbf92a59701e5029021ede13890f66028d9b6530f36e4127e4461c7e0481ada8aae9962f59d0d836ed4d56c4e661925a6fbd8511667a671524ddaa1765151f067d9ea9d060266bb88c2d93d9221cb84325aa44b09bf662a4232411a76b56d0660c4095a89e2fda21a4c2bc8497bc5448c1e65eb80614bb7c6a915757e2975eb2ea591075e459e6eeea0660f14cea703d4b78863875641ab609d8e136aaabc8e89952c4209fc212b9e3975cdffe5b471f8ff8127652afe526766b959684e97dd7e4d25671eeff47e19f6e1eb21ec13cfd023004b140f92e9c595a3cd92a597f40dff7890c9f216385d5516bd9f9b21646de388cad637b4f2459004d70a7ee636554dd5cbc0b3e011a1f917c3b5d5c4d152c8af35d72edb0aed838e5d3b966cc670bd4dd6d432a6cbf5f6d961fcc9c503cf621fec7372e1806ffb034209691c644a9ba71c376c82ab2d24743543b7af15057b539390944154755ddb8e86cb4e041e4cbf60f65f9d8e9e761fd2125a6113d68b386eb3a33b8d66f13b4d96c81660a625224ea68664f9b77ebde5e5c8285d8fc295e59ecf0fce386a79f4cc10e40b0476648a098f6111a142f78c0697cd9ddd39fcc581508400bd684e9d25c85e00a8ea1005e4c92666aa7f2518ae64b89e33dab421c4ec83b3d4321ba86ff93f689ee6f8902644aedf887582fc47fceb96686d3d472d28fe78a9079c78f0957e830a6eb2834b15ac69b2a2c72a51350f15cbec922ee46e8f3f3a6c0b1d82478145a13852c1a56c167b4f5bf0bc0945d5d033c7a531f2f508ef315609b04533f18728943cc6c577242aff4ad0b0efe497b1aa11330fed568bffc391e9cfff2e425cabd901d17872976ffa68cc57fe384ead00fe360e6a90133dada15008bab2e3f36deb664b3b39beb3af559c7145263e042793953fd7ca08787bb43a7bfbe1bb5460d9f6a9776d57389554465536295eceb1a7d6f91d8b8f711c586bf7ba5f32a2e529d68efcd3be3412cb4c9e475918535a134a6f7cf084cc65b60ca8e7a84d9f87bb7617fb17cda0792390e2e1eb816a338217751d85e89e6b4201dcf6bf46c95dda49163e9a3449ca146794029eea7f23dc878182e64c0b151ace3f064da0e9c9832084b0e5314792dff1bd42b28f4642c0e287cf69d2e359b52101cccffef549f6869975d0334665f34663fd529c6f204db07e7e5b8e2a85422ade3b2d3880732d8ecff9b5297e63ffaad05969dc3103833df065976b481bf832455dcaf83917a81547a83a7da0d711db48f2ab12c7ba728ae81a30d65ec0ee3e4494e9fe993e46f1932b7a8967dc0cf0cdee8d1eb87f4a2a81953d656a85b9700e78f6105c156be3248df3f95890a689c941d4494cd34890547b4bd0ee864cac505873dd2287c4c7fd9f94a04e99722ad3ea3a5d7288f7cd26116730d175450fce62b6b212a1d1c9d88899e12f28ea24a503dfb18cacfd7343c68d38ff0335a78884a14b3e96a4b646ab32a1b49a576cde8e97b88f8e78233d2dd9c8622f464d04e254ad49d9e01f15ff497b95a925eddd74e09188bcbc17121a5d4dc012ad5a9eaf044e681dd7303806c7bb265af26c57b2c9db507d1821948634683984afe5b3d72f06f0c39c5fbd8b1ea4ae61052f6e85d5a38f83436cb25eb7e55e383b2bf8a47b22d46d62c60018bd69c3442998f7672d83b18d466fefe9307549be250b8578bcac00c1dc71b3907e3e49aab099f8fcbab52aa9604cd8a82149831a0af2c6cbdc26619f66db23abfe54e42cc16174e572a704239faee326201600fca88c240ebad058076239ff9bbcbff0f26daf7a7f8d14185e77fd1e83da523c4b4ee93efe88f2e94c3e64d4093252e3ca583039701ee790fd873bffd5f2068804f8bdaa0d5c79e7e9c21fca506d1a444e6bad4e6a2e4a73091297f1a9b2d9be3673491f2264e0307b2b6b844d564db7978e4d5f43f3471d5f00fdfabfda4b5a5cc45bba0189b408dbd5b34fd16526fe474173708fa3a1564b7de0150fc90a65737e1e9be254ec012cc4db0b7f9cc1bccd3a709cb5d140fdda3294ec0d07781134825a6c509505524593a5aecd0193645179b5d95a5304fbcdb05127f57eed203c1f5b0833a2236d881d894afab4599cbeeabfd96fc90808b14351b30e1c0b61977ffbb1bb7458dca4f483a74971b99e5f7bc5942220105a37e6174fd72f0950a0b0eea5fdd19e7326a5d0eadc7176538209398b14168b63661accc4e395a558ef31c30c2df335d51f6577396fe8f20fd5e10ea78900488d94f13a9b08220bc2d36694d5de46bd1240849b4c39413eb212e587cfbb962b32ffb803c4eb84bd9377b7a418dd08f20203f9aea557b77b59431774a63769e084f6b0de05907a7be70ecd1ea8afb80192a7c9ebfbbc436999a77c10bf573b07a3cd45f939e7517757b2476a6fc514b15c19d86c67e238866c71e680f3beaca95db14316d74d93f4fc7cb2fc8ba957c757f4ce26a580341e74ce5a93e184d84bc399241efc8678b3bc586ecbd1ceda944afb4a85acd12f3953982de75f7520262869e193dee05c7a018e34c90ddc141cb188504ab022dac6e4283dbaffaaa693567e77a45e3cf0386b8f29425bdc9c0e2191640433916b8fd0268a38741855e6f45a2dad8593a2ce81df8080150b97169774df1733eb4b8250de9d6af1e041acd79ae29dc91f28f09f7e763dc7ce2b50201d0bbba040272b5d4ac9e39aae277648c5a9de589bb4fe09e52d6dab2261616a2179095e611bb4e0fc2f3f066780bb6c179874a585f8eb0113169114ce2492acba5e81fa3b7207d81f71662c96106f4684884045c8c8e391152559e249490cc9574ca8b004805ce65780e6027750fde974bf51f26d69a179781b5db3ffaebc17b7d94330e9058fe2eff984aa8d0555461fef517c526cf181b684ac52f5735148c157fc22b7b5925104e24cebadb0bc4894361714abf33e7bff4c234f484ac409b16eb7984416a678483b17c5e43c06a8a40cc62015196d3381f8d1f178868a88c7aeee5adcec28e3cc0e44f6e2bcc95107bb4f063332da9402307b548c07ba222ed4653d6ea5feb2cf044517d83b0a6036dbd24f2fed6aae72695731ad033b738e85ab8fabdc0374d5248ba3ccbe05579415e6a97ad5c62ae4c99f9a4928db41ceb2a51f26734ea1cd5263ed0fc39c54a38ed29da835452bc9c7107822d4c5ca6212d12684885b1343fcb254ca2c3f34a670e593097c68768fa0daeed796b68dc7f8bb378c13d7da758203d4c763a60c36018170ceef0440e63a18a202e9e8621c435ff3d08d35ad2df543afede6dd66d45f12234d9039f20d6efcca6e4b17064234aaf76710f7d17834637f8e6af6c3153b2612e3acd2e8dab5fc62b3335f7ff18010996422cf56aa0772ca5b64c11edfff13b03096fc3c1f2d6e3049f0c81fc72691c8c99f857ce087499a66f2e7cc9ae4c92c537dae3d2b791317ffa9c9417b4368162e50bafb5ea35e7556b8f36c0528436c7042fc7292b83997cbf4bc6bec9d2ab8af06154f99e57dc86c9a926169db595e4cbb394e222a82971ad93315fc93904f979a560396c22297123f9d7aec2bb2d9b44d1befad63b906b40aae1531c58ce405300fdaa0519f3af55e16872434a379564b96dff2f25c36a8ef91b13b33e6f55ef317ccdce57c6055d4ee16506ff9a6eb6305db27413054b7c62ba7bb2c73e42d9a4b36a73f5dbce3103bada3be7bf384fa1351f7cf2793594ca50fef31b480932a931da6e288c7ef99ee83e43983a3d9327d16cf3f0c2b7f5c7fd3129a52965014679d543345968bd20c38930dbfc520ebc1eda5322c66cdec5c99866b042b470d64abc50d0b18acf56f3d71a0b12f41c1c5b4952249320042498cbc891c810663be52e4e341834f2ea52232e50eedaefabe0addf46355253b114b4063240231080b23c3818385b38ad48c6a16345b7b0a822ccdc59dc468c346f56057582c1d499bee58a384c1c01e86c7a5099103568018135d4527ce8e2a412ff6f87552e287b3e6916235245d020bfe66037ea8e0747153504229a792954d0e453fadbf545ff114c10879fde708e08e9cd1df0622967ca692232b5f2e9294bebc8f3196d1fde39be98ab94d11c31faf734fd1daa976b61b40f3c91f4287549f1f6fba31a1684d972e20eba5af5438e6f2bb161ccc04ec2c98994475f2140ff89a45139cf049d56f14b448c622a856bbe9efabddf26190c41a99e2b91f63d20a12cb71ba69c41d50e7a03c40a0f1053c72414d59617f12343be83a0cd4e9d0e4f1f14a45024319d5e7a10e9eb9f60410bd4375a9fd90ed70bbb24536eab0c042a1bb7a9efe9947f07ba4b99627db904b78a228902cfe606c7a290cf769f437bae40980bee98d79bfe831e277078062f076b461b70d4619d1f1e56190c63ff7611de8f0da3ee8188e8e6c955f7f29d89e4c4bfc6b2afa6191a4d989caaf53e862c8afe37e2e8f85c953d9c1153cb36017e4bcae4b447acad4f5f308ffebb6f88049b585ee5760e84defb9f92e2339c40f4aef8995678de53fa0c081966f2a96160dad536b153e0364413a4e5ed348458718c1a65d1a3d6e875f105d7f24d925d8caaaed647028986649b62ad1b877067682f1b4ef8f4eae8b14b1afba751a29dbcf5afb1d382ff9b169ad4b04832bc74d14fa9cec947c0180a45859032d05de3175a4f58734e65e753ff33e232b63b1797eb85d954c52c3dc17a651f4c7f4f745f5f8d344be25a271782f15ca269e57791e93c7d5928368204bd6ef02b3a12d4a21a9a42a8357181386cd8d942be42474eac7610116b67d2b5f063ad38d731f32b38a7c5f2b008e29d88628a0cd4708071e326d947126a2726d10221365cf29fc53a35fe31d44bd90b9be2f4133ab9398d548860a214c371edd668e4e77a37c3b2f5cfed2627eddb91c48527a99d2e257e20e70215098d151f6f62721ce0700bed0d40312909ffc1feadda81652fc4704c88b807a0923da7ba039587fd96b18d7bac2048fe87030b4732d025f249e962980d1bbdf700f22bd5b4d6b170f971c50a19aad3c2c6c8231ca86161876ca77d8bc6ed1290b693b1bc038d29fcd45c036b5afb6a47ada96fc1c320b21edd20ea412c2eb8b9f61e39ef29366d44ba16b197267c3bd45d01f17baab8c5ff4e697a9f3debf2452b2b4a78fd94333897cece40203092f06d800e24845d02874c061c19ba7ba00feeefa53500481a7b3db1b5c421a2764206a725ef6b7d46cd7ebc49c88cef534ff3901bba6dd9280909035f8b14e41ebf8b191a66e3ee9663dedd37589dc1f608d59fff8d2459a2d18a76ea9acbf18f03e65c99f6097e2c044931e026a7fae27562c7c559bd83c1a68adca053f69c44f7a6957c0f9c94e6abdfe3bab58fcecd76cdd145996b79cc10e347ef57c27b5a258d156f098d69ef8a9ac9fcbbf7ef2c22997d5f76300d3ccb2ea8410fcb1c99f82da2f9e107c56b91614b9dc7467cd1b76a393901f441c112468ec7a88ceee6c54149dd003a225b8911d6badc4a85085ddc4ccf2a06a5e5838ad4ce6cff9ad9aae23b2a9c73a8d301416175bebff91055d98352fbd81851b03e3766f7e4e565ec17a080aff6525df9342116847010884b5cfe61f962edd57c79effae8509649e57b6a55ce2b422c9e236192c2a97e4806e51f31ec849859cdc739a80d15a633390c9ae717e2f2ea9a59b779006c2c0cae5ff562cf6eea571dd0b470d1c85d945573eb9992cda74c120e190fa30a69b9daa03004cc6a733d45790e0181c427166b426ecbc679daa2de35ff79de3428cb65eb11ac323b4a8e8df66553cd19ecb7ca3a6cb2b1c9b5443f1d636ba04cbababfee91b439d3dd7be3bec24e46b6f0090e18f2fef1a284471e38ec703ef6bf709eb2abb1417104c1b704f6ab57b1ab0cc0eebc30b8a21f244a81c535e4e32b39944734cddd03352bd3e763117823d841ee224e5a01f4f602190d434a0f2c31f4875ea2a0d8246b1c566198ffff8d0050c917b4399004f176a3965ad89528e34747b8059bbd2ef4d2db5bb7ae9f8446414bfd7b6f82554bb329a35e2c60fd823046594bb01088bf9a380554824e3530d4b393275d3184f21624540f51013af939e6424ef583f1808c397becb10944d5ba87f2b7e0b15bd338b3deac78b77187b874bb531ff5f37fe9061330ea4694f97173fdf89cabd48c28f5d35ab4e01a4e1d6ba70283038a4027ed83dda172b804eb1b95acefae85e75c982ffd42449566a93a10ea1422c446a3c25f031255456af822931f729744d1294daf9db286fec40a6f151fa65ff2f30d446d8f83ffbb616651cb8e58a01d95b4ff98cb8fb31a5228174fe944c0bf4baab4962f5cad33d288f9436fc77377795e2017672f167a44a314a173938f552d51d387a6cdf0669f0ff107abd885d4a8f084f6bc02b636e0543c18e1bb8c56dd6a3a9dced8a1799c7e4c854ac2dfeebd0968a87bc703537e53ff1a9940f250f5ae5c8d5462bb404724d155a93d8651306295e1f8f8885358415486d566ceed54043725e79cb323104c18e51826db85013bee9b391c17ce3c092f3a5036b946a75e66b048b27389fb7b2fab385c6499ce67683741796455d5a8a0a537d841ae2f2f985ed50f8dc8afe0b45938f967092d086c9c30f90ad1e3cb0d2b759bd46939e50b19abdf11b0bd72b30346ac8df3517d186a7d5613cbea3d3c168439e75f2c281712bc514282a6da011b903e700cda7c8aaaf0b6ec87610d8a648efa8db2dd4f973260101973dacf80648fda302b771d23a03474d27dfe6c0c69d346db22b53c9a5d3851994d1ed0bd2bf40a43222a179ecf21e31bc2f1301f766a329700e3217613ccf1044a7635401f21b93f31ba36a9c47a3c6fee70656d7b4e4aaeaf1f994f543a8d90adf06b20f70019dee0f7585a70f00036a1cd52749459ee5573356e5ea6860b23af412372ec498695711c0f1a3ac67aea00761ea958ec4307766ec1594b77229419dee4e8ab40c18237abc53d6c2b060b865f2f3c6d7a6faa43d55b58be11fa2b17b63ba3af16f237f8d90fb8b5be38af6c77d03a63c7e2ecfeb39ec3a9968fc353d3aac830ad7a2d0c3166ef40701f97d5fa442ba29c1cd30762110587877fc020cfd9fad762611b4e44b3922f3742888155703dbc3904b3a6b3e803bcce780de386f0fd848a607a1a22bdee4835e336ee7bb5c8f6cabe156484f23a489b01720db8f55a4ba33163e3216af196c7b41759d95b427ecb434616427db4d8ef795929cfda0ae3fd96c3c967a7df32b2633745f3697904e3cd5ac26f87302472492ce3cc41e42d73395a13ba92f9108bb166fb86c7924947a3a2a4af3f7de8ebc812eb3f84aeb56339e586e8c02af18a99202b62084c18b841dd43b1b1a24138bd0ee1073bbdd2e22bfcf0c86a70f4d6f1fa974a81d1561e19a148dd61ae8f278b4aa0d094b88e25277196793cfc1da9d8a5bd29d11639d74be8170a2fd856bc4e0be1c455843be7522a1bbf3cf2fd8129ec59ea922e3a4f5c8abe813a563f66ca9745c1e25d3e27235e67f078c61eaa7dea21667347663ab89b699cb668e47c71cf196ebd9994572e56c43f6a6f76e89a4ff1c90cea88b7db01a6cf1522e44fedc7b5d44c8857350c1a58b62742fbd0b938c6be53ef1ae2acdda24758babc0ecdb418db16fccc829d8c7a29e1e358c461abf49c9b673427055e53f8629c89d0658ecf866c6bdb7dbd41858c134e474aee0c4551afa3e681a6bb65db4cd66dd063da926f595233b318bf596ad0557b4eb09ae56b954f7696190139898b7e2d279547ce4eb71c7d1336ba3152a268b99ef06d1f1bd8c86256d52fc1da94a4f9215b8f3255070acf9742201b6bc4258e82dde3fc5308131e661743ee2b95866145f5ba4884d3fe911556610efdd8038cae2a3f96f403992e91e711002953f86a4ee9d5c6fd6f78c84dcaa82e42414924bcf4845c9a13a5ff7e48611cfd92caf7891a191856700a41da8c4da70790a1c6b6a0938cff5819e9e39c882be9d725fc8f4be21101cd974fbe1e78913987dec8dbb35008253b2a6be5fa17a23a3125708602b6a4838549fbf155bce5c3cb5c31cd9dc376dca006e3941a8bcd9aaff2ab07f069f560ca45a22a4d65f407a95951b5db2ad8c8e8fbf6ddf05303d3af9d3e3c196a8e09cc9d9f473d13f9a1d856de884610c72ca2a0509eb5e7e34aebe2953e55688c6948ba3fbcf93805fae2e8ebc64812768dac415159652139899e3169a63ca8dbdde8166aeb6c94c2767c9284f689eee25a205366c5aae7e1d264fbe260eb356fdf3fc555a1e07076ffe3258388bdf2706acb52794d07ca184f56e89422020666928316013a0071f912adda45f0a4871207a566a7414e62da742dd6ff36e64cd464047f8ac56794e9372aca1bc12c367a959e71d09fece14ad2a6c614cff3433b218fea770c9080679bbb2dfe454a19ab4e28e56ca65ef55d0fcf01e5ec153e9a0ffbe95fb3df8fdb3654f90ab0642ce767f622c7a0f35e58a9da463a6eb0491fa9d316826f72c6b747cea5d34c2bee8d3c4480631a5c6806f75ce675b159d58e03b2a8dc55945e2e1ae156487f2dabf22fd5d6ead2ec3ab5f4ac50b91b76c728daed94e1e8485f5dccabb9a91aed3ab266c2620887c91b7442254a49842c9d4c2a42798a80304bbf1c401578c26d8d35a63ccaf9ee584618e18423795a56c0e7b733cde0bfb640a1d7f5479959edd888137ebe488aa3a41e7474c34dfe468bf535783a8cea471a7f1a9da79781ca908cac5b66a39413d1639db451ebaf1ce6f385d6f1854513546f816d829351d5767fe835d396f6d51984b473e4b552a11fa5277f44ddbe0e936f043a6ecefc7dda9a8431b810aa8598ce46e036d73fa007549ffe16b74b43a6002c052650a709c4bb9c6eaa25a3291d0891f4d9c1bae5c41e23d8a5ea674e50ca54d4fc372bd70bef977af0c6c7d75a4edf17b16c16f37e35fe37b989b967e4cf5efedd147addf6e672f3252ea1290d8da5932fe13bf61354e28348161ebb3c637495671800f3a2fa5bf40e57a83209d245a13b2c393c3282df18372413dff697622d0a74dfa54b8acfb904a76dca9198fec83b578a42bcc1789af945583f3eedb283c1db74c1afe0a7f2f226c7a92d8b0476166d2c146febc2fc6a7cc0a5fed048a330858f299a684b5a6526e82aaf170b396a964ac2b8e3fe1a6f946cf16b8f284b896fdbd22d2e0ec3f66a0d276b238ef47190896af57058f9866337795f1cd845f58d75f5590e20d768e9852c2f831f467d4aa24a1b17d5b8f8d62edc4a42bbb167e3472b6d3f9939b70d41955e63a9b255aaf19c7e081e2e4dfb67576ed5d7e04385e51bc3fd6cd27f7703ddd802e5942b8d652e250baf69d1e7808470952d5cf8e164dc4391da1e3cf976fd4b18fbfaaebfe15bbe140e598cc586fa7a72f75d72242a308b7a0a21684f4fbf19f4f818f0b86d6f00f6bd3663013d1861d9e69f2b1e1f308a5d46ca9d5c23da5e58e8178b80a16b96ca836259885eb92454dc6a5fd65cb22c8b7ead65dd1a0cabb522a58416e579d9632fbf90a49de9e1b04e228bfb050f37cbb3370dabb06c8e7b19dd45767acc05e8cbde61a3adb0448603fb01f8f2a6c0703ac876ac2b4a7023319a46d457352c164ce80c660775f81a69d5bb8f57e5b0ebf6a8e6c937aaf4352a9f82c282ca5476167aaa99ed2fbaa9db2fc7b7e40c5c6a1f8cb30aab84f6c4b7ae1b45f6d3d34d69e50072826e2485cd94d285c2ed65c6d8e9966d2b1d81ef3aaf5016854a898ed6ead73e5b32ab5fe89b2c7b859906e1d6e5bb23aa7dbb698979d28d474ee4c28ebd7ab1e7af33d74a517d3d50d63623f9e35970a13a1e3fc76c0de7f0b7ca8e8e0e482e95690b510f8cdba6464c694267cf7183709ca4e69f3384dd1ae07d4652644f3708eca3e2d8b9c68e8b32a6286b7841c57c42b78c3606c915d435e4ca066beff74996793ef2944c5c507d6e8a0cd3c9e7e1f018dc686181662413710d56cc5a221fe6638b8422eafab6117ab3dd23802aca972058044c645f3d68e87dbb46b694dc51bca3ce6de751f32265a5261523d3097e851e31499168e85ab2b0ff093b69ade0f0cae071eb38d0508a52efb0ac11b470cebaafdcb040657be08f82cd64c2f4dbb3ec7b5eba8ac41673fc3153f0f1b4180b777db38536738ea5d8a1ba6adcf26ed04a93ac5c7e97c58de48cef42e4f44b766404c2a389143043ee4e03e0fc7f6c189cb449442e764a02534674f033af079d99fa0fa8cf8ac677ec0ccba8a4c9cb26c92b7fc8f8667258b41ee9da761cfdcf2081f1ed7fce9a1947a1cb8f0cd7b4098dbd6ce3451d875a0041a95f2a4527ca69ac5a040e2d5857e2a71b7312cf821fa471ec867dd041b5f37ad12a4a429bf4f4113384d47b8f53ace06fc14728b1c77bfe18add3948aeb96adee5a94c6a303959e50663b11bd16edde4713c5b0165f47745c8243bf885d86ec70b2487279211322eaa94b91f2efe85aef8a99e6432cca639ff421c8ef6278f2e4f64619c6a77378d0ad62207a9a20e49d0a5d44625c9dc6a717b7e398e83b3be1a3c7ed4094c76b116272ac6fcff9c4766849692b73a0e520bb6591e32f6f189e12c766a91c4280376be2519b125ef6230c58b47dcc1db4ef9244d7e374d963ddd4e8eda2c6542be21e1c1c7c85fab25f12a807e2ceb3513648e82268e53eefd89260d85901a9b99855e062b6b9550c1f82073025a12e603f4082f079627b123ad27c07e810ae292cb93c30f7486a3a9375532a3692ea73e4fa7ef9e734f4dfbd4d77aa15ecbb56a4387a90911a8611f82bd63d9469824cba4b3d1191ad16d0d9b1509c18d8ee861098224d896d0195e7b2c2c30ff1d88e9ad61c531436e11ff02bd19de2f0217204ee28c52cd78e54ebb36a28cf9047081a476a03b15641fef88315cd9ccaa593ed7e4c579cd67d9f54a293c21392103c77afe4393cd86a4c2c1b99f750ea2f9ac450c0050a87de7637872bf43b734aecfc9cdb3b1722010f830171177d5e6b9f2213458aa36b60dd4176819ba71f61d120a78f3eb4fcee44c639e21233a622144de36274744144979cd8b4b6b97863207511bcb0d4cf3131a59b8b0393cb795a19d84f0a622c27182765b046f2300ef6307a38967442d4c41eca8e2bc13d7df94730715856479797532511ee4715b3415b7bfb2dca200f526b7a7678f90495cae7dd14563fecae1324c3892fc72f529b87924c01d46e782380bb1997d2552cfbf2a5388af1455f039142b96dbe452061109d64372f53d7a9a5ae5ff86ca07f628c00a795ed5c9baa5e3e2f7f389228f58e315bb724c7c67483ff4be66df5c3a411bb00395595e4276bb1e35e4ffcd901abb2ab24347e8acb5d947a867405ff53faa2a25f3b70af269bfc022d63a41ad6e2af0aa74c224b38bfaa43c961ce1024267e8087c3e27c00e1091a7f61b8761274d5e49b786cc50d83c8307b59177a92aa93087246573ea6bd5efc1053cf9d58b132bf5aa3e5c1588ad5f2f04f1ddc43169cb509d76956a0712b4f84ba79e85499285bd84b570e313ec69ee1f8c8e8884287992cc35b26c4487122c0b70681e79f524ad93e2be41e3e4201d6476fa7a7e4df547899061f3cbf7d4a23c0e252ce9ac60930e1d4b11c16dd0b7e28acfedd26ebf83fee98e884a11ce3a575f099f6c648c2b41bd113101dce8737988abd389d88ca077cbe17e7031b8406a776d8e4c7e2c4f0fe9d9e77bab543404948c7f900210f0d94666f26d2a688ce8ee3dc7d41eb2c7777e316412ce65f120ce97cb899ae2c22c76134d74cc263aba27c2e5fc3c4791aa360e6132985f3e7eca653aeef18e5453c6f1b2c1c07a3b6912d02e502243069dbdd6c4b0b2001d69d250b19bf17f390f0829b7e0e6d3b6eed0e2c6a381130d79ba2e4d0698ea46f64a706642675f8a9fd5be65359f1f92c258f929d18f454782d4c61f6c7dbfb44baddeb069b2672fc67e0569158650f4928896ef4653b965349ec4a287ba1b6d7667f351447887f639329ac26cc16db4a4fe6c0a0a8fc4bc972e8cef738791dfd8f0ba3bef1cedb32d929ef6dfe51348a27fdbe81cd85caddf2c932747a4362bac0f75a226911cc66e2ed80473271a44305c2fc51edef14d30331914694ead97a6129b98d4eadd34fa76cbfa447cb7df3b7e952fb46cf460c2c4a8dc70797ef726ffe6a79dab1c88c7b31f90d8576b2a15e8e247d7a92f6f4f1e1bc7e98eeae020f8ed2221033aba382f64e9a765ee40e8aead14031cc0e33ac6ee400c5af4139bff9f051cfae3806b30bb2a7e33e9dfb06b2a50b5427ff07cc80474ce689a69276eab2c79f494a7a936a6df67da72a273bba88daf9f891e388bdb7315e1d7d1cb247c766118858826b38cce1a9aa9e68aa091da1e8f9c7b5a697970030b26fbcd5bc8d5a6906b81add9530db586cadd21fecc14e3ed8fac65cddf767799c9db077ccd01cbfc1856b557a19727723631a624e8cf399bf9c5f60488e1447addc4cdaf67c0e0930d1f3eba0ddef21b3e0a2d1d94bd2b07078a8b98d1156b2f9c6381216495eee5da340bba9a49139bc266bcde16ddaec36e9472126f85bccf37824408843aa503253e5f6cfcade4eed8735c07d315817bb4b623fed188ce430ffd5d236c62477a7a0c56b26015bd5fbf6e3b13d2757484564b007208d8da00d2c36e4688b943d78dae1abeba6df96f04c1c7b1dae430ddf793a484ab4b5ff6130294c2c3687fbeada5b65e82d908de943b9192600e1a19905550c10ef9b985d77c6bbff4c24006dd42177280cff24809d81460ca89b9288b45dc743e57935a01bb9bf54ae44595cb8129f32f8beccc068303794bb1a68d7acc277746653afc1166da5af116eb06709ac376aaa7ad96991a50bbbe7183ad958c9927528a5cd83b2c93c227e62fa50670cf8378fa3d77beee2be899d9d4dc302f60d755a0db87bb06f7f998bd97ea193a52929f695642433cf6881e2df9994355dc65a21eb584f2d3a43b62c821060d5efb4ccb75e17615d54f8df7d6ea03d22fc9b3e8b6ea249db905c7f9bce39110fca2d1e436ecd84f52b81fd77dccd122af5b45004d8533c54181b3c0c34b7483ab6a89a8aa687158117a2b3d3574cbf01de2efa21781783a05158fb7577df44b7a7058deaa7c30b817b8e543b9e94cb8e275e219962fbf64d94ffb6b1ed49f5612e8236daf6d1647e45723cfdb4970780c22563b155e33b36878d8375956a5d965ceca448989754399e38010bef987ca6a514ee785827e652bed26a7cab4452a5bd740d0aed5f5700e24316f04194ff138c25808dd804a39cc5eb59f08b354e1f517e3016092e76dc334424cc96de5e30721370670abc012679defb499a3f7dc9d4f77287571202efa21353e34b1c38a82b39b815ab3dbb8ea6fb91b68aedfdace09bbde7b9192beb4576125fe23d1a5c9562204153f1f346b0188dbad0c8e63ecf402f43db9070ce458f7d6b06d29d9702239bde965bf145915af09079df77de1d31145ce2db1bb195a9e3a3838a19fd2259d1f77ab67ff98debe31f52a1acec7c1fe55eaca0e53192c422401cc60f151772480f7fafa70cc1582ba4e9371035ec4e07717e9cc87d73fcd025739dc89e7469c0b5b531e81e6df3d3a07189443a23eeae15729fc50184fdac05d10e3c125473e3d204db275f94ac2a8e54487bc77fb9f78d975d47578efb4d03660ad613f376ebbec149bc25039a90370cd824af09b849f9863aad4b9b85924acb014c50dc947734fd22475b52116008ef242bc064482dde80d8c5ce0e61c578b9d45b4199328d9757d38955415d4e92b2c04267b0255ac3cbe75135148a1f0515de7be800e87462d953c8b4310bd2e5838a60063a177f2a0e18cecf12f415fd787f9baa8ae2acabc330b408f4d5e56ec856a5ff660d14328d905f3abdb61b3a59a59aaedb57d08f1e093aba5fc62883c8ec77ee4e9152062c4860ae72065be9d912ab2e6d877d338d75ce40abbc0334d924794274ba642384861fe1d3056898628de1fd38893bbe193586b9ae9862789d5555ffdfba85e248158b8a48dc51eaef50629afdf20dc908aaf3d98f796131267a15fd3b500312172ceb86b21a2936ffb3277f89ddbc4787f7607e427710635484ffb8c7e488138c4c3e522b53f8a96ba37f89adf4c55b3d100dfb142fc8700bf0d1c25be3cc831abb05439ac98ac86680d35d57c6edc1fc90b6999e018a51184350b82e64e52282ed3342dc76f2c75e482fe6482712b762823332b836b06914d7c06eb2e14f72d987c37e1b48d434b8b6b273d6f0f4966b454ffd4a7b66ff86bc30f5a3843f1a7dc53a3cd5761c51cdba69820c8a90657f837265a9e67ba8185fd9e6f973ffcf7139793f4c1516f6492248eda3471e681ac1baa0980d3421324ce5bcd7117a48f1af51e26a357149b7e4575d9aa60cfcf56ebfb3f7503e26c7842512a805495533a6acf9040c73ac97bbbdb7019bd80326449d712feb32715c729ee6a6590112e39e3b3bdccd1316977cb90f1027081411a1a07840d886e53170c7e102acfc7630229673befe6d1e217e93648bf0528a9fc7514e8e386a028b79a37211e84def38b84e54e2b5e6000086147b041d477b210b33feaa39daca95052614f03b86399f920e00196df7bbb5589c7d55ba720f27ea17796f6562a15dd6d1aa88ddbf08cf81627fc3d0107a10fcca235c6a67a88e90bdf5984bb5a5634569753f8fc37f99a5c2e8c90ec9bae72365440c709891a156f987caf59028c1e474cd94a6066bc54d5abf41a5ba046374c5abf5e46bbb5b6d898595e92c74a05c639ce05f89a5d2aa1eddba45482ab8632207a117a56b9e877aab4c7c849c63edebe262c1f0d2f1c3df5d596b156ed2f425c6120892d644d6ab9169693dc7f49385ad25809de4f437d31923e59e93b948c354ccc822fddac41498af9624c72c217ce4afe988c80854abe32eb8a25031f64070f04383196fc72e9f9f2f9d8d3e30445bf573c6c57dea1e54af144b6c6955943853edac46ed871726d43b9764031b248c83c48fbe798659b0aeee24ed18647b046b23ea68949ac7394dddb92fd49a78983b670bf6368ae61eed27be4be9fd16f9d7ebd58d0f58ab0c90577376d4aaa5f5e0afc1e0e5fc2c6c5ab2ff2a70a7b2d6323ec87e97c491eb74a77f7a2853072c5beef4b508f87beba357624376ca056aa8ec5da14a91139cf117acf336820e5cf447196a936b167786b8a93b2fe4a8c458a6f8a20fc75fdc415f337119a7a528e645eb86b8263d56a4c616a1deaa912a3396a8fd2a979df34efe61463434227b8da9cddcdcde67a3cd4453a8f26f5f6a09760e89e3aff33140c1470da8e1c02919c4e425cb3a464c2aa8b18e9c7ed6bc53f47fc17f7f5b1638e8236803f2472a717a4104bee2e54718d4e49dbcd4b63dac146ec8e557aa4d019afc975a98d73a01289e250fbba0f993822eda1566e66866f3035d505f885d1b93caa4270bb52c9432021a5f1f841eb76cd86db4458b764464f37b71e57f95a8585ccb348ade2554805842f1fd33ee73bfcdc2dba44d4d73178fc9523ca9452b5999f0e6d35bdb4ca9adfc72dab4cb1c4992da88784722e8c5b5ef10da1e11117dd201930df8e2df95b93927b0238dd1c10bf71136c6b3bc7ba9c3d514a734f45f46f2d57d1b22f041ddaf66fa3a3fe69ebb538d3b3fa45210430d8f9eb7dad3fe8e0c8f7d23c44bf3b49e210082434238cdc1b64f612375d6a1f9bc94f9c8e261b1f06e02144ce88864ffd121d1a1490d7a1656733c252fe7296cf2aec2bdd9d1a0e1fa5c73b6561b1c34f3f529997abb33543b115394a4e8849aa8f03830b7bd5e0216c9570825104a40c87b83da5865aaacd172d2eeabc3657c18d4fa2f1e5599438c1c4d56f917118c87578b6a19709a95a0f0748fdab7996fcba32af2f8eb510348f9dd2b660d2d5b1ab4b2eff2880bdef59e9be564af5ea10d5c23431c25da6909b652099b578a98fc293c0a85e60ef30b87d56da702c5612d74c350f71a0bff1c5cb4adaf15d50b42d7eed84266b256d48d2a2554bb1172fbad8ade8dec50179d6699218245c9f1710875245bafcf487d26efeba3b4fe9e97656fd66b3af9e19d4e5a02078b5067ee48e44e3ab589bd3a5d9580a0db3fef842d53db643539aed8bc52b679511e94fcbd0e948d2d5187c36ab748fd08ec5241e75df83dda996f7fb5e8d666f4482bf67c69165394827f2f359de314d804c851730d10a5e98767d84d3fc837722fd717078e7f4e16d19650f93c7ef2e566a1e321ecd1385c5cc7fcc22fef450af85ad0e85b68ac02f7453602a955c0d214c4a801b1cea0de7a1f46a0fa38be62a97fff1c7ed16ca4620a68fa8ddd1db0953c591adef0b172f0a42fd59ee1a073160b1ce7ce406d0d7574bf1d358e4e858247998ae1b858cf068f35a271fae18833a1aae4d9fb56b4e8a77174a7db97eca6e005d3909722cdd115aac12bb6222af1815d14318ebe97e45b1ce97207dcae69e6ebbe9903f0425cc44b88bfc9d89f9ebfedaa241020dc7b27d95bb69b18c8957d009d58a26fa9ecf6ce8181b73bdee84037786a5c3f2be858a8e50f83d0dc1bbacc196fb7cddd19096a3e29edd25b87ead0b6f246881ea331cb1b1e8fad7d9543b5977d180e9590f1e8674e4cc0302af3081f1b32a583da050ffe110a8bab11e0f2c55e95922d154c6728b63dd222caa64119172426d7d9158abfaf8badf0036d458e81f501cce333fd2a872673270e238e047972eb713a5de1ec6a13cebfd3f86bf9d597d4ea79892dbc9d8e2eabb269d40819f754d8ae1869abb86e0e13a4b33035a94e3859a449b4ad309872075b12dd353d3c3bd509f9729eecd91cc43db08cd19abea32ccdf3c1bbc4862084a3ef3fcdbb9bc26f92692f602ee14fc24f9c22d069269d792eaef8db43e3d67d40fee17b75735eadbe0be83fe1ac74a0761b04e340225d6273037945d4423b0f6fbe7fb86aaf139afed3812342554fa5979d28498ffc0f24addc28f270456b2779cb9f0f8d0b08726855056f7d6da7ee6a7a0df9bec86a5bc680400cbb56f36016556c1a1895aa130fccbf06dc96647700be643704d6917833ebefc67630279a9705684e99ea7b28231a27fc1332a57ffa03bd0fc58441166dbca16fc01d5cf9b8943b9e5d4e9e948cabded99e9643bdff700004fe469a8ce75296bfd0d57e1a8aed8aa388246fc312b2a178ace9b6671c55e2984865719e3d722c380ec89ec24b1411f2ab744d91f25540808e9e9d0538d3113d3098f85981a5a7e2118a0f769c4275726536fe1c07b79cbe6e474185bdb14f1f6c7597378466ad02b56745a9da54b3bae6c8cd38fe5254791534f895d542266c06a19e26018f7e5acdbea4e8728fe25b568f98512a2c24c32c15b5968252a9862a6d6e215fd4f606fa69ae100f974a52348b3e049881556e036007f7fa4950089fff7a0055129a3a569da4a2713d15244f454521eb677b50b71123332da63d4ae868b936b768a9bc6464bf5b10bca6416cbc4540264595e546a837ff947d9c57ff33cc801dec69f7d8cf8879b7cc44ba64c426a9d396a878a522ad59cea8d5efa6e050348bd2c554ff105d12bf14c53e83ebc0162313d42495fb17915f2967ab8f2dd588779206db851e08e998e4afda1c5cc0f7a834f93ba36d59d55311661edcf4374746499e377ad03cb38443e74600ac16ef1b6f6c5cf40bd8e101995c6a074fe230e707cca0179ac8e2a44fb6787507eb47e9f1a84d91f2326b2bef730aff929901d8b9abc025a458abf709fb098a05d3975f0bcd05a1f78e64c5af3f2e78d9a01be62cd39cc7405f1dd5faa7d88d255a96cd5f1b6780053cc000cf7ce10a339b497df24b7b93e619982fc29325a50f4b3f471ddc5015c9a363d566d95a950f01bb68acf843cb05f46bb2944fa0cee338cf3bab8bea6b8358878d203011efad8a2f5b9427f1bdb8e5f0800c5ae64e691af2badc57cde8f22da2308a4518fec04af28a457cba2456b4995fc23c20ae1872ef21d51dd41260fda1bff72dd3d124ff198ac6ac02ab3f2361db7c03a723877bf2d87f42efca085e8eee354a657f07a81fd5c96e55ae2d28096a7d6c40f3aea0430b5dcd610c81dc33015be5460e4bc9b92e6865426755bcba3385ff245c9a342f2eb20e47a1ce3b093c21dd0342746de0f203e07f654f3c5324e978904a448248eec2738288d1947de5a0fc73a51e9d10fd3f0dfbbf47cd5a7c609d0b81624fd5d892f8eb0572881dc498ff8c5705f090d2d12e1421b692156c23ec79151a21afeaa90cf029cc2d40cdc60bd9106b957178744748c1199ed9c3e583183607451da6a891a48f8bdd32795b193e2a0a56766c7b794ae5df0bc7c5a090a0c876c1f8aad658ef336b6ee0bcdc43b6b4603b9e6a80485c172166c3581e0ba77860e46bd74312cb21062290e39405036caaccf3f721cf3084f7454671fa5e7628e46608a44f8a674d9aee8aebc231b1d2dfb8f31e28ee496d9029f000a33fc6c19c4bc2009b2048fd1594f80937e3eaef84863d6613f57db96d45ebc64b11451f55eb95db46b50e8b18b71da56e9dd6194f8150470a46fa7d93180079d6991a7ed02e5c920a3fff2ad450db213c27e218b560e5b95fdca7fc85cba98a761b753f576944639d2d08c6b7c75c01f65931f6d45d1356f6c6940a31dcddded774773c49ab6878e11d8b94642a0034ff31cbeb8fe68ba32a3cb4570edda3c90651d0a30a5cc08d073e3715e70d02dd251ecc25bdb87116371dd1ea30e4159f820742f4b4437aff05468e8757e8d85a12f30459b617015a37adfdc8251072d4fa3c8779895dac57336ba10da8cc0a2f9dd502c3be49eff2861808eab4ed4141a24135ce9ed68c3b378927ee28c227e15a31d79204e9b07e3e806ec0cd51ff3c1d14707449aebe8121abc81efc35e643efe63773e8e82b9370ceb67da3a1c354d41fc483da2b0890438dba65c8114cb8563b8ee3655be78994ccaf6850efe4409aa7adb24eeaf8af2693ffd6176b68437eace3f3d94e89ec1d9e1352a42d1128022e3c5f2358abfc18d8dccc72ea89b161fbe698739102c31975cd046eabf85876d5ffcf2173e5e2a18fdb75a4bd848425550a7ac69c4dee7805a58b549b6e7e8540a5801681869035368b8111e5bd2ba63ed488b0497c365d250c324f8169e07b4ea764f85d5f1100872ee27ad433a3083dd671b1793a57824312573ce2f2e81b78498d6d5b4d63dccecaf9874072842f50cf9758232c625f96f7b261ec2b2ef92640abfa1ec50df499c94f6a17b3ef36e68968fea5e91d7f968e0ca70b138e612750c84a2db01cf597ca9c67b8f47dae63bf9e4558e14ee419761ad2a4d3f37789b181afe825a34866dfe7b811e5fb03781ed843d09b34983ca157cbfaf21a09eb0fbc079eb92110ddc89cf5c99dcffbf299a81f7db580c64f74ccce8aab6f07ef53afe640e4256e5f9eec751579bd64fa8d998e957deb2169cb1928112b5cd62ff400781ac00d2e07f106573c9931ee0533a93afab43f232ffdda5334c96e491bb92c85b94fd288dc3de14ca02cddf93771834a12bda77f9192335300e4fa7304e1d0998deede1c6b2ac0741e8fc2fa17230cb8f74def56e2c321f90a4d7e72a758d95abe7b34eb57250d011c8363cbbc897b5bb2f5268c881f3dc0543ea0e62477c53ddf2daf6517fb731957cd7b19a917db1cbab2fd6a8646aaff0d19af635df674dba6539e3996e71ea3f66bf55073b8ca07cb0dac2d784438353ccf198c323ee1d8d6086178e05a936d58805c06b3b866d377d82796de18f5c63d6c6a7781e6c6c5b6a72571a42ad9edcf3e0c7f4c18c2cf0d587ba7207d13abd9d1d6d19942d1c852d91a94ada0d586f01e5a6dac45d9654733451a3570b99a33b847e40676ef2c67816290676f11284a3e18e77d4e88d9e38df51736eb8f6ad09d9f081995e3c96350be9885135f9ac41d724a0e3b997e32b2cadf6d5b8fe8501cbffd6ea4e00398264fe4b507879d5736f22b7770a7da6ba30ae6615b11d7761ed3d077353b7bc947cf7115f6ecb74ec5449fe4ed6084a41a8ffe8911e29ee10c94d708de8c741fc81a3aa2571ce98b3dee4ef181a1feb61338a725b27322392b5b6e13fd96cf67985ab269b96473b9c0c388fad21fcb55ee331c4c371bbc70a45a8fcf3277a1837481c338079ef609b5742afe726760acf528935abe450ddf897ac6ad95194e87434732e6912bbd3520d2017b8387d27643ba721d4f3b67d7c86d9bf110eb1de0741aad68a229c12e3fc559edf01f5eebf8d958de1b5817e4eaf3e1b4074676f82df5662726ba25574fca658c0b06e54dc9397ba0e4b9e0581b49393376a8c98e856217963d2f7d1d55226a0123817a7b3ee7ca6f43814d0feb76b294f2b0bcfae1822797a50a7020747a27906ad06480984390a238b9700bd596adc61724459106ed1278204503d9256b59229f5d7ff408c705878d261833526eb47fe12be41ba6272458ea286e99ed147d8488ed2618c13f838e8e3285db576c36e00abc3f60a8b78ff8b8547554daea8b8c23c7110089331a76a10c255d73a277c7dc44fbe864a24f53b2128e5cb08008ac5489c1ff379317f224a914c0c84cf65e58f7fac9191cb6bb33429ea144a397ef65339083642a7544be623a8f12f858e1d5ab3222798cb254ce27a9c58b2e901d63e000d226db201f2aae9b8466b576ceb2d06f33344ec21aff6f9009f19eb41b11804f79eb0dfec6187a6c7429a22f8a82e9665d8108fd13c78868d27c77138be40878d36fdb57bf215ede4df5212de2e782ae2b219a5988d1aacd1a271f6dd83474b15ad5cca854cacaac2acf2c8d41ec69503d1d6e6c36da0bb37b443af1215d3d4f31bd643aa9745efa542e58c781d994d1b5c796f77150d33549dae20488f5c22d9b8c000ea37c79bf0baa26a772f2cc6062d632e1141e4e7ad72cbeefb3eb61d132776c834c467bed2f3792e4a8c6cc6bb66b09a451bcb39043fe620fb7193de20c9532844e845fc0f2d848218af184f38752d4a13f3e0360191dcc1f49574670a3cc01d28e9033444df565102c0322981a2c3c759711dcce3f911a6745ff234b83e61f73117a47042d06177459d789895aa4e7c5050a02a92aa9f0d119b57b690ce37aa3827efd604f8130ce3ccc485d8a6184e802543dd07fde87a6a6854ec411fc60232158cb4624813e465efbeee53789d65f41a64482790ba674bc137075548c11ce2a6d65516d665d2c8c9713e063930a546c4bd4c055ed88a9953b13ec9710984a201a5df472ba1cc7230ad12cf27d84579d70f4cf129b0da5c5980e01b105ef8e4683181fd6bc65905b8eac8a7295799197a301e4eaaf2780b08eb4ad6611ee5b3a9e4a584f086c8e90e0e9722790d4bd99dff3101eb72bc0bfbd32bcca78b17147aa3ebd4f59d7b8d97018f3af0424086e9697b03263f8bdd7f5e0d352805100a559107505815d4d512c79d55f0d4c247bbc2b6e68babcc3ff03116c387698673f32da12776ea8b091354455d9ef0bddedc3735ae2e135eacfe7f0425d60f45110c1512d1d591a4b533fbaf44db849b544bbbcf89511dce59a503a58d31b36fc4853e4c563845e1e37aaa0107a5641fa5ce047ebc28fdddf134e6bba1bd0b87a12d42ae0ed0ffe1cbf1ec9a7d44caa84b43e9a434e0f5207673fcfb216188b8c566b43c52398c288d405851ddbe4ac2cf426fcd2751d1a264b6a29ab5c336a728ef0774b849706c13143226433c998e34266275e2f3b07d85b8bd2a8f01e07bfe186e3502f934e25189199104dd165045714954df93e1d9e746f1889a9fa457ae475ab9cba5ee192acf48448bc8f95684505dd873ef7ca7504a813580e9d12c94f9019136f43ddc37555ef3a1d0b5d5ee0bc54b6630be919442adaca4acecd63cf80142434c1cc728e64d68b3adb16a308ec3626da01ab4a09409dcf83104fc18c0236a22539dceba5953d67e3900a21d0558b259171c7147658e40ccd041314a27d2972f5ec4e0f6099dfd4033adef2ec80073c162a464c104f4df58a737b7cf8ee17fc37fe67432a605c6972a4f68508fe0f782292ecaff230be98507e9fa6cc2f1b5b3be8e42a87332069489ca88d5732b468186d27929c64dde8cfd66bbea7b69cd44f831e2e361cd828bbcdb2b2e6e5b4e0d49d761f51361de84a1608f0196e19c2aabac94045fd2b1d614aaf</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出计算机组成原理（十一）</title>
    <url>/posts/969736c0.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="7fa652499358267a943c2fb4f8b51f1e21a6562477836c4b7ebb523e05e5a80a">fb26124e0d85f363a66baed35993e1a0948953cce3d484fb31660455b92ccb286ba4467b12dd2afdc0f8bd795964707216933c479f00faf5302337078027ef66e68c754bf0232403ae44399aa06a2cad741400e24549082709cdee4a1c1e38f29d8bb6993c43448bafc4543d636ea5bfe35062ad225c74a80f232ba51d9af45093f5220e616be2d57e02341ffad661bef2886dba249b54377d8b3961fd62e8e7033554e6a1a85b429bcdccd8e910eaca84c8e447cedd760cd76a16c64ec7f94ad050108487716cc544f1ca685285a120a1c590efd559bdca18a90707fae890221e2912f079f089d10fb816e69e85944586941b721161d200273028ce2f3cb2d1a6a47461dcfac58b4612622383de37911e7101936179b0ecfeb18f3600111afc775a9e1f79696dae92585891ef4dfac122f76422fbd003379d1ddae48eca600519f09513d510cc3cf1b57eb77f5c7760071270a8768577f1107a4246324c0c5a4fdad233c5a8a38563c5f0e74105b498bed8b8dbbdce7ee95be3994fb9ba342cc2c55dc3fc0c887f7b93f27a49ad87eba076441b59d8910cedf9a74fecd956397c7d5c59a90603573c9051b192bae6852eb2011286ae203957bb199adf7910e56035bc90c54930a031431f1dfbb4842c845e002e074023e2b009531995259e7d88777b3f2d085c59f0e8a075c4c9041b2d4a8ec4d35df1d093382360989f5931b6abacc9ae90b3f3af93e61bfc86afc1dad128d1f501bb8b305ee46d63b28f2e5696620a551a0b9e8f0f819890935e58e3f3fa54e799197a8e9af0a2da265c034a873b31b5cb8c47b1e0b7191c9e1496735ae48c8e6b0665abd217c760cd80a2593deeb7913551c80c8cc24eeadd23648fb0bca3dfd5176f45edd820c2375d2196d26d68592c725be12bb879b661e0e8b512f3846371f7b380b5947c64ff8f30312bd9dcbcf40866301cac5e4562e2ff20f0d9f88a9cbad250dbbb8668ec30445ae7fd588ce28a97992a2dd759bf83135b00f51c14759d6fcaa656d250e93dbdbb280fcc08e5a1069301e00a7ce3ce4f3c0259f3255aa52c23a772909bcc7ad265584468bff5478bc5788a740456eee533d3a69593ee422bf787e601b6a9fe48834be8d278011b3291cf54d04e1e6d385f570765f1eb18babb7f78f75636b78c21015c6360a4b61b98ee2d443ed385bbd65d948ee7d5f313ac40a8a9df14706fc34cad5d3c81689accc2b172cbe7cc10bedad257c59571596d0767af08117561b33caca245d256e044890142a82d998f69c93e0d2e33a0b28f801509e15bb6c0626f2d951eed9f461203ff822d25d863067d39f014b680c07492dc243eb950b30da22496c3d3d34eb9cd52255ddd809aa155fb7d29863a06bd29f35ab461a11998596aef858fb70c6378b794ca07fe9d23050f46e605a03e88502e0d46d49f6551713621f646720bbed45c1a54ab358772b7298a9fa2db85a5a8431cade9fe61aa43271eb6d3a7fc8dbee2ed3f4c765f13e1b98051e7492c2f3f185f1035758149965e1ce779ce7dcea7c801faae7d42cf5225e48cf26df21b6c3c23b5b1084db81de35d51f920d770778753b408cffd4df63a55bc8434fcfb5cc092a19ce829b77cb68b4fce8c1504e1ece36f5462de920f9054b8036bc0ea7ead17b871a33b8b231d260c45651f486141e31913e0b3e4e6692939ea05e9b80922eecc9228cc3fc0c6d7ee86ab9713fbeb61c1cca74857d517541aa3bf03ce83603bc1f60a3be945877c66fb7122adfc687b19a8618f6ac4f07a8238596595a6b783e6158df73a2a6387110a815e2139f80c2ac6fb6ace42171f46685d337a9e10d42b48dbf7fda63d73c07252d98181f445b5118fd09e88a61434924b22a4bc00fa7472b17207527142923ca64bd4065fb868cf5254abec81ca02655c9428385795920633a1494a8f6120b3f7f3c00e7c5819837a991721d4fbe4ca0f7896e78831c47df0b4fcefd532783b96142bd0851dc7cd617d54a532f3299254897227bb23acd0ca9a1ff3b1cf5bd6a26460da30aaff4fa147d1b384df6d737aa91b2d2c29bf3991afbfd98c151e6b2d17533557401c85f94190f95a070698dcd7b5b85ff27e4c369308849a8ee83d33a85cac0ea15eb2c4d1d86fdd0698047a9cb55a47df8d696e9c38ec183c26225fd7b7c2d0b5b4b920161809b0569d7ad02a2af4ad3b6d56d95151d3c832f0292d4a177de1e50b8476c3d7ad3fe615209f4e627bc8c3e74eff974cfce6b0b42f8ac0f393af050f724dbee0abb2bc64868547d5473e483ecbd04740156cd1c2cccf566f34f6bffd7583580bd83766b2d2280c085d34012e19eb11bb1169b890fb2431849b1d9302b82a7eaa2ebe048df38b949a3812a3c40f3ce178693ffd83284cff8cd0ba86288c675932435cb5cba599332ae5dc1276b34c041bc4a67592e7f6140e08a38423b74559514079576e4a5e81630a12d15f7a2b1269333480f0b2861490f96adef507014771d640a09f54add5c93dd3e2c24f4774f0249790264392c92fd4b5787df6c1559e98f569aba477c51e59c3e2c25950ca86876440e23a8afcf30eeafc0d2102d999e4c2b3c54253e52a00b460c1840c2df710056938f0826a9bb909f99a61dadd7cb64878cdc84a11234e9e9629e4b9146b26e4d42e4612a883c25655da02ead9978727caba77026dd80b3eaf0c65afa961b9e09978858da2fad1459ededd315124157c77dd932cb3e975af52ef84e2b3ba1833e3c5ec46b7e75809a6435bff65918f910c33baf8f3e01e1d7a8656bb5cfe7e61e2197066609453051f4ce20b500c118a986a35a8caacc70a8d2701464fffb8ede28e7161addb791506a1dcb8c90e090578235988750c8768d82f23324a93852c5777fdaf89b85a93460fa9b808d3462536d2ab27e6178031a40906042c139253480424b24ec28c07de32a8bbfb153bb58478de6fd158311b10c20c816f2b67e10ce6be62eb9100f29b4261b53fe86c5f0aeeade14af37b0d53b90179463cd228d6ba0811620a62d0ee46a2dc7803fdba9c714e130273203dd4582743de79383197311e7ce79209f45ee54777f7661fa8282e3f6fb8ab49fdfb8d0092bd58ded921a42e40ae9a2b285711d077157eb0f122ea6c34249a817a86a98498fd0bcf11adad1a4efbd2ca42bdd319e1a18737812979877c1485dcb67d0777a7c70026a61178facb1e56b5ce96b0cc9a8e1f3a4306d38867850ca1127e47720291160344ae6673420b68806b78e494346595082ccdef1a11d2fa287bad4d48b452e742671d1fae014b76cd41980676f772275e2f23a56edbde81b57dd7a0b59494d91283e8a211bac66371cf51eaff9c0150ed86c20faecb20c248ae765e25ab076a89c035ebc6d3db37753bebedd51288843f8a64337f6a99b7ccfed088e990e1bf7e092d05e4c6da8f82d030aeec0d0a0a176fc0b1e5cbf57f10a30cef56477b163932bf37ad8199589826dedd45dea43d58b68752ff06839a3cdf10007c0ac600406c14dd90b47b4ec7cf1ed1c4f1fe182f7a9faa100c34289751510473664f22d41ad147ccb65d18510cc5f12a561abc094b36b65af6765c75d8479a4526e43c6ea0a5a1d9a936f0f4a987db578ccbd46ac982661cdf04eb880fcdc05259f5a230920500574e9243a893988350add6da9178569c674d5584398049d6e62d99f920480740d498e26829875222b55758f56ae93067ac34f50f510e535cbf26e9e2a68fd8594c22014a519699f7f8b8c5350db65739e2d55ef8cd13b0ecc2eadd99195ad6585bf2518282ec44dd7052eb738cd4ddf1470f2a3751fc1e2fa26319aafe10b1933869bfaad85e1cb1877e82148d66967e10d488a3f1da1d4a7d3f79edada7fdea0932d19d89a9a06129e88ceb61873aae43e7ab4b3ad785bd544aaca2d46d76d8058c5599114fafdb95fd939e4ca0051a2885515ac5c781d6149a527f46991a327d1f765a41f67edab3067f0abc66c64df525218ed6d126ea380df467ff3b525b3d68b9e7e43cb010b472c6d2f2facb162f1f830605adf1e61e111e2e5a48220d5a5bd5b1866782ed058c3e38e4f0e05c19445f5e6b061d1d1e63d650e687cdcf61ecbdb538f4f20b30a74a6241aa7f20cecdadc461292c5f075a463b768e1ad36b57160b9546e026a3184fc9fa24a9783ccae5274ed41806e861d0f05a3e84c563a887db7455715956c59bf48e7731d712e64f139e9b59aad054a21ee8cccc40db98d042e4c3b4fb6f68b674743bf68f6f8804c1bef669f1eb506a9aeb0bb29e35b33da206535040ce1885c64b631d021204060f41d4b75f4f61dcb1b3e2066fef7222810b14e710085ac66489ac2fded8bbc4b60ae549268bff322e66342952f892306343006691a4b80716d108b34127e5206bc3acd30793810794129e6fd375848431af20be612905370f8981e48abe35247594b6e968999f1d657df5cbaec6f83ffedae84d26049e6ca5383064269bf13ba96cbc6bc316349448da3da43896d9998dccb85bd9993df41d60fadcac5556f1109692757d68ade7351c8dc7d07c6b100109a561fae5a14dac48d1cd87e917a090c21f025586a9f6fe9a8e43021776771ccf2f816e65a922eac169092075624bc0b6921a5c9601f2ec71c19bdb25d15cd0e5931b35ed2e2d5996610057571e3f0230320cb3cdd149a8a1c4e2227b1f005842034b3c20289b9c6bf9ccedf74efa1544c0ad7e65f999a7a652de60667c1e51e0fd170cb9936a886778d30102a4c62db4e4a7e4120a54ebbf280dc6158311e047989022e3abf6c4bb9d15b6752ea31764102889fcc49f2135ca44ecb432ebf92f3da9e20e6e0904d36cf08de73894e144b6704ec0d0d00f8f9b7554c65a7068c5f8ca9e0ab65eafbf789a301dda51d2e20b7d7a9b903f434cb889dfa7abf4d1088d148a97866d6bfa48fac0725d4c05b5cb1078f5dc7a0d71cd783e573772af0305e8f7df19272900ea687e4d537f7e2780d655e05009dac062e5df6396a093b1e17a5e4af6494446d62c1f4c4c7b362f06a44614cd5e15616e55340780e981d6cd0e156d597fab9ca0c441539a1b65352bff68a1c44509c51cd48887212a114f272cadd958d3830a26ad1cf1421c62a51c87050a2fc9d42f4435f80b13503518f9b9e08dcee35bfac64fd32aa868ab20493604b135254cb30362799242f9d982b9b09feb1ebdb67288824aadcf8d270f3eb255798d166f1f8e15a5804c185eba23b86636554b28bfd3f12e762f99e1e1254b4cf1a34a74bfb2104f055e9dfb372694e708dcb42744bd0e800af3aeeeaa32967662ebcf71de573c6eb7b3bb68eccd623c0a51b945802c6ced7f1b5dc02b1e3484267ecafa1acc9ebc4864f8f8b1f3c720385b1dd80c4333d93745df3f96ea76fb58563b7b42b31a27348b0c1890f6c25ae39e52c3a40475e2a70efbfe81b3fb78468a2006e166540af0f1d967005f3ac94fc7a1f18278f293b3809d09035c76934994fed93bc4f42163a03be77a8bc145c3395384b46ad2d80fa4fb31290e6ac5c09909d1f747d8bbf023e5886f8263c8294874f1dba48a2c7273a09ac17d173e9300782e731c5c58a6790bc416d5f23c671c16dc19543cec7dcc3b019e4b514caab00d308504bc1e2ee96804470782c95985f5f3fb41b106e96f24537adfb98bd4bcb352ab4bd72713614d5149b8dc323db6d1ae2374898273d97a9568aaceff670ee7eb7ce4200a94789b3942a18efa5b3473351a4812ef4df8d23384c4f67915d51d4ec01a607ceca9987d84e638effe6d47d056d0c8fde03509d8d806ec6614d2585fac5e6186114ef01d0df826e39d9b0f77d9b585a215da0002beccbf1e097d5b42d54df4672ffa45e4dc20943c00c73d7b1fd010954c096b78ff7cda1756a5e4ef54a44641a8a2a71d2d2b4df329019d64a0f70e8ca305afa2b05d0eb82cf7f5e1c6936961caa79a9b3ac7f35ebb42e30ff91ec924771901da7afdfe964ff4699c9d6e62f651f3a6edddbb8dbf4d3fee581e2376be39db0dd6a01ddb02be646a51511b5f8cccbf02bb704508aca8e4265c01f19e28b32d20e4a3c0baa7fdd824535b632a4dd36e93605fd825406cc55fcc2b914df84f29551d24892b4cbf6358606973bd9fd3ac27558723ba46854c22fe70c11c172b47ec6923072e0790bb63fd515d829dbe9b2d2312be21f4a277e6e8eeeca720c300b9ccbb42ead1b5c6a535289374d22352feb9ae222fa9c86024519366fd5bbc3e5b6b5764a6844d2abf37d48601a45a1809a074a68304f8f07971bd14b70f580ba4282ad0ce706b0907ebd17144fc42259d6979e6b76fbefe5f0eb6ff1f0cb4bf5e479a1605859e20404db3057f580e400e25df5460107e6759ac6117bcd752f31b92f5a626ad6708c590b4a8baa48efd6ef6c1917a631d15e5aab404c4c90efb7d0cd202f18e068dbf8b4d815da64ca87bbc15acc916423580268b66666510685d48bba0bbdded51decdd9428c422900b48ac90eb94efc674bbf025a2914cc5c5b59312c8611e71e5aa779b9102e51117c7bf6eeb2a068538f35eb890cc4aea5333eca1af4b015421a8023bb33528cf6a028c6292c07acba79402eb567a4a4c0bd1d9de21047d624d2e71c33ced08132cca8edad41731a18b6d85d315bc271bda7f24a2435b81d0d44ccd890a44b17c2f1be0230e70648e72fc3c70786fc1e0f2d077b4813709bb7348d853b2368e2c9feab9c0ed8c99362ff17ed51a122ae12ecd2c744525822e6f0eb22aefc21101d6103609c12a56cf2102bc0de9ddd83d2da2616443347097929c03c9dd48a139393ff160b8163430a59928c027326c74bc9bb6eee6e100b870b88b391c2950b04c9935751bfdb43b3fa85192635a0c490d35f52887091e714e6f31138f871e3af311b8c173c1b62c7f5304e78e3481e625386ab622ac78c2005bfa6a9fb17a018e8c2989134f54d7504c9557e2f583dfb5b8924457f66be5de2b4ee1307f3acc5e9d645739910ffa634dbd5b3bafe99a32814aa64750b56c177c986c8a5749412496f06c4e34a51a6b455fdf0afb14a2442beaaff5e9f3494f897c6144d66dd2d10daf4bdde9dfd77f389ac487c6b051179ae7d11948cc1e2b572fa3b1fe146feed77056906e308fe15ee9719dc4b99f4cbb3303a9135bec5f63df7b9601d00fc5067f3b0e976d17d1824dac07be48742976c9dfbc2c5349f790c66a8a13482dc898609ec2452ee897f2ffd92ab61165e4942de49678e3ef05a7e5e5cf73d589269137c5124bc450d2c049bee0b749a0dc884e9b9590970165eb94f622c6d6a7ee6d1197f5efff966110f2c9e3f8cb33c38b6dc56a3aacdfae110f6cda7d3b489929fb7a32081581554849d4ae41e3e527c9fa73ad8c97522a68b5b91011aa07c9d5c805d6a5dbe4544a87f47038945ba0be63792779f2b432e0a0e2d9ae3924151201e95843edf001340ff44ad9d36c9c37bd1ade26a5d415afbf56593296e5d7110e79db55c4baf917cf97b22d9e399ed1bf41cdc930473be6dbba8616bd6d427ae11b70e6b792a6d0a3314cbc1ef777c0c9beebf9469366fe3449c1948d6bc05c18a8bf855779dd3d328eb3ae68003e795ade405e2bb026c570ffa3bc259e639d1b3e61c65f5bd11239f52afdbe5f962eb5854ba5d9c1d436a5dd90a29b2082353a1423a601cb979acad570fb0b4483a59ef32f2c6c7ba1a9944b3d48863efd23e61ca8028d841adffe0fce302a164196ba4673621813b56ac95813f80bd3a298b28b4c6da793e0105a619b9e2feb9b6cc99d7214f5b303e6d75bdb5a5cffb54c734a92a987de311d0d02207e61f39eff5960de61f65f16051babc5a6e487fa8d1e0e3f0828782bc2984113763bad2f2369baaaefe979901482d7a796a64fc467867f6b0710c3ea96029c692441ec3775751c06262309f6eb3faa5b040e706b620fb9b7a3e0d057be8a40c4856d90631f907057d9e78dae63c856bbfb6dfd62825dfb4e14ee2e15e38966efd2661d8ade9ff9a4fcd14ee38ead7335585a07413c1fb6af07f45562ead5286babff2379a0bfaa03f036f4ed0bcc23150d9eb9d24d3250c109fe41b0b217e701bb23a65f780b1b9462308aa7407975ac6a28e7c826b6eae03a66a2289d7c07132842a028b51869a20e13a2b232f31339ece2c423264daa5d91ab9467959e2fccaf4163178ceb161c16f72ccd7f7345aa8a753e5c520f1e9dc464508958492a3feef8a37f3a72c5fbe053f0b7167daccfb0f46d202285c4ed54855a824bbf226af5ddbe1ccd790d70f9b282a823fabf44ac345da1290e1fb35bdf83d93a1456d7651f273ab539a48bde79818d576fb72de0bf2243da603bc524bfdc4439fb07d5090dc623b6016e5fd2bb820edf40d6eb61b1c0eedafae89246202de8ecc3a3f5f00919be4bbff58c05fa2348a42d5ab221239b6b7a0575494adc7b8f118fddc622f25dc2f71111b2d43b074aace73751614e5b2a21896355abb951d3dc2df7963599bad3c4e01b6df94395777aba4816c0dc7bc86fd853b52c9c32e0832481979cd771a311ef243e8210e59d27d0e7205cde70cd3e36cc38ce648aa5ed012c2336ca6a5bb3ea24675fe2b1ba6c825f3f7da21c8fb294b3f81698fb7520a95acbd779afe890718c4b07f026c34b0ac14013a25b4cfd67e6533612733586340f7f9b7944df9154fd4894995e48c51cf1a3ae3e1ac293539641b74d0974fbe97ecceebcd96d2b1844b8a1c1ea8a07bc005e3186778f45d10e9f6e6beb2dc796f1d7a5ffd8b4b0a70786545a040c9f1d4f5addfb03d5c4506e928e1c2da9fe2350ae293ad57eacf19c65f6d63eb656378fa3cf21155be35373fa5c057e01284a1c7555da6c20cd15c1211a8882282def1e349b3aae25119bfd737d215ce06af11e78aab15780b72920de4971e38922eabc1211d28e15083a7aa214b77fde37b1896e708204457a69840d78af7aaad8cef5d6490546ad8e7cf3fb4e30dd64d26166d49961d126f6d007b8cd5f0d0207689066d4da592c6cf0baf8e4b73812ce282f48e915cf9e39f32f6f756de996379cf46760f176ae006271ce27d3b0a7d6ed3176c70171b3f9c3f97afe1a012571ad0fed87b9286f50a3c806be5993dc28315e4dae278947afaeb940bc999344577b54a048d3b00d0a793680e8278e7de0d71043721f44fec0aa00f2d64c551fd02d33d902e49d87d569af0188c484ccda7a29c95fd65a68dba931256f15c2e919c2959ea3d4e82ae6a716f3e9e3c92a58d228b97f444f7b1b47f2c1b13e7181ee0fdb0bd7eed2c01674322db8ef70707db3031bd220c682bbf15a7aecf18cfea1fd79e3b817bc07e067c08d5ce7730c7d506ed8e084a3e779d19a1eaaa328b5686f4417b00ffd6d3758e74456f5bb1e61f6a36dfa665cc3bc75277a5a31478c29172636330350b6df845406d09ad42677fd56705f78615b8ee1a2062b37299277b40ab0b03319ba069779261f6e2c1f8bdbc74a90374310932ff4a5cdaadc650ac46bc4ffbe803f6410876eb937d75b85450f523213445e37632fdeead638c9da062a8768153332da8ae26c4da55d06e9b87455b886305bc3b8314ae6b89d0553466f20aa191dc1507d11584e015635d6a723682c309aa1bc8c9f56d5f4633a1fb3b7001b06a7df0e92d68099da27df73d5777354d874bbebedc3cba131434ff702e54d4063fe08ea41457ba697268c61f89ea8e49dd04118f206bd2dcbf9cf054eb47396693110c2319c38dc0a8cb4f1d3dabb4d235b9f9f8860aa3017e7cc2e96c1b0c7af4be3cf605ecd72f25e9b9b0d25a560fff68e52f07d94538f336656e2f6afe4ebc85654d30b134df1da0c669d03d8d95d7b43b3f4debd95875404389597aebf0c3fdd90d175e7f988d209bc04b5ece83675ac7f8350c18d33a88b0e66587be6d588dc86188fde8754d2e32a49d786a7eb3dbed675233f3493696db655d6ef84cd58973e841c521b26a19ddd4847ffb11c34278081799cad2b989e335ebde9d4a9087805de8200e42a3aa980adb9d0915aeadf682aec892343ef0d32d864aed807e68ca7150a82b7ae5413307ea589ff3956b00f46323abb08f1c7b382b7bf60a61acb212aae89b29052060f9a66d6ef687f51a660df8f42cc967697ba2caca719c49abd7bbb598fac2b96e157b02f4d717a26ad1db046a01324879fd6b3334fe810789771f45a995335edbcc50e9a3d657535a763cec1df3ba6814cbafeadcb66a6c31cc34a131dda4bd6049cdd1f6399fce369a6188885bd79dbe776400f09bbcd49c3cf748ba3625652eed1fc1366728276eadb10dd235c5ad8ac3702e534e2f36401c501d397f5213f7ad4027e452e33754e601d3a1d03986c46f9873003bced65829ccffa489553b4b884ac8f3cd88ecae932fec0a7e8059e874e82e7e4d2874e90abde902489937313f10c832fa0e28d367855ed8422a47a8f0f9175bfe47e927b52cdc4eee8cea04cee4ff7950f32c1e368f65ce5daeba8d9f7b8cd32e8d2d3c7bb8898337abeb4bf2d998a7e56da1625377920102c32a85ce8ee2cb9e00567ddd8ee69567f7bfdb633b3db705c80f636d576b596af96003d126d2ec008fce67e964b80cff3af19bf45362139c0994e0b321fa954bb80bad485a33dcee9eba1d3f7ead963bfc7a05ba3918c8a560290b07e5ef14ac18d0a7fd5a2a6a8223cc76308882c0a6656c4421b47fb3a295b36ae639ba1848b22ec1ee04d850ddf8582a9af98e9bb26388fabc1819ea81b82aa6661f0ef318a8f99073a64b76aa4abbd194459a39b404f20d44d99db02956c8c374ad04971f654b9cdfff334acd324aa2f7711b6fafc95b38759cf27d52e3b36f4b6aa31ee619ee3b807d900d659b905915e6e612c3eb705e7f258c4ad220cba12ce6fc186346b28e4966ef6ff5b4886d0fddbd4f38703c2598215ad8593993e398ceb4b6031f48e640a9b75b21bc8abad55112989f3045452824020cedf8cebdb2613e3d965f2a7be9381fb80ffa141226de67f1ec0c67b695804428a12716eb76baf832f46eb47e5c162313de466634506ebb70452e8e9f221391382046228488d363e87edc326ac8ef632f25f754c50430e7ba95d53969567b457d4911c3047d64dc20d28f84e0c74484d9b4a7fe103d6b3332937ab7db26d2a545494854df703f829adc4d77a59ec6041c85cfb8f6b731f0e10e3923d6491b0e80c180530355208e372d31b2141e903997d9201145b9751b183f48d3cbf242417feda8c33dd4f51af3cbf1716184ea67ee19cc25eb4ccd9e3dc220628a7be077283ac82929e7224c363cff0f50f7cafbda6ba1d8d118f6f7d376a1c6e5bb98b22790d37ccdf3be1ff94509d688d9ad4bdc5dd41549b94b9726fa7e43899a0e69aa4ce1b8051060550aafdabdb069105fb654aeb63c20e5216493f43f2ed26e116cda3ebfe452ba6cef840a0db06005688cb46f7a7f67783d87b0291b2ca4ccdf2268257ccc6ea360dd312419d2541f3f9633a0c28198c448e004dc9041b565f74bbc6035a4d2755ceb8735ad9b89fba2c6c36088701a74cd0844e48c3a1a7367c7ad6521ca899c363d663247ca9b8938fe1a0cb4062a2656d9f4d61c0858331a5e5bef6353d2465bdb1642fc38207eff3610f77f1cfb2d4ed5954cbf5c001491ca2c4c31265a9ef312c6ea8dcda6231567476cedfc3719d52bd3e5e38e86f1790aa8cbc07cfdca7019bd223c6745d6c478cdb0309453bfa8eee05a8dcb27e60819a2c895c53d8c0f0a896b5f735f60f63b220d653f9d18a56a8314b84dcb031d99a8102ec5e078bef82898afdc72006f903d30dff0202089dc79c68c03f35cb8990243707faf7b981b44dd6c0e2ca2d049742ac87be38290771a03b5cadb64d7db36f0c325fdea2469a148ca56d73f722fa62c57abd463794a5cdd3033dae858dde69e7e5909401c6f20e33b67dbb0c39315f8851a605ac73933691c5f3632e6ab750bd4b102949f7ef7fcb407e241cf90c2f1f3470f68e77975e4aa4d5b1ba517a8a18d9647005a11facd34cb0562c95e77a2114ce8c10b8b7d74d039553adbfa0d095a20e2d038d13f111c6344681f7eb369c9ba4bf0072dc9f94a8df062c63cfb096a7d39b0b15432ea26da5d4e4ddb4e32aab33a437ed5aba61e3295976f23a47d4672986c67d1c6e8099f4edf6e8b91aa182e3488aebc85c8265b3b76f330dea200feaf9c03aea8e10d3446b7becca2113fe4bce13fe2c463b0ab410ce8dd9fdf7fe972a3c7bd400d1bef6b4feb1cad6b38b2b3eaeb0213999cc7d6e9da0039cf2c7998c66d45a9f8fbd497276473ec30b0bc8a2b2d11f277a787f55bb8aee1973ed765ba9e5c39f2709a7810f50ea0a5b6a5d06dd1830fbee3fb33a96c16abd4cacf425aca1ae6f4a181cba83c47bee521bdd545219c8dfbd412fab492b5b40c6b383faa4067802a4850c1acfb688f40147a915aa0881f5778c961f749928df78bf99a40b9f4c5e859884f74e43f662874d1a7ee9e9a58ae61bc9fcb4b3e15c4cd3861940ade861a68de95fc8cf4bdbb9176b3b9f36a6d81a15d625b488f41c2197d3b88162a469600fb3d687a61ae4e4e0bca797b602747cc50359e69560a18af02dd9e45669ba27747646c0ecf4fce95a1191972e7bac1d95ef691b0b7362956d863dc9e074c471ad91ee21ea5580cad55ced4b4596d35d7cca1c6eca2d2aea03738052ceaac451946108eddd2faa6ca6ef7c223f76f89548ac74f346948baaae91f15c1b399094aa52a19a3f63445a6f32d9d487e694315944dead95dd01423776818d4df5aa2a38aa1c5b72c6502df18b8cd79894fd20828fdc646b76f845795a3564b6e16a5d7fc742e5afeed4eab9b0d187141a7957a458ebed48193b51e2f7c244c16b1bc50a93077693a9e22db8082c8c51c572325ce7e830c76d85860898174e168345207e5e261bef6ba3f823cddbfc8cc9bb8ad78ff32e5ebbcfd4a04b8e008541bc41adf3c5f61b9d2693c71aa167147a39a8e7de0de6aa70a85e7149958d07af691628e2980dfb9261a964ab1d317ba3befee78f04311d7313b7497bcb67e0c1baa037817c90f534557e9d007e89f09090f7afcea4a449b9145d268c7def9c4ef4f591e517af4f01105671de9d460364ddbe6a68bb862bb6a8017c12e4f07acdaeeabc8b1c0bc6c5a409014e2dd1ae7480275966966b8d6fe208409c320c2341a739342b762feab6cb4eb64066c0337745019449002070563e1959a2a95dc420d4b5431051fbeb5e2df48b57cbde2b4568d9b43b4116e4f94934422c19fb0e0137a6f5e5ac7ac3ae2c5610d6f8528fe8cb32caf6ba023907c81fd055c4b2849ce05395a6339f6d3a86773fab1fa49c7e32235d7000df34e7cbef8d3859c7e470ee6296ce5c2d2c27f0dbb9c1b9eed99eef10e0e175dc9889a85c462cb8465169146640d0a0a8fb811d2cb184445c01e2e4eca8e2cf33fe9223faf27336e77842990d5d2b56aab7d197a044ebd878470e0e56f1f1eb69585f469625225e9e21bb7631c23024441bf4b12e73615ff810dbe4be09c81b9b2d7e808a21be80977b482b64cb4008488933dd8b4c47d618471ee0d4bd5804549d9dd3c4809b590a9ac585d47405ef42718a7058dd21c910869358827d5932b0a23d3ccb5ffcb4d59df2b3a0f05d6c974405fb730fc46fb14d18ee70421595f54f9c6a8703004260f64bb78ed28413fe7764e84ead2e56b9abb356618d7274ac68171a05275b41bd788bde302362b4ee7f5a7adec532e74a786f1bd3d448c80492265c8589a017152b1ef868ad82da9d917c0b6b0d80e0617bda857f9f07312dd071edffc0c02cd946202fd990a62ae13c0c31e3071cf89dd7792ca24d804c123b72c59cc341c7b9ac3b1b9defa1cf87bb42c35d3b25ca234e166baa9ee774a7b02163f5b10269b1cf6849bac6d2d93978760185ff48fa45f4b61294e26c9e88b80abfdb4da086ed3de8b19c2e398520899b424b342411d6b552be98e65bfaff885104c339c830ce6880638cbf9342d84a9d69c429fff7b8b57dc3086174f168dc349c568a887ae82a0d47ea3458d755e8dc341c9b45afd8d5d77fae2ab177847a6fde743a17022696cd1a83ec266f297bc43f0779e8e3cd21b58bdcda16aadfb80a33f0a5f21428d763af05f8741e77da3c438fa574fbcf99dbd0537b3005efcc1be7b9854da1684858799b8fb11011707414b2f859d146983a53c1091e8ee5af28780b6b5046be00a2d1cc6840502ffcbfdc7adb5fb5a3bcbe8d0a8f499a106c554b7bb5e91f86a7c99dfc2e041898b54a86bc3a3d4bdc611379ff02bb3acecab558baec01614fbc3b39b5891130b8ba159e133f94dae77fbe98f625fce7a21cddeb0479f0fe8771372d49766eb844862c5791e2b5722e8d4a0b67292a512300812c6d23e8869f937e2cca93e7b7e27a56045403ae5ac01bca57522c9c71706271550e6d59adfabfbf19f732706b2b4514c75236f7ab1721976704dc47621c3ada40e0c10f951793f480a8250fba91ee6c39bc8b12213f2f89bee795c78fd7d4e2c9346f2deff379829ae25f8c256937ad3d10b09c5284640190141f388746a5e7f7eed3865e0087777390a8f4ad93fce630ff7daa41eec7b780c8658c1ed5790d0ba9dd84084c112f75d9a3e5d55e0f4ff6d632d1855b127d13da51a1b716347d58f8586052471dc72a4513221e8b5ece7c7b01bd6086c891ec352a1e8eb20122906fb6e0aff31777a0a589d3199919f433107e39e60fcedfc51b3009c3e0cf664c33393b6b02f70b83e835b0daa09ccd6441d912be660c55083b4f9ba0b2d2149248928a5fbc21dac29e03beb70dcd300c6fa5d12c454052ec7e693581a269c7113ddcf34e5040fdbd102f7cd03be2d358a7d8cd3e431c2e3c1d1eb5a2f0fcf04a7b0cc81784a42de5158c2a899a712fa0ae773bd9f6becfe7582a6237458e8aafad6e4d5ff4fb0a0007ff108c58b966017468d7d5d9546f226b231861d35e09f62244d2f03546d7aeb665b591f4a78085d0f388c4f45dfe408e85919ec1b9846303355e575911fc19a54565e0d35534485dd81f1e5a4518bcd159626f6a1d53cb879c0775c467c09d3bf58e164a32de1cee1978ced452b0652e5aa4c7e9614bdcedefd883291c84941299298a642ee1cfdc3ec2465ba9d7fec68ae626702aade4397fef243db840fb92610d944f569e060735fe223a24760f8de6adc68abac53c057f8c3db6e189ba97e20e92e9d984cc5b80f9f0ba2bd71d198543b04a64625b9dbf1b42ad8ebea16fcd4882badea9ec8578d7ec9b1c6c5f14089551397ce01598141a1b40e60babd880095a4573aad4b032bafd92ef1f2cb5f97cdbad85e4399bdcacae73a65156d08da26ec9ffb0e7b8976673822541c6025447531fd11615781482dbf374b89b427178f45121c936ab7cd21ca5ab871f369fc316997f1069a0a81a0c62fd0ae527e5e7552786d39b9b1279b7d5005c6b84d4dacc0d8baf84183c6587d317f2fa78c8810d5fe22d68e4703c9d76e4632c273b51724e4b4f5004bc7ff5f6d5dabf69f184c6f73e4ab3896413c1b1dc3aa2e338b336f12ab77cc76da6c3438e2eb71a5acb9b3461f6041297fe03c57b8248b7cf2c543892906e95747c933dde0cf28a49ac0f7c2c4a94ff62cd00dd6d449600902aba1167c99c057de1669d3fbb20ca8691062e1cd2afae5ee9ddaff3c59a8647437b09f4402dad0d78a5f18de90fe379efb4d9176c8caa9af080ced5fd3c2c87fc4e0ce8ef02978b63a5b31091aadf4b4808ca4c249986c150704b1574ffc6a808064ce3c563e15c2002837d19723d4d156bb4265cc7eec2eafb80321af39ff20c9848e7d83ca636b2e281657f277c34c3fb44343c2f6a82f181052db7b591f981a0f1b25405dcfecef3c732e867bf3065595d7b614729ff0af1bb1b730ba4a075a84ee521d824c9e24840d569fd05074f74822849cea618844636042293520fa276223f2dcc4014e5bf9b16c026e6ffa6e97b97da8bbc49fc26f681c02f82e1114a621f777d2e99350f271c8ad84ef8474f52d4d20d144d1dbef0840b81c26304946d7dd8f96e5c1f1095b9a513c2eebbc5961d602ac91e3d7378833b32d5427dc6bfec7f85c92122d09baea6ad4c324be90fccb494acc4dba08da3d99cae1b80f1ba3b03493ab0b2e123af3463bd71fe1285a36a06aa0e0e097c98058bd9400cb92248dff13c7f9d87e262ddca0600e7a608ca94ea6550d0ca5de6d1cdf1b32ec8874867b423bfb7aee4127e24ce8819f69b76a80950cc9639873634114e176a87c58334a92bd281c6959d54b4b840d6fd865165c5a363e8fed0b4d0f3c63f3b98fbda47a3ddaf450dbb5d70ae3851fa54015ca3bfeb00bdc5fa4adcd0a42105690b90a3e52ae5426075d827bc2d94f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出计算机组成原理（十三）</title>
    <url>/posts/eb9f794a.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="2de047c1d7fbc2b7964d89b286e0e79ff6652256be176fc7c2f163152585004c">fb26124e0d85f363a66baed35993e1a0948953cce3d484fb31660455b92ccb286ba4467b12dd2afdc0f8bd795964707216933c479f00faf5302337078027ef66e68c754bf0232403ae44399aa06a2cad741400e24549082709cdee4a1c1e38f29d8bb6993c43448bafc4543d636ea5bfe35062ad225c74a80f232ba51d9af45093f5220e616be2d57e02341ffad661bef2886dba249b54377d8b3961fd62e8e7033554e6a1a85b429bcdccd8e910eaca84c8e447cedd760cd76a16c64ec7f94ad050108487716cc544f1ca685285a120a1c590efd559bdca18a90707fae890221e2912f079f089d10fb816e69e85944586941b721161d200273028ce2f3cb2d1a6a47461dcfac58b4612622383de37911e7101936179b0ecfeb18f3600111afc775a9e1f79696dae92585891ef4dfac1f1b8310232df791501c9c89556fcf1dda84f2934dad3df369dca2728da62c9977763fcabef14ebc126e43a741da19ac71baa430c935a156360ce0680aa09a1df3fd26b35d4ade34752f13940ec970f9d514e198e61f11c19833811673428a808ddb66e41fac5a56d68cb741a9104eaed15fd09a2aaa781872768bc246911d17a4f06e1ad46f21ccafbb4fa191017d2678959312d5219d085dbac26220f06a50c1c997556821867abedf5dfcd14385ccc350bb5d7e85b4c3deb59ac7f4d4208193f3fddcae03bcce02e67217239079d0be05e0797b421eab93621d69b8ad2eba2763ff37a19dc8814c6e439614070c712cc13994b03c99490af49bc54581fd0ec0a48497b138476fbbe1bb06d4e0233d1719f3d2b67728ebca4b97cac5c789fab3761229d4ca896db6c52b0aea9780014d81d175f036b54c0429e6cf9acd80ecfe40f25cf7ae6b7d3baf48dc2a628d1a3850d79e4056d6db0a61e02985d0a85338fa5349a5c1829cb1c45e6cb383820d5ad82b2fdfb052466dfd673a0b94bf06159d306d2912e5b74231688da6ac28afab258b86e7053a0056b07a4a56837467505f3981c816ef25dadefc5f0b36e8dfa05616de1754cab97ab9267ebc048ebec3e25de80cf10a9e5171fbc82fb5d9866454d87602752fe6a60209ff1059ce932659917cd9b953ebbb225edabd4e2b9e27b520ce739205b842da3855519e4f6d5f0f3220da769e7f804ecd8920397b70f09a9b326a0bddd8091c1f3d1cec17c8881949f36b77d36257bc5456641158fa78eb288ad2991b66b31c95605a128d8b03aaf0952f0442eddd41b4d3227779ccbe2cbc55de94e999c3fa281256407454af5b81f3c87dda94067a44bded23fceb7d243c270025c3006651b53f724c192dfe858781ee17c21e4b66cff7c7415d52e1011e5415aa30805d081db0c47dc8f0df72e29dc326bf96baef602110d038293cf8cb92a81690e8e615d13c170c7ed8ae4ad9e814af4acacd86555bc95863399b35759395fcfdbbfde0e7991526b30bb92e7d28ec9786823b5895accb4f44bcd52987f148ce94bafe615e8230c8f34635459a5c73489d7d6c001cbca7e9788408d005b5e32813666d1fd032c9628300263a41c9340de40d136974a011ca0a30fc9b5f0ec8d4050f04c7dc502cf462c37cf4f1220088f50cb27b0ba7727e6a61871b1b91221368739502a50fc10e9db94bf2a14e08df0390e521875e5e5904e5df6366692d65fbf3e9e213559dba00f5a6e676ece1a7780123452f79a2e294ac42fce02bab9d765929ae99eea2208f0e1e5b5b5f1aca3de30c52c6c0987f857d2eadfa60274f616db7c587ee60cdafc0afe69287241bf92d1dfc43235e551f3a912322e2872fb5e5a27f61717ca821fadc8ce5541196acd359335b7c8ae1062faa95b07d5ef493b37649804a90b28792d76476b0a96263500274efa3d52edcb1ae2e6e7e73d3421f2e8d592c91045853a531d5dac06e60a44e90ec83dbe9d085d01a1e633e9a31bbc1922d4c0e78411af51601a2a01e06a0ae196eb92a3e8a3f16b42771add56533fb01381b51a84828a17056c74793a6ac0e912d3ba872942052fa77b3f63abc23dc57ba22d835a2379b709f56e628bf56d78220dc6f2e7991a857e9f682b555e229c7782892a46db4a4460cc62856f35a84fbdb0c310a51095940446ffc76cb26cbbee24054010ef92d968fcf7f6f29b1c470109bd47551f13f57cf41b2e6ececf331942660aa7dc50fd96a2a1b4bbe1f9318143956ef193bacdce19769e9bbb79d28bde3132c8321d186c80552579a1a0ffcde00d7168ac7e808868397c0eec76e90e6b027ab8165e53cb4b88014be08b0c5d3d0d1b9b867aba021f79becc7ce501355d97bc84fda035ae1568da8de0c5296aeda534365fe9219f9e3d77dee29c133e3757f0081ae51248b8ba78708286a36b1e72579e6d424956f6a3e0dcd871921cb85bc51a0d07b0e3108e08c7fcbd0c79e74a7f6e029d5e8afeb5abc3d68ed7f2f29319cf1b97737359d408df4fb4d6bf4e20d3b378edb6f3ced139b358b2dae3e83c8916b0765e1ea173afcc3cc5a3c62ed95f2bc3ebaf9adc234dfa86c85a5ff390d2c7d15a00cb7b9e0397a4cc640f60009efab7c26e4ae4f99b1807bab575ab9721bb19496eb05b8e7906b163045a558b75b1ffe6b5c6054befb52485f6bf21e2894722fd379c27088c3dc277e20e364f522aa62b99aa4ed3a5bd5f26d52d7e164c73c41b121ef53641c4cb10624c014f8e02f1aecddfb0bc6beeec694d40cb51d6ec3afdfe462a19455f14ecaa0e59c792a39922625c40845a85988b6702e5e0a36b1165d169dde4ebfb6edfd2df4bf25640963b999f1bba28987a680ae60ba8c09442f3ca7d5184a3bc6c7964b8b627ca267a3206d3ce554bde83da6c9bf12bd05adf123565c52bd748ec1c9936e245bd305660778de10a6a0356a2be54dc43b2ccf1dd797028e58ae213bb3c8359b3199d1f8b6a50abc51cd8081e7096b18db1e6882e619372a72ec6363e1b125c560411b4bf57f5a8b337864dd18e4eee5eaa23f38c0981a1016aae459f95652d9d53382a8061fc32b16e36e5b3d5026d6c1f765e1eab49718d7c3c3be25c3ba0fa7d87fc2681522739bec6b0527e1be4181ad74cada27ee776e6f15b171b96412cea83fb281299d0522fe50e2101a2d8daa601a8ef0d0c860b7bae13e18391ce7f7ccfdbed6f6bd04ad9daab8a84819d7f5a2af532b006e345ccf9d3a85bd7ea2139696404aa6d7214169e32c9ed93b988c1a4a1dd34fbf294df760b20c1201ac4a04bcc9da674a12960864855577018dd0d0afce012f9328c783217b2899effb90272bf67d924735db31a49842b8828519a2c62fc9b36487981a040ab34336fd0d3e17b25faf7bf0b554fd46aed9d5c5ce628f4968387c80b98a80e1a57a933e6bc0b11dd98fef7e22f8cd802f5501b83ef9577c80e7eeb3f6c73e641eed366421f19e52f73447adc23aa730f2fb3faa44847e9a06500e0647d13fadf0f9df6dd230dbc0b68b636aa6b0c03d70e5c8f3f56626653941c9e2421172c3d8761acb471a6d3ec30c2a87257d695a99933e65afd59f3f88027c126da1f75831cec61e40c446874083c4eeb95e4744414b2ce101ce3322214326471a675be6299dfc5f6e837eec96a00df20446a46da42277063669eabb92cd902b09bceeb62095f31ee84823c447c5967922e7290bc48926c47f795f36dd7c8e9e2b3f002adaf31d626d4e9b6ece2dc5fbab548be5caeba64d1c94d5b901c8cf152294af2c4e36f93c47a14eff8169dc412291ce3182e04166db86eeb181334d4efbd3a50f9e6caf48e062eab2c9af5d7ec38f1f6e93f2a7a33f4e3b6dbcbd5314b0e3ce24329a0088a00e195ff1f10ddef756119d45c921dbdc6d6c22ada3bce5514cb9cf8d5100355b3604977ee6984b1253b7cca4ab3e365c486edae405d8c19a611943a9087933a67d1fed76cbc66063061e034e7f18db395952ad04b0084237dc22e537ff5af6daba9e1e85918c890360aa504631352fab626aeb8e4e8b2bf16d4ddefa1b23a5b7a948fd045b167c79b6f46c85ce03300eafbcdc377cfa9307b8036d8228bc98f1966d97720aebc5996b71700192c7d51956a38db109c91ca053f9d9d1a50af5792c9ba77df4e6f350f19b2729631cc9d7361226e6eefabbac4d0b690ffe703622247bc357237f1e20cb17bc4843695c7c4450c6bb5629180554a7abc084f7ff403ec28b7f35b33c33bf8a36dbcc9acc739488947dbd8dc1b1a93ac536c7a913fcdbf0074200902617b050616b5096088096d898bb4643a486708a9f424ea9fccebc1bcf31478fddca604014a6fdac9451c84d641f0331b41fa0bc6d28c5569227b8d56a795b7c6c054c46924247b2330dc50e6c2a3e3c5c617ca4b12f828450dc4f32ba2d6da792062f6d067f1c822b42478ca327655e9966b035659c114ad6b56ae495507865d8b8f8278dad88cdbf2f9cdc237d302fb2d160a17856b062bf470527613390cb69f852b59d787847844a989b3effa29bad8aa026fad28f5459844780da747808a1f45415de19161632fcc1b1ed140a45feb5de43d94202031fd4bb950883e9f13236bfa5ddc08e8475fb7bfc8b25e758412bae070741c2be552e36f305df6bc3782f34edd60f519ea33e5e0657eb087d599a5b1436e5f2d7dc709421af1e74d3e0f245ea09bad578d166d5816cca7f2ee99ff3fb789baca4229a47f8ab351f353749273500b3636e67cb86c11330428c50ab87b350955a79e6643fc002b4d0396530493e8b845e3f63cf7fb5bb9ad11b63580c87bb4952d7fef08206b4fb149227101f8af64b872e188dbf4f0645ad703e98cec6198d57889d39f8d8baa1a89f9ee98cfa2d4638090840c3e7d2a548e69737af37f038b1da4aae16d73cdfb201eb91e89eda5a83d93680d2e7fd75bd6e4355b6d11b64da7d19b443f01e0457c5708629b60ce28fe0e09e6283ebb2596dfb6126015c2299fa60227ba6c6ec28e82fbb79ecfccd4822fc6af3d71325c19949b770b8d69733f812df7e7bacba2d6264f6d403247d650a6bf9712a110d738e16a6f9c18203808e0a8004f64e010ca3337fc4f7c313bf1c1e78e5a637f1f5089f151de6ba20053d0d4fbb16aec48a11e723d0ad04f01bb059a38b3653ea025147e9e78ff2fc14fc03dd9db272c4b0f1b3511adb08cce124857a5f156757ec17f877045bfbecd4ff9fff22b6602dfc710ba775588ff3f26c4f87c0e27cd1099879595b330cea2f0f4deabcc7a51ce6d24e067608170cbc78a97bf84b44d186255856b4cc730a2927b90b71ef492f32979e9d5a1f23467a4d14553589af7543f871805994f47179fe9be1782b600009daf7d8af0596255f3978d9c95db47226f664224d5d436dd5ee7147126eefad9cefc8982aff756b4e60303e5007d2fa7feef00c3431078a608ef11c8f26b05f24297e74aa8b3063783b46afa1581b57743e807dea0e83bcdd39dd9c59a2186565f23b0f225dff637ea737ba4b11171500cfd8d2695d60be30424718ba6af032d987c18f374dae03f73f478ff746f093261b13cd79add8816dd581556d8fa3b2d322065739e8cee2db10aee9155f8623eaedfe0f06ce29c5fa8b853029d0fb562a745c090c675890e18010d931f5f0cd73f2fca9c49301ade76799ef9932116d307a16a4507f77de9a3a0ec647ef3a414417908f188981bdba824254746d13a32d0e68d7b87fee030450fc9d846ac5c88b48e963993f6945c65f2347f790dfadeea4cea06e43c435fac0e9d2ab31b2d955fabfe44185757b42d19d5b4302891490c58d059ed24d333e8b0888536c815cd6e68e45125bc72deb4f7f87da4d2238c2c6b78b3fb38c825a8b254033930ac2b8b8739a04606e6d72683ebd77e4a4c7391ff67772f71f9e5c43abaea478ac6da32bfe124a298f4bddb5a5f705ddb35cc83dcbf9a61548ac410a05244c0d5ec702a4332901e93e81dff585903fafe52c3a9fb53a09c47fb4193e54b28cca12b710f61d41bdffa3a2d15f91d784366d9cb59396e17d3e2eb69c1de6a338d8ab6acefa7dd9b2a1b3771d3769f0f5d80fc0ebfb24fb46e8e1ea91353b0094ad86293fe52bf1c6e335367aefeb61be1e5ffda74cb711da9eb368d0cb0cf3efad9f97c0e22546fcc45a2b1990da3be92dfb2730fc3c2042c54349f9e131cc1d6da687fd366b87fa188861d90de09ba668da3ed5b0dff5099d873b87ed004ecbdd1638c81495711a6a8ad3186c539d49a97ea47238aa12efd6c14cd7d4929fa210f6f175fc0b1cd363664070c271bce908f44df15ef16771045c802eefa95da70579ba5234585761b10ccb8bfd879c1fa0a893a2f48fd5c38342573cba982fe680f2c5bf11faf38b34784b53ef650e6509627f181bb58742004a303391d3138c763d8a828750ca654279aeed414774fce266304a9e6f2c646043d5a9ed6f8247709172e71ce3110e155436294680f99b29449a334596e9721364f83507fee2d2b09712dd91648394ca66f06c7523d5323d27003459e8d7fbb6d86fd5f66c2c530a17d5ca5bce6d4071eaa2094b8d9f54a6e2b553be781d846041a7548e183f79f80fba5861e7ad2866c42fb96d15008bb67c934e46e5164a65e53881ddc128783b9dc26b42b7a67f7e993333813cc4561d74e4033131f8d1d4f6dd6c6f533aba385a3c466312deb5c1cc2323d50512359929f28e71b428a7ec6aebab25b0655ea803e45d984c8ccb9e5ca0f961e6c174d95e266948610621662a9631657d1c01d654eeebb8582282653a5d3fe7f0e44d55036af4a59f6361d94a8826a5f4003423e58a263ad15af7a128b55ed644171300836596266f598fa6e15442070057f0c22a90f0e49038af50cc37e752d9169fae616af2aae63a81d1535cfe7812d9a6a91d89f89fab11ac27c6ebc65b6b2cdca699f5f61edb43ad979b91f3ce85b5f8cd430a1d0cab873c8364601cbc9206f7aed1f643d3566f2f9eac54d2fc33ba4128e90b157c28d211e05f36bacd9f6d888b6498aa269f3f9f9885a149fe74bc9f1e29945b82aa37014fcd890057f555ed11674efc4f5e7a4ded810f8f076cb9c046b15462db70c20f9b0ad04f51a46521c16478894557d07a2cd5b29d932a9d6d3343b199eba62bd3ec82f76d16d3657a853f607d9cce478ed0bcd3007d5cf4ccdaf72f1deff4d334a74177d52d531199b7233642368ac436ea3345393aedd2f143bd1b1945fc6ed77e6303f06f073e41fb1a301da93616eecf17a49b7f9ff055dc7e71bac3477d0b54363da0367841c2dffd265f959db2c4d47ad19e4c28c1c06228db1b2f14b5cf2c2aa9ee2dd4db6ded8bd80856eab38eba3cd16fd7a84e47459dabf1063008691c32e2095c35a969121866e4c75493a694537c9ae9ec6561cbfe10f876d14c1971e546c29cb242e32f707106c7d0720c4b4f8b3660e2a093c94b4823857cbbffee0eaa63cbda2cff6eb39ef588cc452c6c3a4b557369ea28f849d4d2c736f80bc8abde64d2d64d7f36851fef3e5105ae119c222387aa589b1381d7ac7a14c036ba55ce3442e6eeb68ddf7586ccd2ddc5e1bb0163f4adc2cd6df4dc504d5f17d297946cde2e85cd8fd50497c3e54d0f6bbde6746ea2bf7dc8a0035d4d7d8daada401cd04f71c7c42f6b536e0de6236ccc2febb694f8b83ad6ff4a619f3e13e63c362b8b3fcd391beeac4e7ff3a3d058eb36661ca2efaca75eab5ddcacc8ba5007dce887b504fcb2a3b87babb012688254cd6b092f6a1a2feeb25325c98cde0c8faf4ebe0cbfc32bde9b90b74ae181859359f2af8a08f3444b53415e0b7f92e1509824587fb60551c6ec6580beb7b9119436261474e74cfbf2b619b2d0ea984b5caa83d530b4d93a93d9aadd7c3f321b9804ba5e2a6dd4f55c40846a71385d67ff2e4f89c1823f51cefed16067f73052c4e6d07931c78c6f1aa7d648796ee0b55cebc72210ff687c174521c3493404a4978d88a504d31f9b50c4892b06d8473f8a2da5de0a56f6e39092392b1ce4b0c17eeb514f3ae82ea5707bd1ed6e9fe196b4b9b5c7755e4ed96b79fd4c42e0cffc9addc630c196e428e717abda616768387eeaa6a83be7ec0120a974c2e87110291b65902c7b227b14c93153360dd22ac63cbba5ee06dbdca6de493cd23e80b8719a46799aa185153aabdd4983736ee1f122154d28982c6b6ed719d77e07c7f42d7dc5ffdc9bc68e7e8953283f54b616c73718591d2ada2fcb4eb4c5bfd4667e9c42ee67a37e0649aee63453154c785456793df090d9e1a699a9275a31c93f7c82ab03c62572ad50195ed8d59626ea3866be6e15d5d7b572283f01f764e7f8449b9ae2ad6c113ec31bbd2cdcaa62258871a61b75f6ee5746bcd5bfe765805e387fbd12aa2775ba6640370eacbe5ee7fea61babbd01e67a0ac593f382ed07d4913177b2c50b752ac45d1a9ab0f7ea512ee599b1d9c8075d8f72a3fe4ff1f87bb27e31317343c9df49c27494b0574685da283be40c8564690259c821a6ddc6feb06655391456a3637f739935041527734934c119c70b78b8d8430879fce569e1b2775933e0352894f8ef25799b3dbb708425ab40dc08731801bee7760fd3da5d990e0f17e680c6e547b2e2d41065c651779cdefd29651bf75ed78db0a329e33ba21fa9f95e99497a3acd747229411f6de89ccc57ee22b3282ad5e2820dc88c5c9cf40ac9213e6886ef7da935882c850bb8515ce557a10d811f034bf70c6e095ea228f1c26025ae7e185ba0f37eb1522a07a7c2399c5f8106f41d9cdb884c4172a15f82fe541cf6875a7bb58dff41ef20e121ce66bdec9d5470091805c022ac08aa439f30555a553b7cb4e000532e3d132f9bd82e7f3de2e6db806420ccf427380a1624f1dc3658d2ba0160cce884f7c87f9b0dba54252a936a984bb0907b8784afb74d7acb9ca28eda15488bbd0acff3784517b4a080739597feb13b40480b40448b7c2b970a041f02a0e05d025ca17aaa09836655b36d9c6b58d7e14998a94482c87ab378a69c3f16ebff58d04cdd2f3744c2c480e510079dee8c2796323a5810c848f558634f62f31b8e48769951867d6357b1254494839b3effd8b832824d9cd04b40e2c6ca9bac2687e9f62ea48e63004cef346738b98c6e73fac8820b7ee51dc164727fc558ccd69ea7a852d0056a166104ee532e364166436e31229dc0d268f30ebc8dd5b5ac52b5a6fda8ce6a1eb2282599bc8615a1ec00095b9a87b819533c7b170a4bbe936894eeac2d98ca05d903795bc256660beedb6cfc44154914cec6eba1a4739d293e013e59bc6fadb7c12293edcf3bc498ee3827de4401c3f8c08fa6c590e6865c9837b50bf8efcebb588df1335f782ec4bb4cb8ee1a3fd16e1a77dac2b0cc907c5973df26310760d01757d5feb5fa7913ce029b2f8b0e125abf349f3d27b3d2796f221ae3dbf7036c162e49ebfe5817d78950bb6655312afc39af64ed43a6491877f728031d9c1532876f8828a965d249508cdfd3bfb538840b628da4fe5d4c91993c9838ebfdc7a49ade0d10c4b4dcebae94b07605a76b878976edb0420593e3174cd612b9ac86abeb4b7ea900e74399149fa90606ae0624018f4dcee186f7f7ac07d793e755e05fa38e8afa4e03ba6f4e4fcc57fa70ee2b9e87e5bd7fa419740bbdbce7caebf74d129c98d7438c6e28fb1ed78acf691708b86f48a4a0d4d6717f5b92427d80aa90c0b38f1e383334341d612b0243abc53b466d91ff2f7b80070c87ce3bd19eba2ae7e30ad2c94ae62fab0067b556e5338372155b8984d7b050af42d718f02db08d7a9337932bde84d977b676b40d40f9fcee305810a1dcc22ea3e568d4908ec6b5350e54d923295f66a952e4a1d21fbc6a4a5bcfd4e28d16b0229ed477a5ba1f573eda1c9fae485f581983bed4b5d9043e157a6efb89369e1fc6bfc39b7ca73de4f30e6af52d3304a61b5a43baa9815875563b453cb20c24cf1b4af4554b1ae83ff3e073931e0513211c50ebcfaa727e7bbf13cb6aff457615b95aed3504fff5fb6187d7174ffc6b655c6178220c3a269269c8c779f6903ff9ab9c9bae8baa4d9e996b1483335a92bd471c163fd63b8761a3e4fab8878e68279a37f2b4e833d71e5b71d5bf314a22349044a297f0a510d8acd14d22604403308e03902c0d36395e21f161eed535f20fd7aae05258ecb8af8830bf47b8b6ebd5701d34744c676d2f0cf6cd507ac601d0319f81156487fdeafb28be370ff864ae9df6fd02cddc44ac9c44aaaa9ee065e02f78cb5081b1667e5e17148f5dfecc372f097b86fbcd71bff274fd183a244d6dc8371ba22496669233e5909213703ba2a7a4b856ea099d1459b87e3c505b285e5eb8fa543976e82d69a7babe0a4f7ce9c17f018e77e39134503efc621600e01b4a8746d90bb0127fabbf0e03476f745c8b3fe919206150f1fef4baaf577686d5f5d66cc369bb274ef42af4f4a3e70c279d3c299506cf4decffddec86b076043886c9baf1eaef890226999a6c95dee74a87a60238f12188a81e38e7d06ae4e1e2a41ec913eb0b608517e3da8509013d27b7fd4d41e9eca01d29575b8ee48058119f56db7bd15f0f8774b409b54539e0b742127b547808109f69cb97f8b23d7d01862772f53036ed09399d9755490fbb737ab128073713d712c366042af072aff3ef0a18dd0ede5f1c7c56d5ae8b219da72b06bd1ff27f82db7ae0bb72dc62d6f1e351c1cee25b495dbbd64a365e5961ceea10d14aa16353c9abdb8900e8becf5df92f93b60c43b02ec4432b0221891f7c0d58942e45263243b0655b4113e4b58d03ead70485973fdecffd7ba8244da091e25691eb8b3720e19728d8c3e6e47a7180d02369c1d1492566848d29f4f95bddc2a595e11a1a5bd6aceb0ee6abedae6bc7bc57efa52ad3abe70457a31317e2f38854154f73f2d601844c37268ef7ea9ec49fd4115cc03ab3dd7b76eaea71baec082109e5494a6fef7c6b8845a974fdd15d69d28dc7208fcea5d25ae784111587455f1d02c3c6b3a6da45fc84cd247c0b9920d9b089deb54925bd5446bf7a2cf149d48281b99df55ca11f9536d4e9d7cdb10939245c0625df6f2b0f6a06142364ce67aaee39166c2fbf4fff7e36f0fde1e4e16756973fc85c1c56f3e242f500b029f58d6ab4e3ff5dad698a6ac089dd114160db80af65c0bfb36f3ebb0dbb6e04e128b533449762f7062b478515ece8bd3ada2d4b5dafc4a13aae5c1b751b550d8bd9560039afff07bded3ba27140958815d593bccfa7e00e3d6486b58580db24cdfd300c749b8cce3faf74fb7c78199853610b00cf5f3d8660673c0cbb47fa2f9cd533d5980a36a79addc6b831f6bfbd2910bb1d8daa6919e8ed656a805096486a0a0912ba82283ecbca7a027b41759f6343b39ce721135c7cc0d2d96590c1bbc58ac097508141020f3a7cef1cc4a8dfea80033e258c8301ea838ec5327c2e50ddb3d1197aac70806ba4690a9c77b3d1c5083835505f5b2d6b374fbb26b14ac8cbb6785df29fe162e62ac5e06bc911e7f887fdc99702877d4678cf0384c554d15417ec8a99308d1b2624a33adef294480c69e82750f1a8d7320971df8bafd722e15e84a888d7d3ae16fceec50be9e702bf4df4288f7f30b5420d0f24f3fa13cb5e8da222a8a7d7da476c6d60e1532597b20fc2f8a69ae46b6579a31f1859e4a0d835c9194c5b43371608a36783a4c9e739da91b5b5693825d7c124d22ee996abb9bc0eef3701ce3ebc4027a6954689d4a95cd0b69ddf5b9d9be69da3fc4c7029a0b67b515151eb686aa2831cda54911403123266e1414ab55404c6da896506a832e253f7598918464076874940e5e177ad50dab83bba1bde7ff5c380b9568d491ac66f85c3fc3ea206046f84d3f3ccc90c0c7b015f9507a0052ca3e9b71e99b25ed814101cb63800553ae9f0eea469d5dddc1807474e47669bc2e78755d811e830cd4f626502a5c55407c1b26f6ae71c12cb3f04ab3131cf4653489308170a983f5cb774f6543ce237282627ffb6448304537b69af5ac7c095d718c86fd660971ee0a5c501f0d7f2b3996852dd498d7652e97208c129d63ce25e7c659b65b44fa8bea22a6dcf9f046fe445438c358aad1fd19b56d0a1ad7bd11bd307bb4641a7f2819d4797b9a48579519b0f4b081c9a3bf8d716078a1dc80e894f6c256aee990e90c82232b2f44fb04795559c3c110abb587cdb34feb5c295681e65e58ec3d30673839f807a6c689e8acd5b9f422dceda470e22ae6183ea6bde1fc514789ccd096ff5f4738ea9f0aad858b4c3693beecf920490c486b3cdd07f1ba03dadb8b611989f621ef8c40da077ee652ce0c0338917e50d44efddfbdf8e18ce441e6490974e9b1a586fc9fd5fa410b8923c59a9991f1e1be159f935d3f5b7c0999f0ffa204d23c9aa8e55aba5413e65ca9700f56de067e1bebfaebbeaf9b2a7610d5578a0c061f3baa4a52c493431ffeb0e324c0195f3f592152403acd1d5b8b0f0aaabdfb0ee121016d5ea15b52bb9f9cfeb70d1fb94a15befa0fc7db4cc10eec85460071ba987ac6f4645d865c432346425e48dbfbcaaf5b8d216aed3ef3d37a0cbfc52c151dd6324dbcf0e1330a6371074c8fdd596a4feab83f71427f055368cfa42b28644ee1008629596b4ce02cf6e4294ccebcc5d525880683ba572fba81de2dcfcbc8c00c152c45507dfb13beab376fcf13b899faa1a74bef331d7ae689012d26be8b66d4824a782d1a922a61d4230334c80617ce87acbe98c35799e04e6bee676bd6d0c00a7c38c3382778410d40d548fcd175bf779d05eb9af30aee16976a6be13fb931422d8f83cb6b88797839f459d6cc7e1b2efbbf111754e4c6ae43715d28cc97c6bb16336ac54840671c32b7f5f9dc4719e0e9c4e1b489310432e0ade96152e7221098354e7977d4c3a1ba3b1b5cbeffdbf5e9b7d0ed78d7f68f07c56f84263b307e8903281d07c81fc687be50569c5f65a72642d93b023fb5fa1953d3ab1d5ea009081e77b06b50f855b4048e7008a9d665b49d945cdef943dde8cacbcffc6aab708aea8a9cf0cf5c79f0a75f0cdd7fd1d2994643639aae7af63d1fa8c77ac38e26d6ffbeca635da22a9b12ba10892f54ae5da393dc0d70a83e643522b479ee2cbec07869569475340cafe29851c5a47b61f9d3ca17075f84f715f890c9b9d14ca820aa70e83217acc452a53c79fa24a6b21e48689c4ac03f5fd548dd1898b22836beb5d74f705e55210b909d74036eb71c4e910153473e7b82867b8c1ba4f22bad3928eed0a6f31e0f4ef50c3a1f75deea31766247cbc4e5c2bd8b3abc39cf7176e8ec85166d427edf77f90e53ed05998653c5650154ca27618902500ae24a7bd43f5592a8844275aa8c2cc02776cd7a8844293d5a8d9d58f14da99e27cf6c5a456232c42e2915287cd97da4ebf8331ed2add7436b5bd61b8578a904838d35dd1d6e2452ce0cfda0f2389e7b6e154d6c52f125cb7358f4a3ae5b4b793c5c9110777de799d97e555d1c17f7a7907742d1a6b0de8042ea8513e6fbc0f8abfd55c92e1c8fc7e391ab4ccf7225ec83c4d85f84959da9a04605ccf1769d09c0a9bb55ab9f14a8cddf65a19d42ca0338b89821790d440bfb2a2d049d5f04dca128523ffcad12e4bf15e73eb897766b79b7ced018da52bcf6ba599e9b00bc5429d5efe89ab168742dad4610478440ad17c659fe7675282ae4161c5fa5b59c105a943716ed3905fc71303bdfe551cc9a14922b32f4ff0ef359d73865df016032d627c01a876376b8ad5cc0eca73d0c020e4edf822e2097247c9a0bd7aabfa4402d78a3d55a66f363a1f00d1197dc29e845e07e15b3601ca635f40f64b8a685d83370ed6f69afedb9cc5eb55be489f9e3a522f1c0a94fecca23673c7071449bbb07a7700d190a071c5b82e27bd807c33438aef093e172f148b4521b92d16e69b5340bf20dace3220dca9d1bdfc8db1a72bb7d6616afbe206df5a27e349176f2e5845870b5ffb938d5bc15cc1240672142871a95957881ca3391ea471252fad494fdc3c28a9b54788dbe5e043b8fd6c9eaa380d9fd53268228f61ffb2cc5d813e3bc052f0dbbb29721a3a5eedc9807da3dd340e847353293a28f2429335168b4d576eb3b4c7e8e62b7e24fa4dc5136dd8111af09e170299e066927e7dd0757027276cec20d06c2eede4734b483c064f40347856e013452d45e8dc38b6162a0fcd182c052c6482eb0e9aa828f28c0ac31b71a3a5a741e434242f42e4ffb5ea8710c0252a0cca78106b0345e852be250f874407440b861f320897c07f2d8234fdfd142ef3e4aa07f1441a7ff4896896fba124f5660802d8cde78af062d5a5e876de10189981dd78d91ece0b4acbcaa0ebb801433ee10aa115a23b13098cd767996373e3062d3a8192e45e721cc410f5ae1dcbef55ccd493af8b714789679f2a45b94c17e612abec3c5aefce4c57fc1fef64b94767d65205554a9e38eadadf20ea2d518e500910d3ab4a140d9e57c853a7ec5cb86b89f940578765d225857627eff76a3823fe0b41801f0e348a12c364100028732df0e15d8649f52b1e46403cf7f30906ca26f1e9d38696ff06774118399f564a008915ea2d9bb53d2ca0c63a4dea954fe801e1167417efe6ab38b3783745c37c1cf1a1fc8860abe2a9018f70b14cbe1f0c233b2aced5a3f252c781425eef33a9a762a6740165dbe95e2d52d7cfbdaac9e663b0b153aba96f957d765d1e7c8029505a9700e18956842f2153609d13c8050665b2b5ef331c7a3f450b227488e7a245b33fb6d856ecbdbf26920696dfac1967adb6809924e7d87e3d108cb840d2b7a0402b157e859c4c3f34b59e011ad6685fc5cfef3920a0008448fe1d83084fd8ea06fb1d210081018ef16beb962b2b41b296915199e8e1e9ab9ae287377cfa5fb06f99db8aa194cd5bae2da139d9e4dbd38d7615c5e85ffea248529a77bd14f781f5faae483530a8f8247d5c646dd884570d37b7a01a8ef140b2070b3e1e12ad78b265b139ec4590598a2319346279f0b443111133ac8907d7a149e62e2805d6a45350015fb7e6cfa23e79837142df5424d8f2a2d3d6d9523408e830a6c041a13d15116c1f5e8516a54bc0059eda0febdd9773a39021e04c8330afc65a3da2b5bf0ae9e605353da6acd160deec4ac23f3eccdbdf159b401efb5a70af8a26636fcdb0b2b7744b5b4d14c7330c46a556ce2fb88706fa2c7c5290cdc80d7362314eba11326258ab6a18333631fba786da4a6fcc315b34abc527c1b58d1815aefe9fbb641aa3cf0dd87e15936e2ac0860f19bb6cf4d845934b964315210b0c941d2eead9187440d310b6dcb6e5a9e36746a48fe592b9db0fd634a21e013e55f18a8a2b8a38dcc9687a9522f56910ef404187fb9f0e7ca08efe4e1660b2c5efec625fc427a73bc3911a512f4454673d2bb7d498f265dffa97eafebe751e8a48d4469155113a2999a575f44aa97018c9308019bd2bbd6b9d5f428a98e05f92212c135584c83a32df14145cbf22b82cef9b346ecce06347e4552be4b84c1409d38d75177710f1e256b68fd5c4f51d4ca93859bc316bbeda6ffdf850f74fc08028c943d8542417011514dbee43e1b78c4708cc9b92e2a5bf60ef791fe04a647f51f1cf1ed2b758a419ed1e73384d98a0884d576af99c50146528797495cb8d5759a6121d39a689566390c176371c4e53e01e563908a9bf1bb1c1bd52f7a7ed46f696f392fa56ed8ec80ac6a2b22f31fbbd904815cb90a254c1c629aa6b2f99fe002854a2347886786cddee5eb8ca4a132c446dfc092958f31737de0019c4a1ddb8d1c26f36c7623cba59d31781e11444bfdaa54ecfc966afcd0143567916195ca163a86bacc812d3f9dbd084926bb70cba8137e18d6a9b0a6bf9054fe8d73e9e100f05390ada873803b32ba5aa576ce3700ec9f7f4c7e06ea6c65fad7f95b6a963d53dd20be4a1f7315de2b1b5ee354b7fe4ba43df63aa694902389edf80e5a3b1836ac0769823ed50cf73773c0ccd56b4e255de0b92ae754651a583abeccc1154f426435dd5ff4e270aae81524503f657a38b1b66bde5808b92e9423fdddec6a1b661819afa1869f801e1d20af6d38db3f5522cbfdbb943c51a4fba2ad7a43adc4286d9d4837da1f9cd0826712a8155a7a61d399f5629c2767dd40a3fd8292f1d0dd2135110f78adfa400fdd8f108014e3a1c1dd1b8fb6398fab5e1bd872ca411d3123e8c520a2ffce30d6c27253de05cc696d096fec562384281d5cae79c79a1f399cf74d3f1198ae492b096086246f50a33345250054e5306749ab85f1c88bb9dedb627b8851c5773f038d9bdd8c8ba3fe63e2d1598a657493bfd4be671ef2427c9f2928b7875551d0d35c890a41c42594f47289c88c55931785e0421f19ddb607d1e0190861bc4265427d45ded50d88c7dd83d719a711b6a970a5c330870673e3691465438a4aaab7b23c4ec2e657c16f145136581c67ce8356c3b36a25ed9a02925e9792a197d68119f0718b1399b8d7cbb23d7ad82439eb87d4300840fe63671b7ce2f251e3c0a54c358e77644dde3f2dcbc19a80264a212fbbf1178251708b531bba56b8f398fc975408e25e92208735b6b0c2b65bca179624d33430eed548e27199affb750b0ad54b1f1bc437b5e6d708baac6309b5a8bb47e40d60520c95ade4f7b2aadc115e7817b31b8c0839039412ea9403564db00b582673fbf27b3b723dcb53dd8e7305d6272fb3693b7fbdb1b632341d69d383cc3bcd61924222d8046f3bc983e38165fa9128d1ef331c87c3bc4943f69d3d9d5e44d368e7b249d08e6bd50516a1de790e0134f4bcb60a8f68f359d25c694aec0cd96b6d889adb97584c2eb350f46585c5842e449fce2034c7427dc6f588413039e38cffb5526452d97badb5ac0b9073b947b297ab66a2ea4af781f78f285189ab711b9b7e713296e8fd51510f9e279efe90b74267cacff99b245294768a829b2b626a67aa81be5bcbbf6ea13047c30681304da69867975c7170339ba115d915ae18a8c168693b2ae09440300e2f8a4b2fedf466a2a2c3c8228ec73037eaf6e3b83e7e7f39395a1dc06f96a1b9a4f141a8e93ea70becd88027324fd2405418722e26d5f1eb7de6299248d80be5dfbfed20d0fc18420c78697f8e91b8aee504caaea147f8330120a5a184800d728d9816ca2d60d4978207a9054431feefd715327a4f7442133d0dcfe662689d4a0ca397df642a6753bd04f24018f76617d0da5e813489be84b4a65bd648efa78d507dd107e0befc07a63f6d40caffb232f428a345dde2956027a4d8ae69dd74f516660c3f72e5f066fa4f464b5da946b62b4031045fa417c213311ac8d339e5478925e87ae196488a333c383c4a101a19517e9a6f17365a6e52d46304ca2c9521bd23c73b732e0f4a8be1260f0820fe7669446daa789c9a2b329e3f8c3502c950914f8870b4e4fb90f842bbb0e681132ae69d232095a9655e2888058b5380a692b97a7b59f4017d2ff1f0496d8db63b4444bb418e5e20cf127a27700dc35bff40a745cea070e9b333147518ba1f6e2113b2a1e3f0cc271c9b8358bac64023fb0b129b5fd05d5429e3a3b0f0504f645f1c6c32d4e1b4eb9f83f10437d2ae3e1bc521e68bce83cb0174979e8b9fc7ba1e10d88fcd31230501c9699091ff898c927b7cb41d89698182413d6e2c16fcb883b502f3734efd73c8cb3859d0062972661c213e2b0fc552f8c8a0c2b83b37da9f05d51dc2505caa708f8e744d3fe2ed398f9fe5431dad98adc75f9180903c0243</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出计算机组成原理（十二）</title>
    <url>/posts/a681da18.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="7d6213e32d7be54ac66318b19863a4c34e6f3946d4049c20d8494c2f4a11164e">fb26124e0d85f363a66baed35993e1a0948953cce3d484fb31660455b92ccb286ba4467b12dd2afdc0f8bd795964707216933c479f00faf5302337078027ef66e68c754bf0232403ae44399aa06a2cad741400e24549082709cdee4a1c1e38f29d8bb6993c43448bafc4543d636ea5bfe35062ad225c74a80f232ba51d9af45093f5220e616be2d57e02341ffad661bef2886dba249b54377d8b3961fd62e8e7033554e6a1a85b429bcdccd8e910eaca84c8e447cedd760cd76a16c64ec7f94ad050108487716cc544f1ca685285a120a1c590efd559bdca18a90707fae890221e2912f079f089d10fb816e69e85944586941b721161d200273028ce2f3cb2d1a6a47461dcfac58b4612622383de37911e7101936179b0ecfeb18f3600111afc775a9e1f79696dae92585891ef4dfac1c97e604c2cc3f220ee046b9f9f00aeebd9042c64eae3fceb33b8c23319d64aeeb3c81f9778a893ccec9f5704cb7e530c9231f5cf3da581266dd47e9ca557fe0e19f6780e8b93dd0770237d4c94c483b9cffd8acc544a0fb46b5dae9b7a2d518095c7bcb9d8c3e85638476d43203882bcc708e75293397ee2089df04d55b8000cd701841c325d8953e3c260b005ed67213c64518083b8b259c194bc61011f426b6c8515ef2b7426aebe846c3dd85e007181e73410b8ab8f38c753b2cbd54651fa74162d676dfa98177fbc6e52e3078e51e28e89017a9fdfcdfe3c207c078e9bc4bdcfe49d51ae51ef5e9758a5520d06f2d0013a0f62da0a388cd9f5ae872fdfdc1d90c2e729274ab9ec615ef3e1aa97e52dd5404a40c2f6596ac3db92248a9c2efd8b03ec081170551d23960739d96e5a452754712351b761fcdaca131c8529cd2411f9a719f8178594ba3e698817c692c4fe001b09ba33db49e25366cd2dd3c3fd9b89e72d9584e1970757b2866c3b116b9c0137e4c9a1401f6451f5a4a4e79e410a9b24d20135837b289079c8cfcc9e0ba7890f1f2f799bf729377bfd16c79dd859e2b2b8146b7b6b950abde96b8e355b8f5648ffced464b9dd604d94efc4a5adf5c41649199cbd3810f8c1b0b727ab7060f82b7cc477600e64afa4466b7db2a362f9049de163bac6bedb03fb3c6ce6a9e8316324364d580c882dffe08ecf62efa6fadf0e2f6e99d6c6155c808954892ad453b9bae354024be035eda1712c0f7a9569bfe399efbb3b38b22e66c8fd9e36771c319dd0995ac927e40a0ee2fa25b62c0f5691a7128b6416d93873eea1852173f81624b366ca75078c1fb9de732c62ee346b7c0fe42c6c8fee69241959ed3782e597402547f655bc92cd797ce11f6f0e867e4991a770a030cfb8d29d5b195ccb703471a7ac7de5b192ad40267b61702d7dca61630d603dc08f8e42e951d84f57f1ae017dfbf3f7c0d52cee3c20dd5bb68ffa4c0b91cd2203006efe79e02b5eaf88a028e757562a47599b356b9b58dc1aa9bebb850a5a9f7ecfef2b2ae3b6951163e36d2ea350481534d6ea5aa41fb98e65f1bdd303aac41e8b37da3111b1ce2a6809e357ad39f49d018243e92dc5102cbeda4d236e3ffe3a15ead875c3c207f639d9ad648d25269c4d773c66a6cd346eab70b00cbfd395335cd79bfea2ecdcc06b88a19d21f5dc06e89af765fa5c314cb37c0e4fb273cc45674820f676cccd75d95a3e4c7193c4b44857e314918127b2450bfc0f4f67cebf52bae3a572f8a198a118cf789d41c71545bddbb519e05adab1ccd4483d25a7c565c0b463b6c9efd750bedbb54c34da09cd41ae5f3e7d08a1bd637caf7d9445f0ad5bf3ca8cb9a5b5f2d8c935b63e44a2194cd3ebd80607f476a1d5594f6944339a1e9582a144793e9f18a35dc86ace3d90a66ca4b2b29f1d6f1fb2d13ed98ad9a73a4a463a93e020aac2a1c4b317a4560178f1aa560fd0feac1839a78e722c69e41aeb15e2c557cef312a1772f6e5afcfa0041b312209c11dfb58066b665b323ff89f883c011df6d8aea5e4d18e8591b6fb660dabb0f5ab26dce0a638ed202cba2124dd8ccdc3e508fc0a2229de21ae1edf1a4d408c099416d65e92146d4960876d4cdedc043b77ef9c736d956425938f047542ba8ec46079a02ceb4c1b0d82404b6e459e8aff90294ec877fb25f8ff7dcda0307b812b435ccd67419d62dbd8551ef32d171c86d5800d44ab273db7afc8c429767dfac9e9b1b3762a2241b3735e255718b97639ea5bc4112dae92c93a9f827ef4036bceb268433e4b60af976aa53fd4a14ac5de7a2c614b5c5a386cf4c46a9eff5dea6df9f69a0893773f51efbfba2377a97cf92a144427ff5795ec6b243a9cf6d8d1e8021344d6f6991539e670833a1fb25b3904d02ca77d0378717f5a86784e5280acfc66dfe3fc93efb20dd5c935ed0ddc9ef67d8ad955539ec7ec8099ba131fbee98c3e4dcb3f0cfa7d67bb15e0c6f0798fceed227d25e37189dbefa1a488f760dbdce97df1a39006921043649434dff2031dade46c901691de1f4e5941a6aff3fbadcb361ba73e8b61dbbf872f601862c5b8f6b02539a818e383b3957ec2bf514b2b2738cf61128c7936694fdd26d2fe1e6d1c82c429a9b6bfe7bc5c4e82ba291f0ec04be43fab40d065b4faea2601ffcec6400c030c03086215896eafa02cb9abfd108efaaa39d2f916924f9ded2fb3ed6556d4b7232d68ce37e8302b7c2368cf7a153054c17f3fc2d96a9f403a9e515ef3f891bb5f6bcfb7b9a2074a2d075d6d2daeab8ed0eb2546009a4e377f0cdb9b1bdf897278577fd75d12bd82837f26a4b1a595bd8cc7bb302dfca176fee5700e7086dde7a30c6de56d6d7381c730f319794460f359ca0920274a0c6fed981f8228f8bc9d7467da3e7934f9da216c943f8ebd4d4ec73c83f692ff5fd00aaa01c3b1a6375571c0382e32600c5b84a67db4b382eb8d8391cc6b0788666353d357d8667cb2670c999f998ce74a90424193b835df6f780e7fbaa6041d3e68510c4e272f0889dabb4ee6b29f971f0e913d2d575fcec088543aef957596f1ca7da726c54ad53025aaca9d49d625508df90eb233274ee093a71f16c6beba80db74bc4ee92647d03d992918ee7a5ea8e191b18c40929e331219f09ec88ffaf4d4f2e34f0f26e723d49d8c4c73e5b2f90b010fb27fdac8312af117ca1a41e4b0a749baafe18fd0780ea7a641090957823582d45c618af4680d3505b47a037fff8b612eca64c28e5d3daedc141aecf3ae9198edba079ff4f8d27b8da179ff3dec2aa52a8048a03ec858919895b58afc92443e926284899cd47a49a5ec0b6da7df756dde987d2a062678a72c936b0ec32366f38d615a8a5fc79b385629ae7affe5695ee8341ad24b076d0932db83da1a4cd7c455ae121641ff3290d914471112a82b6c71a295dd500a1c7a9b8b21d59b3b61027beaedffb54602ade9be7a2a6d2d00cd8b9879424e9a9db940e89813ae7235fcc2d010b19fae993acb3c9328edbac0ff0ede668ca20beceb0f5735ec3732ce51f651d03e369e799d7abd3247423200792c9cf3d33d7c81c4541d75b6032caff3b05060be209956750a0dfde8e7f8c93359819953af5418d9c29ce3c5ea72cf5977eb37c8c4b27345322672a18967718e2a8970b1968185db0a2e6693778d57d24aaa15844fddc779200b4d82b1378d8ae247aa42e2ba689f478d17e0b7ad9ac524e96585caa3b5a6b3cd7e1099dc7a2936922ab87bf3dd7badb0688bf2b752c4c5f679e1f79e0739ba2b6bd2d16e1fb67add67c5369a915f6a1888af648976904b92871c933ba5f5803ae603ea29dbc626131d19138d7c2e68526c335f9ad5050e260911341adff170f8cca6a40038f0939d55a4fcfbdb6b03d9c213f06e369d235c4df9f2c28257e0336a6d26314653c3bf0b40641b6793f09b51c3494b076d13a898879701e5eff73ddb0267f96048a25551711492c3465981d56744b178684fd7df4ad041c1f88c71463160a4177edb56361abd17e0c8fe8b4504814ebebe7cb9a4260715cdeee1e534e2ab5e624cb015f136dc7c722c9778ca5ffedf232e3115dd86434a739d5b64efd84cb378390baea179e6b3c09da825cb7cbd52d3f6ebb228f3445ec1c57dced437390a79daa38978457d135a996c1726f38861df99714cbb6199597cb5ea4cd1c4904074db004586749f9250aaf657e7d4e6ae83a46682a418d05375dcba0d3735dbcb44be2e9d77d42aa5f33faa14dc1fb0e099b19510abd4c1c313d9108998ad71c679ca2ab5de9390490e4a3cc75b2f466e8d6e5eb5ab4cb20e3f5a44f92352a1d446875dd34af69b5183e7c312b7cba2f26d4247a452c4563bbf74dd4b3ebd82b0508f1be4099182db058293fb6b81c68b106c99e9e5e211b9ca25ee0afb994da9df29fbe24438a563479e76c91ebcbcf472c53a744d1e9974a16d3cd0f5177b777c6f49257bee1fd636554a469ea5afa1f86ade7c1ce77bceea549956c30ad98cf4e36f4c14a4980dd2242aa9f8ce9b39660d4dab77a8cfc9eff291886e88c6df1495bf2994bd166e424cf380eccfa34cf0180157fcccdf98c053f77e19514f73a21de28057451032bffa8de70e824cce6029448a2b83fb16e4f4512fd16506c4f69c42513f5b9edd78ed2109cc9c83c8692bb30a2f50f569a7302c952b2cc616d2a5a81f845b32feb8d1711c54d2237f3a0b731a9d0d643e9949564b370be2b7960a89fc8ec6efd29b4c22db7639a7fcba28d5fc95ccc865f2e7732b5ea859d3809770d77e2eeb9659e6fe07825376f11d4f4a18068f0ff5340d28f6ed0ef27d9b7061d2a6990971a3ee984b7cd32f2ef35b742da96183c4becd04ab65b3ddff7adc1b7c2de0b31a849fd2e9cebd151644c52f6562e15936319d6e5f1e4ba304f5c688d8dc0f3ed706daf627d3c299c6cbc93f698c0bcd9ad7ab820e2cbd6d197faf6ae6a5b62a38f8b9bccc03009e0f880c5e2745c47b2bd9b235ed7514e8debdaa32f411dac35fbc43d72f4fc798eb06c872788c01e62c8fb87887e9fd27a7941118bef05e10c4a4b83c4f8f47ca2250879cb1286ac3b5833b6e1861a6b9ab81121b0b7ff0ad69fc9d0b4c8ea3b5f3b1f6323e1609986f5b873640b93f2b9853fa82af7e53fbd917a7da7dc62f43f54f58b404831de2e68e9d325d7c557d7e1aa408c0ac1dd72ff6ba7705cc67895f781867faefd8dca44d38b8f5b73b18d0bf9f69c2a0e12b72382fbc836287967ac16024c0bba779875219ada4f44167aabe4c8b3bc031da8b4d2c5e02a6078bfa4d711e8a46df9d40f79ba173d71a63442681d2e4a52cbe2d6f77dc3a2a62536a55563d92ab5cd84ad27cc1e48b1a7fe7d525fc15dfb124bb63ee749cb114bfa4f8b417af3137f530ada4b982c80bde70d69870dafe8aa48644734042522acaab2d3e264e2ae314e6f8c7a11129e66332a64bdbcc389ae670d847c5020effec3dddeb5677db81ca412124932a81180e9146403adad0fa208a1bae48b9ed711f054141d20db24fcb00307f739bfabf66e4cfaa9fb2cafb84d4c6a8762fe39892071cc1bb033a9d3dcc20fa623ae25698ba28ebae4008296b99e62fbd720908755636b696fa02403e6e6fee0146a3b6c775bac693a31386ff156109469120a166a839907b05b5628bfa796a71295a518ae9e6cd8216f045b4cb3e3549a08382546842f355ec58a872795c7ab237e5b2f83ffda83b8bf5211f875d04137f4c9f2f03df0e77d892b60ac9b56945b175f0b52606a25649eac3a0ec35067ee787764d32493162bb84a977bf51a9e01c9ec97e42015c0635bcb5d6ffef18d0ad7aacbcab390b88aa61e9d88fbb4857634944b6eea00699bd3b856350ab133f7bd95581f07d439149d7ac5bd8bb12be43d6dc8bc38f4a8a98e39890e2bdc52c66d2f69c0f57f8c1813e040f14be87d391098ba14b5e2f01d5863c56deff01e1eab30fdb834e9a398e0b27e5b89918300fb2f6aeba7bfeb513a2ff860c1dc6ac6f57a5df542d654019f0046be437886af9047f239c57dcf616c2fab4200c6fc019e0e7550c03e666fd2134d4eb56813e55257ae51cdc6585f47527a80b4d0d3ddc95100264b10a9c2df2e8c1ee183b9ffe52ddc2ab7f50cb96df57b37a7fc545b11182a339f2f1c3fa88b6e939393eb2755249514197a6967464be3d1e385f476e97668150ce63312a89ebe695b05ffca636bc7e9f30b0b26a6dc5f4b79ff6182e2c3d408eeb631d5f5b483309daea65106c808bdbc8a4f92a33f4426853b1eb09ab3535ba3fa68bb439d453d5311d6679649089d858b194d4b5be284888fc1d0977dae2f97ccccdc5f6e03ca56dbace48732abc59f4af272f41f0965f02ed3eae6d84a6f99d604b5508db5edd02a1e27a5a5d84ddb65e78777d0cf543ca0afea86df7a7a6313ce02a069599eb016dd355398544a6deb139bb247dd6727ddda70d6f0bec367ef01de5154e8818fd55b01e7d49ff5d734a3b5b841249b7371c431c72b52d6265375e8c10a1337eb791c4843ec89423652dd46988dfe65fc8f02ce3be538f54f2e4d8653de992d592169ae64d01afca27a191835e30c2bac41db7b822e85ea0e5d569f429c59f06199910ff9e171db6e7834957588b799aedf269df04935d9c71cfcad3d4596364645941958477920a88dc5f16b367b81162e4d75320b6b4f2f32cfa3595118f443118a1eda8b7700ebb54bc23ecfff31554f1f7b21c4fc8912fce3909ac8bad7864887e09e136b67b422a726edfbd8f0eebc13ea8fd6860b6d1fad7a79bcb2da9c04b09d3125377227b84e5c4773f1b437d63c52889b45c0313d2954b54bb6ed04fb03686bbe79b5969b5f129bea9a5e1a53288b3ac103b758e3f42520f420a37f928f7882903ebe9eea459de31b57fa84648a6a657aae43754ab18733b7dc6d43970508ecc81356492fd186365d1dc441bc2cdf81ef64619f51d822ffc9a5a94a77d5f0c0e2ac636f9bf9ea31955240419103994bd3a452c3f987b90be94ccc001eb8ca62c6a4fdd4ba6e2cc385210ea99e5d97b0fb14c9793a33e4555e52f3efe8f3ef31f1ed5c36a27b0ce6cba2b516c81bfbcfb9f2c371b7c30f5556eb0befbefe1b576f3031b00c54c35a503abaf9ee694d5b6b5bd3b235127f53a01dcf3fd45743c4a88d12e132177ce1d43a77b47ad4b2a0052c557d6bc2816cf12623d09330235e7d7ca19b24454a708afed5c5f53a66b68ca92e37f1205f1a71a1be9eda0347edccafc582bfa3b3395eb4d5777a618b6e55126c56b11f086ada0c5ff76982da0374e2f367b44bcba99262ea08ea10fa36cc49765a53d57cc0d65a75a605fad019aaabbca009a9579f70b4a223358d420b2ae2934783994e0677402133d378224d20c21d32ecf832a38f7ebb8b98246db2c2abbcfc980542deb33205de776c9e9bb4e641d0acc3abb1a95dc0109738a99e759b01f837a66ec7bc593ba0a22e0d9019dffba35a75d97251ec9cd7d9e19d8f136bcf0cf73cd3fb5e26eaf23bc1fbe51fa8bbefcef81b9e8b3ac5aa03e80e7dd6312911c0bf17da57933453bcc1586d309558ff3116435905b3a4170a20e4ecd975b9c0ad02b778d3664d27888286675f9b932288b9c185058cab05e9df6cea47aafdf6c047797acb87dddd2a2083bc693ad07332e10d4b0a871f37b3719f7ec7f93eb72ae31f5c2cc5731e5af5a0dc877fd581b22ff6b386fdb91812cc408d070b1155d887844f11ff45e739f6c88361e88eb2a8828f80cd84e89ed6bfca9955604cc75cbcf756335179509bbdc0f0869c57f2815974dca3bcbf1c062aa919a0e8c3c3f9e5694459652f5bc9eefc39279907588c6fd71510c6e167862baf33cf36f99f196db2b604f08fdf90339f966bd61ad593e0365ba2534ee995e3d104d2801791cfbcec349def344bf131a74d8a9b23d23dbc382d7a05791e22125fa9a07d0977b404e69ea85dfd7ff4c11136005b9c2c1adedf300c569040bc86108ab5a0b62976b5efe28a81f50eab36bfc1d4c98f2f83907368bc4bdf18046099e7bf26bb7db73ff90457e02e1464ae6b28b2a67ad42aee1e51e6f97e32b4f9b24bf2edb84999747c98d5dbc6e358698a4f04151d448ac279b5d97b457577056eaa3155621a932b9f0a22a0366ef674ca9acf871613215875e1196e16014852a8c25c3f902e800dc7a456ec929a9b2421dd0bb04782fc2508cc67866c777bb0d5a7615afbd1a0017a5d1f73a408e9d9df6440b40f782bd722f1f74ea5a6c8cc421bf67998278dfcaec98b8383bd13b7ca12223f438915ee1c61b692856b8336d5fac85517c812da7fae806a25f3318e7373a65bbe16912d772fe9abbada02f297e62b099a9b007145a2cc2fcaeb44e5f099a0ba24642a972dd640ccca4a5a0c11eb95f72bc63d3c727f763c7c105124772c2fd350d8ba3e54ddd6597fde0a6f15375e5503299e77729fcedbc69eabef775005550ebdcee27d5a036fc50bf3b92edf7af4cea21fd27916f6214b0fedf4bf3619229934b54a0fa8652459fd518f3efd10923e24f9413a27b1c5f6a0da12b476bd99130c10ad69a5d1b0549bf0d4042d0051bf551b76bc6bfb919219b9ebb6114c55c1d501fb3f39e2363e69dc30bf33b6104d3e4ae1b31af87526904fa9ed35228287e428f5cfdb607713dff82f72c847851660e2e42babdb6947d2790fb511f6d8aa1a7dcd6db556e94c87cd7bf983a858ebb8945d02c1ba2dca06f6f0755b9d53f9cf5739428871c2c9ffd08f877c02bc6837da880bb44bfdef070b5eef871f8932c2c58a8e5f1b312f6f6b23d3097df3dd93fc032d4d20ce5aa76fca11b50b9f8e444621059f0eb53d0f25ed13cd2a3236a89c4d2ba3921a2bdddc2f9cedb17bc98f463a00d847749eeba6da4af94c36259abd976f61b0cedf2f90f0d32f8d08a96eb198ee25601c1188edca2a863dfd53c46530d7cc041b764919f92540ea30589eb7510877b435a0cbe8a7a7c85bca6f4d8954d01da701f1150af6809062751879e920dac74824804356ebbc798c3d46947c8eda2835e4ae81bbe4c198ccf9df83f310f5e5ce8ffa26a0b66f0b39ffd16ebf6dbf0233a3b443a11bc31a19586a73552a63ac5dc768f8ca602bfb23e6571d90bf05771306163c9411789704e7674267e534339ca8632694ca8ce835e0839c47c7e2690087e8ac8576d7c68761adbd1581877a7f65911f34b07c5625817624bd9db12b3aac410e9b4ac0c65eb1e0c5f0dbffa056a41e9237f3801664605b563eeb3950e42b574130cd6d68bb2072d90c369a99fd78dd755f76591c5b30c53d9052350739b219940456a6179025b233d3491a3bea698b8c35b4d8525fc4f51506495f1d2522014df7edc24e062d42bb0c83cc9ff855729b3487cda7091ae4619e1502bf713f833454afd840c325270f6602750dd53018bd0feaefed23a0789c612ce242e8bdf30ad0098477fd54e6054537e4d18afa81bd00c8bd743ae94d25f983cbd8730f361c6a3ef9bac3b9627077424f3e0bb0cc040f81068896dde519438b5fa174eec39b0181ec2e5debd377496fb80bce0abdc583374deb7cc1085ce75e8c86afb4795d41852111e460022c84733c40137e382055420a8387038377086e6ac63ad0b97739eec404a41045fdec55e4af454896e85098c21de1e694636e8e827fd707ba7c5bf2bf652d706ed122efaaa46dd284410c678a73525177d30465cade10c7040f7615ada64e16deb4111f24113fc3c24acd885ae6aff3b622c8e5c0004d8af782bd8f12e6c11a8c45e30800e5b1763523a6c37359ebdc329e59eda4708e452f857ef25ebb29271b6de43c0055dda4dd30090ba05374adff45a69d2c3a1813abd276bf512cf18ea1e3622ec983802b9ee0dd392677185e799c427b1e86c07f752c92e256ff8445cd323d67fbe3f7e879092624aa75b3ba24ed7a6fe08c4f823ad38a544a9d7b47fb17c5e4ade69ff4be91b48f0a1081e487360625624f48c8cf9625abef3dd8b4921d214db9b44c5cf21b1b364a60e52984411dcaa82deace2f2cb71b95f8b1420f127b6fc9c8247f787d4ec89ff466beadeb3ec209b58ab19f1316454401a0689bbda8196dd29274ec42229c57299fd9c3903c1ea25f4b9247a3202c11aaa34115e807587fdadb770caecceb846bd5f93d435a59c638d6c7d95ec503875d5320557e115d0ccd1a729a3d0fbbb2da5f27818164dd596e21c499d301a3f0aa5dcdd121bbbc07aad7ffdca3eb22556665ed598e78c07a72f3d3657d55c9e83697b92820e5a16f3b5e0508f84cc7ad89c3408e66fe1ad8668925872c5f3b4d6753299cc106e9b0f4fda20d82945d59bba4f9528e33ea9fb0d6d3973e5a541a89000047df9472493d7d3783d5e35076454b35cea9133e00d85edc98f654637a8175429dd67fbcd4f673ea0448c56d548d4bd7eea8ee5d58fa6ea84ba8879186d3eff06e308e265409d65eb39ab2f4c8de2e493a2ee87d77a521e6843d4c74deaadba1cd3847a0431e2453274f76789e8edc6c8d29cfd38517079a69c11f879390258d962005eef46b376b145efd9dabd56bd3979cfc4957becd234f508b5ca05871609e4114be34f6237cd3e9bb7799bcdfc63903584e5b9ff081d8f553f9f4f57442640be2e92a17c3a8f2a54ac11243727ae93ebc6c15387e9d61cb78487d35433675579eaf5f0eee2218c9cb83a7f48f8e2428112a398b3e09bdd035581b8ec7b3658ea42aa48e8b5a12723d8f105aab6300061b6da1dda2d4b959769166d8e502acecc12eb49fcf0b01c8fdd77ef4a96eb4c1db595ad40f0b43fe66c6f777f1fba4ab302ff08b92bc97f9b34426cfe04d2e20a5f09fd44fb100185bf55cc1ce3e864b116daf4fa4d93e3784da5077e3ebdb82896434dccecc43f0a19ea64381fa084003a68e7d6daef6cb4d90933a3350de7b988349c745a498f28c1caeda16f63b846753ea24db8e3c79749c180e0c0178237bc8ce60a9672e07fca33f1206685213de9a1a9f7d75e39846846da730a9769f86e22de19c10eda0bc08de6d4133d938f28a75edcd736e1df829910216f48d97e0aeb31dfeb4e8a4c54829cc3f309e0e9528a4acf90cb4e22aecbef884a82c2538638a4dcbfed882272bcf2d2c16b490ec5a9b8de4a1e4a859893c167908a00b850b751235e2ac88bf5beca6add5e7b1831bd240d484759f9af544082411fbf6aa10202e4bf97b92e5feb64dc88a9175bf4fdf5acbb6ba15ea65492c83cdc9c6eaf10e870ec818bfedf5b85e2b285c1e5751befbaecd70c0ff6dffc7f9dd6da25a0a51bf9e23e2f02b6d959e29de937a56af776a8233e77c9f55d4e6a0caed40b54ff5660ccd9499a104949813a331990f39faa4cae648d83c87fb9092abc59ce961bd1837986f3e248d76fd9527a338344fbdfae60d189e1f64ce48b04845e36c7309753900a46e04d65780104037bccbae6878f4a15af5bbe5960acd92c2d006a206724ad5d2012660d63162e750e3eff9275fe2d9470bb369d7acdd8305dc5fd55dd496e5c79a4e92e5fa0886ca120b2b3ac39e9cb3d8771b7418221fbfae8c5bfcada76fdcf9997fb5ad03652dc3290ef1742f66964583b768d77ac5b9a255911292771b622768a0f6247198d890132987580b09b1bf8fef294e0d2aa6d2e499931196f8b24524786fbeec2c36f1f5006bdd469b20df202b94ce431b6ff415ae417f738c393f27252fe64ab47c80b11fe7eb1f9dab7e89f9a0c2d693059101c7300667b5a42413459210f101f58964cf9a9a1e3f15fefa189ec1026b8a2f3857fef3463be946d4abddbb5d6e985a08da564be4376f1ef430bbd3e5aca868302a9e1148122082a11eda0a4584b65f3380a5ee4a257cc82289ee7889814eb62f46223f11c952061c315b551e5beb84fd50b18c49b7e88367bf26c359e8c928bc3d1571a33de2799174a269d9de484c56e78725cf282e5cb350bcd8a110b8e65b955d7c7daaeb473b6d430986aff5d268d4f656801389a386bd0de89ef89ac98919d2b5760aad95804931762b679ebe64bc3dbdd19764894c31d214298eada24a01fd376acce1a4a3db79107f8fd7684ef1c5195cbc30b3a45539c1183f6e8e29f851ca28a9aa1b5f022be52228dad054e6c00cc086614e1dd182217f883d5842cd7f150292fde84e0e7a5785840d07343b64f9240a0fd77f24696c9feba1122c3caa75c6d48b83880d600d7ad36195f382000396753d4f12018d8ffc8f89906307369cd4277c2d3ae4fc5017e7f297206f6e922c41938030dd653bc9446d3d773d777e4b6050273e640c8256bc870c208043fceb466c44e5e8d4c18de885109b34c549f6f9fe7ebd13890a90a56b0b15b2eca23a2497e1d25da90c511acb2e517f6f6c69fc9a27be399e636518a1c5f1098583844e317d6f7487f8229fad351880f406b500262ce53cc8067a99dd3213a5428bc9513d8ce9aba823020c4ccceec10586338cd57a1af4db3c6a2157c80de45abee58861c8071f86def6db65b7c6eebec7729b8c0d457db409da607ad92e66a23e23c7017d84e3599a9c07e6e0eff00b28ef3148ca821e03700d2bdcad59389498061b97daaad75287ffe087190aae7db757e37fbb65476f86f70e43ef77d0ada029e84bdd3047d789cbbac050fbf7c2b1ebfc5fc987b8c0458ba448b9e0e98ddfae76df8cf4e9fb2a2c4dad408ac276737e2538e132cd44f40bb149f4dc0b65d7dcb3700a6f63e80b5492a5aa93ad226fb8432930a8aebde94f674b08337d93ceda39a7190c9131d1eb15a6f3bd9ab13784301e41c677c505913ec2b409d107153eb1f4f8922cbd390e9825345d2fe124a04de987356a06a72a5a4ff49e2407d92e9f6177069d4df5c113472c124967295c8d2cefd8b071b24d60ceb405af573ea4b757343f653126f6246a0d2f0977eb64d570827913f3bc1af83d1c097bc2821c9bbe61c943e8cfb1e5f2f08cc861894b4b8381d886624df3002abead05140de3f8703a5bfe17c3619636d29b29362f67aa29c0442a4fbb5884bf8d659d904328532d7639f789eb61ef91a3e7d5ea0af80daa834d64134f0968843443d6368979fa525bc4bd4167cd6f403998ce58205d469a129a9a74fcc791d48666fc4e7b74bdb54e5db3580badfc935a08c05a71fb99a1fd3bfedde7744443d30a09f530a0bfd2aedd7ae9d19968d32dc058f25a716483d5ea871154783a6ee347de0d0ffa2df001dc769c027725c1a4a22622442e64f327a3d41585c85d0aef03b738fc0ed778a6b48815947d04a5eb37dbabd9c35238f801e452b0071f478d36e9d580d55d566e74d2b2e23020962018557a89355126338fe9a51a752163b690a8e57111cebad36ec3077d7378d851650679d760ca41b708c02f52ee6da24ff4a4272f597285bf6437ad9cd4243a2a43a8c2e9de77c3af18551185ac15b9136aca9e4ec390e0f542c3d42b2fd63cb5488f21d26cba8cdf3f6fc0ec6948354e9b6ec43eaaca9a0aeaeceb3bca5dc80005b5a36c29384b21593f0fc517aa7884184262d77739f6e28abf261327b294a0b843fc9a176ad64f88509dcd29e802ea04ab16d8346a1d58dabb441e7f2ca4f81c31a6c4211ad323811a12a79aad853be9a74c38c100cf996793cb680eb87e734c9070fafe6cb0c44d00e77b4eb0988e9cf0aada2f27883824c26d1c58a7ff8a4b1e72d6e9598cce18179dfa1b3db014b9d613c18b17575e5643e24edc78fc5b2f8626f16868f0cae8bc74686d07d605f28385a612499aa1c90c573d3cca7597ac86033e05bda4ed13526cee795d340c621c9e79a16e79e9e20da8543daf6c1207ed05ad9281ec8bcb4963a9eb4de0516ad02403376c3e8a71ec768e00a0504f59d991fa730967b47ec346d0e6992e02ca51b342773b988fe6ab276c7fee6f923b83593c0c8bc276f5438639f8bb7bbe821385531fb59f6440bc7bdc3c996fbd7f841d890524acd68c25181fce14d523348cb34c935a79777cf76fb1c4055010c1a75b9a04a8d180ac05026b18bbcb084a208c64f148dbd6c21ec9f26e3f2a2fc9911542659282a58e57e3440c60feabb901f19f731cff03342ebe1e399c6a8e15e62e543b17fedff21ec686ccd8f6038ec5bf0890f131a645df2ca79223dd84120534a332972a4705ebe0d88246157bd0fe28b63ca62ca05b3c1f3fcdd660a5a332b662eb80f8d90f3f034f136ad36e72873875298a6f7ab9d2384471fe71165f1a8531c466ee93317a43c8649e4059f2c071149aa249a829b83670f72519c5ecc7559f970cba616a1ccb7eb367104de7e77bfacd6c68dbd117c7a6cab7dab9289de3428ec9129687708bd5131a15b903241c042fcde0d04f671260bb26bb54a7a8aec21c40074d5686432cb84a3c169fc83e67efa41bf7cf020045dde7e36584bf90de68ba3b53932e7bbf0f54d660a78469c315f50ae4a5f29a1171674806eede4f39aa5bf5aa98b90bed3ad6028caca9626e5f608ee1325221b018b6ae9fd1009fb048442bb62029b8f42b7b8edaa5f8bc3b33016959262f5d04969a38b3b0057cb450ed626633b306c4d91479cbf1e23eeb5cb09e51b0ee87f85092aa7706c7fb904c0331d2f88f7409deca1e29f0637bd88f2001255c1dd3fce1ee77844abb640163937b3f240f32314054fe9cf62cab7c5685d83544e132af1fa6b99337db8df3bd20c6899dad11b359f6e27869ecf463f5b3391a029b9df93a7fa2c70d39a918377aa5adddcca719a75b28ed31801b0b383e1a415750740c35eaaf44f68ae2feefd7bd21f958587e05fede413ea3264ec12bfc6f37be72f63409fcf66a4d48a7f1a6ad417094f59b470059d59e7d51f7b4488611542d2fb4cf65c81fea4a3d823370fb5d6cb1111c92f16c27f37e1116af763c78a167e1a9fade870230ecdcdee0cb0c2667b3a5492fb1f4d80bd8a9b9353863acebe23df42d6ac278ec4332e8577388b6aec8dc715e19bc1677781fc18259fdf08d209ea1dad24b988fe5886e786b751d09cb8b734cc450e57aa94a89682229f16a278acd33ee0893db7010cadc474df12e71c24ac7d98347703a0f059fc34a455ad0aeb0bcb6346728d191bfd40750fd02399211123e37c994fe1724b24faef1559b2708bd970a1b55f358561b22eec3ea650285be5ca4bf776f15754460fe04c2525d09e97847dc83c4ab7a97f019bc934813e1c57b1458bdfe1d78e825b811313c936ce50c1053c407cfaa048c2a1f2257858e1a2f25c1490293a300583796f9d8e1932b271727e0c4c2734d93611fdc759b7760c875335921cdc19820df9f19dd32d7632774a540d36cdce3e7a6e361097d2f1cf78ae895d8d3b45a245c0887f85e27a23b859b48250a843c95726fa6719eb375c00221548d23d5c6881c36da05266234046515f6af0db59c1118da3cc8b46cbd03ac3763f95abf4c592bd059de30b1c2033fbbc165d69323217ba7cf0143aeb9e89401aebaf570b4b39c27cd5f174fe8db9fa0440ef1af33b460dfc49e66fdeafa77b946b30594511f851ca33c92f3eb1ec0fde529532b053d610c8ac5f8b2373dda6bb415311a</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出计算机组成原理（十四）</title>
    <url>/posts/5cb2602f.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="25f4dca2c9366cddfa2366bb522ab8e6ef4ae2d75d9ccc7b81a6678d3f538083">fb26124e0d85f363a66baed35993e1a0948953cce3d484fb31660455b92ccb286ba4467b12dd2afdc0f8bd795964707216933c479f00faf5302337078027ef66e68c754bf0232403ae44399aa06a2cad741400e24549082709cdee4a1c1e38f29d8bb6993c43448bafc4543d636ea5bfe35062ad225c74a80f232ba51d9af45093f5220e616be2d57e02341ffad661bef2886dba249b54377d8b3961fd62e8e7033554e6a1a85b429bcdccd8e910eaca84c8e447cedd760cd76a16c64ec7f94ad050108487716cc544f1ca685285a120a1c590efd559bdca18a90707fae890221e2912f079f089d10fb816e69e85944586941b721161d200273028ce2f3cb2d1a6a47461dcfac58b4612622383de37911e7101936179b0ecfeb18f3600111afc0bff0d0646cc8662e3815e25dfa1adf9</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出计算机组成原理（十）</title>
    <url>/posts/996993ce.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="2a93daf7d02be12c24341dfa19af99a3575854691dba8f83ff919a38ffd2bacb">fb26124e0d85f363a66baed35993e1a0948953cce3d484fb31660455b92ccb286ba4467b12dd2afdc0f8bd795964707216933c479f00faf5302337078027ef66e68c754bf0232403ae44399aa06a2cad741400e24549082709cdee4a1c1e38f29d8bb6993c43448bafc4543d636ea5bfe35062ad225c74a80f232ba51d9af45093f5220e616be2d57e02341ffad661bef2886dba249b54377d8b3961fd62e8e7033554e6a1a85b429bcdccd8e910eaca84c8e447cedd760cd76a16c64ec7f94ad050108487716cc544f1ca685285a120a1c590efd559bdca18a90707fae890221e2912f079f089d10fb816e69e85944586941b721161d200273028ce2f3cb2d1a6a47461dcfac58b4612622383de37911e7101936179b0ecfeb18f3600111afc775a9e1f79696dae92585891ef4dfac1481c31a392ff47209b6604a032a19b3b0082d4bc22045e3e8abdaea71fa133e52a035d9dfad56478daeda49b7d3adf1f8bbefe9fa776d863a00c34d478c1bfcf9341a8ff3724d92f9cd00be67e1ae9a286014dc53e7acdf72349d66bc6edb8e66d4b42bbbdf9529552ab0f1883eed7fb59880bb634c6809ec0ed1b20cf2fa8fa6798101305e77697224472858626911e784a86b8e3730e4d9ef8d30ff11e32eb6da93eaada32c2baf32ed44353d06f45c0c534ae624ccc79395122ffe46bb9f1b6ec8fbb322eca998b809fa7b46f3c07cccc0c42ef9b867d94bc1b13e0fe923f601ae915c50b4b8070f45aae082c9eaa5026daab3926af43dd4b00515780bfac8668dfa56d81b43de55c984129b0cbdc16e911f8942becfcb07d0600ceb12b6a1276d37385e7491668e1ab58cb0e8c3874b9309a7c0c641fc3f11b9b5937ae2e9ab9f1030635d6937453437c9aa07e9f9e93152ed2bb04757ded7925e8a47d7f2d158dcee95777b5c5855f674135aa891ebfd90baccb66a29b0628db77175e4aefd7b6859a171df89d905452c7c9eb53a9659d787762090bde2a33f89c13c1ae7a72afb07c60aa6cb9d9cff6120b30993d24b6f985c5312c49c44b368f46ebb28093774b97428155f47e4750bb5fd8e2b2b4beb206a6982032dc00efc01a6bf83dbae2375efd36176ae1ce9f8945b56f7bdd1013d86bbabe2bd599a5621621e402eb044d29c8e4bdc05acca76cd5e94f2077cbe53511d1610da95dfa5d6438e95e8a821e13fccc80cd157f8428d3a0a2c8895fe2ccfa5a7ff9debb3719ad1fb1e16fb0f6b3c300db20f8fa42928d49f416eee4d0961ede22a4a82e0b64bd9abab11549b61e34107b43c3dd95f642c83f836416238e11c5846cb4f27520da857ce1e7abc531658d0a47762312d2892a83d1e748562e5a8088faf9f149d34b303b1f64d9dd1876698cf4f0d1c5b90970dd5a9c3c0b562a7981f2fd000c19362ed39d443c3fa38010ecda7d09cdbd1e190bfcdd824e12890955c390fe8270eda2511454f687007d8527823af85a5b9cc5b91db5eb8f9cdb38130637ace4ca59681a2e501ff057b9f0d46d364c627716be0747703bd9e5e0431184f30134b4a7992ade142691ec2777a4c52b03d57547b37704a0d38d57b13ab30cc1b5890aa71395fe75220e573c916a9c85a0ed72bef11c69eea943059814afbedbb4094193d56e4acf5962992f4a798c3e2de54cde0b6fcd741534748799073c785ae06a267d4e5b2afd09bd2909017c35ef2e52553b02ee98bc3d54ea275ef258aa06ef2c32d5f10130107318b7e7a64c4b1ed9b1a34ad77a3472bce52f3f652a9d7ba712dd12ad373dc8500832935938dd833029a560eed22564548b99d20d43ebe0427f1721ccaf14493f95deb40651ac235ea31053d082cc272cad84fa8ce99d0b49ed442d223ae47bca687a6c230cf6fa1236d755efeeb85735461de198848d89af8a7058f6ed7bdc77f880aafb73b14e39a3508b850a79846ca55c51f7ec70dcd3719ab78682e0b90dfb2633e1482d065ba879143138ebeb1df1a1555ab6cd8f34bb1cec679b3e234400d5920c506a4f41f2aa5af6710813362ceb9234171d0495ac9bec6a448496467b25f2ea9a30b4350842358fdcc174035336f75c65ca0f5786717fa2909dec53df4db267729a9eeb1c9d4a486896c01463b51ac8d255464e209d3808534585e63a457fcb3c03a044a652aa4bf939b9481c483b13de2bdff90ae5003daae0c7c88e87ce716ad06a7a2f3fdf22dce1f1d51b46ad36af913301f8481579e1657288ffdab361fd5271dd125d3af366e261e9112d6d8e7bd3f5b49517a6fb8e8309e555709f6b6dc4baa6f26ddc8a86df77328f8bc3be5e4ddd07502667870750011cc03993d622bb34e9ea757e35d01be49ef3014385fe676382f763f5fdcaa0981156564cf163ac7f0a40e8a7656dd97f9b4b9df1b463ada7a95f82bbf574b7424ec5b37bfb723a4021bce1dbfe77590e3522c6c450fb0790ac40cb13a7921bf8ca3f2990e2cef7121a6d40fe378727c8b616c56e45524c2dde06b7d73d1386d8bd692ae63fd9a4e6418cfc77aeaa2a5dfec218d611df810bdf14691c22c953f5d2964a4615c6feb2a242e3909588c451a509a097b00dfda5fc10486db2a894781e58188cc823e6fe7caed977c62345d5f5c70eb3ce51eac6d5ae8dba47e1b23b3550ad9bf44cefb55e67bd5db1f71ae17fcb0e6d190421e4cb49c6fcb6968a7803baf4fd62671a617d28aa4ff97184806803b428ebdff7b122926e95b00541a0958f164ee31e5b698141118d8aff7fcf6e7dcfa31918b259ab16d1fcd438013a736a0e5400e1fdb2566cb4a4e9bd94800bffbcb4d96b60a81db2e3e08033eca7fb4ef22c5a1781a2fd676b65cdce9005fd616a795137e993cf484c995d5ec2bfdbe074668c59381c4161b704f9c7da7de8a42f9580035af96d93f5da1cce3bbb82cb16ed5fa7ac17b2bae43ca80260d3ef72c88099ec1cb7a63533f41bb5dc4f1e4c953723600b58d1a6c29a1745636271e3d3b29b4886dd1e9ff839f35f0d5cd29c1fdd5000e5f87a3111b2bc15c18e35a5824a662d479ca9967fd7287e3aee7d1468dea0cdee6de491c36b4a9e8dcc791d4b66ea91baa5fc50bc80a6708b25292ee3c5e3a83862f607d42c2fdcffe1fbbdfd212dee7e6acc9e7f0e2964c87571f686df8be17bebc84215dfe46693275e05b9f96a4c9094e9aa1539f8e1a7965577800323efe8d8df4b1402c8774e0f03d6c6be30f8f064a23a997068c09aaa98f8a08f5eaf63f4e68913897a8f7c620171a4a2d61cbe6c1fec3fa5f2ef2e1fc9b83c450c0fa584fb4635c4f9823cd743b30f3d777a2aa2dfb38c362f709d41f98664630417fb66a280af3c0d3d9ea5155653d7c2f061dd8bef870ab393871f9b93872c82eb1aabc7a62c7795d1eb511bc4a90cc4d5d4b7eb1280367d6b188878880702fd2154605db4015569e558d21fa766ddb01bfab2429464b052aa77891a556c3856b1c5fe11f921a5bcc774d6d907562c1e6ea9614eb7475e1e7248bd65c6dbad20dad57940ef14497b0be0b4fbc51ddc86c5c2590c3ce4997d498aff8b818ef61b8d6fa2e285733fc7958d59f87b06c6ea699cc1be027590f3eb965c2063a6b789b4faf6ef3590e1baf4e885b6f2e8a01522a6849de4ee9077aae70c9382a302d63808ea17f3e878d23edfec416e70c7d2a15a28f5298a0d50fbd9a0c42deb65625242cfb320138cf4178d8e4aa6a97984bc99067a0dade524c1dbe89bbc96cc351d3404bece06433f15ae536cd68f2d987cbeb8f8a324547a6f378aa35b771e9a3736c0d89913425388021cf67aa7fc5283e416899fbe8c1437c8d88d49550f5387af242497f8fed9f99fe50284e1244ee907f1e483d9a3032303e798b68a47700d9b94af1b6c463730a6296fc1540c9b9c2cccd66437ffad3eec9c9a101d019d9663115cdaf027fde648d6d3a10b85b1abee2e0d90ea3a0b8ef14fcd2d2d35b1ba08118766b375c3d17d9ae970b76d5c457346eac6b81f129faf839ca407ba3dcbd164fbe08fb6a4b2e4bf1e5c1f1464431be9de27068789d2e871721197a7295acd66bb6fc793cb348fb558f692bbabf07c65c9cda5a01d1fb9a16eda9f611ddcb6479d27db0713aa6f822e9fbc9a3fbf3e2cfc0f4dc96215d98dda08eb135e4b86cfbc18a23808d61b954c51d287f58c26cfe6011e26edb96b79b0e6d925930a4ea1827738d529fa58fab7f035e0763d574efbe4e9f6f5be5eba21aae3b2a9a8765806bd009580ac32227f5c336a6c43e2b5ce568b4c50f556dc11e2a58b8210183c3ddf936e885a9ac05f926c6617c60e12dc69568af2e7955a0d85a65ec03a8e367feabb76f20933e6c8ef8417ca4b46ba54dd2c5fc1b2290facbf911d7c76ab072e9d95eacbbacb09e386ee79efb907191b43cc46821bb69ebf91ca6c2a68923a08db1479e0113d26f6b365dd02defd6421bba987aaf1837ac35b0b7f6926144db7c8f44c6532ce38ff4f43e542ca8c6ca13a27eee4349aa04e7dc2a76ed40e1ea5b981806cb8e9e165396e7fdd7989e7e0e1555ee568bb4173fe6d24c2d5aad8613f19d7bbaf4396bf26aff8791fb9e858484024212523fc197d525e83f9ec76b9a7545b07edc6131feb7bcb344212d00bb341946a482b38707bf3c12889ca1fd11cc7177a9b050d8f46aa8c30bf99348267ddcc251bdc548623a867d5d50aea9356456a8663535a54064688248edab322c86f8f527bc0141b046551b2bb6d36410a3e04f9674efc30398eeb7b9c770fd2b620a0d25a0a579b6571a36267c86301e8a4c50d5ce9ade1648a7ae0d12da5bd009be9e87d278e0bf6636be7d462fd9515675f7740488aaa03bbaff33b552d667e699a1905478e4c7b34252ebec9e72997e734006392aec357681a725ad65a4e7bb221daced4c942c7f8bbdb33089787b99f2aa438f2db072bc3c85e140c199b2948e640bb56a80a158e12703fe9582877481f644fe84078d979fad3d4856d263e65145abbad4825fc8100fa367da213d7c018638c27ca523d420628d046c4f919c150f90b5c81a2680b4aa523753f5b0744586be5acfb1799c1788422513e1f6bf36dd5d8c839437350950f8f22970f7ed6d537b8b728d36e4a3f5121e4f5b60497049b95692656d5539dee5b336d912dbebdffad4c04085487181d2dd36987fea21456f7a292d95cca433936e3dd3148b5fc34c25893144f9370a7cc983de96a3b44cc2f0f50762b62e28f3a07e99b9f9cea7137c0dc9883b2f0a7d7114827e50ffcf5d7f7a552fb3831e8daf27c9244d4d2a52091b9c2a532efd6e1eb7c922423b85a08f42f0d599703d1ace0231cee4f13288134f16c4509e1339a8845e359b44cdb0cabbcdf5ca20192c104c7aab27b425de174cb43346dde64496a106637ba27fc66e121efad728316d776d6fab73b133f662a3695325f0e50d58b58bb337b34ed5ce92d9bdceb300c12fe1b432c9d61b2a83f10e9730a698ea8282742d3bcb21989c9a3fcee88e1292da64ce313a8486c2dd4724aba7ec956a6c56f648304f9accf72de33932a077ddad241d53a772d76f5052f6ba12ad30dfb6aa614d11874672e5a535e303a6268a59692fb4d78d7245c1a868903cd2ce78c723f4af39d856ae0feb3f4eb1277a7a6dbb9ffae1018e1dea67aed1d6580b40ad1d47d6146c9953d5bc0002ffa7b2ed4f6eff5e229f48b9a540bf923e722be8ec7fa5bfc4ba569f0422a718bc43456310708f57b08b390906ecc6e2cf0da88a4b7c3df3c304ad7c388bc325793646a2c2ec1d9abeb29a59eb18d4f9a78748d707c435b77b68eb062f3d95d994eed574e59229ef858285d63b1d576c513a1f05ad1aa61e32b6af6911da97fb4f86b561c116248b2be34796d83c1620da00b6e8c58c37f4a9da927c754bc499efe5ede89e6dd6130a77c7c88b5b2fd24714086e71047c6635af1670c9bac7132421cf5d08898469d5f511107f29f6aaabfadbd4aa7e6e9cfd3d682eb4b77394ce1f406da1a2b257aa761df6b6e8b9890bcadc0e894082dce816cb584bced12cb8b57c043f78f0f643bc0b0adce483135bde689818c7911bc48990d30c4f4382d14dab8ea95262cc954e930da35a2c27b4791cf8186201a3612930470a8a0a593d31b73407b6f2f9a5d9a113601c05fa87f407cfee2e090837e4266bbb8efd336d5a8154386280ab3cba73c2d0365a8e485d1bdcfaf6ec581a76df2173f3e1c418e296a86a7e20ed8b1a8ab75df5236de8e4808a48e065e915e10f86e302f622b316f43252bf5f4765caaaf255e6f280b8c97e98edacca50c31ce8af166f7b0a26a0b1b576eeb94e529309cbb721afd50fcdde663dba4a23f4d0231efbfe55315fa0f11ba7cf0e83942346f6eddedbb5648967ce47483c4a55463af045ec66174667ec9be1fab0df5dae085d9afb5bcba532972bf60ac60635ca6ffc8e4bd4b9eb7016f01c31ed0ff7d4f282afa85efc6a862769b4d41b779e380b16831819a08533f38c9ca5644bb0e2c4aaaffb1cd1bf946c302eccc59dd08493a0e2416faaeef3d4d2d3c97d7f939352c1ee294b04f969cc938f74a5e48ccb0e1988801a6ed778263306cd541d6766ce3c58b5e3b0e2468c67e3d719d952e14db43ed29380157d55470c1c23258c5b97622c546fe7d1e4eb997c07fc435d5d37bf6dee052cf7269970f19d74e318701d0961565ea9e8b9a145f33c2821d7bdd642a288f0ae4b0531710e2a13f6bd359eb58cf913e365915a567a2fbb6ac6d5178a274a4453e47db45cc7b4283bdcd5b2b4396b956d711295c24b51272cab047c384e603ba3f0eab02c8c4c128229c0f3486bf0ac300c4420de18e10f6965e343ec2e4494e7a801b11e52ec89cbbf4885ccf1988aacf1154d0377d10749a3fb12ce241c2d128bd6b2ba341bbd490d316211ac8c6d5f7ce9ad88994d3cd7560b3850a6ccc6f36208f06729ed3d9aa0bc163107bcdf5227b0cf54e81fd8a6e3a879ebece2d272124c5dc38e8416fcdd722eb66543a6df837bf4142c4670227c3ae86ee6edd61e83577bb6e5e430c5813d977081545ae5fa50abbb836c523aecf9d616a7b42f94c513c9ebcc06d1d66121ca7673ceb5ba61ff249e08b492c2c2974e4affe91735b0fa7c7daf7593acee33d32b21903d284a562fa54c45ee035ccd7eb1c398cba1c80b9e9851960ad032349ca59399bf953c5ca77a06eda59c17495c72a42ad213c94d51f196c7972c44f66163a0f0d33eae293361a4f2ffac015be0cb3e7360b2fc03c203a1e583fba8d851aaf27e490277efd093f447e4b9310742b39bacedcf5e38f75560010eec1880337cb6668a03d31bfd14b7b567df1d36aab67a55230d5075f99b5cd8809f1ecd56509741cf45c57314d25014cbf94ea3096acf237811c6630c7cb2b0749c35a7d89e4011043aa79c19dfc656dbf9ece77d10903b7aa2000b62804bd540f2dd724241edb31e5ea401bb1513eb8157df5f95cf27f5c8e1d12b108895f0b8ff5d7711f470964f51b892f484da7ef0bfb8983455c812534fa0573d69680ba38e0791de0b0a2f3a2df4a696292a95eb750688825cd51ea7f80641f76924e8e7f78204d11e63491b3aa74ef02bca986c4906152cec0c549c0b4804689047b5f54e85daf42d6a0a8d2ecf5a721f3f6fed04e8d45f44ff8641cd5364cd884860546b1ff5960070fb9acc57974bd53b15644e6ae36f6b6c8ca17b524eaf155fb2d8b9de8b74c3703cd122aa663e44693f54488b781523cf8d0ae354eb5484903e9fb3dd173be84a454fd0dec264c62185132b44274ac911f7dfdd4e3c4cb785494dd48eb0451a1f2646ebaa13b700806ce7cd2eca27aa0205cb42eb424bb2468c6cb44355f0365e2faf180347cc2139873e908fb705b23ce83cbc31b9917f553800fd6bcf4ea4c63f63bae0504412cbd5e1fb1e1e6e90ad630bc62c2716d61181edec9b9f0c050cae138814e77333f695b938c70f6297cad8422069f2559c1a37c2451b0f0ee03c7c207feade19b2d3affa42c3bf87f13786a166be1a0ea0254123d748d70ceecc3fc8cfa665ac4eac5baf8d6181f98007ce83a4d14bc5f8b510053c3e1b2db8db20cc59da77deb598e518979ad35947b1fa85276364a6bf8d0ba89c342c17b92a5ccff98ce3ea3bb68d051f3944673dc475a0e8b4209ff39bf14c6f9631828f8bb1b46d164d41c78337f0ad50c2bc71d2d43807666ffafaacde774983da81528e92f009883ef7540827c543bd5666eed38112a364f46e9285b030003c1dc5679f4dd18803e0a694df6cb439158fa2d9442b369a8958aa90d4dd0480a2ec80660c75f1ab76bf83a3436758397b8aa0ec2faf7a1c89cab436f9d58e755d70d794adb591f46232c8ca627ea0c301040a1cb78b7da7a2981326ea64d1b275a4bb50aced85819d78c7cc4b79a42a411db3c32b28323b37fbf8cb3b0eb5943e82a3970525f15692c36db534ec1e168e636526c3c53a3f203e49181a0e79704ad26374a06812e5b6a8c3c88abb88acade9e7c66d9c855ab6168bc12f4eaffb86f8f02ffa3ff5e2c19628fc32d85935382823df6e3c607419c20418d3bba1b75e7766dc476bb7154a16d7055addf5779b54372c7012b172e6dc228450ee54863a87ed8e2e7539cba3de675f3523728b710aacc83c658dd2343f604fed6b400d97fa1eb252bccf0c544fdc62cd6087d5ed0a000bed1923696f7ed0cfd1d3fe1e0e090a7a809f0bd503fd16eecd6dbc7fbb5954f9d7edf8f0dbb57511c551b2ce030524464dd5626287ccc3f60cf6445cdffd4e7e4382e74c1866be5966da0ca23402a65d61b89bda48fd029a0cfe357bf45565cd98da8fd070b6fda96191a13477149ce94dc0c3c2dafe88285fc9b3236825d4bb1941110875f3220e46ee21aecaa2338996c92a37721901bf147b569a117a535b239388c962803640370f6d63483b147df50ad7143713711f35072f1a7444ee4f469e5cc0afb06bd59a84f5956de2ad085018aca65d8a222301d3f9556db3351ec176f776765a383f44586b9865106de4ad3ee658e72fbeb0eaf8dc7ff97bdc806b33132f18c2481cb9020d382aafcad9ce946eb137b5929157256db54a3a2b00cef45348b0429031195cb32ece95bf7aeab1b8cce8b943ee05008f7475288b15e80de584cbbb7b9a17a59ae130e32f130c2d55c1e7f0f83213a3753e15fa47d7bf9ed5d6df58db39a760666a1c9e61504efb012dfb3143f5db77a854c8d54fd6461e937684270d1f9151dc573b9804cbb8677a0a3c3e4b837a5725200901e729010c401dffeb01e6eaa1342d4c1a8b26c004e25afaada5eeef1fa53f36ac3339ab543888763d939996b211fbfdf6665cffad7e2641da5a318537c4093440c317b6b2bd27446ce7e324b83b6078c4789b2b06848df61e34d56b1a326370c4004563fdf7fc092d18c638effe402a2556f6805069b1271dd9e57d64309e5238e67267d1a11274d467b7437a8ba42780eaadc216f0503bf5f7744394f4723f4dd26c4f566b9699b74b2fb4517407d97ac40c46a20ef8faa2fcb5faa6b8812b959a5e2362d6161ce9f094331c2ac06a6924e65b354f09cae238845d60b490edb40bbe12203a22741deecb562c700fe84cf7ae57386b1735cd9febc9fc468cefa2420b5a6bf26f0afc0ee468244f70827cfeb4a8e09b8e9e911e21a81582eed2e1b484b92d4840db7a405bd9efcf2eb0d99fff05c371cf9f4c5148c3b6956698a4ea886cc93e6a5a747318612b09c6b61724bea7d165f4c50631ce818e3ac7b027d07f733e8b5a9359755dd572d0f1f3efbfb0e340932785cfbb46e71a5de6b6ffd5046c1767ff1354cd7a9444438cc1d69fb0a88ffe0e729081fc71d079b2430a96610c144dca11cf8c2a6a5f3c2f66d013b97410181a947911dadc6c8013dd000eab5e5d606505c0c62a58beaa5a4831e09c845fb324935ce8ac44216e8a36ff706d443593095dcb313037e07ac20bd1a419d946415da9f609513a4688734b15ab03f0f0f4dfba00466193658efb539ccf25035105ac75774b0f09ede2c9bea8dcbc33f223b007a62baa9b6d722d40fed1c5eec23c77daa735f4068070c4c823ee0bea4b40cfd96be0cf62eeb6b1806572f19073c9f2c43d2c9fbbf94cc510a2bfcb27f26f034940faed4c2084abfb342cf0ec2a36dcc5ed2178ea4dddebc16c23065082d4d2ada270ba83f989a5d30ac23a6d5a4d35106266bb154309ca322712c020df85f2bbb26f1f7bd53a0c3ce42d97aadcfbb42713a7be7ab1ab816606066201f2108979216beb45d299ecbbaa8a48115a27252084529d0a3c54d29a02649227fd439cf3bbb7321f303a5d1c67136733e9863f24c9b417d73cf99c95f3c73e4c0257223be79ffb28927f2a3d0211b3d99010ec29b89052e83080fb754decd280a9307320844aacaaf095cbaaa184610980d04e48a6baf6eafd7ebaff497520dee435ad6e1d9d802fab514c17cc320da0ada5e15aa7c0050ad80fcdc2ce36723fe3c9922d5510c0f04eea3fb092dd675d3f278cbaf85c0f2edce5561a404d8a12d0d2637703a08ad9bd6e9465f308eeb3977d2c074597a6f15bf056a7a443d4d8781fe0aec807c50dedc0923895e4e96519c3b76dd4252fd9d46515d28c56af3062ebefe42dd5a3cd2583029d2f8c56976b0cf600049948f8b3ad8b87ebde19421468a3b341bf8c41258ced03e742137bb07b15853709614eefa6dc7471055255c5fb2b8b59deea11fcf922aad02dc9ffaa3270196a2a1f6af34883fa8b9423e7bd83b814e1a5c9acb1c6b81a6f756e58e3c56771f25f35e2a47eab7b96946b60a164133be47e7706db918d31616f2edfe46e11d1e6e5d705476a6766cc7bce9954d12996931a45061e6591f9715b7003cd697d063e2ee90a0f976e0849674aa97339fc044cdf52a396a2a776c9f9dc2d284b26ca0ecd0c30489e903d5488478b8b794b2f3f3ff87778b8c85031dac5940a5dd9688a64b5901afa44323bd994751af2ee8d37e44ffdddf6d09763e57aff170b84f671cf460b3f25a4ee6daf454574fdd72bb2590d9560c1fa9f3942d07d8a00a419f4a53e04638708753d631abd3be327ce9d9b624bebb3305aff2211245ec69a78279e0d8ed5b07da1a0bbed0bfa8cec1d17f4ae8d99ce78e45ef6d3984ae93bf48feb54a069930fcbd22ac265300629109d3c76551497fbb8e5e4e5dcc36db4ab931c54ea5a3440e638a4d74b61f1ad768ad12fe06ba6f4a8606069022c8ad9ffc96cb0039c0449370e5d84a91808f633e575877d36f77f03ccef211c7aafadf8b34b6f2286522bd1f3cd16af116e788c6255b709e69a70ea3b50008b72b452e621b148d82a2d783f559f1173470e09e06ab33e851ab115bfa43cea83cd05bdc018ecba38a91457d92a005f8c00921f51a71bc3834b7c988dc0b38a686bef020796164e99caf7610da0b782eb0fafd63ca7475dc67fb622cf7c92a69bbbe793cf69533126525b6b41f56a403ed65b06a79da8cef3870da57b0fd4eca126ca0704cfe0edbc602861d351a3e837f2a83d5ab16693932c9a50b07c41ecae9949a886323762f29b839c3f929da986f4a7f0d1c10bcc26329a58c85fb607b58438c8a5acfa6c3caa1dc23c0dc311fe29049b1f1aec53eec3c2f6fb6b3df02660413a7fd24cd876f0221a7a0e7a2030ca53924f835ccabce581df5b91a31465d6e8347fa94a83d8daee6bda07d8f82b464165012589bca0177c8bfdc12eb74de819beda37ba170f4e6fd00118dc697147de4b10a3f24285649ae7d751ef70f4de99dc2ae0e771ce677d7cc8268ce84ea959128a2d754be513d93803ccaea366346ca23cee8c533dd80164d3520e08803a7849198f4a4802bd5e6ad8116113f1343434de3e120f4719484235df1724025977e18b1bc3094d226055f02f3b0380952436c13b33fd8e2eb02b4e2a09f327b5b1f3b2c1566ca1b5aff2af5c9de183d39e06882b302272173c6a0fd58912499bcb2be2f9e6f03b6603c8cdac1fcfa717a24289218812f5d519d6ee69ef411037a0123ada825a5be4a8d5589784d11721ce97fed232b6ff2fe89b5a6935bd4749adddf83c0e9593e5422e2b0821d4230352e8ff2b7c244b750b3238753ac10758ea72ae53866320d250231dfa0c3e1542b9792da93ca326f437cb0811ec7edd764c2265df44ae3424630fea905d847d08adb77d4c80d267f0bfcd7d87f24ed112e111da53d8e896e5ba744f62366146e104e6417bd813759dcce30bb2547e67a3cd43b89b2431b83fe43f006c21f83b46356e208a3b3373e9ea9ee2049f3ddfd04493d7b78b8bd9138a7eefaceeab5a37968232ccadfe6c76011c0fcdd193219168752cae635df0c45c1006acee1cf53b342213cd91b6536d64ca4647d33d005b13685ff8f976e29ed99efebe03077136103907ace7c2899fbdb057226b61819c75012244724d9527b50b0dfb0</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出计算机组成原理（四）</title>
    <url>/posts/496d4617.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="1bd11e9f0a131c014dda2c05049510f7ed5821ca65d2d72ee32376d2b60fcbc6">fb26124e0d85f363a66baed35993e1a0948953cce3d484fb31660455b92ccb286ba4467b12dd2afdc0f8bd795964707216933c479f00faf5302337078027ef66e68c754bf0232403ae44399aa06a2cad741400e24549082709cdee4a1c1e38f29d8bb6993c43448bafc4543d636ea5bfe35062ad225c74a80f232ba51d9af45093f5220e616be2d57e02341ffad661bef2886dba249b54377d8b3961fd62e8e7033554e6a1a85b429bcdccd8e910eaca84c8e447cedd760cd76a16c64ec7f94ad050108487716cc544f1ca685285a120a1c590efd559bdca18a90707fae890221e2912f079f089d10fb816e69e85944586941b721161d200273028ce2f3cb2d1a6a47461dcfac58b4612622383de37911e7101936179b0ecfeb18f3600111afc775a9e1f79696dae92585891ef4dfac1e4e83bc70d020fc565bb2e1c8d59293cc5084ec6df26828e31e743884a6892067fd7bd6561669cfa0e7c830639d34a35d9a03616b1180e6a14b5c208e0193ee9a969dc714462e2fbb086f97aba31c47261cb8391ad74640e6db6d440118fcafda8a1bf8442fb8cd4da0e81ab6493e5d022eb80d53b8ec901742f560ed0183ec514098ee124735f64694e9d16df70e5eeb39be6fdb87784e596bb414753d8a10b13d90216ce8d927e8e6e75ebe043fd095fc4962f7803cb0ec962e5a3ab74d7b2bd82425b8fe3b78f54095c92a12fbb7b219d7edf14cc7c531bd4b04677966e2fcf7cd75a02f200ef50c6245100d4d4333c376a8ce05b47b8121c6eb2399f83706e92c0b0d8f6309a58c22933962a739900bb48892ad38c60fe6546fdbe671cec98989d480ca6d5905f1332c559ef3f465b1fcb6d8a6feac566ffccd54a8b0e15fe1894014947caa5b5bcb319e63c800ccb87d806514c603c9394f19d6aa03b0e057c563bb5af700a54ec339ba173c80b4b531280c365043d10c9c6032686ae147c46f4ea239a09e5f0c7b44a589c8d16f714253389973fed7d889b8ba73411574e3a707ea3be4f9eebeec6c5a13119f5c88d28e8e2a2f2f01150da53bf424c6e1c96afdc78ff5652283abe2a45d1699831eaeefdf205ecf2e04cdf6b26880830b94f3f4c9ad0e7ced43883f7079b250138a5b2f42c880e6ad061e27c5877ed651a2176c559587ad164fac7148bfaf7215db66422a40414ee6b5e8f7afd588e88cd5a054ac9eca09bcec04d68eaf143e028c1aaa4cfe2c16490973e43f5215fe64ee989e1fd13cdd82119f3b84d5f1fa683b49a942176825e3966df0d078772a317e5570c885217be36283adcb8fdb64fe1bd21504b4b58fcfdf2a3046fced1c201716bf8a4cb2c4277001df2cba9d7900f104a9bebeff7807b592cddad70c3b324194a9c8ab9092c076fd41305b5a3268bc72bcc66327417fb070b4fe2856d85304a8f443e9673e5374fdad81fc16c4c76ff4738bb2dff10cdeea91c15bf90e455918cb36050fe214cd9faa2063ded609fbc3043077466f8cebe2ffd62cdb65d93dc64bda5cbcb7e4211f73b3caf64230f7df5f69fd1bb363f7d622e8fbae21e2ddf3f621e76f65e28ee8885ecab59d1451203e5a2ddedef700898513468d90a65e684721747737a4422d562d871474f794ae077b77d1ed94afd690e0cc29cd9d4d426560079afa9c7edc0413da512dd18d370811da9fbcc525ab58febd91e9ee5c7e655e912cecfed3a346effbe90226e8a20c32e11c32d3654cdd7d97bdae6c9f6ab4a6f1b985f5293480fe7a1f9bd061ecb2944e9fe0e50cd19d2f894069f4b21cb93320fb56d2cb3b9c8417e22e3baaede63d023737ac72acc05ccf592cb1fb641ca7a0569c828853c8864fc31f590c84c640d465780fea542188abc7467e8912a958f83c0129a7e6b1dba5fd29c1f0968498579be98075e994b0d6e8083296b8802bfbb5bb0d97bce177404cda7a6da176ac6053fe2c60c68b2bde155d3611a28aaa0fba38b06049619e7c8134b5425e540285edd9aa1151b33336ba303bbb460e6b39d6ca3b550c97b703a190a7e73633834a32e183e8e49e9eceb96190a3e88093f3b9307ea7bde07b654eef83c7588f82cc49fa7d2edb7f1d5f6b62ac875508334d067b341e8b12bf342d20efe5da903e989d9342e1f86cabd84333cef2b3629ab281bc5963815cad6226e7b2b53f9ac9af7f39f1c4280407d48ffa367128e3e80c159923fd8c573e7637c6d6bee9d2227f60f2f7ddad10c70dadb5a9b9be589d0d4e157b69daa2c86e83e8528ed0714fb04e0b743cb66d6897ab24dd313bae3e0f816c7944478825a53a85fc5d777cbb1c386f40f25aaade8bc7cb5df5bb50ad58f8d4bbf8b6ee2aa5d38489d46955ab9e51dfc4de54026a528564b9362c4f8dcd600b128f2011cc3da908fea5f9a528e0cddab908f6222794e16bea0dcf00def04f51a09cc2370fdcf9fb11004b13aa81117ef675dea7b371e932435593666425e8971ec7bde31c4ad271f26ebcd317e0271517bc8c7d3159f14c833695831bcdb1ae311f5ce6fde0c4744a5b75d30b0020780584e2a5fa078441f1acf8c3bf49af7a6fe2febc24f6cdabf9678347e1c6c51e3fd8a810056636ac9bad18f4902942b2fbfb4eaf0d9be6bb52ab2a598c35a85465839ad3050e4564b97af64c3b0e4e804da7225ac6ae732e89c86f01405a13c83d406f8f676bf031351e7b22345bec6a881084343a1f0a84715da0b39f7304f5b77aed5dffb520b75492da326614670da24fdd2376422ab283bdd2ce9486aa5b53bd3c6a04d68e4e22ebb2b4cb0530d273eb9667019dee596c020d12399a996ab6f992c186a5c00d38ca413025476984e3952c0ed8fb2a406c053f9fd252682c544d8f5386efeaa4576d3b58543f4a1a07707f331bbfa8824616a1e16bff1e1a8fd1914053a99f0b296356c1b1cbc10b05e25d4313841f4dfb0b79cadb42398950436dbfd2081621426d09b4e40ec7b64d7a77617299c7c98256427888d3cd866fd6d8eef1bdee656fbfeb839cdfe731fc50d6ae472dbb4ee1d6bef12a343c52f2652328fed7323aef63672dabb5c1026cf3355cd162b63dd6cdc8806c877e763dcc6eb366c02515722bd8d4df5258d40b78b3d0c7650c97cbc11113eea492496cfc1d80a8c47255c290518f9716bb233d2d88b24ac46eea6b6ce9e9c099e28d5cc5e2c47bcf1018b73eb6c1a3e4e9d53d445c7042ae0cb6d0ac4384a1ad8d48e6edfebd0fad7978aabe93474b011ee9a0175f0a5c14e7f06d6fe419d39587d162b6344edf53be1749c8915e1ef80f2de426f90a7f7d97612b40d2c78bff62fcbea984ced40a37341a289ef3256435c89207f17abcdccc5144bb0eddab6d86c1f50e1b1ca57fb9c9fd82b1ab12fc8d65b42ea069c5e855c3f95335afcbeaffd51ec93f8e96fc10d9e996ae9ff6c11b5d3f322e20b705e26f8658845fe6b3e027348d5ea8959707709a015c22b29a702389d20106a80c3beae1541adb25af65c0321b233ed613fe2e5bb49856d6e536782cbb516d59e4d4dcb2e022cdbe374d0de43eec936257a426944d39da0708ae439a5d5d998a0766674f774427d9ff8935149b52400850fad02121b382a062e4887668d29b00572c0bbb1422ac874a12dfecc32ce2a4da6755a47d63809764066d5aae997b6f0f9005e39305d2275c61f62551c16fc079fc2687df6fa9cda743f95865dba4dd53a26dbb3bca74271690b187dc3ee2834b1050a513b2bfa8dc1f6e2801deab7756e86e21f32b8e10b872eb50033e321f1b03ad86c6f3d5a9606b1aaeacc0d9b8f551c5821ad1271ba34c11e6dcf2e89a7183c4364768d9666f835547ba1025e139e771129ae4033bba036e728f571acd58fe05601873d197b8f99e9ee50aa2c0de7a6802211c2ef31391625c33e519ab8c36ff880312021b2fdfdd02818f21ea34a16a1b0c6ca9a0c22d7c677cff6490ac509fc0de3b179714b8363a07dd12d9ec156fd9595f6bbe5a38b06a28c86bc4a6bd60905b48176453ce3bf9fe9b3c5424948c486c782efc6903be8dc388cf17af02e0f82544cc5c34989d0e8be7dfd2f7569cc7d36d2eb34d928c7c61843a0f83733428f15fa76343666b6c9c917fac955502840d2d73c05997599c13a35d798c3ea75fa581865b2c5adc830512bace28904abc8d1edd967ca656916e29113e68aa01f7e137cc8b1cc540fbd30af8c7a263f7bb6ba673f4665083ab0ba0e07543cde468cb75ae2af0c957023be11f632b26918a78e028d91ca3aeb69ca7c233161221f106991a4d1b4d2004d9233c7cf5869a615f6f054c987eb40ce360b357f92acdf583af146545b226b5a56f7abaf5096398137b0273b525abaffa406fb81a6b22774dedbe6d3a124ec3f95be0d359e83527a63cf59127aad44b33d529547e14209e0e5706d9f46e92ff3e23672e277cf8f4b3427fd52e3a888957c1b6e8927f286009939a1502c387758027c7cdb2155ed40b3faf5555cb6b473e3bc930de65767efa23d3fedb70932c0c8c38528222f037e5ad88f22aca444a2641fd38f554cbb9df446154ca89af1f39413f3e9b79f21d0dfde95dcfcfbd8fd48938a38ca4f448a9dede9f7826fa90d29511f3a66c07b564bbb89b093d94506b5d1ae700455fe5005bf8737791fb5736f76d410636941557c0aec48c23076531ff7204205bb1568658deeb5c146ebfd420696bc75db04d20ce60a9d4da8950ead0a394cb4acb8e0360872f299d1fc99d6c562d6ea65baf4d713c670b5c57b690f462338ced9aa87b2ff289ceafc4f5bc5bd5e7c588e4198c9d4f06031195b8e876b0d33dff4d6e81cea1e71b40c4f54debcea9a8c7743f04e6065f26d6ea170ef4e15fd04d212aac4cb32bfe7b2e3aae65444c933503121f28b0bb05db655fd5f2c516e9c1b05471d86cbe2b822cfd39a66774ec0e11c28d97aca970c2111f5f89c8859edb36280315e807e054e116808d16d8f382880309664a03c49133fe165059dc408debefab70f92a3c55b763ba4116e856f44b0be2de64ae5744dc78c54bbb83b598ab44e84d0d82c96ae3d793e9b2f28f6c04c61cafd2dc768e87c063d0b88a296216a723363bd063623d3eda634e06253a1bbeae7616fae85400aec2ab8f0e76ac8ff822971a3f6d6a6f06c74934e8383d7facbc0f0edf1c65e7eda1da926a5098c785d7534dcb681fccfd5c468dccfc61c2378dc59e40e0d369c6e9b3dab36f89f9c7a8bda493d9c12cdfa02449566b98a247ea2b5cd21ced91c5a63554ef500b3b44e0a5eca56d418b3b7f4e4c2dd1e9deebe0582bef1c4223eef40a879c1c2ff14c8f0aba9412788abdc666f95956c56839589c10a119c1ce462690298b12c015c2d78d48ff243e71d0f74a6ccc8b465ebfd895c2008aab9d8dc4d17c1ad9c587874a8cf92bfff1c635505d224eaf652b00d478dc4bb2d8e3d319f7ee543900ffb72c9a99659252e4dbd401accba7e59bdcddba37d256fd7d2020b4f11fba404041beca5f1d158a1251f9725de10499ce7204f63b11c78776f2cbfacf2084179eab4b0317022f044cc2f4561163da66508d08c307033e9ee6d55a5f775a3f69dbe8cd35c9ae8bbd58185e7ef5d4b88ebb5b263b44b8e6a91077ad4474d00999b82d72790d854a5ad3591c45a6396966046bc14c70fdbaf001e1828626d3b82a25428592611feba34ff3074f5417315c6ddce5bd1358e500c59d905a433a0f239ff90025c1a47625172bae1c0ac8741f718c1f3bbc9e16409f2120d7f3523c900e1bfb5592a65b2171cf7e2806804a2b4bb5de2092d3a4cb8daf2ec9854abd41a4b2cb2b93bf7cf42eadd8565a691f0bd4561c6ba6a892a38ee19a20cd95d5fda9bbd4dabfb25d3591c5d6e5bb242c18f95bd36c62b1bf4f6b0fca49aefa3abc54558062e9cf8e4c3fa4998f0e9037b77dc87cfd352d4f1ade4c8d8bfd1a2ce2fe8c11696525d231cefa3b7c18f225485965a70a70e60221cfb58822b1e3fd2ff081a2c1453fe39cfeca5a40e0425325fae7bd153b4c5d180027b6a33c0b2b371b6d3572d619e3baf1eaf7294c9eab35edf037b090a29c93d3ef6520e7144a72bf73e43ed6e2f369c354891c49c8638cc0641f21a44b2e7ac5c7a6947067050e985d768d8de1caff2656dd96b16f9f90e10a41a7b5c2bf8a49f893552b00a4e6a930266c0ca54d7dee159cd889252cae2a71c32b46e5c9bd067f0f1751f146c441bdcefbf8c354e7fa09c06046925d6e07d1565ee161cdf95879efae74ebd9d03011676f8d024da23f7358d19ef73df4ef6d39c7fcd794128b2d3c0fd1b451098334fb46285e5aa4a2c2ffc434fdae63fe1f2a733e81ec761112f5561ead82563391e39abf44e7deea8b32e9c5ce97e2c789ca0c604c4d927b394e5d6b778fe576d65904a56f57d9a408a099cb8b3c49230e84bbc8ba2a7459af1adf9efd0ffe48a2e0f599ef9c132b69e7205e72a3e3efba55340a0b06862a5161070a504c856c8ff61f846b2098e0f294a91fe3700dc86506fe591c2da65ff4a0adf66bb22614b6f70c0582aaef8beecd9060bf8d5918690873c6163e8f63a9fb732fb671223aa3bf44ab5c8f21ada104545f0ea1a48a51a2f899d51ed2de0aad1126d1c39e18ffcc60fd1b8b62d5ab0ba6c31bed995ef8bb3da2f26d70355f4a4e581b1461b2d1d1bf1844bb474e9ba74c7616743ea4cdcd87dd91cf838d47965b7f351e98c2bf14e3a30eea9859a90e6d336ff22ae98c34e16af1a9f798f19a1cd339fb051ebbabaf20d79f4536ec0ba41b20fcac56b11939dc58bc6f8d2f440e6f1cfb058d92eae5b012c7e04f0bcece3eecd0fdeec1e2ab90ac86bcb809950eb675b89f249cbcd735c1ccd49f833a603de24b94e3561e2bc2157ab55f2aae0413a2b1c7f8312913f69d3759f916b6bc4832682c56d0a57a684a445e2a28ce5b9650a09354fd155123ac5b7c47ef33f178517808210128373ff8a3dcafa5165eecdb988a3bdcd6d8aeecbffe32ccc5d042be1fc218b90ad88e6f83e98582f4fc61322c7428965311cf35adec702fa66acdda285687b31a817d0384012eb6e3a18f4a1cc59f7c4c87f842a06186a35b62783941389e98a52574ebe78f0e725160153b85a0ad8f0302f8c49131af63022aee40752d37f7c2f2caa21a3b8bbfd85ec47a762fb8a8211d30e1655cac15b950b4cf85e1cbc626410db9a52d06f22f87b323fd94caea1ad364ba9ec14722a8954e1cac1e617a065c82dc762fcdc7fa53d059bec8c191c18b27f0908859f5c98c1298cbe1872bbd9b6405f8feeaebc24313eae389cd55d034a0c2f3c41c4881a01c05ad9472e6c1f2d90339ef6722b69063a7f31d362b66e183c5cf4c65a68e19ca4d16c598925d188c80783f059d73705c703a51eac3c229fe62e3d78896924ec9b142c1cb66981e30a8510920c8c60e2b9983585a9e6089be69b97f0e8a82fb0174aaeb5280d54a8b4b3e08b8dc6b87faf758753d1dff684c05e7077b9c28686d1b647b94b2123c760ed68cb34be5bede2e26d5381345605f198d82ea4f575ec3f18709520240fb0960b1c6cfbfeef1fa05a28a7525dc645cc7491b42f3def1988d10620cb8b265da7e2bdf986e9f60c0e43bf09de78425fcf4b73115c204d4fc1c0dfe96f9f8200e8160edb5aff790121dc65fa2623876c72c0b4bc859238d335713f87c6d6b120e7d89e96df24a36f772b880fe757a3028775e54e0bfd47b351db46795f05e9362bfbf0030da36c36169d4bc209a8932cfc28c4574798770c9295fac140677f8d3d5a03319f83f892da63b250753563ef8e03d3252a51ba5cd2a0180a46c66ab0d31f02e9c2b5a183aea758474a8fb86a5d6e49da48d1a32d2a62a4fe935b00d28e30d7724960896f64f96501c85418bde0b8f22cc0723ddeaf0a5b0af8bffaabe990f45fac50a6ac9334efec87db5fbc481d68c5ac6dc9ac897de43f3fccc08c1079ea603c1f2b36ba356526353d9ed373e4fb35df34117870f481a7cf7d1cfff8a0ac2987c2e826b8a603fc37311a7465252016393af487550d028825d8561f13dbef37ed7ecfccefc707ae708785c180fe13e5efa6778e8c2ea442c94f93d9fce1603f93c2ddfa4e24b59786591285af78580d5e74a37c5e322a4f20200993987c4823f7e33ea085d4819330b0083d844ff2d5f16b9e0917a3703cf289f0eef0bbfbb8b83b21af93a194d95cd9893d6ae8cdc18e428c48cf6215ea22dcf8a782bef229edfca6155ff2c4d04065515eb93b903e171ea1a70a6dc5c1ffc644f4ab75b907ed6499ee1e9bb53de930be958bc6f6bdecb7ed096b7c8f5e8b5b165956ca46ea8daf09c5dcb713c1b60ddcadc4cd5dc11382ac3648d8aed65a74ac41d6be624d79c4908abf449ba97c04e3f8e071a0e1ee4b27a12b1dc5fdbd72d6974794ef63b779233232c487e3c7ba638c2508068251c51dd21dca2aeca66d560ee6b7456ad13713e5cfe44f42802af5cb07b3ab4dc7681d669bc672eb46c4899b6dfaef0635d2a92de6a9590bea2b5b7f698684f77f50994a0148e245cc393f5974f5586c5ac746cba9016a6858b0ab55c70afacab2c3222fb3331ea3ec71485017d0f766fd158456c462cdd3efc9ecc4ce0e56ea66242b38abc91e68376fa5d5660cc1d7eaed479f15d89fa201f9b3d790fc04cae0c59dfaafaa6bc7f708e0b7e2bd7f6124c5f8783c3049ef53c482372bb8c62ceccdf6215ec98b1de593736dc6ebffcce0363aecfb32fc600d3a7f0216274cd2aac75d5b0ff1a8d889eecef6129dfb3a37760e6193b0d0f353f2db166a443894fa71d76de61b06ba84f9eecfc0717382a04b57bd667fa0eb614a146bc9bcacd36e1316a2d88c9711f4614f8458542121d96a0dad6012d674e290160dba4978e2555883ed3f370678ba30106249d9f3237b370cf7b9f599a0fbd2d418af672a5505b1ebc8be47f31cd69e56bd508efb066c12e544c6d70abc3b524e1a6362a4ea3da43dd35430b185a952e411a87151cdf1ccd65b939dd7c9eab8633c5944d2cef9781ee110cb3b5767421d5db4d28306f78e0d5b0f768577bfd16f76017c768eb28b779e7c993ad5e5feb790ffb9133c3e94197595c818b59284d63f1531644fe77978498dec1e733cced1c53ec7c599b1ec3ca92ad1ca5411136da70238f7a9a1fccb9470dc0f40d3e9a7af8030bac1bd775b297d00c2eb6a761a894ed20ce92663a51ff7b1b4bb38b10399ff899ec975e86728bbf4b52d169865523a4b3fe5beba0a84611d337f9b0b66205b7dbb23a43a97e99975f537a4765608cdbae3386c2385529571eeaf6904e33fb3468b7dc9a38df3ad355f61626564f2fca0cce62b382ecfb140fa6e1e275b89301ca665243d6a12fce7a08cd48dc3cc239f757daa69ded43fb91e2eca6392fb95a02a613da94552dbbc37c42fac04b13b203c142cd5ef1194685a799d1b9ec88adfad0a9f0373ca8b113d4bbf1c64e05c5512e9ccc9a98b0daae2fd8b3b0dc259400a86fdc3ec7f55f80600f419a60f79ff761fa218833e3e71d8a66e3fceba71af024db0ea50bfd4de3e2f55a149607e1807c3ee6d9156199566a67b907204f9efdae23aa719b4a90fd310f937ca8691f85ed28a6b29811ce5c54dc3579edd9b98be64701f3bc194dc2dda4b1e3d32b1e1f07c37da344233e45165b90fefb1c9f9e0d0a55f1b43f625ff819935dff433875f0247646c8c7009e6e22f547b684aff4df804998b73629cc5d15eb327a3ba0efa3fff368ed243d7d910e0077b2bc4dc3225b0b31e5a206c4d15516465a5e95701725da821b8850a6e51c4185751635e514f51185f99a14422f79dca5f960dc9c7e9d3c02e0eaaa671831ca320443038f744d265bb2d3b9972ce22e124fddff18c49ea48aaaa2f5e1ff948c69e39d1c149aa2acd8867ec98fbea8135c28b888e57fd3ff3409a7da06a4053c80c99f1ee2a916bc2c29397517f8a6ac0f68c286df93668c6fe54239d5bbee80debc38381af17e6f363f26d212e75ad5916878dc1536e7731d499fdf0302c66822adc340cc93006855801fc55ea476ebe117261dd006f166bca4d0d159d585098855e508de2215abb04b59c2d56ca61fcb8e736721c57d4fd38c04849dd7240500e1c048b7df2ab23d537d132be497c3c32c9d774656ee5f08b975db515aecf54ac0143a8407c5d90a14553269e6318b1af55036c6ade85722853aa1825fb4d32fe7d73c013eb5cd2ba68bb10954d057bfd0061d24ec1212383900371f41c849963d3453b4ecd75c1c15588e579fa0930afc2fc1ce79e35b81722a0ec8e6bed172b689bbd2cc80829153a3cba40ed2854ea835c5bf9ef4ad440e4d3759d8cdba1948e2068ea45b33f0312b7e64fb6fcf2c258e70779f46f25e6bceff7870e2290e8ba944bb5127c6e97343d56b13bb6e00143da8ec01297fa469563ed87fb06d19bb251cd33501bd10651be4d037835139d6a105c6bf5ca8ccd985457f0b0f69983b79c8252760db873fef5aeb6ef58e0ae6f517ebbe50f682ef17b2b7bfabbeb006686909584aee49b49802eba7c1f677495493dc120159888fda461da882d28ba1caaabe7fb537e0b2f215d9127b1c5a3b4804cc37427eeb5b3d8162b6094a191af232c2f439748afd0102ba1f91053f36c86afbec23dc3c12cee64289c7b698f43aaef1ce5ec400380322e765f75ad82f5b3f0174a142c159b62104fff91dfc9821ed06f82f7eb18fa75da4ecc2e9e68b0809a8ad1f1e25ff8f68900108d4c2a228cf344dd9f4e55a0a2b14274664334e99daec6e97077ee9746c72c9b0b15ec1348d1c3f085a86fd537afccc042e0ab095f339fd8278c6393fa4786183c6e3fb7224b47f10b7cfa1cd8baf4e67dea9469a799a855c46eaf1fc3e768bb37eded35f9b16fe8ad18068c2cf0eec48b3ae6f28ef141114b9173b6f668afac5759ead250c8b320c6ce72ca3fecd148723464776e2c74586701bb8de3349a3d2e6edfb3a9dca26cb0d185088950e2b6afbc3704d1af3ad840eea303e0e2220806f09f53212a7f7aefaf21b5ebaa96aa14f77a5d92c9a049031cac578b59b611d3de4e6e287ceec76eb3b7b46087f7a6905a73c72502c38f725df9acb17270fdede00f73695a42f73a126767bb79880740e6e65f9676f904c08d1219f66b6cd79166b6893c9798b18e5a6388400854c93c766470e90db587759a42db762c3a372b2ddffdec58141f694dcb17d5829e140b403422f9f7aaf069a1fc3c77088dcd01d81f04421a06ca9c40c655cf4ba5a26389d7409756debd98277870150350e0f1d3c64d1c001c0c0d0761f658a32eb0f21a3d9d54ac00407cc8d1d0e1baf87c937abd0c86f63972e96cc9582d2dc5931cbb9c98dc293b38645d99f7456bbfeb55c601d8fd211aadbc0a6bc0114ce434c7f540730fd19d8af35cb2c18c7e878316692d42c7310bcaa347a56f9b68f897bacaca4a120ab89e75dfea167c2ef61a315f9cc7f9473ed800fd3ce6d2306beeef11a4c0aaf9f56440c1654f4059608132e4b428f60f43a8be5a99cd0b5bbf22cfe181bfb7afe9af81b622e3eea0f207c7cb1ea298ee1f3e26c7047ad88cee31b63a2b64ccd4feeca1b5a6ff3063362d637609731d86b9a253bc0a770d0a40206b90152cd629ccc302c6eb3ae7e0becfb1ceef6379585929aa0b5ce305dcd0b18097ffb12e1065b42cd4fb009cd927ba416441af59255e95c82d73d0a16963936378b1940c65d492b2fd3bf8c9015be290a306abf366a2c011f9578e02590f863d63d29febeaa8a09b699079a1f03942dc7445ee35d1f9beeabdb48ff1803f24472ca558913cdccfe1a65c9cb867fe44f70a329cefdf5f8e590bc198de23d2e46e3a33415f863dbbdee54493830f590f36c71774cff099b53f16fa47bcb5b465246b9d69412959f7b6d82e49053ce6bcc5ff66ffbbee656d225ee618eed466a84413b97bf3c85895e0cfd4e28ae3c17d2e35a5b13dc9720543ba0940ce0b5828aaedb50d9d2e8bfb2509e4f9c77921883a92dd389ed91e8b7c813e0d66a12ce55fa3d0d45a0640605bbf9b3cb9a6505edd5252240152b852e5716f823904817010664a71b00c3cc38379e550457cd55cba0c1af54e4fcd0db8e89a26843a4ec8b9423abb167ccea5310bc234f164c28bdbd318a5cde6a4cedc3850151fcc4186cb5ac4441df09ebe9c2497d2ff8dc3be7deb603e30c9806aaacba2df35a1f8f33dc0e42c2fce1472fedb78881ad379b36e79e0562017237817c4ec0da5a868ee8f87eae0b85ea32d757a7a169ddc5981d523f4f5fe7a2b62e92d82c3df7a9b8374d765e14d711cfdc347d5ca9ccd181c41ffca67d682d86a43778fdc206d18b6eecb29857246b839bc3b3b17ae7ef063f42192b263ac16437136352a2eca3ff105b16e4448b1886dceed55b12685ef567c3248ab0d42a2c3e71db479f358cbe79b77bf21b0499911b9fb67a8f8aa20faf4a23249c8e4b80bf4e81a09efa7c3ded7b4e3df2b4675bdfd92b61de124238cd719c8f1410831bac60d0e4e9239bef1c77cff450eb2b7341a2251149b74a6cdaf2a8d64c6eae2f3af071b148730d33a20861d53c94e39ce0a1826cdfabbce27497148d96c33c6a3e9e8e08dd9e8402367905eb915dfc0343a28c608048975a285baa475520cfb56e07fff8f61cdb208ecc33cbfae528e80080700f142190f5c1d9fb7127941085c87fab30517523ab92c866c67892c5c0ec47ffe0b39fbfbd70c4e0e91af4c001a5284bbf2d684b620cf5771ca4ebcb6af3c0fcf48868701f25f26b59d1da25c9952b9a79d0ee08f54acf4ffcbb1300d3c585c9286a6733f2c120ece7a0863437037ef3cc307e1b50c092dd6b95650c0797b630d3480334cfe593b6033fd67437ae3cc8a905bcbb5d62e0f6fe98d8484cdaa014603ac380ced397d41ac320c47c75d279f9a9eb1e5dd95e47286ea090086d0aa1f0517f7956d8fa81f9c708fde8bef5f4b3eff816e0d0e4f5784908c925101d90ef1bc01a95281d0aa903ad6ccb8ffb46952d6fcc67c47b4efd588816fa4f240edd96aeb7074e8259fff432395db25b1201528b36b26a32d3ed447a2ec971ab2e96dd5ee6847654f88b1f5def8183352ceca3f13c1c6ca892cc3cb2cdb53123411d8427083ef22bd51ccbd477477a0364ef191e7fb841739e0c651fb226cbb2d1a83fb9d31e81e650d5e627b4fecff419ee709ea9f5acc08ed7516b0cb7bffcd40bb6aba3f6abf53f2202d5529993e117bff09dfb94b9fa6f42bb705e46c64e097cc56234a4ea6f70d937fe4235387edeb6fc3c5f5000a852c53b4eddde8eebda27b4224ebfcb595b44764c96cc3ff012dbffb155d75c2d53f9dbcfe33505e6b01c8051b715266161b213606c2ed5eeab27b722428f09bb425769c7de903e08c3c3f81de7d6f934f7bfbca026365af865b1acdc8c9a974667c159f2ee24bf43032efb7853c7943f8e7bb9c888db6661a340932400bfa3d2058b4e7573ab07c41b1226d694678ed30eab442cabbb4db10e28f98db5fd47a8550ec09b8c24d804a48627ddc73b06c715e3757c9b0954b4e2cdeaa0c6163b46fd37eef2d15dac46d36cd7f8c8c70407c4e1e0ae9455a16133833894dea19c20b9587062eefe3821dbf4b845d8133f5d6f2a7620effac57dfa8b3417b7f018555fabe14d9c8b74732183eb9c7c8f2ffd3ed1a2211c887cdee98a485b88b67bfabaa4c724533f20a96f7e4933da8e88251d8a29544d304500624f1dfed35e4a930b5ede75876e7200aa9783770abc9d390a78c85a748d91f79a5f104014ea44a5ad6a76a206ec9ea8ad6f3556de7f63e8b2a2bb09930e3030011f839b44c592e9ba7790b7059a5cb80a6b7a7a27e7f3319f2094e2cbcb1bae5cc64aaf009ddfeceae0a78efc47f02026af033540d42108cbe37a5e08389475982b7e8e68f14793b0490beb452e3d596f695849f606ca9a02a0f6e111ee01be66b7b51970c1987e8ed2e6917f7cbffba98356b2b45a5e7f81e1b1dca04b83d05b8c95cfcce0b0641573066952e50a330c0e6903ae6167afd6a24678ca3871e1d72dd496aeeed9fb22dc18d2ae904cb0697ce354c108374c647f6524cbbf9278f4cccf1ff2d2c8da41176103ac81bb7e0f2d254960b3fdabcbf59a3efcdb0832322ac58ca3dbc194eb8abdae449e74dde04d712e73f9418a96046587fdad58061200cf403aa7aa8fa0e13eecf7cb6c714394bfa531c456e27815cf95228a661c2c7f6e52baef246becbb685fec76278888866872f9a676f9b5b4a517b3870c7b8738ba171584bfec04edd30642c7d09aa893489702f7d4af4c19b6b2373b5e2b28178dc9f3afed8aabf1de723fa091bb78cbc7bd2f0604ec6378babfbd68a182ec1185aba2bbff28dfcaab039753b66cca6104e0d17b9a219e22855d64d01a4114846a697e4af315b69efe7a86d7673ac1ad9cd942b5b6a3afe987e0c4446d9f4b173a58c99d5da8423f4b09a1661f277a7ab32da88c4f71cccbbeb829bbf4c2577b4e7bff571de290823cd7c2c479e962d58c1c7c2632b22a08b9b2c3fa166645df0854c049c7e9715444b48cec89b08cf89be1707d43d9a0617ff0bd5f66defb8b9545e05199eff8da82130424f8a645962bf1fae50ac1919d8307d249f77918e7f5a70fc77b709fb7f16e4f240f7fbc4fef7882e82c16bca395512be1ec69cd9b96699a6ae495199d446b7aa3cb80ad81bba2e697f8db565119e2202466eee7e8117cc2dc44054b8cb2fe3208ce853ba373468ff8f92c600fd81e18751919ec743f1fc6ca28a357020923f5f4e1884a3761729e90104aaac4d40794991185572db684e3a71e5683bb68cc4139645371193be1586c8064afa6c0a7f021a061a3d0f7934814bdd14664302f769875f234872d9786c0e96a1cadeaef37619e5f77b5f79208e7f8d1e483d3a5f4681f039754b2f3ea7fd493dd6e8ffc38e7d98485680254570b7cedf4fde9e990547b1ab102542dcb048dcf0d44b602fecb3efa11af6df4216306ac5ba8e254e62fe72be17cffac7b67e6cbe22cc15a0309496a0f74d05ea30347c7dbc3f6701ec182302884fefa8aad9728bde3bea608849ba6dcf9e5852ec5b4f3fad508f8ddebdc94a6028f9ed1478992c424b4e12cab650b76185c8322dba81d9d69c01a09bd436d767fa84239774e5a229b93c7a414de1cb662239a47b990302f44906e722fa030a62f16c44459a33ae85bd2e6222d9a25a58240098b741b590b58e66642740de7770e0c336bc76b610a4038f6ec31db019ccee4081895a282b1c2910f07a3b6eb7a84058c0a206267e785101f4d4f5f3541e9ebd552e7fc354f28d8c49184502815c64ae1628c204655865bf4883e3cf9cbddeb71e7259319a508050b1d1737932c05e285ba28c098bce8dc3b3384eb7bf1270e93443622e1b8214f579189616181a6ae3ce172804749a70fc01c2b6d0fe74ac0b114f92c96c98afab452bfcfe808c3f855bdf3dbd0aa8094b4ade603e385c67f2e4fe7e7b1a0ceb77a7d63c99be139d3a188fda7243840bc558312cd60488ee41885c4aafc5a0b365101386214c5db9219ec015477b9c9dcae63133e9d3a493d055238893f44891d8e926640bf2b8a4b3ffaf0f5f7080585f954f391882ff02f46b469cf4202afbb9f36afe439935c6535e2815255af3554f99ff7a9275348af76549441e8b720bf1f6f5888200b5d6c99bfc5626af3542f4e314d101726b08454f10f9216a2d948e06f0669bb564a1ddfc381e852ab0db2daa0e14638641798e449cee5a5e57443d785fc4cca375650ba0fe3b22ec5e6ac32408b01bf5b9c80568aaf078c61f47e10c703e7eee7537c062d7bbf304cdc41ddf76d16b3cf9d15a1cd93a3dfff4a7719243b8ddffaaac09d83a3791647e43a3049ea5408916e5d103e1388ceb8021764f07d84d104e39b683fdec828d4c43e6f97bae3b4df7febbc219acd14e644f4d7a066d4cce5135702c05359badcd6caf473c709cf7aefe3b6ecec94ff36da9e5c0a9c7916757909597a82df10f08b04a0ece2ea340c8de987c420dc7526b3f06b0ba09f66eeae4362cc44a3a93d7022835a937aac66fb0e932a257768c8a100729525cc80cb15232f37184add7060ec5dba3e0d5a7efeefd5ed150a07fcb19fbe125ca342f96cf0b049d4eb8d1de69dad0c7209c998cf249a3b0eeed0bf97783b96ab1be1ec4a547af5f2fef8e6d4eba127312625dcefce4449b15d56cc42855ee6d0ee543d6c3dc00c17591eb123953117d483c43fd78d84fef89ec5a3928736ab2472f0b93de8e8278b0b61d2636a997f24beda9034d99f3a8b34b27069644a0a4b71c2ecf72414a297a80ecc06b2c10620e9dfa05c4d8aa0ba9b61b759479c65c10494724d99ffb3a0a4907437d14634f0aa36610d3fee2d790a0a64121db0d8319d31446590f65595a5e29e1a6afcff45cecb6285be1f70c12d47343252ba6492e7dd0c70d33fcf4a9d22580179711e1a2f3669b0bf074b40c011c94627cb3a9713ee0d5ceec35cd996378f72e7913dc691a6b49a9304581272032df8bf6ddfe1f9033d378382f8b91b4ebbc84920de59223b765d2497510234f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础课笔记（一）</title>
    <url>/posts/c499aa8c.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一：基础算法"><a href="#一：基础算法" class="headerlink" title="一：基础算法"></a>一：基础算法</h1><p>算法学习一般过程：上课理解核心思想，知道为什么这样写和为什么是对的，下课理解模板并背过直到能默写出来调试通过，最后用题目巩固知识模板，时常复习，提高熟练度。</p>
<span id="more"></span>

<p>排序基础知识可以参照：</p>
<ol>
<li>初等排序算法： <a href="https://www.grantdrew.top/posts/578803b6.html">https://www.grantdrew.top/posts/578803b6.html</a></li>
<li>高等排序算法：<a href="https://www.grantdrew.top/posts/7ff5bb67.html">https://www.grantdrew.top/posts/7ff5bb67.html</a></li>
<li>归并排序算法：<a href="https://www.grantdrew.top/posts/2aed1d1d.html">https://www.grantdrew.top/posts/2aed1d1d.html</a></li>
</ol>
<p>第一章：基础算法模板整理， <a href="https://www.acwing.com/blog/content/277/">https://www.acwing.com/blog/content/277/</a></p>
<h2 id="1-1：快速排序"><a href="#1-1：快速排序" class="headerlink" title="1.1：快速排序"></a>1.1：快速排序</h2><p>这里就不在赘述具体过程了，大致讲解一下原理，然后上代码。</p>
<p>快排的核心就是利用–分治思想。</p>
<p>一般在算法笔试中不太会用到，可以用库函数sort代替，只有在面试时可能要求手写。</p>
<p><img src="/posts/c499aa8c/image-20210724101609079.png" alt="image-20210724101609079"></p>
<p>原理图如上。</p>
<p>第2步，调整分区有2种做法。</p>
<p>第1种是非原地排序，就是开2个临时数组a和b，然后扫描数组q，对于&lt;=x的数拷贝到a，对于&gt;x的数拷贝到b，最后把a和b拷贝到q，即完成了分区操作。</p>
<p>第2种是原地排序，利用双指针扫描数组q，两个指针i和j分别从左边和右边开始扫描，当左边的数&gt;x且右边的数&lt;=x就交换两个数，直到两指针相遇。</p>
<p><strong>例题：acwing.785. 快速排序（模板题）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定你一个长度为 n 的整数数列。</span><br><span class="line">请你使用快速排序对这个数列按照从小到大进行排序。</span><br><span class="line">并将排好序的数列按顺序输出。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">输入共两行，第一行包含整数 n。</span><br><span class="line">第二行包含 n 个整数（所有整数均在 <span class="number">1</span>∼<span class="number">10</span>^<span class="number">9</span> 范围内），表示整个数列。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出共一行，包含 n 个整数，表示排好序的数列。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤n≤<span class="number">100000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>y总代码：</p>
<p>平均时间复杂度：O(n*logn)。双指针扫描区间[0,n-1]耗时O(n)，递归处理耗时O(logn)。</p>
<p>最坏时间复杂度：O(n^2)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;<span class="comment">// 递归终止</span></span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>,j = r + <span class="number">1</span>,x = q[l+r&gt;&gt;<span class="number">1</span>];<span class="comment">// 注意两指针都取到边界之外</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i ++;<span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j --;<span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// while循环结束后，q[l..j] &lt;= x,q[j+1..r] &gt;= x</span></span><br><span class="line">    quick_sort(q,l,j),quick_sort(q,j+<span class="number">1</span>,r);<span class="comment">// 注意：这个模板必须以j为划分点，不能取i</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    quick_sort(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法正确性证明参考：<a href="https://www.acwing.com/solution/content/16777/">https://www.acwing.com/solution/content/16777/</a></p>
<p>注意：分界点x取左右边界会被卡掉，所以这里取中点。</p>
<p>补充一个从大到小的快排模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;<span class="comment">// 递归终止</span></span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>,j = r + <span class="number">1</span>,x = q[l+r&gt;&gt;<span class="number">1</span>];<span class="comment">// 注意两指针都取到边界之外</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i ++;<span class="keyword">while</span> (q[i] &gt; x);</span><br><span class="line">        <span class="keyword">do</span> j --;<span class="keyword">while</span> (q[j] &lt; x);<span class="comment">// 只是把这两行的大小交换一下</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// while循环结束后，q[l..j] &lt;= x,q[j+1..r] &gt;= x</span></span><br><span class="line">    quick_sort(q,l,j),quick_sort(q,j+<span class="number">1</span>,r);<span class="comment">// 注意：这个模板必须以j为划分点，不能取i</span></span><br><span class="line">    <span class="comment">// 如果要以i为划分点划分子问题，参考上面的正确性证明,递归划分为[l,i-1]和[i,r]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找一组特殊样例：<code>2 ,1 2</code>。</p>
<p>当以j为划分点划分子问题时，分界点x一定不能取到右边界（否则会递归陷入死循环），而l+r&gt;&gt;1是一定不会取到的（下取整），所以正确；</p>
<p>当以i为划分点划分子问题时，分界点x一定不能取到左边界，而改成l+r+1&gt;&gt;1是一定不会取到的（上取整），所以正确。</p>
<p>手动模拟一下，就很清楚了。</p>
<p>快排模板一定要背过，边界问题处理很麻烦。（y总NB！！！）</p>
<h2 id="1-2：归并排序"><a href="#1-2：归并排序" class="headerlink" title="1.2：归并排序"></a>1.2：归并排序</h2><p>在蓝桥杯系列2已经讲解过，这里再介绍一次。</p>
<p>归并的核心还是利用–分治思想。</p>
<p>快排：先处理，再递归。</p>
<p>归并：先递归，再处理。</p>
<p><img src="/posts/c499aa8c/image-20210724161443340.png" alt="image-20210724161443340"></p>
<p>原理图如上。</p>
<p>先递归使得左右两边的内部有序，再归并两个有序部分，形成一个整体。</p>
<p><strong>例题：acwing.787. 归并排序（模板题）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定你一个长度为 n 的整数数列。</span><br><span class="line">请你用归并排序对这个数列按照从小到大进行排序。</span><br><span class="line">并将排好序的数列按顺序输出。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">输入共两行，第一行包含整数 n。</span><br><span class="line">第二行包含 n 个整数（所有整数均在 <span class="number">1</span>∼<span class="number">10</span>^<span class="number">9</span> 范围内），表示整个数列。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出共一行，包含 n 个整数，表示排好序的数列。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤n≤<span class="number">100000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>y总代码：</p>
<p>时间复杂度：O(n*logn)。双指针扫描左右区间耗时O(n)，递归处理耗时O(logn)。</p>
<p>快排递归划分的期望是O(logn)，而归并递归划分一定是O(logn)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N],tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    merge_sort(q,l,mid),merge_sort(q,mid+<span class="number">1</span>,r);<span class="comment">// 以下标中点划分递归</span></span><br><span class="line">    <span class="comment">// 对两个有序数组进行排序，需要临时数组tmp</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>,i = l,j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k++] = q[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k++] = q[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l,j = <span class="number">0</span>;i &lt;= r;i++,j++) q[i] = tmp[j];<span class="comment">// 将tmp拷贝回q</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    merge_sort(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排序算法时间复杂度图：</p>
<p><img src="/posts/c499aa8c/1130_0ce35b527a-1.png" alt="1.png"></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>快排</tag>
        <tag>归并</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础课笔记（三）</title>
    <url>/posts/b991e506.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>高精度减法：</p>
<p><strong>例题：acwing.792. 高精度减法（模板题）</strong></p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定两个正整数，计算它们的差，计算结果可能为负数。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">共两行，每行包含一个整数。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">共一行，包含所求的差。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤整数长度≤<span class="number">10</span>^<span class="number">5</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/b991e506/image-20210725185441637.png" alt="image-20210725185441637"></p>
]]></content>
  </entry>
  <entry>
    <title>算法基础课笔记（二）</title>
    <url>/posts/f48f4654.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-3：二分"><a href="#1-3：二分" class="headerlink" title="1.3：二分"></a>1.3：二分</h2><p>相关文章：</p>
<ol>
<li>蓝桥杯系列二分介绍：<a href="https://www.grantdrew.top/posts/d50f01e.html">https://www.grantdrew.top/posts/d50f01e.html</a></li>
<li>二分查找：<a href="https://www.grantdrew.top/posts/e8eb0481.html">https://www.grantdrew.top/posts/e8eb0481.html</a></li>
</ol>
<span id="more"></span>

<p>二分一般包括整数二分和浮点数二分。</p>
<p>整数二分边界处理比较麻烦，浮点数二分会更好做。</p>
<h3 id="1-3-1：整数二分"><a href="#1-3-1：整数二分" class="headerlink" title="1.3.1：整数二分"></a>1.3.1：整数二分</h3><p>有单调性的区间可以用二分处理，能用二分不一定有单调性。</p>
<p>二分的核心在于有二段性的区间，左边满足某一性质，右边不满足（或者相反），两部分没有交集。</p>
<p><img src="/posts/f48f4654/image-20210724175013829.png" alt="image-20210724175013829"></p>
<p>整数二分的2个模板原理图如上。</p>
<p>两个check函数分别判断mid是否满足红色、绿色性质。</p>
<p>当<code>l = mid</code>时，mid需要+1上取整，<code>r = mid</code>时不需要。</p>
<p>为什么需要+1？</p>
<p>当区间只有l和r两个数时，mid下取整恰好取到l，且check(mid)返回true，那么[l,r]并不会更新，陷入死循环。</p>
<p><strong>例题：acwing.789. 数的范围（模板题）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。</span><br><span class="line">对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 <span class="number">0</span> 开始计数）。</span><br><span class="line">如果数组中不存在该元素，则返回 <span class="number">-1</span> <span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含整数 n 和 q，表示数组长度和询问个数。</span><br><span class="line">第二行包含 n 个整数（均在 <span class="number">1</span>∼<span class="number">10000</span> 范围内），表示完整数组。</span><br><span class="line">接下来 q 行，每行包含一个整数 k，表示一个询问元素。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。</span><br><span class="line">如果数组中不存在该元素，则返回 <span class="number">-1</span> <span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤n≤<span class="number">100000</span></span><br><span class="line"><span class="number">1</span>≤q≤<span class="number">10000</span></span><br><span class="line"><span class="number">1</span>≤k≤<span class="number">10000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">6</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>题解1：STL，见蓝桥杯学习总结（五）。</p>
<p>题解2：手写二分。</p>
<p>y总代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span> (m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;<span class="comment">// 先二分查找x的起始位置</span></span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (q[mid] &gt;= x) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q[l] != x) <span class="built_in">puts</span>(<span class="string">&quot;-1 -1&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,l);</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>,r = n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)&#123;<span class="comment">// 再二分查找x的终止位置</span></span><br><span class="line">                <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;<span class="comment">// l = mid补上+1上取整</span></span><br><span class="line">                <span class="keyword">if</span> (q[mid] &lt;= x) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-2：浮点数二分"><a href="#1-3-2：浮点数二分" class="headerlink" title="1.3.2：浮点数二分"></a>1.3.2：浮点数二分</h3><p>浮点数二分不需要考虑复杂的边界问题。</p>
<p><strong>例题：acwing.7890. 数的三次方根（模板题）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定一个浮点数 n，求它的三次方根。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">共一行，包含一个浮点数 n。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">共一行，包含一个浮点数，表示问题的解。</span><br><span class="line">注意，结果保留 <span class="number">6</span> 位小数。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">−<span class="number">10000</span>≤n≤<span class="number">10000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">1000.00</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">10.000000</span></span><br></pre></td></tr></table></figure>

<p>y总代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">-100</span>,r = <span class="number">100</span>;<span class="comment">// 算平方根左边界取0，立方根左边界取-100</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; <span class="number">1e-8</span>)&#123;<span class="comment">// 经验值，比要求的1e-6多开2位</span></span><br><span class="line">        <span class="keyword">double</span> mid = (l+r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid*mid*mid &gt;= n) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>,l);<span class="comment">// 默认输出6位小数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4：高精度"><a href="#1-4：高精度" class="headerlink" title="1.4：高精度"></a>1.4：高精度</h2><p>有时候遇到数据非常大，超过long long的上限时，需要高精度。</p>
<p>只有C++才需要高精度，python自带，Java有BigDecimal。</p>
<p>高精度面试不常考，笔试中偶尔出现。</p>
<p>一般包括高精度加法、减法、乘法和除法。（A+B,A-B,A*a,A/a）</p>
<p>加、减法都是两个大数A和B之间运算，乘、除法是大数A和小数a（位数小）运算。</p>
<p>位数范围：A、B一般&lt;=10^6，a一般&lt;=10000。</p>
<p>Java处理高精度问题：</p>
<p>Java中有两个类可以来处理高精度的计算，分别是处理整数的BigInteger和处理小数的BigDecimal。</p>
<p>参考：  <a href="https://www.acwing.com/solution/content/34210/%E3%80%82">https://www.acwing.com/solution/content/34210/。</a></p>
<p>python处理高精度问题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python可以直接过</span></span><br><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">print(a+b)</span><br><span class="line">print(a-b)</span><br><span class="line">print(a*b)</span><br><span class="line"><span class="comment"># 高精度除法求商和余数</span></span><br><span class="line">c = <span class="built_in">divmod</span>(a,b)</span><br><span class="line">print(c[<span class="number">0</span>])</span><br><span class="line">print(c[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 也可以输出a//b和a%b</span></span><br></pre></td></tr></table></figure>

<p>C++处理高精度问题：</p>
<p>如何存放一个大数A？假设有9位，A=123456789，将它存入数组，采取小端模式：数组按低位到高位存入A，987654321。这样处理方便进位。</p>
<p>高精度加法：</p>
<p><strong>例题：acwing.791. 高精度加法（模板题）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定两个正整数，计算它们的和。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">共两行，每行包含一个整数。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">共一行，包含所求的和。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤整数长度≤<span class="number">100000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">35</span></span><br></pre></td></tr></table></figure>

<p>首先复习一下整数的笔算加法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">+  <span class="number">8</span> <span class="number">9</span></span><br><span class="line">--------</span><br><span class="line"> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span>   </span><br></pre></td></tr></table></figure>

<p>然后用数组来模拟笔算的过程。</p>
<p>对于A和B的每一位的加法计算，实际上是三个数Ai、Bi和t（进位）的和。</p>
<p>y总代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A + B，A和B都是正整数</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.size() || i &lt; B.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.size()) t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.size()) t += B[i];</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;<span class="comment">// 进位到下一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t) C.push_back(<span class="number">1</span>);<span class="comment">// 判断最高位是否需要进位</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a,b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A,B;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.size()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--) A.push_back(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b.size()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--) B.push_back(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = add(A,B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.size()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>快排</tag>
        <tag>归并</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础课笔记（四）</title>
    <url>/posts/ebcfc63.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
  </entry>
  <entry>
    <title>线性代数中的向量和矩阵范数</title>
    <url>/posts/8c66907d.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="向量范数与矩阵范数"><a href="#向量范数与矩阵范数" class="headerlink" title="向量范数与矩阵范数"></a>向量范数与矩阵范数</h2><span id="more"></span>

<h3 id="1范数概念的引入"><a href="#1范数概念的引入" class="headerlink" title="1范数概念的引入"></a>1范数概念的引入</h3><p>为了度量线性空间中向量或矩阵的“大小”，我们引入范数。</p>
<h3 id="2向量范数：向量的长度模"><a href="#2向量范数：向量的长度模" class="headerlink" title="2向量范数：向量的长度模"></a>2向量范数：向量的长度模</h3><p><img src="/posts/8c66907d/image-20210416145257456.png" alt="image-20210416145257456"></p>
<p>标注上图中的一个小错误，第一条$||x||=0$当且仅当$x=0$时成立，不是$\theta$。</p>
<p><strong>定义：</strong></p>
<p><img src="/posts/8c66907d/image-20210416145311430.png" alt="image-20210416145311430"></p>
<p><strong>常见的几种范数：</strong></p>
<p><img src="/posts/8c66907d/image-20210416145429022.png" alt="image-20210416145429022"></p>
<p>2-范数又称为Euclidean范数，表示自原点的距离。</p>
<p><strong>定义向量间的距离：</strong></p>
<p><img src="/posts/8c66907d/image-20210416145554010.png" alt="image-20210416145554010"></p>
<p><strong>从几何角度理解范数：</strong></p>
<p><img src="/posts/8c66907d/image-20210416145707027.png" alt="image-20210416145707027"></p>
<h3 id="3矩阵范数"><a href="#3矩阵范数" class="headerlink" title="3矩阵范数"></a>3矩阵范数</h3><p><img src="/posts/8c66907d/image-20210416145806961.png" alt="image-20210416145806961"></p>
<p><img src="/posts/8c66907d/image-20210416145818249.png" alt="image-20210416145818249"></p>
<p><strong>常见矩阵范数：</strong></p>
<p><img src="/posts/8c66907d/image-20210416145900729.png" alt="image-20210416145900729"></p>
<p><strong>求矩阵范数：</strong></p>
<p><img src="/posts/8c66907d/image-20210416145927592.png" alt="image-20210416145927592"></p>
<p><img src="/posts/8c66907d/image-20210416145938628.png" alt="image-20210416145938628"></p>
<p><img src="/posts/8c66907d/image-20210416145947626.png" alt="image-20210416145947626"></p>
<p><strong>从几何角度理解范数：</strong></p>
<p><img src="/posts/8c66907d/image-20210416150018177.png" alt="image-20210416150018177"></p>
<p><img src="/posts/8c66907d/image-20210416150029711.png" alt="image-20210416150029711"></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>范数</tag>
      </tags>
  </entry>
  <entry>
    <title>群的定义与基本性质</title>
    <url>/posts/a91f2eaa.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>转载自知乎用户：<a href="https://zhuanlan.zhihu.com/p/162840687?utm_source=qq&utm_medium=social&utm_oi=1122533587357892608">@0003</a>抽象代数不抽象专栏。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol>
<li><p>群是代数学中最基本的代数结构，群论也是抽象代数中最基础的一部分。群是某个群及其在该群上规定的某种二元运算的集合，并且该集合满足一定的条件。集合中的元素可以是数，也可以是集合，在群论中都可以抽象为互异的元素。</p>
<span id="more"></span>
</li>
<li><p>如果需要应对抽象代数的考试，请适当多做一些习题。如果不是，请适当多看一些习题。</p>
</li>
<li><p>本章主要包括群的定义、基本性质、群的阶与元素的阶、循环群等基本概念。有关子群、陪集、Lagrange定理、群同态与群同构、群同态基本定理等内容放在下一篇文章中。在本科低年级的抽象代数课程中，群论通常占教学内容的一半。</p>
</li>
</ol>
<h2 id="1-1-群的定义"><a href="#1-1-群的定义" class="headerlink" title="1.1 群的定义"></a>1.1 群的定义</h2><p>群有几种不同的等价定义，这里先给出其中广泛采用的一种。</p>
<blockquote>
<p> 群的定义</p>
<p>如果一个非空集合 $G$ 上定义了一个二元运算 $\bullet$ ，满足如下性质：</p>
<p>(1) 封闭性, 即对于 $\forall a, b \in G$, 有 $a \bullet b \in G$;</p>
<p>(2) 结合律, 即对于 $\forall a, b, c \in G$, 有 $(a \bullet b) \bullet c=a \bullet(b \bullet c)$;</p>
<p>(3) 存在 $e \in G$, 使得 $\forall a \in G$, 有 $e \bullet a=a$;</p>
<p>(4) 对于 $\forall a \in G$, 存在 $b \in G$, 使得 $b \bullet a=e$;</p>
<p>则称 $G$ 关于运算 $\bullet$ 构成一个群, 记为 $(G, \bullet)$, 或简记为 $G$ 。</p>
</blockquote>
<p>上述定义中，第 $(3)$ 条中的元素 $e$ 称为<strong>单位元</strong> (identity)，第 $(4)$ 条中的 $b$ 称为 $a$ 的<strong>逆元</strong> (inverse)， 通常也记作 $a^{-1}$ 。只成立 (1) 的集合 $G$ 称为原群 (magma) ; 只成立 (1)(2) 的集合 $G$ 称为<strong>半群</strong> (semigroup) ; 只成立 (1)(2) (3) 的集合 $G$ 称为<strong>幺半群</strong> (monoid) 。例如，在 $\mathbb{R}^{3}$ 上的向量积由于不满足结合律，无法构成半群。全体正整数对于整数加法构成半群，全体自然数对于整数加法构成幺半群，全体整数对于整数加法构成群。与上述定义等价的一种定义可以称为群的单边定义，即：</p>
<blockquote>
<p>群的单边定义 </p>
<p>如果一个非空集合 $G$ 上定义了一个二元运算 $\bullet$ ，满足如下性质:</p>
<p>(1) 封闭性, 即对于 $\forall a, b \in G$, 有 $a \bullet b \in G ;$</p>
<p>(2) 结合律, 即对于 $\forall a, b, c \in G$, 有 $(a \bullet b) \bullet c=a \bullet(b \bullet c) ;$</p>
<p>(3’) 存在 $e \in G$, 使得 $\forall a \in G$, 有 $e \bullet a=a$;</p>
<p>(4’) 对于 $\forall a \in G$, 存在 $b \in G$, 使得 $b \bullet a=e$, </p>
<p>则称 $G$ 关于运算 $\bullet$ 构成一个群，记为 $(G, \bullet)$, 或简记为 $G$ 。</p>
</blockquote>
<p>上述定义中, 第 $\left(3^{\prime}\right)$ 条中的元素 $e$ 称为左单位元, 第 $\left(4^{\prime}\right)$ 条中的 $b$ 称为 $a$ 的左逆元。群的单边定义与定义的等价性通常作为教科书的习题, 证明非常简单。同样地, 有右单位元和右逆元的 半群也是群。</p>
<blockquote>
<p>思考：有左单位元和右逆元的半群是群吗? 即在半群 $G$ 中，</p>
<p>(3’) 存在 $e \in G$, 使得 $\forall a \in G$, 有 $e \bullet a=a$;</p>
<p>(4’’) 对于 $\forall a \in G$, 存在 $b \in G$, 使得 $a \bullet b=e$,</p>
</blockquote>
<p>上述思考中，对于 “右逆元” 的定义可能会产生歧义, 这里明确第 (4’’) 条中的 $e$ 指的是第 (3’) 条中的左单位元，否则没有讨论的价值。答案是, 这样的半群并不能构成群, 而是一个可以 称之为left-right system的结构。例：规定集合中所有元素的运算规则为 $a \bullet b=b$, 则可以证 明该运算封闭、满足结合律，且集合中存在左单位元和右逆元，但并不存在右单位元。这里再给出 一种群的等价定义，其等价性也很容易证明。</p>
<blockquote>
<p>群的第二定义 如果一个非空集合 $G$ 上定义了一个二元运算 $\bullet$ ，满足如下性质：</p>
<p>(1) 封闭性, 即对于 $\forall a, b \in G$, 有 $a \bullet b \in G$;</p>
<p>(2) 结合律, 即对于 $\forall a, b, c \in G$, 有 $(a \bullet b) \bullet c=a \bullet(b \bullet c)$;</p>
<p>(5) 对于 $\forall a, b \in G$, 方程 $x \bullet a=b$ 与 $a \bullet y=b$ 在 $G$ 中都有解, </p>
<p>则称 $G$ 关于运算 $\bullet$ 构成一个群, 记为 $(G, \bullet)$, 或简记为 $G$ 。</p>
</blockquote>
<p>Remarks：群是一个带有某种运算的集合。这个运算如何表示并不重要，可以是加法和乘法, 也可 以是其他的运算。在群论中通常将运算符号省略不写，并不失一般性地称群中的运算为乘法。乘法 群中的单位元通常写作1或 $e$; 加法群中的单位元通常写作0，逆元通常写作 $-a$.</p>
<p>群的分类方式有很多，最常见的是根据群中元素的个数分为有限群和无限群。另外，还有一种重要的群称为交换群，定义如下：</p>
<blockquote>
<p>交换群的定义 </p>
<p>如果一个群 $G$ 中的任意两个元素 $a, b$ 都满足 $a b=b a$, 则该群称为<strong>交换群</strong>或<strong>Abel群</strong>。</p>
</blockquote>
<p>后续部分请参看<a href="https://zhuanlan.zhihu.com/p/162840687?utm_source=qq&utm_medium=social&utm_oi=1122533587357892608">原文</a>。</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>群论</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（一）</title>
    <url>/posts/a8eb63b6.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>1.有足够的刷题量（最好200+）</p>
<p>2.锻炼自己的调试能力</p>
<p>3.最好参加模拟赛</p>
<p>4.安排：周日（知识点+例题，取自真题）；周六（扩展+练习）</p>
<p>5.在参考时间内AC（从开始写到AC的时间），练熟练度</p>
<p>6.强调，算法一定要落实到代码的具体实现上</p>
<span id="more"></span>

<p><img src="/posts/a8eb63b6/image-20210219144746547.png" alt="image-20210219144746547"></p>
<h2 id="由数据范围反推算法复杂度以及算法内容"><a href="#由数据范围反推算法复杂度以及算法内容" class="headerlink" title="由数据范围反推算法复杂度以及算法内容"></a>由数据范围反推算法复杂度以及算法内容</h2><p>一般ACM或者笔试题的时间限制是1秒或2秒。<br>在这种情况下，C++代码中的操作次数控制在 10$^7$∼10$^8$最佳。</p>
<p>题目中的数据范围可以给我们很大的提示！！！</p>
<p>注：</p>
<ol>
<li>O(logn)一般指$\log_2n$.</li>
<li>int范围约是2*10$^9$.</li>
<li>long long的范围约是10$^{18}$.</li>
</ol>
<p>下面给出在<strong>不同数据范围下</strong>，代码的时间复杂度和算法该如何选择：</p>
<ol>
<li>n≤30, 指数级别, dfs+剪枝，状态压缩dp</li>
<li>n≤100 =&gt; O(n$^3$)，floyd，dp，高斯消元</li>
<li>n≤1000 =&gt; O(n$^2$)，O($n^2logn$)，dp，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford</li>
<li>n≤10000 =&gt; O(n∗$\sqrt n$)，块状链表、分块、莫队</li>
<li>n≤100000 =&gt; O($nlogn$) =&gt; 各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分</li>
<li>n≤1000000 =&gt; O(n), 以及常数较小的 O($nlogn$) 算法 =&gt; 单调队列、 hash、双指针扫描、并查集，kmp、AC自动机，常数比较小的 O($nlogn$)的做法：sort、树状数组、heap、dijkstra、spfa</li>
<li>n≤10000000 =&gt; O(n)，双指针扫描、kmp、AC自动机、线性筛素数</li>
<li>n≤10$^9$=&gt; O($\sqrt n$)，判断质数</li>
<li>n≤10$^{18}$ =&gt; O($logn$)，最大公约数，快速幂（接近long long范围）</li>
<li>n≤10$^{1000}$=&gt; O($(logn)^2$)，高精度加减乘除</li>
<li>n≤10$^{100000}$=&gt; O($logk×loglogk$)，k表示位数，高精度加减、FFT/NTT</li>
</ol>
<p>作者：yxc<br>链接：<a href="https://www.acwing.com/blog/content/32/">https://www.acwing.com/blog/content/32/</a><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="一-递归与递推"><a href="#一-递归与递推" class="headerlink" title="一 递归与递推"></a>一 递归与递推</h2><h3 id="1-关于scanf-printf与cin-cout的比较："><a href="#1-关于scanf-printf与cin-cout的比较：" class="headerlink" title="1.关于scanf/printf与cin/cout的比较："></a>1.关于<code>scanf/printf</code>与<code>cin/cout</code>的比较：</h3><p><code>cin/cout</code>速度稍慢，当数据范围&lt; 10$^5$时用；</p>
<p><code>scanf/printf</code>速度巨快，当数据范围&gt;= 10$^5$时用。</p>
<h3 id="2-递归-dfs"><a href="#2-递归-dfs" class="headerlink" title="2.递归(dfs)"></a>2.递归(dfs)</h3><p>dfs也即深度优先搜索。</p>
<p>所有递归问题都能画出一棵递归搜索树，方便分析。</p>
<p><img src="/posts/a8eb63b6/image-20210219154349224.png" alt="image-20210219154349224"></p>
<p>常用数字最好记一下：</p>
<p><img src="/posts/a8eb63b6/image-20210219154600997.png" alt="image-20210219154600997"></p>
<h4 id="2-1-acwing-92-递归实现指数型枚举"><a href="#2-1-acwing-92-递归实现指数型枚举" class="headerlink" title="2.1 acwing.92. 递归实现指数型枚举"></a>2.1 acwing.92. 递归实现指数型枚举</h4><p>从 1~n 这 n 个整数中随机选取任意多个，输出所有可能的选择方案。</p>
<p>输入格式</p>
<p>输入一个整数n。</p>
<p>输出格式</p>
<p>每行输出一种方案。</p>
<p><strong>同一行内的数必须升序排列</strong>，相邻两个数用恰好1个空格隔开。</p>
<p>对于没有选任何数的方案，输出空行。</p>
<p>本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。</p>
<p>数据范围</p>
<p>1≤n≤15</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>y总思路：</strong></p>
<p>从数据范围推断时间复杂度约为O(2$^n$)/O(n*2$^n$)。</p>
<p><strong>递归最重要</strong>的是顺序，要把所有方案不重复不遗漏的找出来。</p>
<p>先画图：</p>
<p><img src="/posts/a8eb63b6/image-20210219160249609.png" alt="image-20210219160249609"></p>
<p>注意边界问题：</p>
<p><img src="/posts/a8eb63b6/image-20210222114352254.png" alt="image-20210222114352254"></p>
<p>再考虑代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// soluition 1，y总题解，直接输出排列</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;// 4个最常见的头文件先写上</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> st[N];<span class="comment">// 状态，记录每个位置当前状态，0表示还没考虑，1表示选他，2表示不选</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="comment">// 记录方案，下标从1开始</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st[i] == <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    st[u] = <span class="number">1</span>;<span class="comment">// 第一个分支</span></span><br><span class="line">    dfs(u+<span class="number">1</span>);</span><br><span class="line">    st[u] = <span class="number">0</span>;<span class="comment">// 恢复现场</span></span><br><span class="line">    </span><br><span class="line">    st[u] = <span class="number">2</span>;<span class="comment">// 第二个分支</span></span><br><span class="line">    dfs(u+<span class="number">1</span>);</span><br><span class="line">    st[u] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// solution 2，用vector存储数组再输出，y总思路</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> st[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ways;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; way;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )  <span class="comment">// 记录方案，下标从1开始</span></span><br><span class="line">            <span class="keyword">if</span> (st[i] == <span class="number">1</span>)</span><br><span class="line">                way.push_back(i);</span><br><span class="line">        ways.push_back(way);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    st[u] = <span class="number">2</span>;</span><br><span class="line">    dfs(u + <span class="number">1</span>);     <span class="comment">// 第一个分支：不选</span></span><br><span class="line">    st[u] = <span class="number">0</span>;  <span class="comment">// 恢复现场</span></span><br><span class="line"></span><br><span class="line">    st[u] = <span class="number">1</span>;</span><br><span class="line">    dfs(u + <span class="number">1</span>);     <span class="comment">// 第二个分支：选</span></span><br><span class="line">    st[u] = <span class="number">0</span>;  <span class="comment">// 恢复现场</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ways.size(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ways[i].size(); j ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ways[i][j]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">作者：Bug_FreeOωO</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/6682/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h4 id="2-2-acwing-94-递归实现排列型枚举"><a href="#2-2-acwing-94-递归实现排列型枚举" class="headerlink" title="2.2 acwing.94.递归实现排列型枚举"></a>2.2 acwing.94.递归实现排列型枚举</h4><p> <a href="http://www.grantdrew.top/posts/f62c90a7.html">语法课有一道类似题目823.排列</a></p>
<p>把 1~n 这 n 个整数排成一行后随机打乱顺序，输出所有可能的次序。</p>
<p>输入格式<br>            一个整数n。</p>
<p>输出格式<br>        按照从小到大的顺序输出所有方案，每行1个。</p>
<p>首先，同一行相邻两个数用一个空格隔开。</p>
<p>其次，对于两个不同的行，对应下标的数一一比较，<strong>字典序较小的排在前面</strong>。</p>
<p>数据范围<br>         1≤n≤9<br>        输入样例：<br>              3<br>        输出样例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h5 id="1思路："><a href="#1思路：" class="headerlink" title="1思路："></a>1思路：</h5><p>顺序1：依次枚举每个数放在哪个位置；</p>
<p>顺序2：依次枚举每个位置放哪个数。</p>
<h5 id="2画出递归搜索树（以顺序2为例）："><a href="#2画出递归搜索树（以顺序2为例）：" class="headerlink" title="2画出递归搜索树（以顺序2为例）："></a><strong>2画出递归搜索树</strong>（以顺序2为例）：</h5><p><img src="/posts/a8eb63b6/image-20210225172255694.png" alt="image-20210225172255694"></p>
<h5 id="3代码实现："><a href="#3代码实现：" class="headerlink" title="3代码实现："></a><strong>3代码实现</strong>：</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>  state[N]; <span class="comment">// 0表示还没放数，1~n表示放了哪个数</span></span><br><span class="line"><span class="keyword">bool</span> used[N]; <span class="comment">// true表示用过，false表示没用过</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (u &gt; n)<span class="comment">// 边界</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,state[i]);<span class="comment">// 打印方案</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 依次枚举每个分支，当前位置可以填哪些数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)<span class="comment">// 从小到大枚举保证不重不漏</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!used[i])<span class="comment">// 向下搜索前先判断i是否用过</span></span><br><span class="line">		&#123;</span><br><span class="line">			state[u] = i;<span class="comment">// 第一个位置放1</span></span><br><span class="line">			used[i] = <span class="literal">true</span>;</span><br><span class="line">			dfs(u+<span class="number">1</span>);<span class="comment">// 在第2到n个位置放数</span></span><br><span class="line">			<span class="comment">// 恢复现场</span></span><br><span class="line">			state[u] = <span class="number">0</span>;<span class="comment">// 其实没必要加</span></span><br><span class="line">			used[i] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	dfs(<span class="number">1</span>);<span class="comment">// 注意：下标从1开始，所以dfs(1)</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>u代表层数（也就是放数的第n个位置），n代表分支数。搜索完一个分支，再搜索另一个分支。递归其实就是函数调用，你手动模拟一下函数的执行过程就清楚了。</p>
<h5 id="4时间复杂度分析："><a href="#4时间复杂度分析：" class="headerlink" title="4时间复杂度分析："></a><strong>4时间复杂度分析</strong>：</h5><p>（作为扩展内容，蓝桥杯不要求掌握，但以后面试会用到）</p>
<p><img src="/posts/a8eb63b6/image-20210225175859772.png" alt="image-20210225175859772"></p>
<p><img src="/posts/a8eb63b6/image-20210225180930832.png" alt="image-20210225180930832"></p>
<p>第一层：枚举分支，有一个for循环，复杂度为n；</p>
<p>第二层：有n个函数，每个函数有一个for循环，复杂度为n*n；</p>
<p>第三层：填完一个位置后，还有n-1个位置，复杂度为<code>n*(n-1)*n</code>；</p>
<p>…</p>
<p>最后一层：每个叶子节点输出方案，有一个for循环，复杂度为<code>n!*n</code>。</p>
<p>加起来，通过不等式放缩证明：<code>n! &lt;= (1+n+n(n-1)+n(n-1)(n-2)+...+n!) &lt;= 3*n!</code>，因为括号外层还有个n，所以最终时间复杂度为$O(n*n!)$</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（七）</title>
    <url>/posts/ba5ecc58.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="1-7-acwing-1227-分巧克力（蓝桥杯省赛C-A-B组）"><a href="#1-7-acwing-1227-分巧克力（蓝桥杯省赛C-A-B组）" class="headerlink" title="1.7 acwing.1227. 分巧克力（蓝桥杯省赛C++A/B组）"></a>1.7 acwing.1227. 分巧克力（蓝桥杯省赛C++A/B组）</h4><span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">儿童节那天有 K 位小朋友到小明家做客。</span><br><span class="line">小明拿出了珍藏的巧克力招待小朋友们。</span><br><span class="line">小明一共有 N 块巧克力，其中第 i 块是 Hi×Wi 的方格组成的长方形。</span><br><span class="line">为了公平起见，小明需要从这 N 块巧克力中切出 K 块巧克力分给小朋友们。</span><br><span class="line">切出的巧克力需要满足：</span><br><span class="line">形状是正方形，边长是整数</span><br><span class="line">大小相同</span><br><span class="line">例如一块 <span class="number">6</span>×<span class="number">5</span> 的巧克力可以切出 <span class="number">6</span> 块 <span class="number">2</span>×<span class="number">2</span> 的巧克力或者 <span class="number">2</span> 块 <span class="number">3</span>×<span class="number">3</span> 的巧克力。</span><br><span class="line">当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少么？</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含两个整数 N 和 K。</span><br><span class="line">以下 N 行每行包含两个整数 Hi 和 Wi。</span><br><span class="line">输入保证每位小朋友至少能获得一块 <span class="number">1</span>×<span class="number">1</span> 的巧克力。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出切出的正方形巧克力最大可能的边长。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤N,K≤<span class="number">105</span>,</span><br><span class="line"><span class="number">1</span>≤Hi,Wi≤<span class="number">105</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">2</span> <span class="number">10</span></span><br><span class="line"><span class="number">6</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>y总思路：</p>
<p><img src="/posts/ba5ecc58/image-20210421181429479.png" alt="image-20210421181429479"></p>
<p><img src="/posts/ba5ecc58/image-20210421225102950.png" alt="image-20210421225102950"></p>
<p>时间复杂度：求f(mid)是O(N)，二分是O(logH)，总的是<code>O(N*logH)</code>，也就是<code>10^5*log10^5</code>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> h[N],w[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        res += (h[i]/mid)*(w[i]/mid); <span class="comment">// res求边长为mid时的块数,h[i]/mid下取整</span></span><br><span class="line">        <span class="keyword">if</span> (res &gt;= k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;h[i],&amp;w[i]);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>,r = <span class="number">1e5</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r+<span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细题解思路请参考：<a href="https://www.acwing.com/solution/content/6883/">https://www.acwing.com/solution/content/6883/</a></p>
<h3 id="2-前缀和"><a href="#2-前缀和" class="headerlink" title="2.前缀和"></a>2.前缀和</h3><h4 id="2-1-acwing-795-前缀和（模板题）"><a href="#2-1-acwing-795-前缀和（模板题）" class="headerlink" title="2.1 acwing.795. 前缀和（模板题）"></a>2.1 acwing.795. 前缀和（模板题）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入一个长度为 n 的整数序列。</span><br><span class="line">接下来再输入 m 个询问，每个询问输入一对 l,r。</span><br><span class="line">对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含两个整数 n 和 m。</span><br><span class="line">第二行包含 n 个整数，表示整数数列。</span><br><span class="line">接下来 m 行，每行包含两个整数 l 和 r，表示一个询问的区间范围。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">共 m 行，每行输出一个询问的结果。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤l≤r≤n,</span><br><span class="line"><span class="number">1</span>≤n,m≤<span class="number">100000</span>,</span><br><span class="line">−<span class="number">1000</span>≤数列中元素的值≤<span class="number">1000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">6</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/ba5ecc58/image-20210423220147521.png" alt="image-20210423220147521"></p>
<p><img src="/posts/ba5ecc58/image-20210423220250988.png" alt="image-20210423220250988"></p>
<p>预处理计算完$S_i$之后，查询L到R的和的时间复杂度就从O(n)降低到O(1)。</p>
<p>暴力做法的话<u>每次</u>查询都得遍历数组，时间复杂度为O(n)。</p>
<p>前缀和思想虽然很简单，但是<strong>非常的重要</strong>。</p>
<p><strong>前缀和能快速查询，但不支持修改。</strong></p>
<p><strong>关于前缀和的问题，为了防止-1下标越界，统一从1开始。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[N],s[N];<span class="comment">// 表示原数组和前缀和数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="comment">// i从1开始，不然i-1越界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        s[i] = s[i<span class="number">-1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（三一）</title>
    <url>/posts/4ee7497b.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="1-3-acwing-1296-聪明的燕姿（难）"><a href="#1-3-acwing-1296-聪明的燕姿（难）" class="headerlink" title="1.3 acwing.1296. 聪明的燕姿（难）"></a>1.3 acwing.1296. 聪明的燕姿（难）</h4><p>《信息学奥赛一本通》 , JLOI2014</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">城市中人们总是拿着号码牌，不停寻找，不断匹配，可是谁也不知道自己等的那个人是谁。</span><br><span class="line">可是燕姿不一样，燕姿知道自己等的人是谁，因为燕姿数学学得好！</span><br><span class="line">燕姿发现了一个神奇的算法：假设自己的号码牌上写着数字 S，那么自己等的人手上的号码牌数字的所有正约数之和必定等于 S。</span><br><span class="line">所以燕姿总是拿着号码牌在地铁和人海找数字（喂！这样真的靠谱吗）。</span><br><span class="line">可是她忙着唱《绿光》，想拜托你写一个程序能够快速地找到所有自己等的人。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">输入包含 k 组数据。</span><br><span class="line">对于每组数据，输入包含一个号码牌 S。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">对于每组数据，输出有两行。</span><br><span class="line">第一行包含一个整数 m，表示有 m 个等的人。</span><br><span class="line">第二行包含相应的 m 个数，表示所有等的人的号码牌。</span><br><span class="line">注意：你输出的号码牌必须按照升序排列。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤k≤<span class="number">100</span>,</span><br><span class="line"><span class="number">1</span>≤S≤<span class="number">2</span>×<span class="number">10</span>^<span class="number">9</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">42</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">20</span> <span class="number">26</span> <span class="number">41</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>抓住题目核心，也就是求一个数的所有正约数之和等于给定号码牌，这样的数有多少个。</p>
<p>比如S = 42，这个时候就有3个数满足条件：</p>
<p>41 = (1 + 41) == 42，20 = (1 + 2 + 4 + 5 + 10 + 20) == 42，26 = (1 + 2 + 13 + 26) == 42</p>
<p>约数与因数的区别：约数必须在整除的前提下才存在，而因数是从乘积的角度来提出的。</p>
<p>约数只能对在整数范围内而言，而因数就不限于整数的范围。 </p>
<p><strong>约数个数定理</strong></p>
<p>定理: 若 $n=\prod_{i=1}^{m} p_{i}^{c_{i}}$ 则 $d_{i}=\prod_{i=1}^{m} c_{i}+1$.</p>
<p>证明：我们知道 $p_{i}^{c_{i}}$ 的约数有 $p_{i}^{0}, p_{i}^{1}, \ldots, p_{i}^{c_{i}}$ 共 $c_{i}+1$ 个，根据乘法原理, $n$ 的约数个数就是 $\prod_{i=1}^{m} c_{i}+1$</p>
<p><img src="/posts/4ee7497b/image-20210619101515256.png" alt="image-20210619101515256"></p>
<p>假设d为N的约数，d必然由N的质因数相乘得到。</p>
<p>参考题解：<a href="https://www.acwing.com/solution/content/10545/">https://www.acwing.com/solution/content/10545/</a></p>
<p>观察约数之和的公式，猜测满足所有正约数之和等于给定号码牌的数非常少，所以用dfs暴搜。</p>
<p>应该先从小到大枚举p，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(p : <span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,...)</span><br><span class="line">    <span class="keyword">for</span>(a : <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,...)</span><br><span class="line">        <span class="keyword">if</span>(S mod (<span class="number">1</span>+p1+p1^<span class="number">2</span>+...+p1^a1) == <span class="number">0</span>)</span><br><span class="line">            dfs(下一层)</span><br></pre></td></tr></table></figure>

<p>直接枚举p的话，素数个数非常多，时间复杂度很大，所以必须优化。</p>
<p>考虑特殊情况：</p>
<ol>
<li><p>如果ai = 1的话，S = (1+Pi)的时候，因为Pi为质数，那么S-1也一定为质数，那么这个时候只需要判断S-1是否为质数即可。</p>
</li>
<li><p>如果不满足1，S只会有两种情况，就是一种情况包括一个因子里面有(1+Pi)，另一种情况不包括(1+Pi)，</p>
<p> S = (1+Pi)(1+Pj+Pj^2…..)<br> S = (1+Pi+Pi^2+…)(1+…..)</p>
<p> 这两种情况都可以看出来Pi ^2 &lt;= S，所以我们dfs枚举Pi的上限就是$\sqrt S$。</p>
</li>
</ol>
<p>找个实际的例子模拟一下，就会很清楚整个过程了。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50000</span>;<span class="comment">// 比s最大值2*10^9开根号大一点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> primes[N],cnt;</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> ans[N],len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="comment">// 线性筛法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cnt &amp;&amp; primes[j] * i &lt;= n;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = primes[j];</span><br><span class="line">            st[t*i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % t == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">// 判断素数</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; N) <span class="keyword">return</span> !st[x];<span class="comment">// 2~N-1的数已经筛过了，通过st[i]来判断是不是素数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;primes[i] &lt;= x/primes[i];i++)&#123;<span class="comment">// &gt;= N的数需要用求出的素数来筛</span></span><br><span class="line">        <span class="keyword">if</span> (x % primes[i] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> last,<span class="keyword">int</span> prod,<span class="keyword">int</span> s)</span></span>&#123;<span class="comment">//last表示上一个素数的下标，prod表示当前数，s表示剩余未除的数</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="number">1</span>)&#123;<span class="comment">// 剩余未除的数=1，递归边界</span></span><br><span class="line">        ans[len++] = prod;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// last=-1时，s至少为3=1+2才行，s-1&gt;上一层素数，而且素数时递增枚举的，保证不会重复</span></span><br><span class="line">    <span class="keyword">if</span> (s<span class="number">-1</span> &gt; (last&lt;<span class="number">0</span> ? <span class="number">1</span>:primes[last]) &amp;&amp; is_prime(s<span class="number">-1</span>)) ans[len++] = prod*(s<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 素数p只需要枚举到根号s</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = last+<span class="number">1</span>;primes[i] &lt;= s/primes[i];i++)&#123;<span class="comment">// 防止相乘爆int，改成除法</span></span><br><span class="line">        <span class="keyword">int</span> p = primes[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>+p,t = p;j &lt;= s;t *= p,j += t)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s % j == <span class="number">0</span>) dfs(i,prod*t,s/j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    get_primes(N<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s)&#123;</span><br><span class="line">        len = <span class="number">0</span>;<span class="comment">// 每次计算前把len清零</span></span><br><span class="line">        dfs(<span class="number">-1</span>,<span class="number">1</span>,s);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (len)&#123;</span><br><span class="line">            sort(ans,ans+len);<span class="comment">// 记得排序答案</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-acwing-1299-五指山"><a href="#1-4-acwing-1299-五指山" class="headerlink" title="1.4 acwing.1299. 五指山"></a>1.4 acwing.1299. 五指山</h4><p>《信息学奥赛一本通》</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">大圣在佛祖的手掌中。</span><br><span class="line">我们假设佛祖的手掌是一个圆圈，圆圈的长为 n，逆时针记为：<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,…,n−<span class="number">1</span>，而大圣每次飞的距离为 d。</span><br><span class="line">现在大圣所在的位置记为 x，而大圣想去的地方在 y。</span><br><span class="line">要你告诉大圣至少要飞多少次才能到达目的地。</span><br><span class="line">注意：孙悟空的筋斗云只沿着逆时针方向翻。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">有多组测试数据。</span><br><span class="line">第一行是一个正整数 T，表示测试数据的组数；</span><br><span class="line">每组测试数据包括一行，四个非负整数，分别为如来手掌圆圈的长度 n，筋斗所能飞的距离 d，大圣的初始位置 x 和大圣想去的地方 y。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">对于每组测试数据，输出一行，给出大圣最少要翻多少个筋斗云才能到达目的地。</span><br><span class="line">如果无论翻多少个筋斗云也不能到达，输出 Impossible。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">2</span>&lt;n&lt;<span class="number">10</span>^<span class="number">9</span>,</span><br><span class="line"><span class="number">0</span>&lt;d&lt;n,</span><br><span class="line"><span class="number">0</span>≤x,y&lt;n</span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">0</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>参考文章：<a href="https://zhuanlan.zhihu.com/p/114568325">扩展欧几里得——裴蜀（贝祖）定理</a></p>
<p>参考资料：《算法笔记》，<a href="https://oi-wiki.org/math/gcd/">https://oi-wiki.org/math/gcd/</a></p>
<p>首先介绍<strong>裴蜀定理</strong>。（其实已经介绍过一遍了）</p>
<blockquote>
<p>其内容是：</p>
<p>设a, b是不全为零的整数, 则存在整数x, y,使 $a x+b y=\operatorname{gcd}(a, b).$</p>
<p>对于任意的一组整数x、y，ax+by一定是gcd(a,b)的整数倍。</p>
</blockquote>
<p>注意：裴蜀等式的<strong>解的个数不唯一</strong>！</p>
<p>举例：a=24，b=16，d = gcd(24,16) = 8，(x,y) = (-1,1) = (2,-1) = … ，这里就列出了两组解，它们可以称为裴</p>
<p>蜀数。 </p>
<p>然后是<strong>扩展欧几里得算法</strong>。已经介绍过了欧几里得算法求最大公约数gcd。</p>
<p>而扩展欧几里得算法不仅能求最大公约数，还能求解裴蜀等式的一组整数解x、y。</p>
<p>下面叙述一下具体的<strong>数学形式</strong>的求解思路。</p>
<p>首先假设：我们已经通过扩展欧几里得算法求解出裴蜀等式的一组整数解$x_0,y_0$。</p>
<p>也即：$ax_0+by_0=gcd(a,b)=d$。</p>
<p>令：$a^{‘}=\frac a d,b^{‘}=\frac b d$。则有结论，裴蜀等式的通解有这样的形式：$\begin{cases}x=x_0+k<em>b^{‘}\ y=y_0-k</em>a^{‘}\end{cases}$，其中k为任意整数。</p>
<p>验证上述解的形式是否裴蜀等式：$ax+by=a(x_0+k<em>b^{‘})+b(y_0-k</em>a^{‘})=d$，所以必然是等式的解。</p>
<p>下证等式的通解必然是满足上述形式：不妨设$x^{‘},y^{‘}$是等式的通解，则有：$ax^{‘}+by^{‘}=d$。</p>
<p>与等式$ax_0+by_0=d$联立可以求得：$a(x^{‘}-x_0)=b(y_0-y^{‘})$，则有：$a^{‘}(x^{‘}-x_0)=b^{‘}(y_0-y^{‘})$，所以</p>
<p>有：$b^{‘}|a^{‘}(x^{‘}-x_0)$，又：$(a^{‘},b^{‘})=1$，所以：$b^{‘}|(x^{‘}-x_0)$，即：$x^{‘}-x_0=kb^{‘}$，再代入</p>
<p>$a^{‘}(x^{‘}-x_0)=b^{‘}(y_0-y^{‘})$，有：$ka^{‘}=y_0-y^{‘}$。综上所述，<strong>上述解的形式必然是裴蜀等式的通解</strong>。</p>
<p>接下来讲解一下<strong>算法形式</strong>的求解思路。</p>
<p>设$a x_{1}+b y_{1}=\operatorname{gcd}(a, b)$，$b x_{2}+(a \bmod b) y_{2}=\operatorname{gcd}(b, a \bmod b)$。</p>
<p>由欧几里得定理可知： $\operatorname{gcd}(a, b)=\operatorname{gcd}(b, a \bmod b)$，所以 $a x_{1}+b y_{1}=b x_{2}+(a \bmod b) y_{2}$。</p>
<p>又因为 $a \bmod b=a-\left(\left\lfloor\frac{a}{b}\right\rfloor \times b\right)$，所以 $a x_{1}+b y_{1}=b x_{2}+\left(a-\left(\left\lfloor\frac{a}{b}\right\rfloor \times b\right)\right) y_{2}$，</p>
<p>$a x_{1}+b y_{1}=a y_{2}+b x_{2}-\left\lfloor\frac{a}{b}\right\rfloor \times b y_{2}=a y_{2}+b\left(x_{2}-\left\lfloor\frac{a}{b}\right\rfloor y_{2}\right)$。</p>
<p>因为 $a=a, b=b$, 所以 $x_{1}=y_{2}, y_{1}=x_{2}-\left\lfloor\frac{a}{b}\right\rfloor y_{2}$。</p>
<p>将 $x_{2}, y_{2}$ 不断代入递归求解直至递归边界 $x=1, y=0$ 回溯反解出$x_{1},y_{1}$。</p>
<p>扩展欧几里得算法代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exGcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123; <span class="comment">// x和y的值需要更新</span></span><br><span class="line">    <span class="keyword">if</span> (!b)&#123;<span class="comment">// 递归边界</span></span><br><span class="line">        x = <span class="number">1</span>,y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d = exGcd(b,a%b,y,x);<span class="comment">// 求公约数，注意x和y交换了顺序，和证明不一样，这样更方便</span></span><br><span class="line">    y -= a/b*x;<span class="comment">// 更新x和y，x不变不用写</span></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,x,y;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">int</span> d = exGcd(a,b,x,y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d * %d + %d * %d = %d\n&quot;</span>,a,x,b,y,d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面的代码可以求出裴蜀等式的一组特解，再通过通解公式我们就能得到全部解。</p>
<p>思路回到题目。</p>
<p><img src="/posts/4ee7497b/image-20210619214119402.png" alt="image-20210619214119402"></p>
<p>再介绍一下同余式的概念。形如$ax\equiv c(mod;n)$的式子称为同余式，表示：<code>(ax-c)mod n = 0</code>。</p>
<p>我们要求的就是满足方程<code>-a*n+b*d=y-x</code>的b的最小正整数值，这些量都是整数。</p>
<ol>
<li>当$(n,d)\nmid y-x$时，由于左边是常量n与d的线性组合，必然被(n,d)整除，所以方程肯定没有整数解。</li>
<li>当$(n,d)\mid y-x$时，对于裴蜀等式<code>n*x+d*y=(n,d)</code>，只要左右两边同乘$\frac {y-x} {(n,d)}$，就能转化为所求方程。</li>
</ol>
<p>由裴蜀等式的通解知道：$b=b_0+k*\frac n {(n,d)}$，b的最小正整数值=$b_0;mod;\frac n {(n,d)}$。</p>
<p>原理：不论b0是个多大或者多小的一个数字，它通过k∗n/gcd(n,d)都能把这个数缩小到0−n/gcd(n,d)之间。</p>
<p><code>int get_mod(int a,int b)  return (a % b + b) % b;// 将负余数转成正的</code></p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">exGcd</span><span class="params">(LL a,LL b,LL &amp;x,LL &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)&#123;</span><br><span class="line">        x = <span class="number">1</span>,y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    LL d = exGcd(b,a%b,y,x);</span><br><span class="line">    y -= a/b*x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    LL n,d,x,y,a,b,gcd;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>,&amp;n,&amp;d,&amp;x,&amp;y);</span><br><span class="line">        gcd = exGcd(n,d,a,b);</span><br><span class="line">        <span class="keyword">if</span> ((y-x) % gcd != <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            b *= (y-x)/gcd,n /= gcd;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(b%n+n)%n);<span class="comment">// 求b%n的正余数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>扩展欧几里得算法</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（三七）</title>
    <url>/posts/5c52e695.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="2-3-acwing-1078-旅游规划（蓝桥压轴级别）"><a href="#2-3-acwing-1078-旅游规划（蓝桥压轴级别）" class="headerlink" title="2.3 acwing.1078. 旅游规划（蓝桥压轴级别）"></a>2.3 acwing.1078. 旅游规划（蓝桥压轴级别）</h4><p>《信息学奥赛一本通》</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">W 市的交通规划出现了重大问题，市政府下定决心在全市各大交通路口安排疏导员来疏导密集的车流。</span><br><span class="line">但由于人员不足，W 市市长决定只在最需要安排人员的路口安排人员。</span><br><span class="line">具体来说，W 市的交通网络十分简单，由 n 个交叉路口和 n−<span class="number">1</span> 条街道构成，交叉路口路口编号依次为 <span class="number">0</span>,<span class="number">1</span>,…,n−<span class="number">1</span> 。</span><br><span class="line">任意一条街道连接两个交叉路口，且任意两个交叉路口间都存在一条路径互相连接。</span><br><span class="line">经过长期调查，结果显示，如果一个交叉路口位于 W 市交通网最长路径上，那么这个路口必定拥挤不堪。</span><br><span class="line">所谓最长路径，定义为某条路径 p=(v1,v2,…,vk)，路径经过的路口各不相同，且城市中不存在长度大于 k 的路径（因此最长路径可能不唯一）。</span><br><span class="line">因此 W 市市长想知道哪些路口位于城市交通网的最长路径上。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含一个整数 n。</span><br><span class="line">之后 n−<span class="number">1</span> 行每行两个整数 u,v，表示编号为 u 和 v 的路口间存在着一条街道。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出包括若干行，每行包括一个整数——某个位于最长路径上的路口编号。</span><br><span class="line">为了确保解唯一，请将所有最长路径上的路口编号按编号顺序由小到大依次输出。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤n≤<span class="number">2</span>×<span class="number">10</span>^<span class="number">5</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">4</span></span><br><span class="line"><span class="number">0</span> <span class="number">6</span></span><br><span class="line"><span class="number">0</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">8</span></span><br><span class="line"><span class="number">6</span> <span class="number">9</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>考察树形DP。</p>
<p>题目中的最长路径也就是指树的直径，在蓝桥杯总结（二一）提到。</p>
<p>在AcWing 1207. 大臣的旅费中用了2次<strong>dfs来求树的直径</strong>。</p>
<p>本题介绍<strong>树形DP解法求树的直径</strong>。（题目要求最长路径上所有点）</p>
<p>观察树的形状我们可以直到每条直径都必然有一个最高点，可以将以哪个点作为最高点作为集合划分的依据。</p>
<p>对于每个最高点i，我们只要求出每个子结点<strong>往下走</strong>的最大长度d1(i)和次大长度d2(i)（从树的形状可以直观地理解），d1(i)、d2(i)加起来就是经过最高点i的直径。</p>
<p>求出以每个结点为最高点的直径，取max就得到树的直径ans了。</p>
<p>直径求法的正确性证明如下：</p>
<p>参考题解：<a href="https://www.acwing.com/solution/content/8986/">https://www.acwing.com/solution/content/8986/</a></p>
<p><img src="/posts/5c52e695/image-20210628231123899.png" alt="image-20210628231123899"></p>
<p>那么问题来了，如何判断一个结点i是否在一条直径上呢？</p>
<p>从结点i出发走到树的尽头一共有三条可能的最长路径：1.往下走，最大长度d1(i)和次大长度d2(i)，上面已经求出；2.通过父结点j往上走，最大值用数组up[j]记录；3.通过父结点j往（下）子结点走，又分为2种情况，当<code>d1(j)</code>经过结点i时，结点i通过父结点j走到尽头的最长路径就是<code>up[i] = max(up[j]+1,d2(j)+1)</code>，当<code>d1(j)</code>不经过结点i时，那么这个最长路径就是<code>up[i] = max(up[j]+1,d1(j)+1) </code>。（对照下图）</p>
<p>最后，如果对d1(i),d2(i)以及up[i]中的三个取最大的两个，加起来记为人，如果<code>r = ans</code>，那么经过结点i的最大路径=树的直径，说明结点i在一条直径上。</p>
<p>求树的直径的过程是自下而上的，因为父结点往下走的长度取决于子结点往下走的长度；判断一个结点是否在一条直径上的过程是自上而下的，因为求子结点往上走的长度取决于父结点往上走的长度。</p>
<p>两次dfs都是O(n)的，所以**时间复杂度是O(n)**。</p>
<p><img src="/posts/5c52e695/image-20210628231846921.png" alt="image-20210628231846921"></p>
<p>注意：交叉路口下标从0开始。</p>
<p>还是用数组模拟邻接表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>,M = <span class="number">2</span>*N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,maxd;<span class="comment">// 树的直径maxd</span></span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> d1[N],d2[N],p[N],up[N];<span class="comment">// d1、d2分别存结点u往下走的最大、次大长度</span></span><br><span class="line"><span class="comment">//p存下结点u往下最大路走的子结点，up存下结点u往上走的最长路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	e[idx] = b,ne[idx] = h[a],h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_d</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> father)</span></span>&#123;<span class="comment">// dfs求每个结点最大、次大长度</span></span><br><span class="line">    <span class="comment">// 第二个参数记录父节点，防止往回走</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i;i = ne[i])&#123;<span class="comment">// ~i等价于i != -1</span></span><br><span class="line">		<span class="comment">// -1:原码，1,001，补码，1,111，补码全为1，取反就是0,000</span></span><br><span class="line">		<span class="keyword">int</span> j = e[i];</span><br><span class="line">		<span class="keyword">if</span> (j != father)&#123;</span><br><span class="line">			dfs_d(j,u);<span class="comment">// 递归子结点</span></span><br><span class="line">			<span class="keyword">int</span> distance = d1[j] + <span class="number">1</span>;<span class="comment">// 结点u经过子结点j往下走的路径distance</span></span><br><span class="line">			<span class="keyword">if</span> (distance &gt; d1[u])&#123;<span class="comment">// 更新最大值和次大值</span></span><br><span class="line">				d2[u] = d1[u],d1[u] = distance;</span><br><span class="line">				p[u] = j;<span class="comment">// 记录最大路径经过的子结点j</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (distance &gt; d2[u]) d2[u] = distance;<span class="comment">// 更新次大值</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	maxd = max(maxd,d1[u] + d2[u]);<span class="comment">// 求树的直径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_u</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> father)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i;i = ne[i])&#123;</span><br><span class="line">		<span class="keyword">int</span> j = e[i];</span><br><span class="line">		<span class="keyword">if</span> (j != father)&#123;<span class="comment">// 判断结点j是否经过直径</span></span><br><span class="line">			up[j] = up[u] + <span class="number">1</span>;<span class="comment">// 记录通过父结点u往上走的长度up[j]</span></span><br><span class="line">			<span class="keyword">if</span> (p[u] == j) up[j] = max(up[j],d2[u] + <span class="number">1</span>);<span class="comment">// 父结点的d1路径过子结点j</span></span><br><span class="line">			<span class="keyword">else</span> up[j] = max(up[j],d1[u] + <span class="number">1</span>);<span class="comment">// 不经过则用d2路径求max </span></span><br><span class="line">			dfs_u(j,u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);<span class="comment">// 记得h数组置-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++)&#123;<span class="comment">// n个顶点，n-1条边</span></span><br><span class="line">    	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    	add(a,b),add(b,a);<span class="comment">// 构建邻接表</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs_d(<span class="number">0</span>,<span class="number">-1</span>);<span class="comment">// 先递归再计算，自下而上的过程</span></span><br><span class="line">    dfs_u(<span class="number">0</span>,<span class="number">-1</span>);<span class="comment">// 先计算再递归，自上而下的过程</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">    	<span class="keyword">int</span> d[<span class="number">3</span>] = &#123;d1[i],d2[i],up[i]&#125;;<span class="comment">// 排序求三者最大的两个</span></span><br><span class="line">    	 sort(d,d+<span class="number">3</span>);</span><br><span class="line">    	 <span class="keyword">if</span> (d[<span class="number">1</span>] + d[<span class="number">2</span>] == maxd) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-acwing-1303-斐波那契前-n-项和"><a href="#2-4-acwing-1303-斐波那契前-n-项和" class="headerlink" title="2.4 acwing.1303. 斐波那契前 n 项和"></a>2.4 acwing.1303. 斐波那契前 n 项和</h4><p>《信息学奥赛一本通》</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">大家都知道 Fibonacci 数列吧，f1=<span class="number">1</span>,f2=<span class="number">1</span>,f3=<span class="number">2</span>,f4=<span class="number">3</span>,…,fn=fn−<span class="number">1</span>+fn−<span class="number">2</span>。</span><br><span class="line">现在问题很简单，输入 n 和 m，求 fn 的前 n 项和 Sn mod m。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">共一行，包含两个整数 n 和 m。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出前 n 项和 Sn mod m 的值。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤n≤<span class="number">2000000000</span>,</span><br><span class="line"><span class="number">1</span>≤m≤<span class="number">1000000010</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">5</span> <span class="number">1000</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>n的范围是2*10^9，m的范围是10^9+10。数据范围特别大，考察<strong>矩阵快速幂</strong>，也就是<strong>矩阵运算+快速幂</strong>。</p>
<p>参考文章：<a href="https://www.acwing.com/blog/content/25/">y总求解Fibonacci数列的若干方法</a></p>
<p>文中介绍了几种算法。</p>
<p>其中递归时间复杂度为O(2^n)，最慢，最常见的做法。</p>
<p>在众多算法中，矩阵快速幂时间复杂度是O(logn)，最快。</p>
<p>补充一种通项公式解法：</p>
<p>时间复杂度可能和矩阵快速幂差不多（个人猜测），但是数据量特大时<strong>精度会降低很多</strong>！（不太推荐使用）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> sqrt5 = <span class="built_in">sqrt</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">double</span> alpha = (<span class="number">1</span> + sqrt5) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">double</span> beta = (<span class="number">1</span> - sqrt5) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">double</span> ret = (<span class="built_in">pow</span>(alpha, n) - <span class="built_in">pow</span>(beta, n)) / sqrt5;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法：<strong>矩阵快速幂</strong>。</p>
<p>首先要掌握<strong>快速幂算法</strong>，求 m^k%p，时间复杂度 O(logk)。</p>
<p>参考文章：<a href="https://www.grantdrew.top/posts/50ce0ed6.html">快速幂算法</a></p>
<p>问题：如何构造Fibonacci数列的矩阵？<br>定义序列$f_i$为Fibonacci数列的第i项，i从1开始。<br>我们首先定义一个向量：$F_n = [f_n\ f_{n+1}],F_{n+1} = [f_{n+1}\ f_{n+2}]$，然后可以找到一个矩阵A使得:$F_{n+1} = F_n * A$。<br>不难得出：$A = \left[ \begin{matrix} 0 &amp; 1 \ 1 &amp; 1 \end{matrix} \right]\ (f_{n+2} = f_n +f_{n+1})$<br>由此可以得到递推公式：$F_n = F_1 * A^{n-1}$。<br>利用快速幂的算法我们能够很快计算出$A^n$，只是把数字换成了矩阵。</p>
<hr>
<p>回到题目，我们要求的是$f_n$的前n项和$S_n\ mod\ m$，所以我们构造的向量需要多加一个维度$S_n$。<br>$F_n = [f_n\ f_{n+1}\ S_n],F_{n+1} = [f_{n+1}\ f_{n+2}\ S_{n+1}]$，然后可以找到一个矩阵A使得:$F_{n+1} = F_n * A$。<br>不难得出：$A = \left[ \begin{matrix} 0 &amp; 1 &amp; 0 \ 1 &amp; 1 &amp; 1 \ 0 &amp; 0 &amp; 1 \end{matrix} \right]$<br>由此可以得到递推公式：$F_n = F_1 * A^{n-1}$。</p>
<hr>
<p>代码：<br>参考1：y总快速幂模板<br>参考2：<a href="https://www.grantdrew.top/posts/50ce0ed6.html">快速幂算法</a><br>参考3：<a href="https://www.acwing.com/solution/content/8881/">https://www.acwing.com/solution/content/8881/</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速幂模板,二进制迭代写法</span></span><br><span class="line"><span class="comment">// 通过二进制将乘法转化成加法来处理，效率高</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span> % p, t = m;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k&amp;<span class="number">1</span>) res = res * t % p;</span><br><span class="line">        t = t * t % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/5c52e695/image-20210701205328763.png" alt="image-20210701205328763"></p>
<p>因为快速幂的时间复杂度是$O(logn)$，而第二个mul函数的for循环次数为$3^3$,所以本题的时间复杂度为$O(3^3*logn)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AC代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> c[],<span class="keyword">int</span> a[],<span class="keyword">int</span> b[][N])</span></span>&#123;<span class="comment">// 计算F1 = F1 * a</span></span><br><span class="line">    <span class="keyword">int</span> temp[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)</span><br><span class="line">            temp[i] = (temp[i] + (LL)a[j]*b[j][i]) % m;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">memcpy</span>(c,temp,<span class="keyword">sizeof</span> temp);<span class="comment">// 注意：sizeof后面不能写c，是指针的大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> c[][N],<span class="keyword">int</span> a[][N],<span class="keyword">int</span> b[][N])</span></span>&#123;<span class="comment">// 计算a = a * a</span></span><br><span class="line">    <span class="keyword">int</span> temp[N][N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; N;k++)</span><br><span class="line">                temp[i][j] = (temp[i][j] + (LL)a[i][k]*b[k][j]) % m;</span><br><span class="line">    <span class="built_in">memcpy</span>(c,temp,<span class="keyword">sizeof</span> temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算初始向量F_1</span></span><br><span class="line">    <span class="keyword">int</span> F1[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> a[N][N] = &#123;<span class="comment">// 快速幂矩阵a</span></span><br><span class="line">      &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">      &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">      &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    n--;<span class="comment">// 矩阵快速幂求F_n</span></span><br><span class="line">    <span class="keyword">while</span> (n)&#123;<span class="comment">// n&amp;1，偶数返回1，否则返回0</span></span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) mul(F1,F1,a);<span class="comment">// F1 = F1 * a</span></span><br><span class="line">        mul(a,a,a);<span class="comment">// a = a * a</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,F1[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>树形DP</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（三三）</title>
    <url>/posts/33ef06f1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="1-7-acwing-1225-正则问题"><a href="#1-7-acwing-1225-正则问题" class="headerlink" title="1.7 acwing.1225. 正则问题"></a>1.7 acwing.1225. 正则问题</h4><p>第八届蓝桥杯省赛C++A组,第八届蓝桥杯省赛JAVAA组</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">考虑一种简单的正则表达式：</span><br><span class="line">只由 x ( ) | 组成的正则表达式。</span><br><span class="line">小明想求出这个正则表达式能接受的最长字符串的长度。</span><br><span class="line">例如 ((xx|xxx)x|(x|xx))xx 能接受的最长字符串是： xxxxxx，长度是<span class="number">6</span>。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">一个由x()|组成的正则表达式。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出所给正则表达式能接受的最长字符串的长度。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">输入长度不超过<span class="number">100</span>，保证合法。</span><br><span class="line"></span><br><span class="line">输入样例：</span><br><span class="line">((xx|xxx)x|(x|xx))xx </span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>这两题都与数论无关。</p>
<p>本题考察<strong>递归</strong>，应当放在第一讲。</p>
<p>题意是求在规则之下的xxxxx…的最大长度。</p>
<ul>
<li>规则1：() 的意思是有括号的先算括号里面的，优先级最高，把括号计算的结果在和括号外的字符拼接，即括号是相对独立，完整的个体</li>
</ul>
<ul>
<li>规则2：|的意思是|这个符号两侧的字符串只能选其中一个，由于这题要求能拼接的字符串最长，因此应该选择字符|字符串xxx…长度较大的一侧</li>
</ul>
<p>再次强调，所有递归问题都可以画一棵递归搜索树来帮助理解。</p>
<p><img src="/posts/33ef06f1/image-20210621131754393.png" alt="image-20210621131754393"></p>
<p>代码·：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span>&#123;</span></span><br><span class="line">    <span class="keyword">static</span> String str;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        str = s.next();</span><br><span class="line">        System.out.println(dfs());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; str.length())&#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(k) == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                k++;<span class="comment">// 跳过&#x27;(&#x27;</span></span><br><span class="line">                res += dfs();<span class="comment">// 遇到()或者|都往下递归一层</span></span><br><span class="line">                k++;<span class="comment">// 跳过&#x27;)&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (str.charAt(k) == <span class="string">&#x27;|&#x27;</span>)&#123;</span><br><span class="line">                k++;<span class="comment">// 跳过&#x27;|&#x27;</span></span><br><span class="line">                <span class="keyword">int</span> t = dfs();</span><br><span class="line">                res = res &gt; t ? res : t;<span class="comment">// 取左右两边的最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (str.charAt(k) == <span class="string">&#x27;)&#x27;</span>) <span class="keyword">break</span>;<span class="comment">// 跳出循环，这一层已经算完了</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                k++;<span class="comment">// 跳过&#x27;x&#x27;</span></span><br><span class="line">                res++;<span class="comment">// 数量+1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-8-acwing-1225-正则问题（巨难）"><a href="#1-8-acwing-1225-正则问题（巨难）" class="headerlink" title="1.8 acwing.1225. 正则问题（巨难）"></a>1.8 acwing.1225. 正则问题（巨难）</h4><p>第十届蓝桥杯省赛C++A组,第十届蓝桥杯省赛JAVAA组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">糖果店的老板一共有 M 种口味的糖果出售。</span><br><span class="line">为了方便描述，我们将 M 种口味编号 <span class="number">1</span>∼M。</span><br><span class="line">小明希望能品尝到所有口味的糖果。</span><br><span class="line">遗憾的是老板并不单独出售糖果，而是 K 颗一包整包出售。</span><br><span class="line">幸好糖果包装上注明了其中 K 颗糖果的口味，所以小明可以在买之前就知道每包内的糖果口味。</span><br><span class="line">给定 N 包糖果，请你计算小明最少买几包，就可以品尝到所有口味的糖果。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含三个整数 N,M,K。</span><br><span class="line">接下来 N 行每行 K 这整数 T1,T2,⋅⋅⋅,TK，代表一包糖果的口味。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">一个整数表示答案。</span><br><span class="line">如果小明无法品尝所有口味，输出 −<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤N≤<span class="number">100</span>,</span><br><span class="line"><span class="number">1</span>≤M,K≤<span class="number">20</span>,</span><br><span class="line"><span class="number">1</span>≤Ti≤M</span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">6</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>本题也是考察<strong>递归</strong>，自我感觉难度比较大。</p>
<p>观前提示：第一次接触的铁汁需要高能预警，全程信息密度超大需要反复听！！！（每看一遍都有新的收获）</p>
<p>重复覆盖问题。</p>
<p><img src="/posts/33ef06f1/image-20210621151826794.png" alt="image-20210621151826794"></p>
<p>大致顺序：先枚举可选择数最少的一列，然后再在这一列中枚举选择哪一行。</p>
<p>三个优化方向：迭代加深–&gt;枚举可选择数最少的列–&gt;可行性剪枝。</p>
<p>其中迭代加深与可行性剪枝合起来称为*<em>IDA</em>算法*<em>。（DFS版本的A</em>算法）</p>
<p>迭代加深的意思也就是在dfs函数中添加一个参数（本题是depth）来控制迭代次数，1次不能搜到答案，参数</p>
<p>+1搜2次，2次不够就3次，直到达到参数的限制范围，如本题糖果包数最多不可能超过m次。这样做的好处是</p>
<p>防止答案在浅层而dfs搜索到很深找不到答案。</p>
<p>可行性剪枝用到的是估价函数h，用来确定答案的下界（至少的方案数）。</p>
<p>本题的各种<strong>位运算</strong>的操作也是非常之精妙！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>, M=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; col[N];<span class="comment">//用来记录col中每一列可选择的行数有哪些</span></span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> log2[M];<span class="comment">//预处理，方便计算 log2(2的n次方)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">// 返回二进制最后一位1及以后的数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">h</span><span class="params">(<span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//编写估价函数，可行性剪枝，看这时的state最少需要用几行来完成</span></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//求最小方案数时，假设选择了某一列，则等价于选择了这一列的全部方案数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>-state;i;i-=lowbit(i))</span><br><span class="line">        <span class="comment">// i表示剩下哪些位数为1的列需要选择方案，lowbit可以高效地找到1的位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> c=log2[lowbit(i)];<span class="comment">//i返回最后一位1，通过log2直接映射为最后一位1的位置</span></span><br><span class="line">        res++;</span><br><span class="line">        <span class="comment">// 举例：可能选择第2列的3种方案，但res只计算了一次，所以是估计最少需要的行数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> row:col[c])</span><br><span class="line">        &#123;</span><br><span class="line">            i=i&amp;~row; <span class="comment">//row表示哪一列有1，每次选择一种方案，等价于将这种方案对应的位变为0，通过&amp;操作实现</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 搜索使得所有口味都被选到时返回true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> depth,<span class="keyword">int</span> state)</span><span class="comment">// depth表示层数，state用于维护选择糖果过程中已经选择了哪些口味</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!depth||h(state)&gt;depth)<span class="comment">// 递归边界</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//若层数为0或者最小需要选择的方案数大于当前可选的方案数的话，则判断是否合法</span></span><br><span class="line">        <span class="comment">//判断方法：看state是否全为1</span></span><br><span class="line">        <span class="keyword">return</span> state==(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>;<span class="comment">// (1&lt;&lt;m)-1表示m位全是一，即2^m-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接下来找可选择数最少的一列，这样需要的时间最少</span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">-1</span>;<span class="comment">//t是指向选择数最少的那一列的指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span> - state; i; i -= lowbit(i))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> c = log2[lowbit(i)];</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">-1</span> || col[t].size() &gt; col[c].size())</span><br><span class="line">            t = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接下来枚举选择哪一行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> row: col[t])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每搜索一层就表示选择了一种方案</span></span><br><span class="line">        <span class="keyword">if</span>(dfs(depth<span class="number">-1</span>,state|row)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="comment">//预处理log2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        log2[<span class="number">1</span>&lt;&lt;i]=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> state=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将该包糖果所包含的糖果对应的位数置为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">            state=state|<span class="number">1</span>&lt;&lt;c<span class="number">-1</span>;<span class="comment">// 左移c-1位，c=1时不用移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 枚举每一列</span></span><br><span class="line">        <span class="comment">//找出这包糖果 哪个位置可以填成1，将该列对应的col+1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(state&gt;&gt;j&amp;<span class="number">1</span>)<span class="comment">//若第j位有1</span></span><br><span class="line">            &#123;</span><br><span class="line">                col[j].push_back(state);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> depth=<span class="number">0</span>;<span class="comment">// depth用于控制搜索层数不超过限制m，state参数用于搜索的判断</span></span><br><span class="line">    <span class="keyword">while</span>(!dfs(depth,<span class="number">0</span>)&amp;&amp;depth&lt;=m) depth++;</span><br><span class="line">    <span class="keyword">if</span>(depth&gt;m) depth=<span class="number">-1</span>;<span class="comment">// m种口味的糖果至多需要m包</span></span><br><span class="line">    <span class="comment">// 迭代加深控制层数不超过m，防止答案在浅层而dfs搜索到很深找不到答案</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;depth&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>位运算</tag>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（三九）</title>
    <url>/posts/d1f4ef89.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="3-acwing-1213-斐波那契"><a href="#3-acwing-1213-斐波那契" class="headerlink" title="3 acwing.1213. 斐波那契"></a>3 acwing.1213. 斐波那契</h4><p>第五届蓝桥杯省赛C++A组,第五届蓝桥杯省赛JAVAA组</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">斐波那契数列大家都非常熟悉。它的定义是：</span><br><span class="line">f(x)=<span class="number">1.</span>...(x=<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">f(x)=f(x−<span class="number">1</span>)+f(x−<span class="number">2</span>)....(x&gt;<span class="number">2</span>)</span><br><span class="line">对于给定的整数 n 和 m，我们希望求出：</span><br><span class="line">f(<span class="number">1</span>)+f(<span class="number">2</span>)+…+f(n) 的值。</span><br><span class="line">但这个值可能非常大，所以我们把它对 f(m) 取模。</span><br><span class="line">但这个数字依然很大，所以需要再对 p 求模。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">输入包含多组数据。</span><br><span class="line">每组数据占一行，包含三个整数 n,m,p。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">每组数据输出一个整数，表示答案。</span><br><span class="line">每个数占一行。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">0</span>&lt;n,m,p&lt;<span class="number">10</span>^<span class="number">18</span></span><br><span class="line">测试数据不超过<span class="number">100</span>组</span><br><span class="line"></span><br><span class="line">输入样例<span class="number">1</span>：</span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line">输出样例<span class="number">1</span>：</span><br><span class="line"><span class="number">0</span></span><br><span class="line">输入样例<span class="number">2</span>：</span><br><span class="line"><span class="number">15</span> <span class="number">11</span> <span class="number">29</span></span><br><span class="line">输出样例<span class="number">2</span>：</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>参考题解：<a href="https://www.acwing.com/solution/content/43729/">https://www.acwing.com/solution/content/43729/</a></p>
<p>y总说了，这题巨难，做好心理准备。（看着寥寥无几的题解和通过数就知道了）</p>
<p>应该是我目前为止遇到最难的题了。（蓝桥杯不简单）</p>
<p>难点：数据范围特大，需要取2次模，多组测试数据。（斐波那契数列可能没你想的那么简单！）</p>
<p>题目涉及到斐波那契求前n项和，可以参考 acwing.1303. 斐波那契前 n 项和。（矩阵快速幂）</p>
<p>前n项和Sn和第m项f(m)都可能会非常大，先考虑Sn % f(m)有没有公式表示，因为它不可能直接存下来，再考虑它mod p，p相比前面的就小得多。</p>
<p>之前介绍了矩阵快速幂求解前n项和，这里直接推导<strong>数学公式</strong>计算。（斐波那契前 n 项和公式）</p>
<p><img src="/posts/d1f4ef89/image-20210705132018482.png" alt="image-20210705132018482"></p>
<p>所以：<strong>Sn = f(n+2) - 1</strong>。</p>
<p><img src="/posts/d1f4ef89/image-20210706115427262.png" alt="image-20210706115427262"></p>
<p><img src="/posts/d1f4ef89/image-20210706115509499.png" alt="image-20210706115509499"></p>
<p><img src="/posts/d1f4ef89/image-20210706115530101.png" alt="image-20210706115530101"></p>
<p><img src="/posts/d1f4ef89/image-20210706111228721.png" alt="image-20210706111228721"></p>
<p>矩阵快速幂求Fibonacci数列第n项就不再介绍了，具体参见蓝桥杯（三七）。</p>
<p>注意到数据范围是10^18，大概是2^60，计算a=a*a时用到两个10^18相乘就是10^36，超过long long的范围，所以需要高精度或者龟速乘来处理。</p>
<p><strong>龟速乘</strong>（慢工出细活，时间换精度），原理类似快速幂，将乘法转化成加法来处理爆long long的问题，相应的时间也会从O(1)变成O(logn)。</p>
<p><code>a(10)*b(10) = a(10)*b(2)，eg. a(10)*19(10) = a(10)*10011(2) = 2^0 *a +2^1 *a +2^4 *a</code></p>
<p>快速幂和龟速乘都用到了倍增思想以及二进制。</p>
<p>注：上面图片中推导过程不太完整，有部分地方没有说明，但是在代码中会完整计算，样例也会基本覆盖所有情况。（再次吐槽，这题真的超级麻烦）</p>
<p>参考：<a href="https://www.acwing.com/blog/content/4794/">https://www.acwing.com/blog/content/4794/</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 龟速乘与快速幂的对比</span></span><br><span class="line"><span class="comment">//龟速乘,利于快速幂的思想进行乘 </span></span><br><span class="line"><span class="function">ll <span class="title">mul</span><span class="params">(ll n,ll m,ll p)</span></span>&#123;<span class="comment">// 相乘爆long long，相加不会爆long long</span></span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            res = (res + n)%p;</span><br><span class="line">        &#125;</span><br><span class="line">        n = n*<span class="number">2</span>%p;</span><br><span class="line">        m /= <span class="number">2</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快速幂</span></span><br><span class="line"><span class="function">ll <span class="title">power</span><span class="params">(ll n,ll m,ll p)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(m != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            ans = ans * n % p;</span><br><span class="line">        n = n * n % p;</span><br><span class="line">        m = m/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>代码：</p>
<p>注意：long long的输入输出很容易出错，导致整道题错误！！！</p>
<p>mod p与% p的区别：前者是数学上的取模运算，结果&gt;=0且&lt;p；后者是C++中的取模运算，结果可能为负数，需要转化为正数。</p>
<p>代码量和注释量都非常大！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line">LL n,m,p;</span><br><span class="line"><span class="function">LL <span class="title">qmul</span><span class="params">(LL a,LL b)</span></span>&#123;<span class="comment">// 龟速乘计算(a*b) % p</span></span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = (res + a) % p;<span class="comment">// b(2)的末位是1</span></span><br><span class="line">        a = (a + a) % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;<span class="comment">// b(2)向右移动一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(LL c[][<span class="number">2</span>],LL a[][<span class="number">2</span>],LL b[][<span class="number">2</span>])</span></span>&#123;<span class="comment">// 可以省略第1维，后面不能省略</span></span><br><span class="line">    LL temp[<span class="number">2</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">2</span>;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">2</span>;k++)</span><br><span class="line">                temp[i][j] = (temp[i][j] + qmul(a[i][k],b[k][j])) % p;<span class="comment">// 龟速乘替代普通乘</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(c,temp,<span class="keyword">sizeof</span> temp);<span class="comment">// sizeof c是错误的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">F</span><span class="params">(LL n)</span></span>&#123;<span class="comment">// Fn = F1*a^(n-1)</span></span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 特判n=0的情况，否则陷入死循环</span></span><br><span class="line">    </span><br><span class="line">    LL f[<span class="number">2</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>&#125;;<span class="comment">// 初始矩阵F1 = [1 1;0 0]，第1行是f(1),f(2)</span></span><br><span class="line">    LL a[<span class="number">2</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;<span class="comment">// 等价于&#123;&#123;0,1&#125;,&#123;1,1&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(LL k = n<span class="number">-1</span>; k ;k &gt;&gt;= <span class="number">1</span>)&#123;<span class="comment">// 等价于n--;while(n)&#123;...k &gt;&gt;= 1&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) mul(f,f,a);</span><br><span class="line">        mul(a,a,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">H</span><span class="params">(LL m,LL k)</span></span>&#123;<span class="comment">// 计算(f(m-1)*f(k) - 1)  (mod f(m))，利用Fibonacci两数相乘结论</span></span><br><span class="line">    <span class="comment">// 参考最后一种情况</span></span><br><span class="line">    <span class="keyword">if</span> (k % <span class="number">2</span>)<span class="comment">// k是奇数，结果是f(m-k)-1  (mod f(m))，m = k不可能出现，不用特判</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> F(m-k) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">// k是偶数，结果是f(m)-f(m-k)-1，f(m)=f(m-k)可能成立，需要特判</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || (m == <span class="number">2</span> &amp;&amp; k == <span class="number">1</span>)) <span class="keyword">return</span> F(m) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> F(m) - F(m-k) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">G</span><span class="params">(LL n,LL m)</span></span>&#123;<span class="comment">// 计算(f(n)-1) mod f(m) = (f(n) mod f(m) - 1) mod f(m)</span></span><br><span class="line">    <span class="comment">// 根据n/m，n%m，n/(2m)三个数进行分类讨论，注意是下取整，结果可能出现负数需要特判</span></span><br><span class="line">    <span class="keyword">if</span> (m % <span class="number">2</span> == <span class="number">0</span>)<span class="comment">// m是偶数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n / m % <span class="number">2</span> == <span class="number">0</span>)<span class="comment">// 且n/m是偶数，结果是f(n mod m)-1  (mod f(m))</span></span><br><span class="line">        &#123;   <span class="comment">// 特判n整除m的情况,设n = k*m,利用情况1所归纳出的公式可知f(k*m)=f((k-1)*m)*f(m-1)=...=f(m)*xxx</span></span><br><span class="line">            <span class="comment">// 所以此时f(n) mod f(m) = 0</span></span><br><span class="line">            <span class="keyword">if</span> (n % m == <span class="number">0</span>) <span class="keyword">return</span> F(m)<span class="number">-1</span>;<span class="comment">// F(n % m) = 0，但取模结果为正，所以加上F(m)</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> F(n % m) - <span class="number">1</span>;             </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">// 且n/m是奇数，结果是f(m-1)*f(n mod m)  (mod(f(m))</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> H(m,n % m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">// m是奇数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n / m % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; n / m / <span class="number">2</span> % <span class="number">2</span> == <span class="number">0</span>)<span class="comment">// 且n/m和n/(2m)都是偶数，结果是f(n mod m)-1  (mod f(m))</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % m == <span class="number">0</span>) <span class="keyword">return</span> F(m)<span class="number">-1</span>;<span class="comment">// F(n % m) = 0，但取模结果为正，所以加上F(m)</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> F(n % m) - <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n / m % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; n / m / <span class="number">2</span> % <span class="number">2</span>)<span class="comment">// 且n/m是偶数，n/(2m)是奇数，结果是f(m)-f(n mod m)-1  (mod f(m))</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 特判f(m) = f(n mod m)的情况，只可能是f(1) = f(2)</span></span><br><span class="line">            <span class="keyword">if</span> (n % m == <span class="number">1</span> &amp;&amp; m == <span class="number">2</span>) <span class="keyword">return</span> F(m)<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> F(m) - F(n % m) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n / m % <span class="number">2</span> &amp;&amp; n / m / <span class="number">2</span> % <span class="number">2</span> == <span class="number">0</span>)<span class="comment">// 且n/m是奇数，n/(2m)是偶数，结果是f(m-1)*f(n mod m)-1  (mod(f(m))</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> H(m,n % m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">// 且n/m是奇数，n/(2m)是奇数，结果是f(m)-[f(m-1]*f(n mod m)  (mod(f(m))]-1  (mod(f(m))</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当n mod m 是奇数时，套用结论，f(m-1)*f(n mod m) = f(m- n mod m)</span></span><br><span class="line">            <span class="keyword">if</span> (n % m % <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 特判f(m) = f(m- n mod m)的情况，只可能是f(1) = f(2)</span></span><br><span class="line">                <span class="keyword">if</span> (m == <span class="number">2</span> &amp;&amp; m - n % m == <span class="number">1</span>) <span class="keyword">return</span> F(m) - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> F(m) - F(m - n % m) - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">// 当n mod m 是偶数时，套用结论，f(m-1)*f(n mod m) = f(m) - f(m- n mod m)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 结果是f(m - n mod m)-1  (mod(f(m))，f(m - n mod m)不可能=0，不用特判</span></span><br><span class="line">                <span class="keyword">return</span> F(m - n % m) - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;p) != EOF)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(G(n+<span class="number">2</span>,m) % p + p) % p);<span class="comment">// 最终输出的答案应该是：(f(n+2)-1) mod f(m) mod p</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意： &gt;&gt; 1 和/ 2不总是等价的，比如-1 &gt;&gt; 1 = -1, -1 / 2  = 0。如果不在F(n)中加入n=0的特判，就会陷入死循环！</p>
<h4 id="4-acwing-1206-剪格子"><a href="#4-acwing-1206-剪格子" class="headerlink" title="4 acwing.1206. 剪格子"></a>4 acwing.1206. 剪格子</h4><p>第四届蓝桥杯省赛C++A/C组,第四届蓝桥杯省赛JAVAA/C组</p>
<p><img src="/posts/d1f4ef89/image-20210706181114316.png" alt="image-20210706181114316"></p>
<p>我们沿着图中的红色线剪开，得到<strong>两个部分</strong>，每个部分的数字和都是 60。</p>
<p>本题的要求就是请你编程判定：对给定的 m×n 的格子中的整数，是否可以分割为<strong>两个连通的部分</strong>，使得这两个区域的数字和相等。</p>
<p>如果存在多种解答，请输出包含左上角格子的那个区域包含的格子的最小数目。</p>
<p>如果无法分割，则输出 0。</p>
<p><img src="/posts/d1f4ef89/image-20210706181154353.png" alt="image-20210706181154353"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入格式</span><br><span class="line">第一行包含两个整数 m,n,表示表格的宽度和高度。</span><br><span class="line">接下来是 n 行，每行 m 个正整数，用空格分开。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">在所有解中，包含左上角的分割区可能包含的最小的格子数目。</span><br><span class="line">如果无法分割，则输出 <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤n,m&lt;<span class="number">10</span>,</span><br><span class="line">格子内的数均在<span class="number">1</span>到<span class="number">10000</span>之间。</span><br><span class="line"></span><br><span class="line">输入样例<span class="number">1</span>：</span><br><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">10</span> <span class="number">1</span> <span class="number">52</span></span><br><span class="line"><span class="number">20</span> <span class="number">30</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">输出样例<span class="number">1</span>：</span><br><span class="line"><span class="number">3</span></span><br><span class="line">输入样例<span class="number">2</span>：</span><br><span class="line"><span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">30</span> <span class="number">80</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">100</span></span><br><span class="line">输出样例<span class="number">2</span>：</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>坑：n和m是反过来的，n行在后面。</p>
<p>这题难度与斐波那契不相上下。（高难预警）</p>
<p>错误预警：</p>
<ol>
<li>没有判断剪开后只有两个连通块；</li>
<li>按照一笔能画完的方式搜索；</li>
<li>按照两笔能画完的方式搜索。</li>
</ol>
<p>以上都是错误的！</p>
<p>蓝桥杯官网仅包含了以左上角为起点，可不重复一笔画完成的裁剪数据，比如题目描述中的图一。</p>
<p>所以说，网上题解水太深，质量参差不齐，你把握不住，还是y总最靠谱！</p>
<p>且看y总的“锯齿状”搜索！</p>
<p>未完待更。</p>
<h4 id="5-acwing-523-组合数问题"><a href="#5-acwing-523-组合数问题" class="headerlink" title="5 acwing.523. 组合数问题"></a>5 acwing.523. 组合数问题</h4><p>NOIP2016提高组</p>
<p><img src="/posts/d1f4ef89/image-20210706222159450.png" alt="image-20210706222159450"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入格式</span><br><span class="line">第一行有两个整数 t, k ，其中 t 代表该测试点总共有多少组测试数据，k 的意义见问题描述。</span><br><span class="line">接下来 t 行每行两个整数 n, m，其中 n, m 的意义见问题描述。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">共 t 行，每行一个整数代表所有的 <span class="number">0</span> ≤ i ≤ n, <span class="number">0</span> ≤ j ≤ min(i, m) 有多少对 (i, j) 满足 Cji 是 k 的倍数。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤n,m≤<span class="number">2000</span>,<span class="number">2</span>≤k≤<span class="number">21</span>,<span class="number">1</span>≤t≤<span class="number">10</span>^<span class="number">4</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>前置知识：（排列组合忘完了）</p>
<p>参考排列组合相关知识：<a href="https://oi-wiki.org/math/combination/">https://oi-wiki.org/math/combination/</a></p>
<p>排列的计算公式如下：<br>$$<br>\mathrm{A}<em>{n}^{m}=n(n-1)(n-2) \cdots(n-m+1)=\frac{n !}{(n-m) !}<br>$$<br>组合数计算公式：<br>$$<br>\mathrm{C}</em>{n}^{m}=\frac{\mathrm{A}<em>{n}^{m}}{m !}=\frac{n !}{m !(n-m) !}<br>$$<br>如何理解上述公式? 我们考虑 $n$ 个人 $m(m \leq n)$ 个出来，不排队， 不在乎顺序 $C</em>{n}^{m}$ 。如果在乎排列那么就是 $A_{n}^{m}$, 如果不在乎那么就要除掉重复，那么重复了多少? 同样选出的来的 $m$ 个人， 他们还要”全排”得 $A_{n}^{m}$, 所以得：<br>$$<br>\begin{gathered}<br>\mathrm{C}<em>{n}^{m} \times m !=\mathrm{A}</em>{n}^{m} \<br>\mathrm{C}<em>{n}^{m}=\frac{\mathrm{A}</em>{n}^{m}}{m !}=\frac{n !}{m !(n-m) !}<br>\end{gathered}<br>$$</p>
<p>$$<br>\text { 组合数也常用 }\left(\begin{array}{c}<br>n \<br>m<br>\end{array}\right) \text { 表示，读作 }\lceil n \text { 选 } m\rfloor, \text { 即 } \mathrm{C}_{n}^{m}=\left(\begin{array}{c}<br>n \<br>m<br>\end{array}\right) \text { 。 }<br>$$</p>
<p>参考题解：<a href="https://www.acwing.com/solution/content/3157/">https://www.acwing.com/solution/content/3157/</a></p>
<p>根据题意，划定的组合数的i、j的范围限制在蓝色阴影梯形。我们不妨将区域扩展为n*m的整个矩形，在对角线之上的${C}_{i}^{j}$是不合法的，设为0；对于蓝色阴影梯形，如果$C_i^j\ %\ k = 0$，设为1，否则设为0。所以整个矩形上的每个点都有一个值，0或1。</p>
<p><img src="/posts/d1f4ef89/image-20210707171919463.png" alt="image-20210707171919463"></p>
<p>我们再通过二维前缀和来预处理这个矩形区域，计算1的个数，也就是答案。</p>
<p>接下来的问题是如何计算组合数？</p>
<ol>
<li>通过题目中给出的定义公式，有阶乘的乘法和除法，很容易爆long long，精度可能也不高，比较麻烦。</li>
<li>按照递推公式（杨辉三角的公式表达）计算，${C}<em>{n}^{m}={C}</em>{n-1}^{m}+{C}_{n-1}^{m-1}$。（时间复杂度：$O(n^2)$）</li>
</ol>
<p>由于${C}_{n}^{m}$表示从n个不同的数中选择m个数的方案数，因此转化为以下两项之和：一，不选最后一个数，从前n-1个数中选m个数；二，选最后一个数，从前n-1个数中选m-1个数。（参考：算法笔记）</p>
<p>注意：${C}<em>{n}^{0}={C}</em>{n}^{n}=1,{C}_{0}^{0}一般约定为1$。</p>
<p>在计算组合数的过程中还需要判断% k的值。</p>
<p>递推出$C_n^m$的时间复杂度是 $O(n^2)$，预处理二维前缀和的时间复杂度也是$O(n^2)$。每次查询时直接查表即可，时间复杂度是 O(1)，一共有 t 次询问，因此总时间复杂度是 $O(n^2+t)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">int</span> c[N][N];<span class="comment">// 组合数 % k的余数</span></span><br><span class="line"><span class="keyword">int</span> s[N][N];<span class="comment">// 二维前缀和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;t,&amp;k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)<span class="comment">// 预处理组合数 % k</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!j) c[i][j] = <span class="number">1</span> % k;</span><br><span class="line">            <span class="keyword">else</span> c[i][j] = (c[i<span class="number">-1</span>][j<span class="number">-1</span>] + c[i<span class="number">-1</span>][j]) % k;<span class="comment">// % k结果为0答案+1，否则不变</span></span><br><span class="line">            <span class="keyword">if</span> (!c[i][j]) s[i][j] = <span class="number">1</span>;<span class="comment">// 1，初始化前缀和数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 下标从1开始，方便和c数组统一处理，但需要判断下标是否越界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)<span class="comment">// 计算二维前缀和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)&#123;</span><br><span class="line">            <span class="comment">//s[i][j] = (j &lt;= i &amp;&amp; c[i][j] == 0 ? 1 : 0);// 等价于1的处理</span></span><br><span class="line">            <span class="keyword">if</span> (i) s[i][j] += s[i<span class="number">-1</span>][j];<span class="comment">// 等价于i-1&gt;=0</span></span><br><span class="line">            <span class="keyword">if</span> (j) s[i][j] += s[i][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i &amp;&amp; j) s[i][j] -= s[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理询问</span></span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[n][m]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>矩阵快速幂</tag>
        <tag>龟速乘</tag>
        <tag>组合数</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（三二）</title>
    <url>/posts/7ef1a5a3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="1-5-acwing-1223-最大比例"><a href="#1-5-acwing-1223-最大比例" class="headerlink" title="1.5 acwing.1223. 最大比例"></a>1.5 acwing.1223. 最大比例</h4><p>第七届蓝桥杯省赛C++A/B组</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">X星球的某个大奖赛设了 M 级奖励。</span><br><span class="line">每个级别的奖金是一个正整数。</span><br><span class="line">并且，相邻的两个级别间的比例是个固定值。</span><br><span class="line">也就是说：所有级别的奖金数构成了一个等比数列。</span><br><span class="line">比如：<span class="number">16</span>,<span class="number">24</span>,<span class="number">36</span>,<span class="number">54</span>，其等比值为：<span class="number">3</span>/<span class="number">2</span>。</span><br><span class="line">现在，我们随机调查了一些获奖者的奖金数。</span><br><span class="line">请你据此推算可能的最大的等比值。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行为数字 N ，表示接下的一行包含 N 个正整数。</span><br><span class="line">第二行 N 个正整数 Xi，用空格分开，每个整数表示调查到的某人的奖金数额。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">一个形如 A/B 的分数，要求 A、B 互质，表示可能的最大比例系数。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">0</span>&lt;N&lt;<span class="number">100</span></span><br><span class="line"><span class="number">0</span>&lt;Xi&lt;<span class="number">10</span>^<span class="number">12</span></span><br><span class="line">数据保证一定有解。</span><br><span class="line"></span><br><span class="line">输入样例<span class="number">1</span>：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1250</span> <span class="number">200</span> <span class="number">32</span></span><br><span class="line">输出样例<span class="number">1</span>：</span><br><span class="line"><span class="number">25</span>/<span class="number">4</span></span><br><span class="line">输入样例<span class="number">2</span>：</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3125</span> <span class="number">32</span> <span class="number">32</span> <span class="number">200</span></span><br><span class="line">输出样例<span class="number">2</span>：</span><br><span class="line"><span class="number">5</span>/<span class="number">2</span></span><br><span class="line">输入样例<span class="number">3</span>：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">549755813888</span> <span class="number">524288</span> <span class="number">2</span></span><br><span class="line">输出样例<span class="number">3</span>：</span><br><span class="line"><span class="number">4</span>/<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>与等差数列那题有类似之处。</p>
<p>辗转相减法：也称为更相减损术，用于求两数的最大公约数。数学表达：<code>(a,b) = (b,a-b)</code></p>
<p>基本原理是：大数减小数，直到两数相等时，即为最大公约数。</p>
<p>这个原理很容易理解，也很好证明。</p>
<p>辗转相除法的时间复杂度是O(logn)，而辗转相减法的时间复杂度是O(n)，当数据量达到10^9这种级别时，差</p>
<p>距很大，后者用到的情况很少。</p>
<p><img src="/posts/7ef1a5a3/image-20210620162227589.png" alt="image-20210620162227589"></p>
<p>我们要求最大的公比，也就是要保证k的取值最大，所以k是$\alpha_1,\alpha_2,…,\alpha_{N-1}$的最大公约数。</p>
<p>所以问题就是：给定两个数$p^x$和$p^y$，如何求出$f(p^x,p^y)=p^{(x,y)}$。</p>
<p>利用辗转相减法，$p^{(x,y)}=p^{(y,y-x)}=f(p^y,p^{y-x})=f(p^y,\frac {p^y} {p^x})$，就转化成了一个递归问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line">LL x[N],a[N],b[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a,LL b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我们这里要用更相减损术的是指数，所以要让(p/q)^x1,(p/q)^x2,...,(p/q)^x(N-1)，两两计算，互除，除到结果为1,即x1=x2,此时幂次为0，结果为1，这其实就是y总的思路</span></span><br><span class="line"><span class="comment">//把分子分母分别去算，结果是相同的因为，分子分母的幂次是相同的</span></span><br><span class="line"><span class="function">LL <span class="title">gcd_sub</span><span class="params">(LL a,LL b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) swap(a,b);<span class="comment">// 保证a&gt;b，大的除以小的</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> a;<span class="comment">// 递归边界</span></span><br><span class="line">    <span class="keyword">return</span> gcd_sub(b,a/b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">cin</span> &gt;&gt; x[i];</span><br><span class="line">    sort(x,x+n);<span class="comment">// 排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (x[i] != x[i<span class="number">-1</span>])&#123;<span class="comment">// 判重</span></span><br><span class="line">            LL d = gcd(x[i],x[<span class="number">0</span>]);</span><br><span class="line">            a[cnt] = x[i]/d;<span class="comment">//得到x[i]/x[0]的分子</span></span><br><span class="line">            b[cnt] = x[<span class="number">0</span>]/d;<span class="comment">//得到x[i]/x[0]的分母</span></span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LL up = a[<span class="number">0</span>],down = b[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; cnt;i++)&#123;<span class="comment">// a[i1]/b[i1] = p^x,a[i2]/b[i2] = p^y，求p^(x,y)</span></span><br><span class="line">        up = gcd_sub(up,a[i]);</span><br><span class="line">        down = gcd_sub(down,b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; up &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; down &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-acwing-1301-C-循环"><a href="#1-6-acwing-1301-C-循环" class="headerlink" title="1.6 acwing.1301. C 循环"></a>1.6 acwing.1301. C 循环</h4><p>《信息学奥赛一本通》 , POJ</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">对于 C 语言的循环语句，形如：</span><br><span class="line"><span class="keyword">for</span> (variable = A; variable != B; variable += C)</span><br><span class="line">  statement;</span><br><span class="line">请问在 k 位存储系统中循环几次才会结束。</span><br><span class="line">若在有限次内结束，则输出循环次数。否则输出死循环。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">多组数据，每组数据一行四个整数 A,B,C,k。</span><br><span class="line">读入以 <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> 结束。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">若在有限次内结束，则输出循环次数。</span><br><span class="line">否则输出 FOREVER。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤k≤<span class="number">32</span>,</span><br><span class="line"><span class="number">0</span>≤A,B,C&lt;^<span class="number">2</span>k</span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">2</span> <span class="number">16</span></span><br><span class="line"><span class="number">3</span> <span class="number">7</span> <span class="number">2</span> <span class="number">16</span></span><br><span class="line"><span class="number">7</span> <span class="number">3</span> <span class="number">2</span> <span class="number">16</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">2</span> <span class="number">16</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">32766</span></span><br><span class="line">FOREVER</span><br></pre></td></tr></table></figure>

<p>思路：类似五指山那题。</p>
<p>k位系统指的是对于一个数A只能存储k个二进制位，也就是A mod 2^k的结果。</p>
<p>比如110010，对于3位系统只能存下后三位(010)2 = (2)10。</p>
<p>所以退出循环的条件就是：(A + xC) mod 2^k = B，求x的最小值。</p>
<p>转化为：xC - y*2^k = B - A。</p>
<p>再利用扩展欧几里得算法求解方程ax+by = c的方式来解上面的方程。</p>
<p><img src="/posts/7ef1a5a3/image-20210620174737862.png" alt="image-20210620174737862"></p>
<p>当(a,b)|B-A时，有解，否则无解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">exGcd</span><span class="params">(LL a,LL b,LL &amp;x,LL &amp;y)</span></span>&#123;<span class="comment">// ax + by = d</span></span><br><span class="line">    <span class="keyword">if</span> (b==<span class="number">0</span>)&#123;</span><br><span class="line">        x = <span class="number">1</span>,y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    LL d = exGcd(b,a%b,y,x);</span><br><span class="line">    y -= a/b*x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL a,b,c,k;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; k,a || b || c || k)&#123;</span><br><span class="line">        LL z = <span class="number">1ll</span> &lt;&lt; k,x,y;<span class="comment">// z是long long的1</span></span><br><span class="line">        LL d = exGcd(c,z,x,y);</span><br><span class="line">        <span class="keyword">if</span> ((b-a) % d)  <span class="built_in">puts</span>(<span class="string">&quot;FOREVER&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            x *= (b-a)/d;</span><br><span class="line">            z /= d;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; (x%z+z)%z &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/7ef1a5a3/image-20210620181546866.png" alt="image-20210620181546866"></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（三五）</title>
    <url>/posts/eb5cdad3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="1-3-acwing-1222-密码脱落"><a href="#1-3-acwing-1222-密码脱落" class="headerlink" title="1.3 acwing.1222. 密码脱落"></a>1.3 acwing.1222. 密码脱落</h4><p>第七届蓝桥杯省赛C++A/C组,第七届蓝桥杯省赛JAVAC组</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">X星球的考古学家发现了一批古代留下来的密码。</span><br><span class="line">这些密码是由A、B、C、D 四种植物的种子串成的序列。</span><br><span class="line">仔细分析发现，这些密码串当初应该是前后对称的（也就是我们说的镜像串）。</span><br><span class="line">由于年代久远，其中许多种子脱落了，因而可能会失去镜像的特征。</span><br><span class="line">你的任务是：</span><br><span class="line">给定一个现在看到的密码串，计算一下从当初的状态，它要至少脱落多少个种子，才可能会变成现在的样子。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">共一行，包含一个由大写字母ABCD构成的字符串，表示现在看到的密码串。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示至少脱落了多少个种子。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">输入字符串长度不超过<span class="number">1000</span></span><br><span class="line"></span><br><span class="line">输入样例<span class="number">1</span>：</span><br><span class="line">ABCBA</span><br><span class="line">输出样例<span class="number">1</span>：</span><br><span class="line"><span class="number">0</span></span><br><span class="line">输入样例<span class="number">2</span>：</span><br><span class="line">ABDCDCBABC</span><br><span class="line">输出样例<span class="number">2</span>：</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>考察<strong>区间DP</strong>问题。区间DP属于线性DP的一种。（参考<a href="https://oi-wiki.org/dp/interval/">oi-wiki</a>）</p>
<p>令状态 f(i,j)表示将下标位置 i 到 j 的所有元素合并能获得的价值的最大值，那么 </p>
<p>f(i,j)=max{f(i,k)+f(k+1,j)+cost}，cost为将这两组元素合并起来的代价。</p>
<p>区间 DP 的特点：</p>
<p><strong>合并</strong>：即将两个或多个部分进行整合，当然也可以反过来；</p>
<p><strong>特征</strong>：能将问题分解为能两两合并的形式；</p>
<p><strong>求解</strong>：对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。</p>
<p>题目问的是已知当前序列，求从原始状态到现在至少脱落了多少个种子。</p>
<p>将题意转化一下：已知当前序列，求至少添加几个种子使它成为镜像串。（逆向思维）</p>
<p>还可以继续转化一下：<strong>已知当前序列，求至少删去几个种子使它成为镜像串。</strong>（可行性：添加种子使得左右配对也就等价于删去无法配对的单独种子）</p>
<p>所以最终的答案就是：<strong>至少脱落的种子数量=序列总长度 - 最长回文子序列长度</strong>。</p>
<p>注意：子串和子序列有区别，前者要求是序列中连续的一段，后者没有要求连续。</p>
<p><strong>算法1：y氏DP分析法。</strong></p>
<p><img src="/posts/eb5cdad3/image-20210625200659435.png" alt="image-20210625200659435"></p>
<p>关于第2和3种情况：情况2是包含L且不包含R；而f[L,R-1]表示的是所有从L到R-1的回文子序列的集合，它一定不包含R，但L是否包含不确定，所以它表示的子序列范围比情况2更大。由于集合属性是长度的最大值，且包含L的长度一定比不包含L的长度大，所以情况2集合的属性等价于f[L,R-1]的属性。（情况3分析类似）</p>
<p>我们发现第4种情况实际上是包含在第2和3种情况中的，所以可以省略第4种情况，前3种情况就能覆盖全部情况了。</p>
<p>对于端点从小到大枚举，这种做法是错误的，因为求f[L,R]会涉及到f[L+1,R-1]，而后者还没计算。</p>
<p>所以我们采用下面的方法，保证现在计算的状态所用到的之前的状态都已经计算过了。</p>
<p>每个区间状态都是由被它包含的更小的区间状态转移而来，所以我们一般先枚举区间长度，再枚举区间左右端点，再枚举决策，构成三层循环。（决策可能不需要多一重循环）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];<span class="comment">// 求max，dp数组初始化为0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;s);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>;len &lt;= n;len++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i + len - <span class="number">1</span> &lt; n;i++)&#123;<span class="comment">// i,j分别表示左右端点</span></span><br><span class="line">            <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">1</span>) dp[i][j] = <span class="number">1</span>;<span class="comment">// 初始化len=1的情况,dp[0][1]的len=2</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = max(dp[i+<span class="number">1</span>][j],dp[i][j<span class="number">-1</span>]);<span class="comment">// 情况2和3</span></span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) dp[i][j] = max(dp[i][j],dp[i+<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">2</span>);<span class="comment">// 情况1</span></span><br><span class="line">            &#125;<span class="comment">// 当len=2时，情况1计算f[0][1]会用到f[1][0]，这个数不合法，这时的子序列长度应为2</span></span><br><span class="line">            <span class="comment">// 而f[1][0]=0，所以不会影响</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n - dp[<span class="number">0</span>][n<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法2：另一种DP解法。</strong></p>
<p>参考自：<a href="https://www.acwing.com/solution/content/37925/%E3%80%82">https://www.acwing.com/solution/content/37925/。</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N][N];<span class="comment">//f[l][r]:表示将s[l~r]变成镜像串的最小操作数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    状态转移方程：</span></span><br><span class="line"><span class="comment">        ①s[l] == s[r]，此时可以直接从f[l + 1][r - 1]转移而来，并且操作数不用变</span></span><br><span class="line"><span class="comment">        ②s[l] != s[r]，此时可以选择从f[l + 1][r] 或 f[l][r - 1]转移而来，并且操作数+1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="built_in">memset</span>(f , <span class="number">0x3f</span> , <span class="keyword">sizeof</span> f);<span class="comment">// 求min，所以f数组置为INF，否则结果一直是0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">0</span> ; len &lt;= n ; len++)<span class="comment">// len必须从0开始枚举，与上一种方法不同</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span> ; l + len - <span class="number">1</span> &lt; n ; l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(len &lt;= <span class="number">1</span>) f[l][r] = <span class="number">0</span>;<span class="comment">// 初始化len&lt;=1的情况，长度为1或0就是镜像串</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[l] == s[r]) f[l][r] = f[l + <span class="number">1</span>][r - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> f[l][r] = min(f[l][r] , min(f[l + <span class="number">1</span>][r] , f[l][r - <span class="number">1</span>]) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="comment">// 当len=2时，情况1计算f[0][1]会用到f[1][0]，这个数不合法，这时的子序列操作数应为0</span></span><br><span class="line">            <span class="comment">// 而len=0的时候已经令f[1][0]=0，所以不会影响</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[<span class="number">0</span>][n - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上2种做法最好都掌握。<strong>注意DP数组的初始化问题</strong>，看决策是求max还是求min，还是别的。</p>
<h4 id="1-4-acwing-1220-生命之树"><a href="#1-4-acwing-1220-生命之树" class="headerlink" title="1.4 acwing.1220. 生命之树"></a>1.4 acwing.1220. 生命之树</h4><p>第六届蓝桥杯省赛C++B组,第六届蓝桥杯省赛JAVAB组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">在X森林里，上帝创建了生命之树。</span><br><span class="line">他给每棵树的每个节点（叶子也称为一个节点）上，都标了一个整数，代表这个点的和谐值。</span><br><span class="line">上帝要在这棵树内选出一个非空节点集 S，使得对于 S 中的任意两个点 a,b，都存在一个点列 &#123;a,v1,v2,…,vk,b&#125; 使得这个点列中的每个点都是 S 里面的元素，且序列中相邻两个点间有一条边相连。</span><br><span class="line">在这个前提下，上帝要使得 S 中的点所对应的整数的和尽量大。</span><br><span class="line">这个最大的和就是上帝给生命之树的评分。</span><br><span class="line">经过 atm 的努力，他已经知道了上帝给每棵树上每个节点上的整数。</span><br><span class="line">但是由于 atm 不擅长计算，他不知道怎样有效的求评分。</span><br><span class="line">他需要你为他写一个程序来计算一棵树的分数。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行一个整数 n 表示这棵树有 n 个节点。</span><br><span class="line">第二行 n 个整数，依次表示每个节点的评分。</span><br><span class="line">接下来 n−<span class="number">1</span> 行，每行 <span class="number">2</span> 个整数 u,v，表示存在一条 u 到 v 的边。</span><br><span class="line">由于这是一棵树，所以是不存在环的。</span><br><span class="line">树的节点编号从 <span class="number">1</span> 到 n。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一行一个数，表示上帝给这棵树的分数。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤n≤<span class="number">10</span>^<span class="number">5</span>,</span><br><span class="line">每个节点的评分的绝对值均不超过 <span class="number">10</span>^<span class="number">6</span>。</span><br><span class="line"></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">-2</span> <span class="number">-3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>考察<strong>树形DP</strong>，其实就是把DP放在树上处理，一般采用深度优先遍历的方式递归处理。</p>
<p>图的存储方式在蓝桥杯总结（二一）介绍过了，这里就不重复了。（这里用邻接表存储）</p>
<p>题意：找到一个无向图中的连通块，使得它的节点权值的总和最大。</p>
<p>深度优先遍历每个子结点。</p>
<p><img src="/posts/eb5cdad3/image-20210625231338415.png" alt="image-20210625231338415"></p>
<p>状态表示：f[u]:在以u为根的子树中包含u的所有连通块的权值的最大值</p>
<p>状态计算：假设s1，s2,…sk 是u的孩子，f[u]=w[u]+max(f[s1],0)+max(f[s2],0)+…max(f[sk],0)从根结点开始</p>
<p>时间复杂度：O(n)。只需要计算每条边，一共n-1条边。</p>
<p>这里采用数组实现邻接表来存储图。（图论一章介绍过数组实现单链表，忘记了的话看看826.单链表）</p>
<p>对于图的各种存储方式还不懂的话建议参考：<a href="https://www.cnblogs.com/linfangnan/p/12745834.html">https://www.cnblogs.com/linfangnan/p/12745834.html</a></p>
<p><img src="/posts/eb5cdad3/image-20210626100745550.png" alt="image-20210626100745550"></p>
<p><img src="/posts/eb5cdad3/image-20210626111810469.png" alt="image-20210626111810469"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = N * <span class="number">2</span>;<span class="comment">// N个顶点至多2*N条有向边</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> w[N];<span class="comment">// 节点的权值</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="comment">// h是顶点集（头结点），e[i]=b表示a指向b（一条边），ne[i]表示结点i的next的指针，idx指向当前需要插入（已经用过）的结点</span></span><br><span class="line">LL f[N];<span class="comment">// 在以u为根的子树中包含u的所有连通块的权值的最大值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><span class="comment">// 这里采用数组实现邻接表来存储图，也就是将多个单链表h[i]拼起来</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;<span class="comment">// 头插法创建单链表，新节点指向已有节点</span></span><br><span class="line">    <span class="comment">// h[a]是单链表a的起点，相当于头结点，最后一个插入元素的地址，也是idx区间的终点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> father)</span><span class="comment">// 求f[i]，第二个参数记录父节点，防止往回走</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[u] = w[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])<span class="comment">// i != -1等价于~i</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j != father)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(j, u);</span><br><span class="line">            f[u] += max(<span class="number">0ll</span>, f[j]);<span class="comment">// long long的0，和0比较一下，如果&lt;=0没必要加上</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);<span class="comment">// 记得h数组置-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )<span class="comment">// 一共n-1条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        add(a, b), add(b, a);<span class="comment">// 构建无向图</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    LL res = f[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ ) res = max(res, f[i]);<span class="comment">// 求f[1]到f[n]的max</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>树形DP</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（三八）</title>
    <url>/posts/ab39ced6.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="2-5-acwing-1217-垒骰子"><a href="#2-5-acwing-1217-垒骰子" class="headerlink" title="2.5 acwing.1217.垒骰子"></a>2.5 acwing.1217.垒骰子</h4><p>第六届蓝桥杯省赛C++A/B/C组,第六届蓝桥杯省赛JAVAA/B/C组</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> 赌圣atm晚年迷恋上了垒骰子，就是把骰子一个垒在另一个上边，不能歪歪扭扭，要垒成方柱体。</span><br><span class="line">经过长期观察，atm 发现了稳定骰子的奥秘：有些数字的面贴着会互相排斥！</span><br><span class="line">我们先来规范一下骰子：<span class="number">1</span> 的对面是 <span class="number">4</span>，<span class="number">2</span> 的对面是 <span class="number">5</span>，<span class="number">3</span> 的对面是 <span class="number">6</span>。</span><br><span class="line">假设有 m 组互斥现象，每组中的那两个数字的面紧贴在一起，骰子就不能稳定的垒起来。</span><br><span class="line">atm想计算一下有多少种不同的可能的垒骰子方式。</span><br><span class="line">两种垒骰子方式相同，当且仅当这两种方式中对应高度的骰子的对应数字的朝向都相同。</span><br><span class="line">由于方案数可能过多，请输出模 <span class="number">10</span>^<span class="number">9</span>+<span class="number">7</span> 的结果。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含两个整数 n,m，分别表示骰子的数目和排斥的组数。</span><br><span class="line">接下来 m 行，每行两个整数 a,b，表示 a 和 b 数字不能紧贴在一起。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">共一个数，表示答案模 <span class="number">10</span>^<span class="number">9</span>+<span class="number">7</span> 的结果。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤n≤<span class="number">10</span>^<span class="number">9</span>,</span><br><span class="line"><span class="number">1</span>≤m≤<span class="number">36</span>,</span><br><span class="line"><span class="number">1</span>≤a,b≤<span class="number">6</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">544</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>考察矩阵快速幂算法，感觉很难想到。</p>
<p>看完题，先不考虑巨大的数据量，根据一步步往上垒骰子这种模式，首先要想到DP解法，然后再考虑优化。</p>
<p>一个骰子的摆放方式是24种 (任意一面朝上侧面都可以旋转四次 4 * 6 = 24)</p>
<p>状态划分根据加入的第i个骰子最上面的数字j是几分为6种情况。</p>
<p>状态数量是<code>6*n</code>，状态转移量是6，所以复杂度为<code>36*n</code>。</p>
<p><img src="/posts/ab39ced6/image-20210702172930648.png" alt="image-20210702172930648"></p>
<p>接下来再考虑通过矩阵快速幂来优化时间复杂度。</p>
<p>由于DP数组的这种迭代的特点和Fibonacci数列很相似，所以构造矩阵处理。</p>
<p>因为数字的互斥关系是固定的且只有一组样例，所以矩阵A是不变的，可以计算快速幂。</p>
<p>计算A^2的时候需要三重循环6^3，所以时间复杂度为O(216*logn)。</p>
<p>构造向量和矩阵：$F_i = [f_{i,1}\ f_{i,2}\ …\ f_{i,6}],F_{i-1} = [f_{i-1,1}\ f_{i-1,2}\ …\ f_{i-1,6}]$，然后可以找到一个矩阵A使得:$F_{i} = F_{i-1} * A$，所以：$F_n = F_1*A^{n-1}$。矩阵A由0和4构成。</p>
<p>规则：1 的对面是 4，2 的对面是 5，3 的对面是 6。</p>
<p>再根据排斥规则来计算A矩阵，每组排斥数会使得A中的两项为0。</p>
<p>这里做法可以改进一下，不用像Fibonacci数列构造向量，直接把F扩充成矩阵，第一行不变，后面全部置零，就不用多写一个矩阵乘向量的函数。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6</span>,P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_op</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">// 求对面的数，0、1、2的对面是3、4、5</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">2</span>) <span class="keyword">return</span> x + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x - <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> c[][N],<span class="keyword">int</span> a[][N],<span class="keyword">int</span> b[][N])</span></span>&#123;<span class="comment">// 矩阵乘法：c = a*b</span></span><br><span class="line">    <span class="keyword">int</span> temp[N][N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; N;k++)<span class="comment">// a * b先用LL存，防止爆int</span></span><br><span class="line">                temp[i][j] = (temp[i][j] + (LL)a[i][k]*b[k][j]) % P;</span><br><span class="line">    <span class="built_in">memcpy</span>(c,temp,<span class="keyword">sizeof</span> temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++) a[i][j] = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">while</span> (m--)&#123;<span class="comment">// 初始化矩阵a</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        x--,y--;<span class="comment">// 从0开始计算，骰子上的数都-1</span></span><br><span class="line">        a[x][get_op(y)] = <span class="number">0</span>,a[y][get_op(x)] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f[N][N] = &#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>&#125;;<span class="comment">// 初始化f矩阵，f1的第一行都是4，后面都是0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = n<span class="number">-1</span>;k;k &gt;&gt;= <span class="number">1</span>)&#123;<span class="comment">// 快速幂的for循环写法</span></span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) mul(f,f,a);</span><br><span class="line">        mul(a,a,a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;<span class="comment">// 计算i个骰子的所有摆放方案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++) res = (res + f[<span class="number">0</span>][i]) % P;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十-疑难杂题"><a href="#十-疑难杂题" class="headerlink" title="十 疑难杂题"></a>十 疑难杂题</h2><p>最后剩下的7道题难度还比较大。（前2道还好，后面更难）</p>
<p>最后一章写完，蓝桥杯系列文章也就结束了！</p>
<h4 id="1-acwing-1242-修改数组"><a href="#1-acwing-1242-修改数组" class="headerlink" title="1 acwing.1242. 修改数组"></a>1 acwing.1242. 修改数组</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定一个长度为 N 的数组 A=[A1,A2,⋅⋅⋅AN]，数组中有可能有重复出现的整数。</span><br><span class="line">现在小明要按以下方法将其修改为没有重复整数的数组。</span><br><span class="line">小明会依次修改 A2,A3,⋅⋅⋅,AN。</span><br><span class="line">当修改 Ai 时，小明会检查 Ai 是否在 A1∼Ai−<span class="number">1</span> 中出现过。</span><br><span class="line">如果出现过，则小明会给 Ai 加上 <span class="number">1</span>；如果新的 Ai 仍在之前出现过，小明会持续给 Ai 加 <span class="number">1</span>，直到 Ai 没有在 A1∼Ai−<span class="number">1</span> 中出现过。</span><br><span class="line">当 AN 也经过上述修改之后，显然 A 数组中就没有重复的整数了。</span><br><span class="line">现在给定初始的 A 数组，请你计算出最终的 A 数组。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含一个整数 N。</span><br><span class="line">第二行包含 N 个整数 A1,A2,⋅⋅⋅,AN。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出 N 个整数，依次是最终的 A1,A2,⋅⋅⋅,AN。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤N≤<span class="number">10</span>^<span class="number">5</span>,</span><br><span class="line"><span class="number">1</span>≤Ai≤<span class="number">10</span>^<span class="number">6</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>看到题目我大概能猜到是模拟题，果不其然。</p>
<p>本题有2种做法，平衡树和并查集。</p>
<p>如果不熟悉<strong>朴素并查集</strong>请移步：<a href="https://www.grantdrew.top/posts/ad6fe702.html%E3%80%82">https://www.grantdrew.top/posts/ad6fe702.html。</a></p>
<p>算法1：并查集。（推荐做法，比较好写）</p>
<p>本题的并查集比较特殊，它是一个单链状的树。一般的并查集大多是多分支的树。</p>
<p>用到并查集的查找操作，没用到合并操作。</p>
<p>参考：<a href="https://www.acwing.com/solution/content/9045/">https://www.acwing.com/solution/content/9045/</a></p>
<p><img src="/posts/ab39ced6/image-20210702214149713.png" alt="image-20210702214149713"></p>
<p><img src="/posts/ab39ced6/image-20210702220526656.png" alt="image-20210702220526656"></p>
<p>时间复杂度：O(N)。（N = Ai）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">5</span>;<span class="comment">// Ai的大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[a] != a) p[a] = find(p[a]);<span class="comment">// p[a] = a表示还没用过，递归查找没用过的第1个数</span></span><br><span class="line">    <span class="keyword">return</span> p[a];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; N;i++) p[i] = i;<span class="comment">// 初始化，编号最大值是N，不是n</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        x = find(x);<span class="comment">// 找到第1个没有用过的数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,x);</span><br><span class="line">        p[x] = x + <span class="number">1</span>;<span class="comment">// p[x]表示x在树中的下一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>算法2：平衡树/STL set。这里先不介绍，比较麻烦。</p>
<p>有兴趣参考题解：<a href="https://www.acwing.com/solution/content/43965/%E3%80%82">https://www.acwing.com/solution/content/43965/。</a></p>
<h4 id="2-acwing-1234-倍数问题"><a href="#2-acwing-1234-倍数问题" class="headerlink" title="2 acwing.1234. 倍数问题"></a>2 acwing.1234. 倍数问题</h4><p>第九届蓝桥杯省赛C++A组,第九届蓝桥杯省赛JAVAA组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">众所周知，小葱同学擅长计算，尤其擅长计算一个数是否是另外一个数的倍数。</span><br><span class="line">但小葱只擅长两个数的情况，当有很多个数之后就会比较苦恼。</span><br><span class="line">现在小葱给了你 n 个数，希望你从这 n 个数中找到三个数，使得这三个数的和是 K 的倍数，且这个和最大。</span><br><span class="line">数据保证一定有解。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包括 <span class="number">2</span> 个正整数 n, K。</span><br><span class="line">第二行 n 个正整数，代表给定的 n 个数。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一行一个整数代表所求的和。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤n≤<span class="number">10</span>^<span class="number">5</span>,</span><br><span class="line"><span class="number">1</span>≤K≤<span class="number">10</span>^<span class="number">3</span>,</span><br><span class="line">给定的 n 个数均不超过 <span class="number">10</span>^<span class="number">8</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>这题考察背包问题。</p>
<p>与 acwing.1047. 糖果 类似，只不过多了一个只能选择3个数的限制。</p>
<p>本题要选择n个数，选3个数，且和是k的倍数。限制条件有3个，所以DP需要3个维度，是背包问题的变形。</p>
<p>将k的倍数问题转化为mod k的余数是多少，这样就很容易用DP处理。（y总的技巧）</p>
<p>注意可能出现负余数需要处理一下。</p>
<p>y氏DP分析法：</p>
<p><img src="/posts/ab39ced6/image-20210704224603184.png" alt="image-20210704224603184"></p>
<p>算法1：三维朴素DP解法，TLE+MLE。y总上面计算过了，空间太大了。（测试的2个样例都能过）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>,M = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">4</span>][M];<span class="comment">// j从0到3都需要使用，至少开4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;K);</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dp);<span class="comment">// 求max置为-INF</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">// 初始化条件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);<span class="comment">// 边读入边处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">3</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; K;k++)&#123;<span class="comment">// 记得处理负余数</span></span><br><span class="line">                dp[i][j][k] = max(dp[i<span class="number">-1</span>][j][k],dp[i<span class="number">-1</span>][j<span class="number">-1</span>][((k-x)%t + t) % t] + x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[n][<span class="number">3</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法2：二维DP+贪心优化。时间复杂度：O(3m*3m)。</p>
<p>贪心策略：我们会发现，选取一个数x和它本身的大小无关，而与x mod K的值有关，当有多个数取值相等时，取最大的数。</p>
<p>算法1中DP数组第1维大小是10^8，贪心优化之后，对于0~10^3-1的每个余数取值，只需要取前三大的数就行，所以DP数组第1维大小是3*10^3。这里用二维优化，n个数用另外的数组存。</p>
<p>二维优化类似01背包的滚动数组，第二维j必须逆序遍历！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">4</span>][N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        a[x % m].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        sort(a[i].begin(),a[i].end());</span><br><span class="line">        reverse(a[i].begin(),a[i].end());<span class="comment">// 从小到大排序再反转，实现从大到小排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>;u &lt; <span class="number">3</span> &amp;&amp; u &lt; a[i].size();u++)&#123;</span><br><span class="line">            <span class="comment">// 加上&lt;size的判断，a[i]的数可能不够3个</span></span><br><span class="line">            <span class="keyword">int</span> x = a[i][u];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span>;j &gt;= <span class="number">1</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; m;k++)&#123;</span><br><span class="line">                    dp[j][k] = max(dp[j][k],dp[j<span class="number">-1</span>][(k - x%m + m) % m] + x);</span><br><span class="line">                    <span class="comment">//原式：f[i][j][k]=max(f[i-1][j][k], </span></span><br><span class="line">                    <span class="comment">//f[i-1][j-1][(k-x%m + m)%m] + x)</span></span><br><span class="line">                    <span class="comment">//等价变形即为代码式子&lt;-让j从大到小枚举即为等价变形</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[<span class="number">3</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>并查集</tag>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（三六）</title>
    <url>/posts/8e52910a.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="2-习题"><a href="#2-习题" class="headerlink" title="2.习题"></a>2.习题</h3><h4 id="2-1-acwing-1226-包子凑数"><a href="#2-1-acwing-1226-包子凑数" class="headerlink" title="2.1 acwing.1226. 包子凑数"></a>2.1 acwing.1226. 包子凑数</h4><p>第八届蓝桥杯省赛C++A/B组,第八届蓝桥杯省赛JAVAA/B组</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">小明几乎每天早晨都会在一家包子铺吃早餐。</span><br><span class="line">他发现这家包子铺有 N 种蒸笼，其中第 i 种蒸笼恰好能放 Ai 个包子。</span><br><span class="line">每种蒸笼都有非常多笼，可以认为是无限笼。</span><br><span class="line">每当有顾客想买 X 个包子，卖包子的大叔就会迅速选出若干笼包子来，使得这若干笼中恰好一共有 X 个包子。</span><br><span class="line">比如一共有 <span class="number">3</span> 种蒸笼，分别能放 <span class="number">3</span>、<span class="number">4</span> 和 <span class="number">5</span> 个包子。</span><br><span class="line">当顾客想买 <span class="number">11</span> 个包子时，大叔就会选 <span class="number">2</span> 笼 <span class="number">3</span> 个的再加 <span class="number">1</span> 笼 <span class="number">5</span> 个的（也可能选出 <span class="number">1</span> 笼 <span class="number">3</span> 个的再加 <span class="number">2</span> 笼 <span class="number">4</span> 个的）。</span><br><span class="line">当然有时包子大叔无论如何也凑不出顾客想买的数量。</span><br><span class="line">比如一共有 <span class="number">3</span> 种蒸笼，分别能放 <span class="number">4</span>、<span class="number">5</span> 和 <span class="number">6</span> 个包子。</span><br><span class="line">而顾客想买 <span class="number">7</span> 个包子时，大叔就凑不出来了。</span><br><span class="line">小明想知道一共有多少种数目是包子大叔凑不出来的。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含一个整数 N。</span><br><span class="line">接下来 N 行，每行包含一个整数 Ai。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数代表答案。</span><br><span class="line">如果凑不出的数目有无限多个，输出INF。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤N≤<span class="number">100</span>,</span><br><span class="line"><span class="number">1</span>≤Ai≤<span class="number">100</span></span><br><span class="line">输入样例<span class="number">1</span>：</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">输出样例<span class="number">1</span>：</span><br><span class="line"><span class="number">6</span></span><br><span class="line">输入样例<span class="number">2</span>：</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">输出样例<span class="number">2</span>：</span><br><span class="line">INF</span><br><span class="line">样例解释</span><br><span class="line">对于样例<span class="number">1</span>，凑不出的数目包括： <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">11</span>。</span><br><span class="line">对于样例<span class="number">2</span>，所有奇数都凑不出来，所以有无限多个。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>参考题解：<a href="https://www.acwing.com/solution/content/17888/%E3%80%82">https://www.acwing.com/solution/content/17888/。</a></p>
<p>和<a href="https://www.acwing.com/problem/content/1207/">1205. 买不到的数目</a>有相似的地方，一样会用到裴蜀定理。</p>
<p>由1205得到结论：（可以当公式记忆）</p>
<blockquote>
<p>如果 a,b 均是正整数且互质，那么由 ax+by,x≥0,y≥0不能凑出的最大数是 (a−1)(b−1)−1=a*b - a - b.</p>
</blockquote>
<p>题目一看，是个<strong>组合问题</strong>，是<strong>完全背包问题</strong>的变形：有几个物品，每个物品无限个，每个物品选任意个，能否凑到某个重量。</p>
<p>任意两个数的组合必定是他们gcd的倍数，同样可以推广到更多数：如果这些数的gcd是d，那么他们的组合是d的倍数。<strong>如果d不是1</strong>，那么必然有无限个数无法被组合出来，答案是INF；<strong>如果d是1</strong>，那么两个数a,b，最大不能表示出来的数是：(a−1)(b−1)−1。当数字更多的时候，这个上界必然更小（可选的数字变多了），而99和98是100内最大的互质的数，所以这个上界选择10000。</p>
<p>那么下面的事情就是看这么多数中有多少个不能被组合出来，回到了刚开始分析的完全背包问题：</p>
<p>忘记了<a href="https://www.grantdrew.top/posts/141c4cb6.html#2-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">完全背包问题</a>的复习一下。</p>
<p>1.状态定义:<br>$d p(i, j)$ 表示前选 $i$ 项物品任意个，重量为 $j$, 属性为能否达到重量 $j($ true $/$ false $)$</p>
<p>2.状态转移:<br>集合分析法：由最后不同的一步来划分集合，在重量为 $j$ 的时候，第 $i$ 个物品<strong>选了几件</strong>。 $d p(i, j)=d p(i-1, j)|d p(i-1, j-w(i))| \ldots | d p(i-1, j-k * w(i))(k&lt;=j / w(i))$<br>但是, 完全背包问题有个特殊的地方，那就是状态重叠： $d p(i, j-w(i))$ 是由 $d p(i-1, j-w(i))|d p(i-1, j-2 * w(i)) \ldots| d p(i-1, j-k * w(i))(k&lt;=j /w(i))$<br>转移过来, 仔细看上下两个式子就会发现 $d p(i, j-w(i))$ 的状态就是 $d p(i, j)$ 后面一大部分。<br>所以最终方程为 $: d p(i, j)=d p(i-1, j) | d p(i, j-w(i))(w(i)&lt;=j)$。</p>
<p>取“或”，因为只要有一种情况能凑出来就能达到，dp(i,j)是true。</p>
<p>算法1：完全背包二维做法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>,M = <span class="number">10000</span>;<span class="comment">// 无法被组合出的数上限是10000</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">bool</span> dp[N][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b,a%b) : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        d = gcd(d,a[i]);<span class="comment">// 求a数组的最大公约数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d != <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;INF&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;<span class="comment">// dp[0][0]初始化为true，重量为0一定能组合出来，什么都不选</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= M;j++)&#123;<span class="comment">// j从0开始枚举</span></span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= a[i]) dp[i][j] |= dp[i][j-a[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= M;j++)&#123;<span class="comment">// j从1开始枚举，因为j=0肯定能组合出来</span></span><br><span class="line">            <span class="keyword">if</span> (!dp[n][j]) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法2：完全背包一维优化。（DP数组只依赖2层，第2维计算j只依赖比它小的数，可以一维优化）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>,M = <span class="number">10000</span>;<span class="comment">// 无法被组合出的数上限是10000</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">bool</span> dp[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b,a%b) : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        d = gcd(d,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d != <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;INF&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;<span class="comment">// dp[0][0]初始化为true，重量为0一定能组合出来，什么都不选</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="comment">// 一维优化，j直接从a[i]开始枚举</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = a[i];j &lt;= M;j++) dp[j] |= dp[j-a[i]];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= M;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!dp[j]) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-acwing-1070-括号配对"><a href="#2-2-acwing-1070-括号配对" class="headerlink" title="2.2 acwing.1070. 括号配对"></a>2.2 acwing.1070. 括号配对</h4><p>《信息学奥赛一本通》</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Hecy 又接了个新任务：BE 处理。</span><br><span class="line">BE 中有一类被称为 GBE。</span><br><span class="line">以下是 GBE 的定义：</span><br><span class="line">空表达式是 GBE</span><br><span class="line">如果表达式 A 是 GBE，则 [A] 与 (A) 都是 GBE</span><br><span class="line">如果 A 与 B 都是 GBE，那么 AB 是 GBE</span><br><span class="line">下面给出一个 BE，求至少添加多少字符能使这个 BE 成为 GBE。</span><br><span class="line">注意：BE 是一个仅由 (、)、[、]四种字符中的若干种构成的字符串。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">输入仅一行，为字符串 BE。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出仅一个整数，表示增加的最少字符数。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">对于所有输入字符串，其长度小于<span class="number">100</span>。</span><br><span class="line"></span><br><span class="line">输入样例：</span><br><span class="line">[])</span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>本题是acwing.1222. 密码脱落的例题，也是考察<strong>区间DP</strong>。（与POJ2955类似）</p>
<p>与密码脱落这题不同的地方在于A、B乘起来的结果是GBE，类似于密码脱落和石子合并两题的结合。</p>
<p>若括号序列是回文串，那么一定是合法的。但是该题新加了一个条件即()[]这样并列的括号也是合法的。</p>
<p>这里的定义2中的GBE也就是一个<strong>回文序列</strong>（如<code>[()()]</code>），定义2中的GBE是一个<strong>并列括号序列</strong>（如<code>()[]</code>）。</p>
<p>注意一下：定义2中的GBE和回文序列还是有一点区别的，单个符号可以是回文序列，但不满足GBE。</p>
<p>算法1：y式DP分析法。</p>
<p><img src="/posts/8e52910a/image-20210628210930813.png" alt="image-20210628210930813"></p>
<p>按s[i]、s[j]是否包含在需要操作的区间划分，也就是说s[i]、s[j]是否包含在进行操作使之变成GBE的区间中。</p>
<p>都不包含这类情况显然是包含在前两种情况中，所以可以不考虑。</p>
<p>注意整个集合划分的特点：先进行回文序列的划分，执行计算，然后再进行并列括号序列的划分，这两步是先后顺序，不是并列的关系。（和其他大部分集合划分的一个不同点）</p>
<p>并列括号序列中，k从i开始取，到j-1结束，因为(i,i)这种序列也需要操作。</p>
<p>时间复杂度：O(n^3)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span> l,<span class="keyword">char</span> r)</span></span>&#123;<span class="comment">// 检查是否满足s[i] == s[j]</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="string">&#x27;(&#x27;</span> &amp;&amp; r == <span class="string">&#x27;)&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="string">&#x27;[&#x27;</span> &amp;&amp; r == <span class="string">&#x27;]&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>;len &lt;= n;len++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i + len - <span class="number">1</span> &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">1</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">// len &gt;= 2的情况，至少2个字符</span></span><br><span class="line">                dp[i][j] = INF;<span class="comment">// 求min，初始化INF，排除不合法状态</span></span><br><span class="line">                <span class="keyword">if</span> (check(s[i],s[j])) dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>];<span class="comment">// 集合1情况4</span></span><br><span class="line">                dp[i][j] = min(dp[i][j], min(dp[i][j<span class="number">-1</span>],dp[i+<span class="number">1</span>][j]) + <span class="number">1</span>);<span class="comment">// 集合1情况23</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i;k &lt;= j<span class="number">-1</span>;k++)&#123;<span class="comment">// 集合2</span></span><br><span class="line">                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[<span class="number">0</span>][n<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法2：另一种DP分析法。</p>
<p>参考题解：<a href="https://www.acwing.com/solution/content/8845/%E3%80%82%EF%BC%88%E5%92%8CPOJ2955%E5%81%9A%E6%B3%95%E7%B1%BB%E4%BC%BC%EF%BC%89">https://www.acwing.com/solution/content/8845/。（和POJ2955做法类似）</a></p>
<p>从当前BE变成GBE需要添加最少字符的数量 等价于 当前BE变成最大的GBE需要去掉字符的数量<br>即至少添加最少字符 等价于 总数量 - 最大GBE子序列的长度。</p>
<p>注意：这题和密码脱落也有些不同，GBE有回文的性质 或者 有另外一种性质，例如<code>[]()</code> , <code>([])</code>均是GBE，因此需要对s[L] 和 s[R]不匹配的情况需要进一步划分，划分方式和石子合并类似。</p>
<p><img src="/posts/8e52910a/image-20210628220235949.png" alt="image-20210628220235949"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span> l,<span class="keyword">char</span> r)</span></span>&#123;<span class="comment">// 检查是否满足s[i] == s[j]</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="string">&#x27;(&#x27;</span> &amp;&amp; r == <span class="string">&#x27;)&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="string">&#x27;[&#x27;</span> &amp;&amp; r == <span class="string">&#x27;]&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>;len &lt;= n;len++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i + len - <span class="number">1</span> &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// if (len == 1) dp[i][j] = 0;可省略</span></span><br><span class="line">            <span class="keyword">if</span> (check(s[i],s[j])) dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">2</span>;<span class="comment">// 集合1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i;k &lt;= j<span class="number">-1</span>;k++)&#123;</span><br><span class="line">                dp[i][j] = max(dp[i][j],dp[i][k] + dp[k+<span class="number">1</span>][j]);<span class="comment">// 集合2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n - dp[<span class="number">0</span>][n<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>背包问题</tag>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（三十）</title>
    <url>/posts/54c6ca4d.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="3-3-acwing-1237-螺旋折线"><a href="#3-3-acwing-1237-螺旋折线" class="headerlink" title="3.3 acwing.1237. 螺旋折线"></a>3.3 acwing.1237. 螺旋折线</h4><p>第九届蓝桥杯省赛C++B组,第九届蓝桥杯省赛JAVAB组</p>
<span id="more"></span>

<p><img src="/posts/54c6ca4d/image-20210617092152977.png" alt="image-20210617092152977"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">对于整点 (X,Y)，我们定义它到原点的距离 dis(X,Y) 是从原点到 (X,Y) 的螺旋折线段的长度。</span><br><span class="line">例如 dis(<span class="number">0</span>,<span class="number">1</span>)=<span class="number">3</span>,dis(−<span class="number">2</span>,−<span class="number">1</span>)=<span class="number">9</span></span><br><span class="line">给出整点坐标 (X,Y)，你能计算出 dis(X,Y) 吗？</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">包含两个整数 X,Y。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示 dis(X,Y)。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">−<span class="number">10</span>^<span class="number">9</span>≤X,Y≤<span class="number">10</span>^<span class="number">9</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">0</span> <span class="number">1</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>算法1：模拟。参考<a href="https://www.acwing.com/problem/content/description/758/">756.蛇形矩阵</a></p>
<p>需要遍历所有点，大概10^18，TLE。</p>
<p>算法2：找规律。</p>
<p>把红线上所有点的dis(x,y)算出来，直接找规律。</p>
<p>观察数据范围，发现时间复杂度应该控制到$O(\sqrt n)$。</p>
<p>我们按正方形的圈数n来找规律。上面是对称的，下面不是对称的。</p>
<p><img src="/posts/54c6ca4d/image-20210617095216174.png" alt="image-20210617095216174"></p>
<p>判断点在哪个方向的边上时，可以画两条线y=x和y=-x来判断。</p>
<p>时间复杂度：O(1)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(x) &lt;= y)&#123;<span class="comment">// 在上方</span></span><br><span class="line">        <span class="keyword">int</span> n = y;<span class="comment">// dis = 起点dis + 偏移量</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (LL)(<span class="number">2</span>*n<span class="number">-1</span>)*(<span class="number">2</span>*n) + x - (-n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">abs</span>(y) &lt;= x)&#123;<span class="comment">// 在右方</span></span><br><span class="line">        <span class="keyword">int</span> n = x;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (LL)(<span class="number">2</span>*n)*(<span class="number">2</span>*n) + n - y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">abs</span>(x) &lt;= <span class="built_in">abs</span>(y) + <span class="number">1</span> &amp;&amp; y &lt; <span class="number">0</span>)&#123;<span class="comment">// 在下方</span></span><br><span class="line">        <span class="comment">// 必须满足y &lt; 0，如果不加可能在左方，eg.(-3,2)</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">abs</span>(y);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (LL)(<span class="number">2</span>*n)*(<span class="number">2</span>*n+<span class="number">1</span>) + n - x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">// 在左方</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">abs</span>(x);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (LL)(<span class="number">2</span>*n<span class="number">-1</span>)*(<span class="number">2</span>*n<span class="number">-1</span>) + y - (-n+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八-数论"><a href="#八-数论" class="headerlink" title="八 数论"></a>八 数论</h2><p>推荐一个系列文章：<a href="https://mp.weixin.qq.com/s/dFBbbTB8Fz2_n3YeMIj7nw">https://mp.weixin.qq.com/s/dFBbbTB8Fz2_n3YeMIj7nw</a></p>
<p>推荐一个数学系（ACM选手）UP主：<a href="https://www.bilibili.com/video/BV1Nb411y7ZX">https://www.bilibili.com/video/BV1Nb411y7ZX</a></p>
<p>这是他的知乎文章：<a href="https://www.zhihu.com/question/379824357/answer/1088257294">https://www.zhihu.com/question/379824357/answer/1088257294</a></p>
<p>最大公约数与最大公倍数问题请参考<a href="https://www.grantdrew.top/posts/e808698d.html">gcd问题与lcm问题</a>.</p>
<p>参考资料：<a href="https://oi-wiki.org/math/gcd/%E3%80%82">https://oi-wiki.org/math/gcd/。</a></p>
<p><img src="/posts/54c6ca4d/image-20210617105109560.png" alt="image-20210617105109560"></p>
<p><code>int gcd(int a,int b)&#123;return !b?a:gcd(b,a%b);&#125; // 注意加上&#123;&#125;</code></p>
<p>注意：这里要求a&gt;b，但是a&lt;b也能计算，会多递归一次，相当于交换。</p>
<h4 id="1-1-acwing-1246-等差数列"><a href="#1-1-acwing-1246-等差数列" class="headerlink" title="1.1 acwing.1246. 等差数列"></a>1.1 acwing.1246. 等差数列</h4><p>第十届蓝桥杯省赛C++B/C组,第十届蓝桥杯省赛JAVAC组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">数学老师给小明出了一道等差数列求和的题目。</span><br><span class="line">但是粗心的小明忘记了一部分的数列，只记得其中 N 个整数。</span><br><span class="line">现在给出这 N 个整数，小明想知道包含这 N 个整数的最短的等差数列有几项？</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">输入的第一行包含一个整数 N。</span><br><span class="line">第二行包含 N 个整数 A1,A2,⋅⋅⋅,AN。(注意 A1∼AN 并不一定是按等差数</span><br><span class="line">列中的顺序给出)</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数表示答案。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">2</span>≤N≤<span class="number">100000</span>,</span><br><span class="line"><span class="number">0</span>≤Ai≤<span class="number">10</span>^<span class="number">9</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="number">4</span> <span class="number">10</span> <span class="number">20</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">10</span></span><br><span class="line">样例解释</span><br><span class="line">包含 <span class="number">2</span>、<span class="number">6</span>、<span class="number">4</span>、<span class="number">10</span>、<span class="number">20</span> 的最短的等差数列是 <span class="number">2</span>、<span class="number">4</span>、<span class="number">6</span>、<span class="number">8</span>、<span class="number">10</span>、<span class="number">12</span>、<span class="number">14</span>、<span class="number">16</span>、<span class="number">18</span>、<span class="number">20</span>。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p><img src="/posts/54c6ca4d/image-20210617112144250.png" alt="image-20210617112144250"></p>
<p>当公差d取到每个数与第一个数的差的最大公约数时，项数最少。前提时d != 0。</p>
<p>如果d = 0，那么项数 = n。</p>
<p>0与任何数a的最大公约数(0,a)是a。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b,a%b):a;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    sort(a,a+n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">0</span>;<span class="comment">// 求gcd，i从1开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) d = gcd(d,a[i] - a[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (d == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(a[n<span class="number">-1</span>] - a[<span class="number">0</span>])/d + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-acwing-1295-X的因子链"><a href="#1-2-acwing-1295-X的因子链" class="headerlink" title="1.2 acwing.1295. X的因子链"></a>1.2 acwing.1295. X的因子链</h4><p>《信息学奥赛一本通》 , POJ</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入正整数 X，求 X 的大于 <span class="number">1</span> 的因子组成的满足任意前一项都能整除后一项的严格递增序列的最大长度，以及满足最大长度的序列的个数。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">输入包含多组数据，每组数据占一行，包含一个正整数表示 X。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">对于每组数据，输出序列的最大长度以及满足最大长度的序列的个数。</span><br><span class="line">每个结果占一行。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤X≤<span class="number">2</span>^<span class="number">20</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p><strong>算术基本定理</strong></p>
<blockquote>
<p>每一个正整数都可以表示成若干整数的乘积，这种分解方式在忽略排列次序的条件下是唯一的。</p>
</blockquote>
<p><img src="/posts/54c6ca4d/image-20210618205713629.png" alt="image-20210618205713629"></p>
<p>将题目中所给的正整数X进行质因数分解：$X=p_1^{\alpha_1}·p_2^{\alpha_2}····p_k^{\alpha_k}$($\alpha_i&gt;0$，且$p_i$是质数)</p>
<p>所以X一共有$\alpha_1+\alpha_2+…+\alpha_k$个质因子。</p>
<p>审题：构建了一个序列{$a_k$}，序列中的每个数由X 的大于 1 的因子组成，</p>
<p>且满足任意前一项都能整除后一项的严格递增序列。求该序列的最大长度，以及满足最大长度的序列的个数。</p>
<p>注意：序列中每个数的构建方式，从X的因子中选取，<strong>X的因子k满足k|X</strong>。（质因子和因子不一样）</p>
<p>我们首先选取X的一个质因子作为首项，然后逐步加入一个新的质因子，这样序列的<strong>最大长度</strong>就是：</p>
<p>$\alpha_1+\alpha_2+…+\alpha_k$。所以，满足最大长度的序列的个数也就是<strong>X的所有质因子的排列个数</strong>。</p>
<p>但是要注意重复的质因子交换顺序还是同一种序列！所以我们先计算全排列，再去除相同项的排列。</p>
<p>举个例子：$X = 2^2<em>3^3</em>5$，一共有2+3+1=6个质因子，最大长度是6。最大长度序列个数有$\frac {6!} {2!*3!}$个。</p>
<p>6!是所有质因子（包括重复的）的全排列，2!表示相同的序列如2,3,3,5,2,3中在全排列中计算了2!次，但是实</p>
<p>际上是同一种，所以/2!。3!同理。</p>
<p>由特殊到一般，我们归纳出多重集的排列数问题的计算公式：</p>
<p>满足最大长度的序列的个数=$\frac {(\alpha_1+\alpha_2+…+\alpha_k)!} {\alpha_1!<em>\alpha_2!</em>…*\alpha_k!}$.</p>
<p>多重集的排列数常被称作 <strong>多重组合数</strong>，属于组合（离散）数学知识。</p>
<p>多重集的排列数 | 多重组合数参考资料：<a href="https://oi-wiki.org/math/combination/">https://oi-wiki.org/math/combination/</a></p>
<p><strong>素数筛法</strong></p>
<p>如果我们想要知道小于等于n有多少个素数呢？</p>
<p>一个自然的想法是对于小于等于n的每个数进行一次质数检验。这种暴力的做法显然不能达到最优复杂度。</p>
<p>所以我们需要素数筛法，先来看<strong>线性筛法</strong>，也称<strong>Euler 筛法</strong>（欧拉筛法）。</p>
<p>它的时间复杂度是O(n)，可以求出1~n内的所有质数以及其中每个数的最小质因子。</p>
<p>在实现形式上，埃氏筛是直接用素数遍乘自然数删去自身倍数；线性筛是先建立一个素数数列，然后用每个自</p>
<p>然数遍乘数列中的素数删去素数倍数。</p>
<p>线性筛法的思想：用<strong>最小的质因子</strong>筛掉合数。</p>
<p>如何保证线性:一个合数只能被筛掉一次。</p>
<p>如何保证一个数字只被筛掉一次:这个数字只被它的最小质因数筛掉，当它的其他质因数想要筛掉它时，将无</p>
<p>法进行筛除操作。</p>
<p>参考文章1：<a href="https://blog.csdn.net/Wansit/article/details/115439545">https://blog.csdn.net/Wansit/article/details/115439545</a></p>
<p>参考文章2：<a href="https://blog.csdn.net/m0_49959202/article/details/108684545">https://blog.csdn.net/m0_49959202/article/details/108684545</a></p>
<p>参考文章3：<a href="https://zhuanlan.zhihu.com/p/124068032%EF%BC%8C%E6%8A%8A%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A%E5%BE%97%E5%BE%88%E6%B8%85%E6%A5%9A">https://zhuanlan.zhihu.com/p/124068032，把原理解释得很清楚</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> primes[N],cnt;<span class="comment">// primes存放所有质数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];<span class="comment">// 当前数是否被筛过，1表示筛过，0表示没有被筛过</span></span><br><span class="line"><span class="keyword">int</span> min_p[N];<span class="comment">// 存放i的最小质因数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) min_p[i] = i,primes[cnt++] = i;<span class="comment">// 如果i未被筛过，那么这i必为素数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cnt &amp;&amp; primes[j] * i &lt;= n;j++)&#123;<span class="comment">// 筛掉pj*i这个合数</span></span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;<span class="comment">// pj一定不大于i的最小质因子，如果大于一定会break</span></span><br><span class="line">            min_p[primes[j]*i] = primes[j];<span class="comment">// pj*i的最小质因数是pj</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">// 保证要筛除的数只会被最小质因子筛除，不重复筛</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    get_primes(<span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">20</span>;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,primes[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/54c6ca4d/image-20210618233309226.png" alt="image-20210618233309226"></p>
<p>if(i%p[j]==0)break;语句实现不重复删。证明很简单，自然数i从最小素数2开始乘，i×p[j]以每个p[j]为最小质因数，直到p[j]整除i时，i×p[j]还是以p[j]为最小质因数，但下一个数i×p[j+1]=(i/p[j])×p[j]×p[j+1]中p[j+1]就不是最小质因数了，所以不必继续乘了。</p>
<p>eg.当i = 4时，素数数组已经有2和3，<code>4*2</code>以p[0]=2为最小质因数，要筛掉。因为4 % 2 == 0，所以break。但是<code>4*3</code>不是以3而是2为最小质因数，它应该被<code>2*6</code>筛掉。</p>
<hr>
<p>有了多重组合数和线性筛法的补充知识，再来看题目。</p>
<p>首先用线性筛法求出每个数的最小质因数，然后分解质因数，求出多重组合数。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = (<span class="number">1</span>&lt;&lt;<span class="number">20</span>)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;<span class="comment">// 最多要计算20!，long long最大是2^31-1，可以存下</span></span><br><span class="line"><span class="keyword">int</span> primes[N],cnt;<span class="comment">// primes存放所有质数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> min_p[N];<span class="comment">// 存放i的最小质因数</span></span><br><span class="line"><span class="keyword">int</span> fact[<span class="number">30</span>],sum[<span class="number">25</span>];<span class="comment">// fact存放i的所有质因数，sum存放对应的次数，sum的次数最多不超过20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) min_p[i] = i,primes[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cnt &amp;&amp; primes[j]*i &lt;= n;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = primes[j]*i;</span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            min_p[t] = primes[j];</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    get_primes(N);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) != EOF)&#123;</span><br><span class="line">    <span class="comment">// 分解x的质因数，p为最小质因数，x = p*y,y=p1*z,z=p2*w,...,每次用最小质因数来分解，直到1</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>,tot = <span class="number">0</span>;<span class="comment">// k记录质因数的个数，tot记录总的次数</span></span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = min_p[x];</span><br><span class="line">            fact[k] = p,sum[k] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % p == <span class="number">0</span>)&#123;</span><br><span class="line">                x /= p;</span><br><span class="line">                sum[k] ++,tot++;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算多重组合数</span></span><br><span class="line">        LL res = <span class="number">1</span>;<span class="comment">// 计算阶乘可以用前缀和方式处理一下，不用重复计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= tot;i++) res *= i;<span class="comment">// 求tot!</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>;j &lt;= sum[i];j++) res /= j;<span class="comment">// tot/(sum[i])!</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %lld\n&quot;</span>,tot,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>多重组合数</tag>
        <tag>线性筛法</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（三四）</title>
    <url>/posts/84c21f94.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="九-复杂DP"><a href="#九-复杂DP" class="headerlink" title="九 复杂DP"></a>九 复杂DP</h2><h3 id="1-例题"><a href="#1-例题" class="headerlink" title="1.例题"></a>1.例题</h3><h4 id="1-1-acwing-1050-鸣人的影分身"><a href="#1-1-acwing-1050-鸣人的影分身" class="headerlink" title="1.1 acwing.1050. 鸣人的影分身"></a>1.1 acwing.1050. 鸣人的影分身</h4><p>《信息学奥赛一本通》</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">在火影忍者的世界里，令敌人捉摸不透是非常关键的。</span><br><span class="line">我们的主角漩涡鸣人所拥有的一个招数——多重影分身之术——就是一个很好的例子。</span><br><span class="line">影分身是由鸣人身体的查克拉能量制造的，使用的查克拉越多，制造出的影分身越强。</span><br><span class="line">针对不同的作战情况，鸣人可以选择制造出各种强度的影分身，有的用来佯攻，有的用来发起致命一击。</span><br><span class="line">那么问题来了，假设鸣人的查克拉能量为 M，他影分身的个数最多为 N，那么制造影分身时有多少种不同的分配方法？</span><br><span class="line">注意：</span><br><span class="line">影分身可以分配<span class="number">0</span>点能量。</span><br><span class="line">分配方案不考虑顺序，例如：M=<span class="number">7</span>,N=<span class="number">3</span>，那么 (<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>) 和 (<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>) 被视为同一种方案。</span><br><span class="line">    </span><br><span class="line">输入格式</span><br><span class="line">第一行是测试数据的数目 t。</span><br><span class="line">以下每行均包含二个整数 M 和 N，以空格分开。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">对输入的每组数据 M 和 N，用一行输出分配的方法数。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">0</span>≤t≤<span class="number">20</span>,</span><br><span class="line"><span class="number">1</span>≤M,N≤<span class="number">10</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">7</span> <span class="number">3</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p><strong>整数划分问题</strong>，经典问题，积累。</p>
<p>算法1：递归dfs。(20ms)</p>
<p>这道题目相当于是把n个苹果放m个盘子里的一道题。（比较经典的题目）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//没有苹果，全部盘子为0</span></span><br><span class="line">    <span class="keyword">if</span>(y == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//没有盘子，没法放</span></span><br><span class="line">    <span class="keyword">if</span>(y &gt; x)&#123;<span class="comment">//盘子数大于苹果数，至多只能x个盘子上都放一个 </span></span><br><span class="line">        <span class="keyword">return</span> f(x,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f(x - y, y) + f(x, y - <span class="number">1</span>);<span class="comment">//盘子数小于等于苹果数 -&gt; 分类讨论：有盘子为空，没有盘子为空</span></span><br><span class="line"><span class="comment">//有盘子为空的时候即至少有一个盘子为空，f(x,y-1);没有盘子为空即最少每个盘子都有一个,f(x-y,y)     </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n,m;<span class="comment">//n个苹果分到m个盘子里去，运行盘子为空 </span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; f(n,m) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">作者：白線流つ</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/8444/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>算法2：dp。(20ms)</p>
<p>实际上我们可以发现，在递归的过程中就是要用到之前的数据，继而这道题可以转换为记忆化搜索将结果保存来做，即dp做法，但是这个dp是从递归去思考出来的- -而不是像灿总那样直接思考dp做法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">25</span>][<span class="number">25</span>],m,n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,m,n;</span><br><span class="line">    <span class="keyword">for</span>(m=<span class="number">0</span>;m&lt;=<span class="number">10</span>;m++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;=<span class="number">10</span>;n++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(m&lt;n)a[m][n]=a[m][m]; </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">0</span>)a[m][n]=<span class="number">1</span>;<span class="comment">// 注意a[0][0]是1</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">0</span>)a[m][n]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> a[m][n]=a[m-n][n]+a[m][n<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[m][n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法3：爆搜。(Java782ms,C++22ms)</p>
<p>暴力枚举每个盒子放多少个球，为了方便从左到右的球的数量从小到大递增，dfs过程中需要添加多start作为开始枚举的位置。</p>
<p>枚举时注意方案是不考虑顺序的！所以球的数量从小到大递增。可以画递归搜索树帮助理解！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//枚举第u个盒子，nums表示当前剩下多少个能量，从start数开始枚举</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> nums,<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == n + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums == <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                ans ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; nums) <span class="keyword">return</span>;<span class="comment">//可行性剪枝</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start ;i &lt;= nums;i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(u + <span class="number">1</span>,nums - i,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> T = scan.nextInt();</span><br><span class="line">        <span class="keyword">while</span>(T -- &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             ans = <span class="number">0</span>;<span class="comment">// 计算之前将ans置零</span></span><br><span class="line">             m = scan.nextInt();<span class="comment">//能量</span></span><br><span class="line">             n = scan.nextInt();<span class="comment">//分身个数</span></span><br><span class="line">             dfs(<span class="number">1</span>,m,<span class="number">0</span>);</span><br><span class="line">             System.out.println(ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">作者：小呆呆</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/8648/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>算法4：y总DP分析。(11ms)</p>
<p>这里的集合划分依据比较难想到，但思路和前面2种算法有联系。</p>
<p><img src="/posts/84c21f94/image-20210624180703937.png" alt="image-20210624180703937"></p>
<p>最小值=0：f[i,j]表示的所有方案中都空出至少1个盘子，转化为f[i,j-1]；</p>
<p>最小值&gt;0：f[i,j]表示的所有方案中每个盘子至少有1个苹果，就可以让所有盘子的苹果数-1，是等价的，转化</p>
<p>为f[i-j,j]。</p>
<p><strong>注意初始化f[0,0]为1而不是0。状态计算满足的条件是j&gt;=1和i&gt;=j。</strong>DP问题注意细节！！！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">        <span class="comment">//memset(dp,0,sizeof dp);也可以不加，会覆盖掉</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) dp[<span class="number">0</span>][i] = <span class="number">1</span>;<span class="comment">// 0个苹果方案数都初始化为1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= j)  dp[i][j] += dp[i-j][j];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[m][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-acwing-1047-糖果"><a href="#1-2-acwing-1047-糖果" class="headerlink" title="1.2 acwing.1047. 糖果"></a>1.2 acwing.1047. 糖果</h4><p>《信息学奥赛一本通》</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">由于在维护世界和平的事务中做出巨大贡献，Dzx被赠予糖果公司<span class="number">2010</span>年<span class="number">5</span>月<span class="number">23</span>日当天无限量糖果免费优惠券。</span><br><span class="line">在这一天，Dzx可以从糖果公司的 N 件产品中任意选择若干件带回家享用。</span><br><span class="line">糖果公司的 N 件产品每件都包含数量不同的糖果。</span><br><span class="line">Dzx希望他选择的产品包含的糖果总数是 K 的整数倍，这样他才能平均地将糖果分给帮助他维护世界和平的伙伴们。</span><br><span class="line">当然，在满足这一条件的基础上，糖果总数越多越好。</span><br><span class="line">Dzx最多能带走多少糖果呢？</span><br><span class="line">注意：Dzx只能将糖果公司的产品整件带走。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含两个整数 N 和 K。</span><br><span class="line">以下 N 行每行 <span class="number">1</span> 个整数，表示糖果公司该件产品中包含的糖果数目，不超过 <span class="number">1000000</span>。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">符合要求的最多能达到的糖果总数，如果不能达到 K 的倍数这一要求，输出 <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤N≤<span class="number">100</span>,</span><br><span class="line"><span class="number">1</span>≤K≤<span class="number">100</span>,</span><br><span class="line"></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">14</span></span><br><span class="line">样例解释</span><br><span class="line">Dzx的选择是<span class="number">2</span>+<span class="number">3</span>+<span class="number">4</span>+<span class="number">5</span>=<span class="number">14</span>，这样糖果总数是<span class="number">7</span>的倍数，并且是总数最多的选择。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>考察背包问题的应用，本题考察01背包问题。背包问题也就是一种选择模型。</p>
<p>DP数组的第1维度往往是数量，第2维度往往是限制条件。</p>
<p><img src="/posts/84c21f94/image-20210624224759644.png" alt="image-20210624224759644"></p>
<p>自己想不到DP集合的状态表示内容。这里状态表示的是方案，不是方案数量，属性是糖果总数的最大值。</p>
<p>筛选标准：最后不同的一步 (在这里是选不选这个物品) </p>
<p>不选的话：子集合都不包括第 $i$ 个物品, 表示的意义就是前 $i-1$ 个物品, $% k=j$ 的集合: $d p(i-1, j)$ 。</p>
<p> 选择第 $i$ 个物品：子集合都包括第 $i$ 个物品, 并且前面选择的商品和 $S$ 满足 $(S+a[i]) % k=j$, 而我们需要从和这个 $S$ 有关的集合, 状态记录的都是% $k$ 后的结果, 所以我们只需要知道 $S % k(=(j-a[i]) % k)$ 的那个状态的值。</p>
<p>由于第2维度不具有单调性，所以不能优化成1维，其实01背包问题大多数情况下也没必要优化，一般空间大小都够。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">// 初始化为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; k;j++) dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][(j+k-w%k)%k] + w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[n][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置memset(f,-0x3f,sizeof f);的解释，因为memset是按照字节赋值的。一个整型int有四个字节，所以这样赋值后，每个数组元素的值都变成了 -0x3f3f3f3f,而这个数的大小在-1e9的左右，由于一般的数据都不会小于-1e9，所以这时候它可以作为无穷小来用。</p>
<p>初始化：$d p(0,0)=0, d p(0, i)(i \neq 0)$ 都是<strong>不合法的状态</strong>, 所以必须要初始化为<strong>负无穷</strong>，不然的话可以选择先初始化第一件物品的所有情况，再迭代第二个物品之后(仔细想想, 如果不合法的状态初始化为0了, 后面递推的时候, 答案就会变大)</p>
<p>关于负余数的说明：下面大致说明下正确性，<br>1.假如 $(j-w[i]&gt;=0)$, 由于 $k % k=0$, 所以不会影响。<br>2.假如 $(j-w[i]&lt;0)$, 带个负数进去试下就可以验证，在这里 $+k$ 可以使 $(j-w[i]) % k$ 变成 $[0, n-1]$之间，再取余仍然是 $[0, n-1]$ 之间。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>背包问题</tag>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>整数划分</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（三）</title>
    <url>/posts/d5e32c3c.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>续蓝桥杯学习总结（二）。</p>
</blockquote>
<h3 id="3-递推"><a href="#3-递推" class="headerlink" title="3.递推"></a>3.递推</h3><p>关于递归与递推的区别：</p>
<p><strong>递推</strong>：从初值出发反复进行某一运算得到所需结果。—–从<strong>已知到未知</strong>，从小到达（比如每年长高9cm，20年180，30后270）</p>
<p><strong>递归</strong>：从所需结果出发不断回溯前一运算直到回到初值再递推得到所需结果—-从<strong>未知到已知</strong>，从大到小，再从小到大(你想进bat，那么编程就得牛逼，就得卸载玩者农药，努力学习）。<strong>递归(Recursion)是从归纳法(Induction)衍生出来的</strong>。</p>
<span id="more"></span>

<h4 id="3-1-acwing-717-简单斐波那契（语法课）"><a href="#3-1-acwing-717-简单斐波那契（语法课）" class="headerlink" title="3.1 acwing.717.简单斐波那契（语法课）"></a>3.1 acwing.717.简单斐波那契（语法课）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">以下数列<span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> …被称为斐波纳契数列。</span><br><span class="line"></span><br><span class="line">这个数列从第<span class="number">3</span>项开始，每一项都等于前两项之和。</span><br><span class="line"></span><br><span class="line">输入一个整数N，请你输出这个序列的前N项。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">一个整数N。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">在一行中输出斐波那契数列的前N项，数字之间用空格隔开。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">0</span>&lt;N&lt;<span class="number">46</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">5</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> fabo[<span class="number">48</span>];</span><br><span class="line">    fabo[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    fabo[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= n;i ++) fabo[i] = fabo[i<span class="number">-1</span>]+fabo[i<span class="number">-2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="built_in">cout</span> &lt;&lt; fabo[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化版本，节省空间，和语法课相同</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>,b =<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> fn = a + b;</span><br><span class="line">	a = b,b = fn;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-2-acwing-95-费解的开关（算法竞赛进阶指南，难）"><a href="#3-2-acwing-95-费解的开关（算法竞赛进阶指南，难）" class="headerlink" title="3.2 acwing.95.费解的开关（算法竞赛进阶指南，难）"></a>3.2 acwing.95.费解的开关（算法竞赛进阶指南，难）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">你玩过“拉灯”游戏吗？</span><br><span class="line"><span class="number">25</span> 盏灯排成一个 <span class="number">5</span>×<span class="number">5</span> 的方形。</span><br><span class="line">每一个灯都有一个开关，游戏者可以改变它的状态。</span><br><span class="line">每一步，游戏者可以改变某一个灯的状态。</span><br><span class="line">游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。</span><br><span class="line">我们用数字 <span class="number">1</span> 表示一盏开着的灯，用数字 <span class="number">0</span> 表示关着的灯。</span><br><span class="line">下面这种状态</span><br><span class="line"><span class="number">10111</span></span><br><span class="line"><span class="number">01101</span></span><br><span class="line"><span class="number">10111</span></span><br><span class="line"><span class="number">10000</span></span><br><span class="line"><span class="number">11011</span></span><br><span class="line">在改变了最左上角的灯的状态后将变成：</span><br><span class="line"><span class="number">01111</span></span><br><span class="line"><span class="number">11101</span></span><br><span class="line"><span class="number">10111</span></span><br><span class="line"><span class="number">10000</span></span><br><span class="line"><span class="number">11011</span></span><br><span class="line">再改变它正中间的灯后状态将变成：</span><br><span class="line"><span class="number">01111</span></span><br><span class="line"><span class="number">11001</span></span><br><span class="line"><span class="number">11001</span></span><br><span class="line"><span class="number">10100</span></span><br><span class="line"><span class="number">11011</span></span><br><span class="line">给定一些游戏的初始状态，编写程序判断游戏者是否可能在 <span class="number">6</span> 步以内使所有的灯都变亮。</span><br><span class="line">输入格式</span><br><span class="line">第一行输入正整数 n，代表数据中共有 n 个待解决的游戏初始状态。</span><br><span class="line">以下若干行数据分为 n 组，每组数据有 <span class="number">5</span> 行，每行 <span class="number">5</span> 个字符。</span><br><span class="line">每组数据描述了一个游戏的初始状态。</span><br><span class="line">各组数据间用一个空行分隔。</span><br><span class="line">输出格式</span><br><span class="line">一共输出 n 行数据，每行有一个小于等于 <span class="number">6</span> 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。</span><br><span class="line">对于某一个游戏初始状态，若 <span class="number">6</span> 步以内无法使所有灯变亮，则输出 −<span class="number">1</span>。</span><br><span class="line">数据范围</span><br><span class="line"><span class="number">0</span>&lt;n≤<span class="number">500</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">00111</span></span><br><span class="line"><span class="number">01011</span></span><br><span class="line"><span class="number">10001</span></span><br><span class="line"><span class="number">11010</span></span><br><span class="line"><span class="number">11100</span></span><br><span class="line"></span><br><span class="line"><span class="number">11101</span></span><br><span class="line"><span class="number">11101</span></span><br><span class="line"><span class="number">11110</span></span><br><span class="line"><span class="number">11111</span></span><br><span class="line"><span class="number">11111</span></span><br><span class="line"></span><br><span class="line"><span class="number">01111</span></span><br><span class="line"><span class="number">11111</span></span><br><span class="line"><span class="number">11111</span></span><br><span class="line"><span class="number">11111</span></span><br><span class="line"><span class="number">11111</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>先枚举第一行的灯，每个灯有按或不按两种选择，可以用到<u>指数型枚举</u>。</p>
<p>第二行的灯受第一行影响，如果第一行灯是灭的，它下方第二行灯必须按，因为只有第二行这个灯能影响它的状态；同理，第一行灯是亮的，它下方第二行灯必须不能按。</p>
<p>由此我们知道，<strong>每一行灯按或不按由前一行状态唯一确定</strong>。</p>
<p><img src="/posts/d5e32c3c/image-20210314090051648.png" alt="image-20210314090051648"></p>
<p><img src="/posts/d5e32c3c/image-20210314092102637.png" alt="image-20210314092102637"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;<span class="comment">// 按一次开关改变5个灯的状态</span></span><br><span class="line"><span class="keyword">char</span> g[N][N], backup[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个操作是把(x, y)以及上下左右的灯都变成相反的颜色</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><span class="comment">// 通过坐标偏移量实现</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        <span class="comment">//如果在边界外边，直接忽略即可</span></span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= <span class="number">5</span> || b &lt; <span class="number">0</span> || b &gt;= <span class="number">5</span>) <span class="keyword">continue</span>;</span><br><span class="line">        g[a][b] ^= <span class="number">1</span>;   <span class="comment">//异或，值不同时结果为1，相同为0</span></span><br><span class="line">        <span class="comment">// &#x27;0&#x27;是48 所以 ^1就是49 ==&#x27;1&#x27;</span></span><br><span class="line">        <span class="comment">// &#x27;0&#x27;对应十进制48,110000（2），110000 ^ 000001 = 110001(对应十进制49，&#x27;1&#x27;)</span></span><br><span class="line">       <span class="comment">// &#x27;0&#x27;^1 = &#x27;1&#x27;,&#x27;1&#x27;^1=&#x27;0&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 按行输入，把每一行当成一个字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ ) <span class="built_in">cin</span> &gt;&gt; g[i];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 这里我们枚举了第一行的32种按法，不用管是亮是灭，把第一行所有情况都按一遍</span></span><br><span class="line">        <span class="comment">// 按每种情况的第一行，去遍历接下来的行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> op = <span class="number">0</span>; op &lt; <span class="number">32</span>; op ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 我在对这种情况操作的时候，得先备用一下</span></span><br><span class="line">            <span class="comment">// 把原始数组备份一下，然后操作g，操作完了还原，然后再操作</span></span><br><span class="line">            <span class="built_in">memcpy</span>(backup, g, <span class="keyword">sizeof</span> g);</span><br><span class="line">            <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 第一行的按法(在这里 1 表示按了, 0 表示不按)，这里只是为了输出第一行按完之后的状态</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ )</span><br><span class="line">                <span class="keyword">if</span> (op &gt;&gt; i &amp; <span class="number">1</span>)  <span class="comment">// 取op对应二进制数的第i位数字</span></span><br><span class="line">                                  <span class="comment">// 00010 &gt;&gt; 1 &amp; 1  是1 所以turn(0, 1) 就是第一行第二个位置</span></span><br><span class="line">                &#123;                 <span class="comment">// 数字3 对应了00011 表示第1 和第2个位置的按一下</span></span><br><span class="line">                    step ++ ;</span><br><span class="line">                    turn (<span class="number">0</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// 然后通过第一行按完之后的状态，按234行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )<span class="comment">// 枚举行数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>;j ++ )<span class="comment">// 枚举每行的灯</span></span><br><span class="line">                    <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        step ++;</span><br><span class="line">                        turn (i + <span class="number">1</span>, j);  <span class="comment">// 如果这个位置是灭的，就按下一行对应的位置</span></span><br><span class="line">                    &#125;</span><br><span class="line">            <span class="keyword">bool</span> dark = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j ++ )</span><br><span class="line">                <span class="keyword">if</span> (g[<span class="number">4</span>][j] == <span class="string">&#x27;0&#x27;</span>)<span class="comment">// 判断最后一行的灯，如果至少有一个暗就无解</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dark = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对于32种情况的这一种，如果所有的全亮就记录下步数(事实上只记录了最后一行是否dark)</span></span><br><span class="line">            <span class="keyword">if</span> (!dark) res = min(res, step);</span><br><span class="line">            <span class="built_in">memcpy</span> (g, backup, <span class="keyword">sizeof</span> g);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res &gt; <span class="number">6</span>) res = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h5><ul>
<li><strong>细节很多，一定要自己多动手写写，最好打一下挑战模式</strong></li>
<li>枚举第一行时：1表示按一下，0表示不按(当然反过来也可以啦~看你)</li>
<li>在遍历整个矩阵时：1是灯亮，0是灯灭</li>
<li>memcpy 可以用来复制数组，这里是先把原数组备份一下，然后对本数组操作，本次操作结束后，要再把备份数组还原回来，再进行下一次操作啦~</li>
<li>从第一行开始递推，若达到第n行不全为0，说明这种点击方式不合法。<br>在所有合法的点击方式中取点击次数最少的就是答案。<br>对第一行的32次枚举涵盖了该问题的整个状态空间，因此该做法是正确的</li>
<li>时间复杂度：<code>32*25*5*500</code><br>对第一行操作有32种可能 * 共有25个灯 * 每一次操作改变5个灯的状态 * 最多读入的时候可能有500次light矩阵</li>
<li>如果是一个偶数^1,那么答案是偶数+1.如果是一个奇数^1,那么答案是奇数-1。</li>
</ul>
<p>代码 by y总</p>
<p>注释 by 小张同学 &amp; grant</p>
<p><a href="https://www.acwing.com/solution/content/8747/">链接</a></p>
<h5 id="补充说明："><a href="#补充说明：" class="headerlink" title="补充说明："></a>补充说明：</h5><p>首先，这题根本就没有什么所谓的状压dp，而且只有一个地方用到了状态压缩，即第一行按开关的方式</p>
<p>本题主要的考察内容其实就是位运算，暴力以及一些递推思想</p>
<p><strong>1.高票题解代码中的 if (k &gt;&gt; j &amp; 1) 究竟什么意思？</strong></p>
<p>其中，k保存的根本就不是第一行的灯所有可能的状态，不然它第j位都为1了还按它干嘛？ k单纯只是保存了第一行按开关的32种方式，与输入数据无关。</p>
<p>且大多数题解代码中都规定了k在二进制下某位为1就代表我们选择按下这一位所在编号的开关，你也可以自己规定k在二进制下某位为0才代表我们选择按下这一位所在编号的开关，这都无所谓。</p>
<p>比如k在二进制下表示为10001，就代表我们选择按第一行编号为0和编号为4的开关，然后对输入数据中第一行这两位执行turn操作。</p>
<p><strong>2.递推思想</strong></p>
<p>当前行若某一位(i,j)为0，那就用其所在列的下一行(i+1,j)去执行turn操作，以使(i,j)变为1，即变亮。</p>
<p>如果对(i,j)执行turn操作，使(i,j)变为1，就会破坏上一行的灯的状态。</p>
<p>所以只能从下一行去改变上一行的灯的状态。</p>
<p>作者：月入星河晚<br>链接：<a href="https://www.acwing.com/solution/content/22367/">https://www.acwing.com/solution/content/22367/</a><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（九）</title>
    <url>/posts/37f8c544.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>100里程碑！！！</strong></p>
<p><img src="/posts/37f8c544/image-20210428224908874.png" alt="image-20210428224908874"></p>
<span id="more"></span>

<h4 id="2-4-acwing-1230-K倍区间（蓝桥杯第八届B组）"><a href="#2-4-acwing-1230-K倍区间（蓝桥杯第八届B组）" class="headerlink" title="2.4 acwing.1230. K倍区间（蓝桥杯第八届B组）"></a>2.4 acwing.1230. K倍区间（蓝桥杯第八届B组）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定一个长度为 N 的数列，A1,A2,…AN，如果其中一段连续的子序列 Ai,Ai+<span class="number">1</span>,…Aj 之和是 K 的倍数，我们就称这个区间 [i,j] 是 K 倍区间。</span><br><span class="line">你能求出数列中总共有多少个 K 倍区间吗？</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含两个整数 N 和 K。</span><br><span class="line">以下 N 行每行包含一个整数 Ai。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，代表 K 倍区间的数目。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤N,K≤<span class="number">100000</span>,</span><br><span class="line"><span class="number">1</span>≤Ai≤<span class="number">100000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>在比赛时，未必能一下就想到最优的解法，可以先从简单的暴力做法写起，拿到一部分分数，不要放弃。</p>
<p><img src="/posts/37f8c544/image-20210428230845430.png" alt="image-20210428230845430"></p>
<p>对于第三重循环计算一段区间的总和，可以用前缀和简化。</p>
<p>我们发现可以存余数来判断是否满足要求，则可以优化成O(n)。</p>
<p>先开一个数组cnt[i]来存余数是i的数有多少个，用空间换时间。</p>
<p>附上一份高赞题解：<a href="https://www.acwing.com/solution/content/6909/">https://www.acwing.com/solution/content/6909/</a></p>
<p>我们可以用一个数组cnt，规定cnt[i]表示当前位置之前，前缀和取模后等于i的个数，以后每出现一次前缀和</p>
<p>（取模后）和它相等，那么k倍区间就加上<code>cnt[s[i] % k]</code>，然后<code>cnt[s[i] % k]++</code>。</p>
<p><code>res += cnt[s[i] % k];</code>先执行，因为要判断当前区间右端点的左边的同余元素，再更新当前位置。</p>
<p><code>cnt=0</code>必须加上，当右端点为1时，若刚好是k的倍数，此时答案应该+1，若没有这句不会+1。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL; <span class="comment">// 可能爆int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line">LL s[N],cnt[N];</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;s[i]);</span><br><span class="line">        s[i] += s[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    cnt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        res += cnt[s[i]%k];</span><br><span class="line">        cnt[s[i]%k]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充：有关段错误的调试方法，使用exit(0)进行二分判断出错位置。</p>
<p>对于类似的没有输出信息的错误都可以采用这种二分找错的方法。</p>
<p><img src="/posts/37f8c544/image-20210429081035194.png" alt="image-20210429081035194"></p>
<h2 id="三-数学与简单DP"><a href="#三-数学与简单DP" class="headerlink" title="三 数学与简单DP"></a>三 数学与简单DP</h2><h3 id="1-数学问题"><a href="#1-数学问题" class="headerlink" title="1.数学问题"></a>1.数学问题</h3><p>关于数学问题，OIwiki是个好东西！</p>
<h4 id="1-1-acwing-1205-买不到的数目（第四届A组）"><a href="#1-1-acwing-1205-买不到的数目（第四届A组）" class="headerlink" title="1.1 acwing.1205. 买不到的数目（第四届A组）"></a>1.1 acwing.1205. 买不到的数目（第四届A组）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">小明开了一家糖果店。</span><br><span class="line">他别出心裁：把水果糖包成<span class="number">4</span>颗一包和<span class="number">7</span>颗一包的两种。</span><br><span class="line">糖果不能拆包卖。</span><br><span class="line">小朋友来买糖的时候，他就用这两种包装来组合。</span><br><span class="line">当然有些糖果数目是无法组合出来的，比如要买 <span class="number">10</span> 颗糖。</span><br><span class="line">你可以用计算机测试一下，在这种包装情况下，最大不能买到的数量是<span class="number">17</span>。</span><br><span class="line"></span><br><span class="line">大于<span class="number">17</span>的任何数字都可以用<span class="number">4</span>和<span class="number">7</span>组合出来。</span><br><span class="line">本题的要求就是在已知两个包装的数量时，求最大不能组合出的数字。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">两个正整数 n,m，表示每种包装中糖的颗数。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">一个正整数，表示最大不能买到的糖数。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">2</span>≤n,m≤<span class="number">1000</span>，</span><br><span class="line">保证数据一定有解。</span><br><span class="line"></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">4</span> <span class="number">7</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>这是一个非常经典的问题，可以当作一个定理来用。（靠数学积累了）</p>
<p>先分析一下：</p>
<p>根据学过的代数知识，对于给定的数n，m，显然有：$(n,m)|n,(n,m)|m$，推出：$(n,m)|xn+ym$</p>
<p>也就是说，n和m的线性组合一定是(n,m)的倍数，只有这种情况才有解。</p>
<p><strong>给定a，b，若d=gcd(a,b)&gt;1,则一定不能凑出最大数。答案要求a，b互质！</strong></p>
<p>有线性代数线性相关、无关，线性表出內味了！</p>
<p>没思路？试试打表找规律！（对于数学问题，没思路不妨试试打表）</p>
<p><strong>补充知识：裴蜀定理</strong>，<a href="https://oi-wiki.org/math/bezouts/">https://oi-wiki.org/math/bezouts/</a></p>
<p>是一个关于最大公约数的定理。</p>
<blockquote>
<p>其内容是：</p>
<p>设a, b是不全为零的整数, 则存在整数x, y,使 $a x+b y=\operatorname{gcd}(a, b).$</p>
</blockquote>
<p>证明过程看上面链接。它的一个重要推论是：a,b互质的充分必要条件是存在整数x,y使ax+by=1.</p>
<p>其实在高等代数的多项式部分有相关的定理、结论。</p>
<p>尝试dfs打表：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (m &gt;= p &amp;&amp; dfs(m-p,p,q)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (m &gt;= q &amp;&amp; dfs(m-q,p,q)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p,q;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; p &gt;&gt; q;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1000</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfs(i,p,q)) res = i;</span><br><span class="line">        <span class="comment">// res会不断更新到最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 2 1</span></span><br><span class="line"><span class="comment">3 4 5</span></span><br><span class="line"><span class="comment">3 5 7</span></span><br><span class="line"><span class="comment">3 7 11</span></span><br><span class="line"><span class="comment">4 9 23</span></span><br><span class="line"><span class="comment">5 9 31</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>m表示当前要凑的总数量，如果m == 0，就表示m已经被凑出来了，否则枚举当前选哪种糖，如果选p并且m - p可以被凑出来，那就是说明m可以被凑出；同理如果选q并且m - q可以被凑出来，那就说明m可以被凑出。</p>
<p>找规律：固定p不变，观察q变化时，答案怎么变化，再固定q不变，观察p变化时，答案怎么变化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>:n+<span class="number">2</span> m+<span class="number">2</span></span><br><span class="line"><span class="number">3</span>:n+<span class="number">1</span> m+<span class="number">2</span></span><br><span class="line"><span class="number">4</span>:n+<span class="number">2</span> m+<span class="number">6</span>    <span class="number">3</span>: m = <span class="number">2</span>n<span class="number">-3</span></span><br><span class="line">                 <span class="number">1</span> = <span class="number">2</span>*<span class="number">2</span> + x x=<span class="number">-3</span>   <span class="number">2</span>n<span class="number">-3</span> = m</span><br><span class="line">             <span class="number">4</span>: m = <span class="number">3</span>n<span class="number">-4</span></span><br><span class="line">             <span class="number">5</span>: m = <span class="number">4</span>n<span class="number">-5</span></span><br><span class="line">             p q</span><br><span class="line">             ans = (q<span class="number">-1</span>)p - q</span><br></pre></td></tr></table></figure>

<p>找到规律直接给出代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 证明比较复杂，以后可以当作结论直接记住</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p,q;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; p &gt;&gt; q;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (p<span class="number">-1</span>)*(q<span class="number">-1</span>)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>前缀和</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（二一）</title>
    <url>/posts/5efa61a1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="4-4-acwing-1207-大臣的旅费"><a href="#4-4-acwing-1207-大臣的旅费" class="headerlink" title="4.4 acwing.1207. 大臣的旅费"></a>4.4 acwing.1207. 大臣的旅费</h4><p>第四届蓝桥杯省赛C++A组,第四届蓝桥杯省赛JAVAA组</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">很久以前，T王国空前繁荣。</span><br><span class="line">为了更好地管理国家，王国修建了大量的快速路，用于连接首都和王国内的各大城市。</span><br><span class="line">为节省经费，T国的大臣们经过思考，制定了一套优秀的修建方案，使得任何一个大城市都能从首都直接或者通过其他大城市间接到达。</span><br><span class="line">同时，如果不重复经过大城市，从首都到达每个大城市的方案都是唯一的。</span><br><span class="line">J是T国重要大臣，他巡查于各大城市之间，体察民情。</span><br><span class="line">所以，从一个城市马不停蹄地到另一个城市成了J最常做的事情。</span><br><span class="line">他有一个钱袋，用于存放往来城市间的路费。</span><br><span class="line">聪明的J发现，如果不在某个城市停下来修整，在连续行进过程中，他所花的路费与他已走过的距离有关，在走第x千米到第x+<span class="number">1</span>千米这一千米中（x是整数），他花费的路费是x+<span class="number">10</span>这么多。也就是说走<span class="number">1</span>千米花费<span class="number">11</span>，走<span class="number">2</span>千米要花费<span class="number">23</span>。</span><br><span class="line">J大臣想知道：他从某一个城市出发，中间不休息，到达另一个城市，所有可能花费的路费中最多是多少呢？</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">输入的第一行包含一个整数 n，表示包括首都在内的T王国的城市数。</span><br><span class="line">城市从 <span class="number">1</span> 开始依次编号，<span class="number">1</span> 号城市为首都。</span><br><span class="line">接下来 n−<span class="number">1</span> 行，描述T国的高速路（T国的高速路一定是 n−<span class="number">1</span> 条）。</span><br><span class="line">每行三个整数 Pi,Qi,Di，表示城市 Pi 和城市 Qi 之间有一条双向高速路，长度为 Di 千米。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示大臣J最多花费的路费是多少。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤n≤<span class="number">10</span>^<span class="number">5</span>,</span><br><span class="line"><span class="number">1</span>≤Pi,Qi≤n,</span><br><span class="line"><span class="number">1</span>≤Di≤<span class="number">1000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">5</span> </span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">2</span> </span><br><span class="line"><span class="number">1</span>  <span class="number">3</span>  <span class="number">1</span> </span><br><span class="line"><span class="number">2</span>  <span class="number">4</span>  <span class="number">5</span> </span><br><span class="line"><span class="number">2</span>  <span class="number">5</span>  <span class="number">4</span> </span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">135</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>参考题解：<a href="https://www.acwing.com/solution/content/7826/">https://www.acwing.com/solution/content/7826/</a></p>
<p><img src="/posts/5efa61a1/image-20210529162242775.png" alt="image-20210529162242775"></p>
<p>经过简单计算，得出路费计算公式：长度为S，路费为<code>f(S) = 10*S + 1/2*S*(S+1)</code>。</p>
<p>我们要求的就是给定的树中长度最长的路径。（也就是树的直径）</p>
<p>这里的图也可以看成是一种特殊的树。</p>
<p><strong>经典问题：求树的直径？</strong>（任意2点之间的路径唯一）</p>
<p>一种简单的做法。</p>
<p>1.在树中任取一点x，分别求x到其他点的距离，存到dist[]；</p>
<p>2.通过第1步，找到距离x最远的点y，再求y到其他点的距离，存到dist[]，在dist中的最大值就是答案，直径。</p>
<p>证明：反证法</p>
<p><img src="/posts/5efa61a1/image-20210529163733200.png" alt="image-20210529163733200"></p>
<ul>
<li><p>情况1：xy与uv有交点，由于离x最远的点是y，因此</p>
<p>  有 1 + 3 &lt;= 3 + 4</p>
<p>  即 3 &lt;= 4</p>
<p>  则 3 + 2 &lt;= 4 + 2</p>
<p>  由于 3 + 2是树的直径，因此4 + 2一定是树的直径，因此y不是树的直径的端点矛盾</p>
</li>
<li><p>情况2:xy与uv没有交点，由于离x最远的点是y，因此</p>
<p>  有 1 + 2 &gt;= 1 + 3 + 5</p>
<p>  即 2 &gt;= 3 + 5</p>
<p>  即 2 &gt; 5</p>
<p>  则 2 + 3 &gt; 5</p>
<p>  则 2 + 3 + 5 &gt; 4 + 5</p>
<p>  由于 4 + 5是树的直径，但存在着一个长度更长的路径，因此y不是树的直径的端点矛盾</p>
</li>
</ul>
<p>因此，y一定是树的直径的端点。所以从y开始到达的最远距离就是树的直径。</p>
<p>时间复杂度：O(n)。</p>
<p>求直径的过程会把树遍历两边，但是要忽略常数。</p>
<p><strong>图的存储方式：</strong></p>
<p>1.邻接矩阵（适合稠密图），本题的话要开10^10，不可取</p>
<p>2.邻接表（适合稀疏图），两种实现方式</p>
<ul>
<li>vector</li>
<li>单链表</li>
</ul>
<p>稠密图：包含很多边；稀疏图：包含较少边。</p>
<p>3.补充：<a href="https://blog.csdn.net/sugarbliss/article/details/86495945">链式前向星–最通俗易懂的讲解</a>，前向星也就是数组模拟链表</p>
<p>推荐文章：<a href="https://www.cnblogs.com/linfangnan/p/12745834.html%EF%BC%8C%E9%9D%9E%E5%B8%B8%E5%85%A8%E9%9D%A2">https://www.cnblogs.com/linfangnan/p/12745834.html，非常全面</a></p>
<p><img src="/posts/5efa61a1/image-20210529165839639.png" alt="image-20210529165839639"></p>
<p>1.y总DFS题解</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span> &lt;Edge&gt; h[N];<span class="comment">// 构建邻接表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> father,<span class="keyword">int</span> distance)</span></span>&#123;</span><br><span class="line">    dist[u] = distance;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> node : h[u])&#123;<span class="comment">// father表示已经遍历过的城市</span></span><br><span class="line">        <span class="keyword">if</span> (node.id != father) dfs(node.id,u,distance + node.w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        h[a].push_back(&#123;b,c&#125;);<span class="comment">// a连向b</span></span><br><span class="line">        h[b].push_back(&#123;a,c&#125;);<span class="comment">// b连向a</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>);<span class="comment">// 求首都1到其他城市的距离</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> u = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (dist[i] &gt; dist[u]) u = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(u,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((dist[i] &gt; dist[u])) u = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s = dist[u];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,s*<span class="number">10</span>+s*(s+<span class="number">1ll</span>)/<span class="number">2</span>);<span class="comment">// 1ll，long long的1，因为会爆int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.自己写的BFS题解，本菜鸡出息了，终于能写一题了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n; </span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">int</span> st[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span> &lt;Edge&gt; h[N];<span class="comment">// 构建邻接表</span></span><br><span class="line"><span class="keyword">int</span> q[N];<span class="comment">// bfs数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);<span class="comment">// 判重数组必须更新</span></span><br><span class="line"></span><br><span class="line">    dist[u] = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = u;</span><br><span class="line">    st[u] = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>,tt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> node:h[t])&#123;</span><br><span class="line">            <span class="keyword">if</span> (st[node.id] != <span class="literal">true</span>)&#123;<span class="comment">// 判重</span></span><br><span class="line">                dist[node.id] = dist[t]+node.w;</span><br><span class="line">                q[++tt] = node.id;</span><br><span class="line">                st[node.id] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        h[a].push_back(&#123;b,c&#125;);</span><br><span class="line">        h[b].push_back(&#123;a,c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bfs(<span class="number">1</span>);<span class="comment">// 求首都1到其他城市的距离</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> u = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (dist[i] &gt; dist[u]) u = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bfs(u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((dist[i] &gt; dist[u])) u = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s = dist[u];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,s*<span class="number">10</span>+s*(s+<span class="number">1ll</span>)/<span class="number">2</span>);<span class="comment">// 1ll，long long的1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-拓展内容"><a href="#5-拓展内容" class="headerlink" title="5.拓展内容"></a>5.拓展内容</h3><p>如何用数组实现链表与邻接表？</p>
<ul>
<li><p>我们可以用结构体+指针的方式来实现（动态）链表，但是每生成一个节点，需要调用<code>new Node();</code>，非常慢，笔试<strong>容易超时</strong>，面试才会考虑这种方式。</p>
</li>
<li><p>数组模拟（静态）单链表，算法笔试中应用较多的邻接表（本质就是多个单链表），它用于存储树和图。</p>
</li>
<li><p>双链表，主要用来优化某些问题。</p>
</li>
</ul>
<h4 id="5-1-acwing-826-单链表（模板题）"><a href="#5-1-acwing-826-单链表（模板题）" class="headerlink" title="5.1 acwing.826.单链表（模板题）"></a>5.1 acwing.826.单链表（模板题）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">实现一个单链表，链表初始为空，支持三种操作：</span><br><span class="line"></span><br><span class="line">向链表头插入一个数；</span><br><span class="line">删除第 k 个插入的数后面的数；</span><br><span class="line">在第 k 个插入的数后插入一个数。</span><br><span class="line">现在要对该链表进行 M 次操作，进行完所有操作后，从头到尾输出整个链表。</span><br><span class="line">注意:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 <span class="number">1</span> 个插入的数，第 <span class="number">2</span> 个插入的数，…第 n 个插入的数。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含整数 M，表示操作次数。</span><br><span class="line">接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：</span><br><span class="line"></span><br><span class="line">H x，表示向链表头插入一个数 x。</span><br><span class="line">D k，表示删除第 k 个插入的数后面的数（当 k 为 <span class="number">0</span> 时，表示删除头结点）。</span><br><span class="line">I k x，表示在第 k 个插入的数后面插入一个数 x（此操作中 k 均大于 <span class="number">0</span>）。</span><br><span class="line">输出格式</span><br><span class="line">共一行，将整个链表从头到尾输出。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤M≤<span class="number">100000</span></span><br><span class="line">所有操作保证合法。</span><br><span class="line"></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">10</span></span><br><span class="line">H <span class="number">9</span></span><br><span class="line">I <span class="number">1</span> <span class="number">1</span></span><br><span class="line">D <span class="number">1</span></span><br><span class="line">D <span class="number">0</span></span><br><span class="line">H <span class="number">6</span></span><br><span class="line">I <span class="number">3</span> <span class="number">6</span></span><br><span class="line">I <span class="number">4</span> <span class="number">5</span></span><br><span class="line">I <span class="number">4</span> <span class="number">5</span></span><br><span class="line">I <span class="number">3</span> <span class="number">4</span></span><br><span class="line">D <span class="number">6</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">6</span> <span class="number">4</span> <span class="number">6</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>数组实现单链表图示：</p>
<p><img src="/posts/5efa61a1/image-20210529195758318.png" alt="image-20210529195758318"></p>
<p>数组和结构体+指针分别实现静、动态单链表，数组更快。</p>
<p>如何用数组实现栈与队列？</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="comment">// head表示头结点的下标，也即指向头结点</span></span><br><span class="line"><span class="comment">// e[i]表示结点i的值</span></span><br><span class="line"><span class="comment">// ne[i]表示结点i的next的指针</span></span><br><span class="line"><span class="comment">// idx指向当前需要插入（已经用过）的结点</span></span><br><span class="line"><span class="keyword">int</span> head,e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 头插法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_head</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head,head = idx,idx++;<span class="comment">// idx已经用过，需要往后推进一位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将x插入下标是k的结点之后</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[k];</span><br><span class="line">    ne[k] = idx;</span><br><span class="line">    idx++;<span class="comment">// 同理idx要往后推进一位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将下标为k的结点的后一个结点删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第k个插入的数其实就是下标k-1的数</span></span><br><span class="line"><span class="comment">// 插入第1个点，下标idx=0；第2个点，下标idx=1；... ；插入第k个点，下标idx=k-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">while</span> (m--)&#123;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="comment">//scanf(&quot;%c&quot;,&amp;op);</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;I&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">//scanf(&quot;%d %d&quot;,&amp;x,&amp;y);</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            add(x<span class="number">-1</span>,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;H&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">//scanf(&quot;%d&quot;,&amp;x);</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            add_to_head(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">//scanf(&quot;%d&quot;,&amp;x);</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span>) head = ne[head];<span class="comment">// 删除头一个结点</span></span><br><span class="line">            <span class="keyword">else</span> remove(x<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head;i != <span class="number">-1</span>;i = ne[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,e[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别注意：如果用scanf输入会读入末尾的回车符，需要再读入k和x时处理，<code>scanf(&quot;%d\n&quot;,xxx);</code></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>BFS</tag>
        <tag>图论</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（二七）</title>
    <url>/posts/4c4fce4f.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="3-习题"><a href="#3-习题" class="headerlink" title="3.习题"></a>3.习题</h3><p>这几道习题都有一定难度。</p>
<h4 id="3-1-acwing-1215-小朋友排队"><a href="#3-1-acwing-1215-小朋友排队" class="headerlink" title="3.1 acwing.1215. 小朋友排队"></a>3.1 acwing.1215. 小朋友排队</h4><p>第五届蓝桥杯省赛C++B/C组</p>
<span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n 个小朋友站成一排。</span><br><span class="line">现在要把他们按身高从低到高的顺序排列，但是每次只能交换位置相邻的两个小朋友。</span><br><span class="line">每个小朋友都有一个不高兴的程度。</span><br><span class="line">开始的时候，所有小朋友的不高兴程度都是 0。</span><br><span class="line">如果某个小朋友第一次被要求交换，则他的不高兴程度增加 1，如果第二次要求他交换，则他的不高兴程度增加 2（即不高兴程度为 3），依次类推。当要求某个小朋友第 k 次交换时，他的不高兴程度增加 k。</span><br><span class="line">请问，要让所有小朋友按从低到高排队，他们的不高兴程度之和最小是多少。</span><br><span class="line">如果有两个小朋友身高一样，则他们谁站在谁前面是没有关系的。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">输入的第一行包含一个整数 n，表示小朋友的个数。</span><br><span class="line">第二行包含 n 个整数 H1,H2,…,Hn，分别表示每个小朋友的身高。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一行，包含一个整数，表示小朋友的不高兴程度和的最小值。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">1≤n≤100000,</span><br><span class="line">0≤Hi≤1000000</span><br><span class="line">输入样例：</span><br><span class="line">3</span><br><span class="line">3 2 1</span><br><span class="line">输出样例：</span><br><span class="line">9</span><br><span class="line">样例解释</span><br><span class="line">首先交换身高为3和2的小朋友，再交换身高为3和1的小朋友，再交换身高为2和1的小朋友，每个小朋友的不高兴程度都是3，总和为9。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>看这题目就是一道贪心问题，可以用冒泡（归并）排序来处理。</p>
<p>序列中逆序对的数量就是至少要交换的次数，使逆序数对变得有序。</p>
<p>证明：在冒泡排序中，每交换一次相邻的两个数，必然使逆序对数量-1，因为这两个数之外的部分相对位置没</p>
<p>有改变，逆序对不受影响。<strong>所以有k个逆序对，至少需要交换k次。</strong>在冒泡排序中，有k个逆序对就需要k次交</p>
<p>换。所以贪心策略是k个逆序对进行k次交换。</p>
<p>可以证明，每个小朋友需要交换的次数是前面比它大的数和后面比它小的数，因为如果前面有比它大的数，那</p>
<p>么它必定和前面的交换一次，使得前面大的数排到后面，同理可以知道比它小的数一定要和它交换到前面</p>
<p>那么我们求每个小朋友a[i]前后比它大/小的数（也即a[i]的逆序对总数）就有三种方法，冒泡排序、归并排序</p>
<p>与树状数组。</p>
<p>对于序列中每个数的逆序对数量：前面比它大的数k1和后面比它小的数k2，他的不高兴度就是<code>1+2+3+...+(k1+k2)</code>。int最大值约为2*10^9，会爆int。</p>
<p>题解1：暴力法。时间复杂度：O(n^2)，目前TLE。</p>
<p>参考题解：<a href="https://www.acwing.com/solution/content/7296/%E3%80%82">https://www.acwing.com/solution/content/7296/。</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[N],num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">summary</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    k=(<span class="number">1</span>+x)*x/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;a[i])&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[i])&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res=summary(res);</span><br><span class="line">        num[i]=res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans+=num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题解2：树状数组，维护了区间中小朋友<strong>身高出现的次数</strong>。时间复杂度：O(n*logn)。</p>
<p>参考代码：y总，参考思路：<a href="https://www.acwing.com/solution/content/7296/%E3%80%82">https://www.acwing.com/solution/content/7296/。</a></p>
<p>每次读入一个数就先把它放到树状数组中去，但这个树状数组保存的并不是这个数，而是这个数出现的次数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;<span class="comment">// 树状数组以身高为下标</span></span><br><span class="line"><span class="keyword">int</span> h[N],tr[N],sum[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x;i &lt;= N;i += lowbit(i)) tr[i] += v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x;i;i -= lowbit(i)) res += tr[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;h[i]),h[i]++;<span class="comment">// 注意身高可能为0，但是树状数组下标从1开始</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每个数前面有多少个数比它大，正向枚举，求的就是前面数中多少个数比它大</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)&#123;</span><br><span class="line">        <span class="comment">// 等价于sumn[i] = i - query(h[i])，i是前面出现数的个数</span></span><br><span class="line">        sum[i] = query(N<span class="number">-1</span>) - query(h[i]);</span><br><span class="line">        add(h[i],<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每个数后面有多少个数比它小，这里一定要逆序枚举</span></span><br><span class="line">    <span class="comment">// 记得清空数组</span></span><br><span class="line">    <span class="built_in">memset</span>(tr,<span class="number">0</span>,<span class="keyword">sizeof</span> tr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n;i;i --)&#123;</span><br><span class="line">        sum[i] += query(h[i]<span class="number">-1</span>);</span><br><span class="line">        add(h[i],<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 答案存LL</span></span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        res += (LL)sum[i]*(sum[i]+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题解3：归并排序。时间复杂度：O(n*logn)。</p>
<p>参考题解：<a href="https://www.acwing.com/solution/content/42097/%E3%80%82">https://www.acwing.com/solution/content/42097/。</a></p>
<p>类似题目：<a href="https://www.acwing.com/problem/content/790/">acwing.788. 逆序对的数量</a>。</p>
<p>我们把所有小朋友的身高按读入的顺序进行归并排序，分别统计每个小朋友的逆序对。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>  N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">LL h[N];</span><br><span class="line">PII temp[N];</span><br><span class="line">PII w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    merge_sort(l,mid),merge_sort(mid+<span class="number">1</span>,r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = l,j = mid+<span class="number">1</span>,k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span> (w[i].x &lt;= w[j].x)&#123;<span class="comment">// 计算i后面比它小的数的个数</span></span><br><span class="line">            h[w[i].y] += j - mid <span class="number">-1</span>;<span class="comment">// 相对于i来说，j 前面的数都比它小</span></span><br><span class="line">            temp[k++] = w[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">// 计算j前面比它大的数的个数</span></span><br><span class="line">            h[w[j].y] += mid - i +<span class="number">1</span>;<span class="comment">// 相对于j来说，i 后面的数都比它大</span></span><br><span class="line">            temp[k++] = w[j++]; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)&#123;<span class="comment">// 计算i后面比它小的数的个数</span></span><br><span class="line">        h[w[i].y] += r - mid;<span class="comment">// 相对于i来说，mid+1到r所有的数都比它小</span></span><br><span class="line">        temp[k++] = w[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r)&#123;</span><br><span class="line">        temp[k++] = w[j++];<span class="comment">// 相对于j来说，不存在逆序对了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 物归原主</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l,j = <span class="number">0</span>;i &lt;= r;i++,j++) w[i] = temp[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);<span class="comment">// w[i]第一维是身高，第二维是下标，读入顺序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i].x),w[i].x++,w[i].y = i;</span><br><span class="line">    merge_sort(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        res += (LL)h[i]*(h[i]+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>树状数组</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（二三）</title>
    <url>/posts/23f22e2b.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="4-acwing-112-雷达设备（算法竞赛进阶指南）"><a href="#4-acwing-112-雷达设备（算法竞赛进阶指南）" class="headerlink" title="4 acwing.112. 雷达设备（算法竞赛进阶指南）"></a>4 acwing.112. 雷达设备（算法竞赛进阶指南）</h4><span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">假设海岸是一条无限长的直线，陆地位于海岸的一侧，海洋位于另外一侧。</span><br><span class="line">每个小岛都位于海洋一侧的某个点上。</span><br><span class="line">雷达装置均位于海岸线上，且雷达的监测范围为 d，当小岛与某雷达的距离不超过 d 时，该小岛可以被雷达覆盖。</span><br><span class="line">我们使用笛卡尔坐标系，定义海岸线为 x 轴，海的一侧在 x 轴上方，陆地一侧在 x 轴下方。</span><br><span class="line">现在给出每个小岛的具体坐标以及雷达的检测范围，请你求出能够使所有小岛都被雷达覆盖所需的最小雷达数目。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行输入两个整数 n 和 d，分别代表小岛数目和雷达检测范围。</span><br><span class="line">接下来 n 行，每行输入两个整数，分别代表小岛的 x，y 轴坐标。</span><br><span class="line">同一行数据之间用空格隔开。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，代表所需的最小雷达数目，若没有解决方案则所需数目输出 −<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤n≤<span class="number">1000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">-3</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>思路：区间贪心（区间选点），可以参考算法笔记P122</p>
<p>y总题解（少见hh）：<a href="https://www.acwing.com/solution/content/1061/">https://www.acwing.com/solution/content/1061/</a></p>
<p>问题转化（很重要，求圆不方便）：</p>
<p>将根据坐标点寻找覆盖它的雷达圆，转化成为根据若干给定区间，求最少选取多少个点，使得每个区间上最少</p>
<p>选一个点。</p>
<p>如下图所示，对于任意一个小岛 (x,y)，我们都可以在海岸线上求出能覆盖该小岛的建造雷达的区间 [a,b]。</p>
<p><img src="/posts/23f22e2b/image-20210603170022189.png" alt="image-20210603170022189"></p>
<p>对于上面这个图片的小岛而言,它可以被雷达搜索到,只有当他的x坐标在[a,b]区间才会被搜索到.当然y坐标也不</p>
<p>能够太大了,如果太大了那么肯定是无解的情况.</p>
<p>贪心策略：</p>
<ul>
<li><p>将所有区间按右端点从小到大排序；</p>
</li>
<li><p>依次考虑每个区间：（扫描每个线段）</p>
<ul>
<li>如果当前区间包含最后一个（上一个）选择的点，则直接跳过；</li>
<li>如果当前区间不包含最后一个选择的点，则在当前区间的右端点的位置选一个新的点；</li>
</ul>
</li>
</ul>
<p><img src="/posts/23f22e2b/image-20210603172632900.png" alt="image-20210603172632900"></p>
<p>时间复杂度</p>
<p>计算每个坐标所对应的区间，需要 O(n) 的计算量；</p>
<p>将所有区间排序需要 O(nlogn)的计算量；</p>
<p>扫描所有区间需要 O(n)的计算量；</p>
<p>所以总共的时间复杂度是 O(nlogn)。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> l,r;<span class="comment">// 用double，区间端点有小数</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Segment&amp; s) <span class="keyword">const</span>&#123;<span class="comment">// 重载&lt;，按右端点排序</span></span><br><span class="line">        <span class="keyword">return</span> r &lt; s.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;seg[N];</span><br><span class="line"><span class="keyword">int</span> n,d;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> failed = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span> (y &gt; d) failed = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">double</span> len = <span class="built_in">sqrt</span>(d*d - y*y);</span><br><span class="line">            seg[i] = &#123;x - len,x + len&#125;;</span><br><span class="line">            <span class="comment">// C++11之前的写法：seg[i].l = x - len,seg[i].r = x + len;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (failed)&#123; <span class="comment">// 纵坐标超过雷达半径</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        sort(seg,seg + n);<span class="comment">// 对区间右端点排序</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> last = -INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (last &lt; seg[i].l)&#123;<span class="comment">// 如果当前区间不包含最后一个选择的点，则选择当前右端点</span></span><br><span class="line">                cnt++;</span><br><span class="line">                last = seg[i].r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-acwing-1235-付账问题"><a href="#5-acwing-1235-付账问题" class="headerlink" title="5 acwing.1235. 付账问题"></a>5 acwing.1235. 付账问题</h4><p>第九届蓝桥杯省赛C++A组,第九届蓝桥杯省赛JAVAA组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">几个人一起出去吃饭是常有的事。</span><br><span class="line">但在结帐的时候，常常会出现一些争执。</span><br><span class="line">现在有 n 个人出去吃饭，他们总共消费了 S 元。</span><br><span class="line">其中第 i 个人带了 ai 元。</span><br><span class="line"></span><br><span class="line">幸运的是，所有人带的钱的总数是足够付账的，但现在问题来了：每个人分别要出多少钱呢？</span><br><span class="line">为了公平起见，我们希望在总付钱量恰好为 S 的前提下，最后每个人付的钱的标准差最小。</span><br><span class="line">这里我们约定，每个人支付的钱数可以是任意非负实数，即可以不是 <span class="number">1</span> 分钱的整数倍。</span><br><span class="line">你需要输出最小的标准差是多少。</span><br><span class="line">    </span><br><span class="line">标准差的介绍：标准差是多个数与它们平均数差值的平方平均数，一般用于刻画这些数之间的“偏差有多大”。</span><br><span class="line">形式化地说，设第 i 个人付的钱为 bi 元，那么标准差为 :</span><br></pre></td></tr></table></figure>

<p><img src="/posts/23f22e2b/image-20210604145017091.png" alt="image-20210604145017091"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入样例<span class="number">1</span>：</span><br><span class="line"><span class="number">5</span> <span class="number">2333</span></span><br><span class="line"><span class="number">666</span> <span class="number">666</span> <span class="number">666</span> <span class="number">666</span> <span class="number">666</span></span><br><span class="line">输出样例<span class="number">1</span>：</span><br><span class="line"><span class="number">0.0000</span></span><br><span class="line">输入样例<span class="number">2</span>：</span><br><span class="line"><span class="number">10</span> <span class="number">30</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">7</span> <span class="number">4</span> <span class="number">8</span> <span class="number">3</span> <span class="number">6</span> <span class="number">4</span> <span class="number">7</span></span><br><span class="line">输出样例<span class="number">2</span>：</span><br><span class="line"><span class="number">0.7928</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>最后这几道题难度都比较大，都是作为倒数2道的压轴题，而且贪心题目之间关联性不是很大。</p>
<p><img src="/posts/23f22e2b/image-20210604151334463.png" alt="image-20210604151334463"></p>
<p><img src="/posts/23f22e2b/image-20210604181858754.png" alt="image-20210604181858754"></p>
<p><img src="/posts/23f22e2b/image-20210604181911691.png" alt="image-20210604181911691"></p>
<p>以上分类讨论中的两点就是本题的贪心策略。</p>
<p>先对$a_1$到$a_n$排序，然后判断$a_1$与S/n的大小。</p>
<p><img src="/posts/23f22e2b/image-20210604183308616.png" alt="image-20210604183308616"></p>
<p>当$b_1$确定之后，后面的$b_2$到$b_n$的和也是一个定值，可以接着第一步的思路，继续比较$a_2$与新的平均值的大</p>
<p>小。排序是因为要把钱多的人放在后面，因为他们要分担前面钱不够的人，也就是说他们付的钱是由钱少同学</p>
<p>确定的。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> S;<span class="comment">// 用double存，要计算平均值</span></span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %lf&quot;</span>,&amp;n,&amp;S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"></span><br><span class="line">    sort(a,a+n); <span class="comment">// 记得排序</span></span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">0</span>,avg = S / n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">double</span> cur = S/(n-i);<span class="comment">// 当前平均值</span></span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; cur) cur = a[i];<span class="comment">// 带的钱a[i]不够平均值则全交</span></span><br><span class="line">        <span class="comment">// 带的钱a[i]够平均值则交平均值</span></span><br><span class="line">        res += (cur-avg)*(cur-avg)/n;</span><br><span class="line">        S -= cur;<span class="comment">// 更新当前要付的总费用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.4lf\n&quot;</span>,<span class="built_in">sqrt</span>(res));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-acwing-1239-乘积最大"><a href="#6-acwing-1239-乘积最大" class="headerlink" title="6 acwing.1239. 乘积最大"></a>6 acwing.1239. 乘积最大</h4><p>第九届蓝桥杯省赛C++B组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定 N 个整数 A1,A2,…AN。</span><br><span class="line">请你从中选出 K 个数，使其乘积最大。</span><br><span class="line">请你求出最大的乘积，由于乘积可能超出整型范围，你只需输出乘积除以 <span class="number">1000000009</span> 的余数。</span><br><span class="line">注意，如果 X&lt;<span class="number">0</span>， 我们定义 X 除以 <span class="number">1000000009</span> 的余数是负(−X)除以 <span class="number">1000000009</span> 的余数，即：<span class="number">0</span>−((<span class="number">0</span>−x)%<span class="number">1000000009</span>)</span><br><span class="line">    </span><br><span class="line">输入格式</span><br><span class="line">第一行包含两个整数 N 和 K。</span><br><span class="line">以下 N 行每行一个整数 Ai。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示答案。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤K≤N≤<span class="number">10</span>^<span class="number">5</span>,</span><br><span class="line">−<span class="number">10</span>^<span class="number">5</span>≤Ai≤<span class="number">10</span>^<span class="number">5</span></span><br><span class="line">输入样例<span class="number">1</span>：</span><br><span class="line"><span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">-100000</span></span><br><span class="line"><span class="number">-10000</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">100000</span></span><br><span class="line"><span class="number">10000</span></span><br><span class="line">输出样例<span class="number">1</span>：</span><br><span class="line"><span class="number">999100009</span></span><br><span class="line">输入样例<span class="number">2</span>：</span><br><span class="line"><span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">-100000</span></span><br><span class="line"><span class="number">-100000</span></span><br><span class="line"><span class="number">-2</span></span><br><span class="line"><span class="number">-100000</span></span><br><span class="line"><span class="number">-100000</span></span><br><span class="line">输出样例<span class="number">2</span>：</span><br><span class="line"><span class="number">-999999829</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>负余数：</p>
<ul>
<li>数论中：<code>-2 mod 10 = 8</code>，取模运算不会得到负值</li>
<li>C++中：<code>-2 mod 10 = -2</code></li>
</ul>
<p>注意本题中所定义的负余数是按照C++的。</p>
<p>在蓝桥杯（十三）中提到负余数的处理问题，</p>
<p><code>int get_mod(int a,int b)  return (a % b + b) % b;// 将负余数转成正的</code></p>
<p>本题要分五种情况讨论！</p>
<p><img src="/posts/23f22e2b/image-20210604193246678.png" alt="image-20210604193246678"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大佬文字版思路</span></span><br><span class="line">该题的题解是整理了一下 y总视频里面讲解思路,希望对看完视频还不大理解的同学有点帮助</span><br><span class="line">首先我们知道 如果 k == n ,那么就证明所有的数字是全部都选,</span><br><span class="line">             如果 k &lt; n , 那么就要思考怎样去选择了:</span><br><span class="line"><span class="number">1.</span>k 如果是偶数的话,选出来的结果一定是非负数 , 原因如下:</span><br><span class="line">             (<span class="number">1</span>) # 负数的个数是偶数个的话,负负得正,那么一定是非负数</span><br><span class="line">             (<span class="number">2</span>) # 负数的个数如果是奇数个的话,那么我们就只选偶数个绝对值最大的负数</span><br><span class="line"><span class="number">2.</span>k 如果是奇数个的话,</span><br><span class="line">             (<span class="number">1</span>)# 所有的数字如果都是负数,那么选出来的结果也一定都是负数    </span><br><span class="line">             (<span class="number">2</span>)# 否则的话,则一定至少有 <span class="number">1</span>个非负数, 那么我们将最大的数取出来, 此时要选的个数就是 k--, </span><br><span class="line">                <span class="meta"># k-- 是偶数,那么就又转化为 k-- 是偶数的情况思考</span></span><br><span class="line">作者：大厂狗狗</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/8724/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p><img src="/posts/23f22e2b/image-20210604194403016.png" alt="image-20210604194403016"></p>
<p>k是奇数时，两种情况都需要先选择最大的那个数，然后问题就转化成了k是偶数的情况。</p>
<p>找到几种情况的共同点之后，就可以统一处理了。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000009</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    sort(a,a+n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>,res = <span class="number">1</span>;<span class="comment">// sign作为正负号标志，res作为乘积</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>,r = n<span class="number">-1</span>;<span class="comment">// 双指针算法</span></span><br><span class="line">    <span class="keyword">if</span> (k % <span class="number">2</span>)&#123;</span><br><span class="line">        res = a[r--];</span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) sign = <span class="number">-1</span>;<span class="comment">// 说明全部是负数，最终结果也是负数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (k)&#123;<span class="comment">// 把所有数选完退出</span></span><br><span class="line">        LL x = (LL)a[l]*a[l+<span class="number">1</span>],y = (LL)a[r<span class="number">-1</span>]*a[r];<span class="comment">// 可能爆int</span></span><br><span class="line">        <span class="keyword">if</span> (x*sign &gt; y*sign)&#123;<span class="comment">// 如果最终结果是正的，挑绝对值大的，反之挑小的</span></span><br><span class="line">            <span class="comment">// 通过sign巧妙将几种情况统一了，y总yyds</span></span><br><span class="line">            res = x%mod * res%mod;<span class="comment">// res也要取模再相乘</span></span><br><span class="line">            l += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res = y%mod * res%mod;</span><br><span class="line">            r -= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>中位数</tag>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>贪心</tag>
        <tag>区间问题</tag>
        <tag>不等式</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（二九）</title>
    <url>/posts/c1e9c753.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="4-补充：差分算法"><a href="#4-补充：差分算法" class="headerlink" title="4.补充：差分算法"></a>4.补充：差分算法</h3><p>参考资料：<a href="https://oi-wiki.org/basic/prefix-sum/%E3%80%82">https://oi-wiki.org/basic/prefix-sum/。</a></p>
<p>差分是一种和前缀和相对的策略，可以当做是求和的逆运算。</p>
<p>墙推：<a href="https://blog.csdn.net/weixin_45629285/article/details/111146240">前缀和与差分算法总结</a></p>
<span id="more"></span>

<h4 id="4-1-acwing-797-差分（一维差分）"><a href="#4-1-acwing-797-差分（一维差分）" class="headerlink" title="4.1 acwing.797. 差分（一维差分）"></a>4.1 acwing.797. 差分（一维差分）</h4><p>模板题, Hulu面试题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入一个长度为 n 的整数序列。</span><br><span class="line">接下来输入 m 个操作，每个操作包含三个整数 l,r,c，表示将序列中 [l,r] 之间的每个数加上 c。</span><br><span class="line">请你输出进行完所有操作后的序列。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含两个整数 n 和 m。</span><br><span class="line">第二行包含 n 个整数，表示整数序列。</span><br><span class="line">接下来 m 行，每行包含三个整数 l，r，c，表示一个操作。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">共一行，包含 n 个整数，表示最终序列。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤n,m≤<span class="number">100000</span>,</span><br><span class="line"><span class="number">1</span>≤l≤r≤n,</span><br><span class="line">−<span class="number">1000</span>≤c≤<span class="number">1000</span>,</span><br><span class="line">−<span class="number">1000</span>≤整数序列中元素的值≤<span class="number">1000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">6</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">1</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>差分可以维护多次对序列的一个区间加上一个数，并在最后询问某一位的数或是多次询问某一位的数。</p>
<p>注意：<strong>修改操作一定要在查询操作之前</strong>。</p>
<p>对于给定的序列a[1],a[2],…,a[n]，我们构造一个差分数组b[n]，使得：<code>a[i] = b[1]+b[2]+...+b[i]</code>，也就</p>
<p>是说a[N]是b[N]的前缀和数组。</p>
<p>$\text { 这种策略的定义是令 } b_{i}=\left{\begin{array}{ll}<br>a_{i}-a_{i-1} &amp; i \in[2, n] \<br>a_{1} &amp; i=1<br>\end{array}\right.$</p>
<p><strong>核心操作</strong>：将a[L~R]全部加上c，等价于：b[L] += c,b[R+1] -= c。</p>
<p>简单证明一下：</p>
<ol>
<li>对于a[1~L-1]：没有影响；</li>
<li>对于a[L<del>R]：b[L] += c，所以a[L</del>R] += c；</li>
<li>对于a[R+1~n]：b[L] += c,b[R+1] -= c，所以无影响。</li>
</ol>
<p>初始化差分数组b[n]：相当于按a[1<del>1],a[2</del>2],a[n-n]的顺序分别加上一个给出的数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    b[l] += c,b[r+<span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        insert(i,i,a[i]);<span class="comment">// 初始化差分数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> l,r,c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;c);</span><br><span class="line">        insert(l,r,c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;<span class="comment">// 计算前缀和并输出</span></span><br><span class="line">        a[i] = a[i<span class="number">-1</span>] + b[i];<span class="comment">// 先修改，再查询，不能合成一步或者调换顺序</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-acwing-798-差分矩阵（二维差分）"><a href="#4-2-acwing-798-差分矩阵（二维差分）" class="headerlink" title="4.2 acwing.798. 差分矩阵（二维差分）"></a>4.2 acwing.798. 差分矩阵（二维差分）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入一个 n 行 m 列的整数矩阵，再输入 q 个操作，每个操作包含五个整数 x1,y1,x2,y2,c，其中 (x1,y1) 和 (x2,y2) 表示一个子矩阵的左上角坐标和右下角坐标。</span><br><span class="line">每个操作都要将选中的子矩阵中的每个元素的值加上 c。</span><br><span class="line">请你将进行完所有操作后的矩阵输出。</span><br><span class="line"> </span><br><span class="line">输入格式</span><br><span class="line">第一行包含整数 n,m,q。</span><br><span class="line">接下来 n 行，每行包含 m 个整数，表示整数矩阵。</span><br><span class="line">接下来 q 行，每行包含 <span class="number">5</span> 个整数 x1,y1,x2,y2,c，表示一个操作。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">共 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤n,m≤<span class="number">1000</span>,</span><br><span class="line"><span class="number">1</span>≤q≤<span class="number">100000</span>,</span><br><span class="line"><span class="number">1</span>≤x1≤x2≤n,</span><br><span class="line"><span class="number">1</span>≤y1≤y2≤m,</span><br><span class="line">−<span class="number">1000</span>≤c≤<span class="number">1000</span>,</span><br><span class="line">−<span class="number">1000</span>≤矩阵内元素的值≤<span class="number">1000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>对于给定的矩阵<code>a[N][N]</code>，我们构造一个差分矩阵b<code>[N][N]</code>，使得：<code>a[i][j]</code>是<code>b[i][j]</code>的二维前缀和。</p>
<p><strong>核心操作</strong>：给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素<code>a[i][j]</code>加上c。</p>
<p>等价于：B[x1, y1] += c, B[x2 + 1, y1] -= c, B[x1, y2 + 1] -= c, B[x2 + 1, y2 + 1] += c。</p>
<p><img src="/posts/c1e9c753/image-20210613220956311.png" alt="image-20210613220956311"></p>
<p><code>b[x1][ y1 ] +=c ;</code> 让整个a数组中(x1,y1)到大矩形右下角范围的元素都加上了c。</p>
<p><code>b[x1,][y2+1]-=c</code> ; 让整个a数组中绿色矩形面积的元素再减去c，使其内元素不发生改变。</p>
<p><code>b[x2+1][y1]- =c ;</code> 对应图3 ,让整个a数组中紫色矩形面积的元素再减去c，使其内元素不发生改变。</p>
<p><code>b[x2+1][y2+1]+=c;</code> 对应图4,让整个a数组中红色矩形面积的元素再加上c，红色内的相当于被减了两次，再</p>
<p>加上一次c，才能使其恢复。</p>
<p>初始化差分数组<code>b[N][N]</code>：相当于按{(1,1),(1,1)}，{(1,2),(1,2)}，{(n,m),(n,m)}的顺序分别加上一个给出的数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,q;</span><br><span class="line"><span class="keyword">int</span> a[N][N],b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x1][y2+<span class="number">1</span>] -= c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y2+<span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">            insert(i,j,i,j,a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span> x1,y1,x2,y2,c;</span><br><span class="line">    <span class="keyword">while</span> (q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;c);</span><br><span class="line">        insert(x1,y1,x2,y2,c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)&#123;<span class="comment">// 求b[1][1]到b[i][j]的前缀和a[i][j]</span></span><br><span class="line">            a[i][j] = a[i<span class="number">-1</span>][j] + a[i][j<span class="number">-1</span>] - a[i<span class="number">-1</span>][j<span class="number">-1</span>] + b[i][j];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>差分知识总结：</p>
<p><img src="/posts/c1e9c753/image-20210610181619879.png" alt="image-20210610181619879"></p>
<blockquote>
<p>前缀和与差分模板总结（来自于yls视频）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一维前缀和</span></span><br><span class="line">S[i] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + ... a[i]</span><br><span class="line">从a[l]到a[r]的和为：a[l] + ... + a[r] = S[r] - S[l - <span class="number">1</span>]</span><br><span class="line"><span class="comment">// 二维前缀和</span></span><br><span class="line">S[i, j] = 第i行j列格子左上部分所有元素的和</span><br><span class="line">S&#123;x,y&#125; = S&#123;x<span class="number">-1</span>,y&#125;+S&#123;x,y<span class="number">-1</span>&#125;-S&#123;x<span class="number">-1</span>,y<span class="number">-1</span>&#125;+a&#123;x,y&#125;</span><br><span class="line">以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</span><br><span class="line">S[x2, y2] - S[x1 - <span class="number">1</span>, y2] - S[x2, y1 - <span class="number">1</span>] + S[x1 - <span class="number">1</span>, y1 - <span class="number">1</span>]</span><br><span class="line"><span class="comment">// 一维差分</span></span><br><span class="line">给区间[l, r]中的每个数加上c：</span><br><span class="line">B[l] += c, B[r + <span class="number">1</span>] -= c</span><br><span class="line"><span class="comment">// 二维差分</span></span><br><span class="line">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：</span><br><span class="line">B[x1, y1] += c, B[x2 + <span class="number">1</span>, y1] -= c, B[x1, y2 + <span class="number">1</span>] -= c, B[x2 + <span class="number">1</span>, y2 + <span class="number">1</span>] += c</span><br></pre></td></tr></table></figure>

<h4 id="4-3-acwing-1232-三体攻击（三维差分，困难）"><a href="#4-3-acwing-1232-三体攻击（三维差分，困难）" class="headerlink" title="4.3 acwing.1232. 三体攻击（三维差分，困难）"></a>4.3 acwing.1232. 三体攻击（三维差分，困难）</h4><p>第九届蓝桥杯省赛C++A组,第九届蓝桥杯省赛JAVAA组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">三体人将对地球发起攻击。</span><br><span class="line">为了抵御攻击，地球人派出了 A×B×C 艘战舰，在太空中排成一个 A 层 B 行 C 列的立方体。</span><br><span class="line">其中，第 i 层第 j 行第 k 列的战舰（记为战舰 (i,j,k)）的生命值为 d(i,j,k)。</span><br><span class="line">三体人将会对地球发起 m 轮“立方体攻击”，每次攻击会对一个小立方体中的所有战舰都造成相同的伤害。</span><br><span class="line">具体地，第 t 轮攻击用 <span class="number">7</span> 个参数 lat,rat,lbt,rbt,lct,rct,ht 描述；</span><br><span class="line">所有满足 i∈[lat,rat],j∈[lbt,rbt],k∈[lct,rct] 的战舰 (i,j,k) 会受到 ht 的伤害。</span><br><span class="line">如果一个战舰累计受到的总伤害超过其防御力，那么这个战舰会爆炸。</span><br><span class="line">地球指挥官希望你能告诉他，第一艘爆炸的战舰是在哪一轮攻击后爆炸的。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包括 <span class="number">4</span> 个正整数 A,B,C,m；</span><br><span class="line">第二行包含 A×B×C 个整数，其中第 ((i−<span class="number">1</span>)×B+(j−<span class="number">1</span>))×C+(k−<span class="number">1</span>)+<span class="number">1</span> 个数为 d(i, j, k)；</span><br><span class="line">第 <span class="number">3</span> 到第 m+<span class="number">2</span> 行中，第 (t − <span class="number">2</span>) 行包含 <span class="number">7</span> 个正整数 lat, rat, lbt, rbt, lct, rct, ht。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出第一个爆炸的战舰是在哪一轮攻击后爆炸的。</span><br><span class="line">保证一定存在这样的战舰。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤A×B×C≤<span class="number">10</span>^<span class="number">6</span>,</span><br><span class="line"><span class="number">1</span>≤m≤<span class="number">10</span>^<span class="number">6</span>,</span><br><span class="line"><span class="number">0</span>≤d(i, j, k), ht≤<span class="number">10</span>^<span class="number">9</span>,</span><br><span class="line"><span class="number">1</span>≤lat≤rat≤A,</span><br><span class="line"><span class="number">1</span>≤lbt≤rbt≤B,</span><br><span class="line"><span class="number">1</span>≤lct≤rct≤C</span><br><span class="line">层、行、列的编号都从 <span class="number">1</span> 开始。</span><br><span class="line"></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">2</span></span><br><span class="line">样例解释</span><br><span class="line">在第 <span class="number">2</span> 轮攻击后，战舰 (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>) 总共受到了 <span class="number">2</span> 点伤害，超出其防御力导致爆炸。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>考察二分、前缀和与差分。（PS：本题与树状数组和线段树无关）</p>
<p>问题：从第几轮攻击开始，某个格子的生命小于0。</p>
<p>由题意知道生命值一定是递减的，满足二分的条件。如果从头开始遍历，比较慢，所以用二分优化。</p>
<p>由于是立方体，所以用到三维差分，</p>
<p>设读入的数据存入<code>S[N][N][N]</code>（这里为了方便展开成三维，代码中做了映射处理，实际只有一维），构造差</p>
<p>分数组<code>b[N][N][N]</code>。</p>
<p>类比一维和二维，我们得到三维前缀和公式：用到三个集合的<strong>容斥原理</strong>，<strong>奇数个-1就+，偶数个-1就-</strong></p>
<p>S{x,y,z} = S{x-1,y,z}+S{x,y-1,z}+S{x,y,z-1}-S{x-1,y-1,z}-S{x,y-1,z-1}-S{x-1,y,z-1}+S{x-1,y-1,z-1}+b{x,y,z}</p>
<p>由此可以反求出b{x,y,z}，<strong>构造差分数组</strong>。</p>
<p>同理类比一维和二维，我们得到三维差分公式：从(x1, y1,z1)到(x2,y2,z2)范围内的S{i,j,k}都<strong>减去</strong>一个数h</p>
<p>注意这里是减去一个数h！！！</p>
<p>b{x1,y1,z1} -= h,b{x1,y1,z2+1} += h,b{x1,y2+1,z1} += h,b{x1,y2+1,z2+1} -= h,</p>
<p>b{x2+1,y1,z1} += h,b{x2+1,y1,z1+1} -= h,b{x2+1,y2+1,z2+1} += h    <strong>奇数个+1就+=h，偶数个就-=h</strong></p>
<p>由于题目只给出了A×B×C的范围，不知道每个维度具体范围，所以直接开一维数组，需要映射处理一下。</p>
<p>二维映射：<code>AXB，(i,j)--&gt;i*B+j</code>；三维映射：AXBXC，<code>(i,j,k)--&gt;(i*B+j)*C+k</code></p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>;<span class="comment">// 开2倍1e6，因为数组从1开始，有三个面不能用</span></span><br><span class="line"><span class="comment">// 最坏情况只有一层，底下整个面不能用，开2倍</span></span><br><span class="line"><span class="keyword">int</span> A,B,C,m;</span><br><span class="line">LL s[N],b[N],bp[N];<span class="comment">// 防止爆int</span></span><br><span class="line"><span class="keyword">int</span> op[N&gt;&gt;<span class="number">1</span>][<span class="number">7</span>];<span class="comment">// 三体攻击的伤害</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[<span class="number">8</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k)</span></span>&#123;<span class="comment">// 三维坐标的映射</span></span><br><span class="line">    <span class="keyword">return</span> (i*B+j)*C+k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(b,bp,<span class="keyword">sizeof</span> b);<span class="comment">// 拷贝原始差分数组</span></span><br><span class="line">    <span class="comment">// 对伤害范围内的数减去伤害值h</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= mid;i++)&#123;<span class="comment">// 计算从1到mid的累积伤害</span></span><br><span class="line">        <span class="keyword">int</span> x1 = op[i][<span class="number">0</span>],x2 = op[i][<span class="number">1</span>],y1 = op[i][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> y2 = op[i][<span class="number">3</span>],z1 = op[i][<span class="number">4</span>],z2 = op[i][<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> h = op[i][<span class="number">6</span>];</span><br><span class="line">        b[get(x1,y1,z1)] -= h;</span><br><span class="line">        b[get(x1,y1,z2 + <span class="number">1</span>)] += h;</span><br><span class="line">        b[get(x1,y2 + <span class="number">1</span>,z1)] += h;</span><br><span class="line">        b[get(x1,y2 + <span class="number">1</span>,z2 + <span class="number">1</span>)] -= h;</span><br><span class="line">        b[get(x2 + <span class="number">1</span>,y1,z1)] += h;</span><br><span class="line">        b[get(x2 + <span class="number">1</span>,y1,z2 + <span class="number">1</span>)] -= h;</span><br><span class="line">        b[get(x2 + <span class="number">1</span>,y2 + <span class="number">1</span>,z1)] -= h;</span><br><span class="line">        b[get(x2 + <span class="number">1</span>,y2 + <span class="number">1</span>,z2 + <span class="number">1</span>)] += h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重新计算前缀和数组s，判断生命值是否&lt;0</span></span><br><span class="line">    <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span> s);<span class="comment">// 前缀和数组置0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= A;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= B;j++)<span class="comment">// 把求差分数组的公式反过来就是求前缀和</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= C;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                s[get(i,j,k)] = b[get(i,j,k)];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>;u &lt; <span class="number">8</span>;u++)&#123;<span class="comment">// u从1开始，因为不用第1项</span></span><br><span class="line">                    <span class="keyword">int</span> x = i - d[u][<span class="number">0</span>],y = j - d[u][<span class="number">1</span>],z = k - d[u][<span class="number">2</span>],t = d[u][<span class="number">3</span>];</span><br><span class="line">                    </span><br><span class="line">                    s[get(i,j,k)] -= s[get(x,y,z)]*t;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (s[get(i,j,k)] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;A,&amp;B,&amp;C,&amp;m);</span><br><span class="line">    <span class="comment">// 读入s数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= A;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= B;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= C;k++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;s[get(i,j,k)]);</span><br><span class="line">    <span class="comment">// 初始化差分数组b</span></span><br><span class="line">    <span class="comment">// 也可以像二维差分那题用insert数组s中的数初始化，代码会短一点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= A;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= B;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= C;k++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>;u &lt; <span class="number">8</span>;u++)&#123;<span class="comment">// 求差分数组一共8项，t表示正负号</span></span><br><span class="line">                    <span class="keyword">int</span> x = i - d[u][<span class="number">0</span>],y = j - d[u][<span class="number">1</span>],z = k - d[u][<span class="number">2</span>],t = d[u][<span class="number">3</span>];</span><br><span class="line">                    bp[get(i,j,k)] += s[get(x,y,z)] * t;</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)<span class="comment">// 读取三体攻击伤害值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">7</span>;j++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对每轮攻击进行二分，判断那一轮生命达到0</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>,r = m;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l+r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>insert的写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(LL b[],<span class="keyword">int</span> x1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y1,<span class="keyword">int</span> y2,<span class="keyword">int</span> z1,<span class="keyword">int</span> z2,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[get(x1,  y1,   z1)  ] +=c;</span><br><span class="line">    b[get(x1,  y1,   z2+<span class="number">1</span>)] -=c;</span><br><span class="line">    b[get(x1,  y2+<span class="number">1</span>, z1)  ] -=c;</span><br><span class="line">    b[get(x1,  y2+<span class="number">1</span>, z2+<span class="number">1</span>)] +=c;</span><br><span class="line">    b[get(x2+<span class="number">1</span>,y1,   z1)  ] -=c;</span><br><span class="line">    b[get(x2+<span class="number">1</span>,y1,   z2+<span class="number">1</span>)] +=c;</span><br><span class="line">    b[get(x2+<span class="number">1</span>,y2+<span class="number">1</span>, z1)  ] +=c;</span><br><span class="line">    b[get(x2+<span class="number">1</span>,y2+<span class="number">1</span>, z2+<span class="number">1</span>)] -=c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码太长的debug方式：</p>
<ol>
<li>使用文本对比工具，比如Vscode自带的，ctrl选择两个文件，右键比较，也可以用专业软件像beyond compare</li>
<li>与AC代码比较，一段一段CV，二分找到错误点</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>前缀和</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（二二）</title>
    <url>/posts/6eec8d79.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="六-贪心"><a href="#六-贪心" class="headerlink" title="六 贪心"></a>六 贪心</h2><p>贪心问题<strong>没有普遍统一的模板</strong>，跳跃性很强，结论证明往往很难。</p>
<p>做法：1.找以往做过的相似的题目 2.不会的只能靠猜了</p>
<p>贪心是求解一类最优化问题的方法，考虑当前状态下<strong>局部最优</strong>的策略，来使<strong>全局</strong>结果达到<strong>最优</strong>。</p>
<p>贪心的证明往往比贪心更难。</p>
<p>代码随想录：<a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.md">贪心专题文章</a>，题目数量多，总结全面。LeetCode101贪心算法专题。</p>
<p>要证明贪心策略的正确性常会用到反证法，找一找是否有反例，还有一种就是数学归纳法。</p>
<p>做题时没必要非得证明出来，能AC就能成功。</p>
<span id="more"></span>

<h4 id="1-acwing-1055-股票买卖-II（LeetCode）"><a href="#1-acwing-1055-股票买卖-II（LeetCode）" class="headerlink" title="1 acwing.1055. 股票买卖 II（LeetCode）"></a>1 acwing.1055. 股票买卖 II（LeetCode）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定一个长度为 N 的数组，数组中的第 i 个数字表示一个给定股票在第 i 天的价格。</span><br><span class="line">设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</span><br><span class="line">注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含整数 N，表示数组长度。</span><br><span class="line">第二行包含 N 个不大于 <span class="number">10000</span> 的正整数，表示完整的数组。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示最大利润。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤N≤<span class="number">10</span>^<span class="number">5</span></span><br><span class="line">输入样例<span class="number">1</span>：</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span> <span class="number">1</span> <span class="number">5</span> <span class="number">3</span> <span class="number">6</span> <span class="number">4</span></span><br><span class="line">输出样例<span class="number">1</span>：</span><br><span class="line"><span class="number">7</span></span><br><span class="line">输入样例<span class="number">2</span>：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">输出样例<span class="number">2</span>：</span><br><span class="line"><span class="number">4</span></span><br><span class="line">输入样例<span class="number">3</span>：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span> <span class="number">6</span> <span class="number">4</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line">输出样例<span class="number">3</span>：</span><br><span class="line"><span class="number">0</span></span><br><span class="line">样例解释</span><br><span class="line">样例<span class="number">1</span>：在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">3</span> 天（股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span><span class="number">-1</span> = <span class="number">4</span> 。随后，在第 <span class="number">4</span> 天（股票价格 = <span class="number">3</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">6</span><span class="number">-3</span> = <span class="number">3</span> 。共得利润 <span class="number">4</span>+<span class="number">3</span> = <span class="number">7</span>。</span><br><span class="line"></span><br><span class="line">样例<span class="number">2</span>：在第 <span class="number">1</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天 （股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span><span class="number">-1</span> = <span class="number">4</span> 。注意你不能在第 <span class="number">1</span> 天和第 <span class="number">2</span> 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br><span class="line"></span><br><span class="line">样例<span class="number">3</span>：在这种情况下, 不进行任何交易, 所以最大利润为 <span class="number">0</span>。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>根据数据范围，时间复杂度应该控制为：O(n)或者O(n*logn)。</p>
<p>交易策略：对于数组的相邻两天，只要后一天比前一天价格高，就进行一次交易。</p>
<p>性质：任意交易天数跨度大于1的交易，必然可以分解为多个交易天数等于1的交易。</p>
<p>代码：</p>
<p>时间复杂度：O(n).</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N  = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> price[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;price[i]);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> dt = price[i+<span class="number">1</span>] - price[i];</span><br><span class="line">        <span class="keyword">if</span> (dt &gt; <span class="number">0</span>) res += dt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-acwing-104-货仓选址"><a href="#2-acwing-104-货仓选址" class="headerlink" title="2 acwing.104. 货仓选址"></a>2 acwing.104. 货仓选址</h4><p>《算法竞赛进阶指南》, 模板题</p>
<p>本题在<a href="https://www.grantdrew.top/posts/baabc5c0.html">寒假每日一题</a>中出现过。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">在一条数轴上有 N 家商店，它们的坐标分别为 A1∼AN。</span><br><span class="line">现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。</span><br><span class="line">为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行输入整数 N。</span><br><span class="line">第二行 N 个整数 A1∼AN。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示距离之和的最小值。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤N≤<span class="number">100000</span>,</span><br><span class="line"><span class="number">0</span>≤Ai≤<span class="number">40000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span> <span class="number">2</span> <span class="number">9</span> <span class="number">1</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>从直觉上看，我们不妨猜货仓应该建在所有商店的中间位置。</p>
<p>这很容易证明，如果建在两个商店之外，距离一定比在中间大。</p>
<p>从2个、3个商店，手动模拟一下，很容易发现上述规律，应该建在中位数这个位置。</p>
<p>出题人往往根据已有的数学模型，包装成一个题目，用贪心求解。</p>
<p>严格数学证明：</p>
<p><img src="/posts/6eec8d79/image-20210530172414373.png" alt="image-20210530172414373"></p>
<p>问题核心在于分组求绝对值之和最大值。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    sort(a,a+n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> c = a[n/<span class="number">2</span>];<span class="comment">// 求中位数</span></span><br><span class="line">    LL res = <span class="number">0</span>;<span class="comment">// 用LL来存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) res += <span class="built_in">abs</span>(a[i] - c);<span class="comment">// 求距离</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-acwing-122-糖果传递（困难）"><a href="#3-acwing-122-糖果传递（困难）" class="headerlink" title="3 acwing.122. 糖果传递（困难）"></a>3 acwing.122. 糖果传递（困难）</h4><p>《算法竞赛进阶指南》,微软面试题 , HAOI2008，有难度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">有 n 个小朋友坐成一圈，每人有 a[i] 个糖果。</span><br><span class="line">每人只能给左右两人传递糖果。</span><br><span class="line">每人每次传递一个糖果代价为 <span class="number">1</span>。</span><br><span class="line">求使所有人获得均等糖果的最小代价。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行输入一个正整数 n，表示小朋友的个数。</span><br><span class="line">接下来 n 行，每行一个整数 a[i]，表示第 i 个小朋友初始得到的糖果的颗数。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示最小代价。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤n≤<span class="number">1000000</span>,</span><br><span class="line"><span class="number">0</span>≤a[i]≤<span class="number">2</span>×<span class="number">10</span>^<span class="number">9</span>,</span><br><span class="line">数据保证一定有解。</span><br><span class="line"></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>思路：<strong>数学演算</strong></p>
<p><img src="/posts/6eec8d79/image-20210602151746775.png" alt="image-20210602151746775"></p>
<p>将所有量进行数学化计算，构建数学模型，最终结果就是极小化红色标注的绝对值不等式，然后就可以直接套用上一题货仓选</p>
<p>址的做法。（$x_1$等表示从$a_1$传递到$a_2$的糖果数量，可正可负，如果是负数表示是反向传递的）</p>
<hr>
<p>下一步，要<strong>证明</strong>方案是否一定存在。（如果只想AC可以不看证明）</p>
<p>比如，当a1=3时，x3=5，方案就不成立，因为给出的糖果不可能比已有的还多。</p>
<p>首先可以证明：</p>
<p>所有$x_i(i=1,2,…,n)$同时大于0不成立。假设所有$x_i$大于0，那么可以让所有$x_i$都减去最小的$x_i$，使得每个</p>
<p>人得到的糖果数量是一样的效果，因为相互抵消了，这是就有部分$x_i$等于0，部分大于0，所以不成立。</p>
<p>同理可以证明所有$x_i(i=1,2,…,n)$同时小于0也不成立。</p>
<p>由上述结论可知：存在部分$x_i&gt;=0$，部分&lt;0。</p>
<p>一定存在至少一个分界点$a_m$满足左边&gt;=0，右边&lt;0。也就是说这个人一定往两边传递糖果。</p>
<p>那我们可以从分界点处把环变成一条直线。</p>
<p><img src="/posts/6eec8d79/image-20210603084728611.png" alt="image-20210603084728611"></p>
<p><img src="/posts/6eec8d79/image-20210603085513979.png" alt="image-20210603085513979"></p>
<p>对于每一个$x_k$，分成两种情况，当$x_k&gt;=0$时，糖果立即传递给右边；当$x_k&lt;0$时，先不给。</p>
<p>我们先考虑糖果从左往右传递的情况，可以得到上上图的两个式子。</p>
<p>第一个式子：当$x_{k-1}&gt;=0$时，$a_1$到$a_{k-1}$的糖果数小于（我觉得是等于）平均值。</p>
<p>然后再根据第二个式子，就能得到$a_k &gt;= x_k$，得证。</p>
<p>从右往左传递糖果时，dfs回溯。</p>
<p><img src="/posts/6eec8d79/image-20210603093751143.png" alt="image-20210603093751143"></p>
<hr>
<p>以上证明实在看不懂可以略过。（不影响AC）</p>
<p>参考题解：<a href="https://www.acwing.com/solution/content/5531/">https://www.acwing.com/solution/content/5531/</a></p>
<p><img src="/posts/6eec8d79/image-20210603094531778.png" alt="image-20210603094531778"></p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line">LL c[N];<span class="comment">// 避免爆int都用LL存</span></span><br><span class="line">LL s[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;s[i]);</span><br><span class="line">        s[i] += s[i<span class="number">-1</span>]; <span class="comment">// 求前缀和</span></span><br><span class="line">    &#125;</span><br><span class="line">    LL  ave = s[n]/n;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;<span class="comment">// 注意边界，计算c[0]到c[n-2]</span></span><br><span class="line">        c[k++] = i*ave - s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    c[k++] = <span class="number">0</span>;<span class="comment">// 再计算c[n-1]</span></span><br><span class="line"></span><br><span class="line">    sort(c,c+k);<span class="comment">// 题解1，排序，O(n*logn)，比题解2慢2倍左右</span></span><br><span class="line">    LL m = c[k/<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//nth_element(c,c+k/2,c+k); 题解2，O(n)，比较快</span></span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) res += <span class="built_in">abs</span>(c[i] - m);<span class="comment">// 注意边界</span></span><br><span class="line">    <span class="comment">//for (int i = 0;i &lt; n;i++) res += abs(c[i] - c[k/2]);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充：</p>
<p>快速选择函数nth_element(数组初位置，寻找元素，数组末位置)（STL）</p>
<p>也可以自己实现，利用<strong>快排</strong>。</p>
<p>C++的STL库中的nth_element()方法，默认是求区间<strong>第k小</strong>的（划重点）。</p>
<p>举个栗子求第3小，对于 a[9]={4,7,6,9,1,8,2,3,5};</p>
<p>nth_element(a,a+2,a+9)，**将下标为2，也就是第3个数放在正确的位置，求的是第3小的数a[2]**。（下标从零开始）</p>
<p>寒假每日一题入门题（一）中介绍过两种题解。</p>
<p>1.sort，时间复杂度：O(n*logn)    2.nth_element，时间复杂度：O(n)</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>中位数</tag>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>前缀和</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（二五）</title>
    <url>/posts/fb41f209.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="七-树状数组、线段树与差分"><a href="#七-树状数组、线段树与差分" class="headerlink" title="七 树状数组、线段树与差分"></a>七 树状数组、线段树与差分</h2><p>之前我们先学习了双指针、宽搜，跳过了本章内容，现在补上。</p>
<p>树状数组与线段树是两种比较特殊的数据结构。</p>
<p>本章内容难度比较高，但在蓝桥杯中考察最基本应用，涉及也较少。</p>
<span id="more"></span>

<p>邱秋老师的《Programming Challenges》对大部分数据结构都有详细的介绍。</p>
<p>胡凡的《算法笔记》也介绍了树状数组。</p>
<p>推荐文章：<a href="https://blog.csdn.net/bestsort/article/details/80796531%E3%80%82">https://blog.csdn.net/bestsort/article/details/80796531。</a></p>
<p><img src="/posts/fb41f209/image-20210606191703653.png" alt="image-20210606191703653"></p>
<h3 id="1-树状数组"><a href="#1-树状数组" class="headerlink" title="1.树状数组"></a>1.树状数组</h3><p>树状数组，又称二叉索引树（binary index tree），简称BIT，是一个多叉树。</p>
<p>树状数组是一个查询和修改复杂度都为log(n)的数据结构。它支持修改，是一个在线做法。</p>
<p><strong>主要用于给某个位置上的数加上一个数和快速求前缀和。</strong>（单点修改和区间查询）</p>
<p>前缀和只能查询，复杂度为O(1)，但是不支持修改。</p>
<p>树状数组的定义：树状数组是<strong>一维</strong>的！！！</p>
<p><img src="/posts/fb41f209/image-20210606194200602.png" alt="image-20210606194200602"></p>
<p>其中横坐标为数组A元素的序号x（从1开始计数），纵坐标为lowbit(x)。</p>
<p><code>inline int lowbit(int x) &#123; return x &amp; (-x); &#125;</code></p>
<p>lowbit(x)就是取x的二进制最右边的1和它右边所有0。<strong>右边有k个0表示在第k层。</strong></p>
<p>例如，十进制数40的二进制表示为101000，lowbit($40_{10}$)＝$1000_{2}$=8。</p>
<p>所以：核心点，<code>T[x] = sum(x-2^k,x] = sum(x-lowbit(x),x]</code>。（左开右闭）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回前x个数之和:a[1]+a[2]+...+a[x]</span></span><br><span class="line"><span class="comment">// 时间复杂度：O(logn)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x;i &gt; <span class="number">0</span>;i -= lowbit(i)) res += t[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将a[x] + v</span></span><br><span class="line"><span class="comment">// 时间复杂度：O(logn)</span></span><br><span class="line"><span class="comment">// 记住！！！</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x;i &lt;= n;i += lowbit(i)) t[i] += v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上两个函数就是BIT最核心的内容，可以解决一系列问题。</p>
<h4 id="1-1-acwing-1264-动态求连续区间和"><a href="#1-1-acwing-1264-动态求连续区间和" class="headerlink" title="1.1 acwing.1264. 动态求连续区间和"></a>1.1 acwing.1264. 动态求连续区间和</h4><p>《信息学奥赛一本通》,模板题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定 n 个数组成的一个数列，规定有两种操作，一是修改某个元素，二是求子数列 [a,b] 的连续和。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含两个整数 n 和 m，分别表示数的个数和操作次数。</span><br><span class="line">第二行包含 n 个整数，表示完整数列。</span><br><span class="line">接下来 m 行，每行包含三个整数 k,a,b （k=<span class="number">0</span>，表示求子数列[a,b]的和；k=<span class="number">1</span>，表示第 a 个数加 b）。</span><br><span class="line">数列从 <span class="number">1</span> 开始计数。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出若干行数字，表示 k=<span class="number">0</span> 时，对应的子数列 [a,b] 的连续和。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤n≤<span class="number">100000</span>,</span><br><span class="line"><span class="number">1</span>≤m≤<span class="number">100000</span>，</span><br><span class="line"><span class="number">1</span>≤a≤b≤n</span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">10</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">4</span> <span class="number">8</span></span><br><span class="line"><span class="number">1</span> <span class="number">7</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">4</span> <span class="number">8</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">35</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>模板题，直接套用上面讲的理论。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N],tr[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">// 三个核心函数都得背过</span></span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>&#123;<span class="comment">// add()，加数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x;i &lt;= n;i += lowbit(i)) tr[i] += v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">// query()，查询</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x;i;i -= lowbit(i)) res += tr[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) update(i,a[i]);<span class="comment">// 初始化树状数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> k,x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;k,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,getSum(y) - getSum(x<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">else</span> update(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-acwing-1265-数星星"><a href="#1-2-acwing-1265-数星星" class="headerlink" title="1.2 acwing.1265. 数星星"></a>1.2 acwing.1265. 数星星</h4><p>《信息学奥赛一本通》 , Ural 1028</p>
<p>天空中有一些星星，这些星星都在不同的位置，每个星星有个坐标。</p>
<p>如果一个星星的左下方（包含正左和正下）有 k 颗星星，就说这颗星星是 k 级的。</p>
<p><img src="/posts/fb41f209/image-20210607085405626.png" alt="image-20210607085405626"></p>
<p>例如，上图中星星 5 是 3 级的（1,2,4 在它左下），星星 2,4 是 1级的。</p>
<p>例图中有 1个 0 级，2个 1 级，1 个 2 级，1 个 3 级的星星。</p>
<p>给定星星的位置，输出各级星星的数目。</p>
<p>换句话说，给定 N 个点，定义每个点的等级是在该点左下方（含正左、正下）的点的数目，试统计每个等级有多少个点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入格式</span><br><span class="line">第一行一个整数 N，表示星星的数目；</span><br><span class="line">接下来 N 行给出每颗星星的坐标，坐标用两个整数 x,y 表示；</span><br><span class="line">不会有星星重叠。星星按 y 坐标增序给出，y 坐标相同的按 x 坐标增序给出。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">N 行，每行一个整数，分别是 <span class="number">0</span> 级，<span class="number">1</span> 级，<span class="number">2</span> 级，……，N−<span class="number">1</span> 级的星星的数目。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤N≤<span class="number">15000</span>,</span><br><span class="line"><span class="number">0</span>≤x,y≤<span class="number">32000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">7</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>题目要求求某一个点(x,y)左下方星星的个数(不包括自己)，且星星按y坐标增序给出，y 坐标相同的按x坐标增序给出,因此对于每个新来的点(x,y),y是当前纵坐标的最大值，只需要求[1,x]中星星出现的数量即可，利用前缀和。</p>
<p><img src="/posts/fb41f209/image-20210607090931297.png" alt="image-20210607090931297"></p>
<p>注意：本题给出的星星坐标是按照纵坐标增序的，所以后面给出的星星横坐标可能比前面给出的要小，所以必</p>
<p>须更新前缀和数组，就必须用到树状数组了，实现在线查询。</p>
<p>不包括自己，而计算前缀和会加进去，注意审题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">32010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> tr[N],level[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>&#123;<span class="comment">// 注意：不要写成i &lt;= n，因为x可能&gt;n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x;i &lt;= N;i += lowbit(i)) tr[i] += v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x;i;i -= lowbit(i)) res += tr[i];</span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        x++;<span class="comment">// 细节，前缀和数组从1开始，题目x&gt;=0</span></span><br><span class="line">        <span class="comment">// 注意：求左下方星星数目时，自己也会包含进去，但题目要求不包含</span></span><br><span class="line">		<span class="comment">// 所以先查询前缀和，再插入点</span></span><br><span class="line">        level[query(x)] ++;<span class="comment">// 统计左下方星星数为x的星星+1</span></span><br><span class="line">        add(x,<span class="number">1</span>);<span class="comment">// 将横坐标为x的星星+1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,level[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（二八）</title>
    <url>/posts/bb24e60c.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="3-2-acwing-1228-油漆面积（困难）"><a href="#3-2-acwing-1228-油漆面积（困难）" class="headerlink" title="3.2 acwing.1228. 油漆面积（困难）"></a>3.2 acwing.1228. 油漆面积（困难）</h4><p>第八届蓝桥杯省赛C++A组,第八届蓝桥杯省赛JAVAA组</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">X星球的一批考古机器人正在一片废墟上考古。</span><br><span class="line">该区域的地面坚硬如石、平整如镜。</span><br><span class="line">管理人员为方便，建立了标准的直角坐标系。</span><br><span class="line">每个机器人都各有特长、身怀绝技。</span><br><span class="line">它们感兴趣的内容也不相同。</span><br><span class="line">经过各种测量，每个机器人都会报告一个或多个矩形区域，作为优先考古的区域。</span><br><span class="line">矩形的表示格式为 (x1,y1,x2,y2)，代表矩形的两个对角点坐标。</span><br><span class="line">为了醒目，总部要求对所有机器人选中的矩形区域涂黄色油漆。</span><br><span class="line">小明并不需要当油漆工，只是他需要计算一下，一共要耗费多少油漆。</span><br><span class="line">其实这也不难，只要算出所有矩形覆盖的区域一共有多大面积就可以了。</span><br><span class="line">注意，各个矩形间可能重叠。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行，一个整数 n，表示有多少个矩形。</span><br><span class="line">接下来的 n 行，每行有 <span class="number">4</span> 个整数 x1,y1,x2,y2，空格分开，表示矩形的两个对角顶点坐标。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">一行一个整数，表示矩形覆盖的总面积。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤n≤<span class="number">10000</span>,</span><br><span class="line"><span class="number">0</span>≤x1,x2,y2,y2≤<span class="number">10000</span></span><br><span class="line">数据保证 x1&lt;x2 且 y1&lt;y2。</span><br><span class="line"></span><br><span class="line">输入样例<span class="number">1</span>：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">10</span> <span class="number">10</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">20</span> <span class="number">20</span></span><br><span class="line"><span class="number">2</span> <span class="number">7</span> <span class="number">15</span> <span class="number">17</span></span><br><span class="line">输出样例<span class="number">1</span>：</span><br><span class="line"><span class="number">340</span></span><br><span class="line">输入样例<span class="number">2</span>：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">10</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">7</span> <span class="number">12</span> <span class="number">10</span></span><br><span class="line"><span class="number">8</span> <span class="number">1</span> <span class="number">15</span> <span class="number">15</span></span><br><span class="line">输出样例<span class="number">2</span>：</span><br><span class="line"><span class="number">128</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>蓝桥杯压轴题，考察线段树、扫描线。</p>
<p>参考资料：<a href="https://oi-wiki.org/geometry/scanning/%E3%80%82">https://oi-wiki.org/geometry/scanning/。</a></p>
<p>线段树的一个特例，很少见的应用。</p>
<p>题解1：暴力法。acwing过5个数据，一半，TLE，蓝桥杯OJ可以过。用boolean处理比int稍好一些。</p>
<p>参考代码：<a href="https://blog.csdn.net/qq_43515011/article/details/87926698%E3%80%82">https://blog.csdn.net/qq_43515011/article/details/87926698。</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	Scanner sn = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">boolean</span> [][]coordinate = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">10000</span>][<span class="number">10000</span>];</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">int</span> n = sn.nextInt();</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">int</span> x1 = sn.nextInt();</span><br><span class="line">    		<span class="keyword">int</span> y1 = sn.nextInt();</span><br><span class="line">    		<span class="keyword">int</span> x2 = sn.nextInt();</span><br><span class="line">    		<span class="keyword">int</span> y2 = sn.nextInt();</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> j = x1;j &lt; x2;j++)</span><br><span class="line">    			<span class="keyword">for</span>(<span class="keyword">int</span> k = y1;k &lt; y2;k++)</span><br><span class="line">    			&#123;</span><br><span class="line">    				<span class="keyword">if</span>(coordinate[j][k] == <span class="keyword">false</span>)</span><br><span class="line">    					coordinate[j][k] = <span class="keyword">true</span>;</span><br><span class="line">    			&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10000</span>;i++)</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">10000</span>; j++)</span><br><span class="line">    		&#123;</span><br><span class="line">    			<span class="keyword">if</span>(coordinate[i][j] == <span class="keyword">true</span>)</span><br><span class="line">    				count++;</span><br><span class="line">    		&#125;</span><br><span class="line">    	</span><br><span class="line">    	System.out.print(count);</span><br><span class="line">    	sn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题解2：扫描线+线段树。这题太<strong>劝退</strong>了。</p>
<p>扫描线一般运用在图形上面，它和它的字面意思十分相似，就是一条线在整个图上扫来扫去，它一般被用来解</p>
<p>决图形面积，周长等问题。本题就是一个求矩形面积并问题。扫描线属于计算几何的知识。</p>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1yo4y197Zd%E3%80%82">https://www.bilibili.com/video/BV1yo4y197Zd。</a></p>
<p>参考资料：<a href="https://blog.csdn.net/tomorrowtodie/article/details/52048323%E3%80%82">https://blog.csdn.net/tomorrowtodie/article/details/52048323。</a></p>
<p>扫描线图示：有一条扫描线从左往右扫描。</p>
<p><img src="/posts/bb24e60c/image-20210609222748276.png" alt="image-20210609222748276"></p>
<p>扫描线问题的两种类型：</p>
<ol>
<li>数据量大：需要通过<strong>线段树</strong>由O(n^2)优化到O(n*logn)</li>
<li>矩形是斜着摆的，包含三角形、圆形等：计算几何，公式复杂，需要自己推</li>
</ol>
<p>构建一个”非常特殊“的线段树，维护的是矩形纵坐标区间的有效长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;<span class="comment">// 左右边界</span></span><br><span class="line">    <span class="keyword">int</span> cnt;<span class="comment">// 当前区间被覆盖的次数</span></span><br><span class="line">    <span class="keyword">int</span> len;<span class="comment">// 至少被覆盖1次的区间长度</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// cnt和len都是不考虑父结点的情况下的结果，只考虑子结点</span></span><br></pre></td></tr></table></figure>

<p>我们用扫描线去扫描每一条边的时候，都需要更新线段树的有效长度。</p>
<p>是如何更新的呢？</p>
<p>如果扫到的这条边是某矩形的入边，这段高度的矩形开始覆盖，覆盖次数cnt+1，则往区间插入这条线段。</p>
<p>如果扫到的这条边是某矩形的出边，这段高度的矩形结束覆盖，覆盖次数cnt-1，则往区间删除这条线段。</p>
<p>细节问题：要将区间转化为点。</p>
<p>C++版本：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment</span>// 线段结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y1, y2;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Segment &amp;t)<span class="keyword">const</span><span class="comment">// 重载小于号，按横坐标排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; t.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;seg[N * <span class="number">2</span>];<span class="comment">// 每个矩形两段边，最多N*2</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> cnt, len;<span class="comment">// cnt：当前区间被覆盖的次数，len：至少被覆盖1次的区间长度</span></span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// cnt是成对+1，-1的，所以cnt&gt;=0</span></span><br><span class="line">    <span class="comment">// cnt非0说明区间被整段覆盖，线段树区间[0,0]对应的实际线段是[0,1]，所以len=0-0+1</span></span><br><span class="line">    <span class="keyword">if</span> (tr[u].cnt &gt; <span class="number">0</span>) tr[u].len = tr[u].r - tr[u].l + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 未被整段覆盖但已经是最小单位，不能再划分，有效长度为0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tr[u].l == tr[u].r) tr[u].len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 未被整段覆盖，有缝隙，合并左右孩子长度</span></span><br><span class="line">    <span class="keyword">else</span> tr[u].len = tr[u &lt;&lt; <span class="number">1</span>].len + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u] = &#123;l, r&#125;;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 将0到10000的整个区间二分至叶子节点（单位长度为1，坐标都是整数）</span></span><br><span class="line">    <span class="comment">// 读入的线段[0,1]对应线段树[0,0]</span></span><br><span class="line">    build(u &lt;&lt; <span class="number">1</span>, l, mid), build(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">// 和一般线段树不一样，不用pushup</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span><span class="comment">// 区间修改，但特殊在于懒标记cnt不往下传递</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)<span class="comment">// 线段树区间被读入的Segment完全覆盖</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].cnt += k;<span class="comment">// 入边+1，出边-1</span></span><br><span class="line">        pushup(u);<span class="comment">// 更新区间被覆盖的有效长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) modify(u &lt;&lt; <span class="number">1</span>, l, r, k);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) modify(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">        seg[m ++ ] = &#123;x1, y1, y2, <span class="number">1</span>&#125;;</span><br><span class="line">        seg[m ++ ] = &#123;x2, y1, y2, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(seg, seg + m);</span><br><span class="line"></span><br><span class="line">    build(<span class="number">1</span>, <span class="number">0</span>, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注意用的是根结点的len，本题的特殊之处</span></span><br><span class="line">        <span class="comment">// 第一条线段不用算面积</span></span><br><span class="line">        <span class="comment">// 顺序不可换</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) res += tr[<span class="number">1</span>].len * (seg[i].x - seg[i - <span class="number">1</span>].x);<span class="comment">// 面积=宽度*有效长度</span></span><br><span class="line">        modify(<span class="number">1</span>, seg[i].y1, seg[i].y2 - <span class="number">1</span>, seg[i].k);<span class="comment">// [y1,y2]对应线段树的[y1,y2-1]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">    <span class="keyword">static</span> PrintWriter pw = <span class="keyword">new</span> PrintWriter(System.out);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">10010</span>,n;</span><br><span class="line">    <span class="keyword">static</span> Node[] node = <span class="keyword">new</span> Node[N*<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">static</span> Segment[] seg = <span class="keyword">new</span> Segment[N*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        n = Integer.parseInt(br.readLine());</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            String[] s = br.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> x1 = Integer.parseInt(s[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> y1 = Integer.parseInt(s[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">int</span> x2 = Integer.parseInt(s[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">int</span> y2 = Integer.parseInt(s[<span class="number">3</span>]);</span><br><span class="line">            seg[m++] = <span class="keyword">new</span> Segment(x1,y1,y2,<span class="number">1</span>);</span><br><span class="line">            seg[m++] = <span class="keyword">new</span> Segment(x2,y1,y2,-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(seg,<span class="number">0</span>,m);</span><br><span class="line">        build(<span class="number">1</span>,<span class="number">0</span>,<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) res += node[<span class="number">1</span>].len * (seg[i].x - seg[i - <span class="number">1</span>].x);</span><br><span class="line">            modify(<span class="number">1</span>,seg[i].y1,seg[i].y2-<span class="number">1</span>,seg[i].k);</span><br><span class="line">        &#125;</span><br><span class="line">        pw.print(res);</span><br><span class="line">        pw.flush();</span><br><span class="line">        br.close();</span><br><span class="line">        pw.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        node[u] = <span class="keyword">new</span> Node(l,r);</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        build(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">        build(u&lt;&lt;<span class="number">1</span> | <span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node[u].l &gt;= l &amp;&amp; node[u].r &lt;= r)&#123;</span><br><span class="line">            node[u].cnt += k;</span><br><span class="line">            pushup(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = node[u].l + node[u].r &gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (l &lt;= mid) modify(u&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">            <span class="keyword">if</span> (r &gt; mid) modify(u&lt;&lt;<span class="number">1</span> | <span class="number">1</span>,l,r,k);</span><br><span class="line">            pushup(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node[u].cnt &gt; <span class="number">0</span>) node[u].len = node[u].r - node[u].l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node[u].l == node[u].r) node[u].len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> node[u].len = node[u&lt;&lt;<span class="number">1</span>].len + node[u&lt;&lt;<span class="number">1</span> | <span class="number">1</span>].len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> cnt,len;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.l = l;</span><br><span class="line">        <span class="keyword">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Segment</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Segment</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y1,y2;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Segment</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y1,<span class="keyword">int</span> y2,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y1 = y1;</span><br><span class="line">        <span class="keyword">this</span>.y2 = y2;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Segment seg)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果指定的数与参数相等返回0，小于返回-1，大于返回1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x - seg.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>线段树</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（二六）</title>
    <url>/posts/9e4fb9d0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="2-线段树"><a href="#2-线段树" class="headerlink" title="2.线段树"></a>2.线段树</h3><p>线段树（segment tree）是一种以<strong>二叉树</strong>为基础的数据结构，可以用于进行高效的范围最大（小）值查询、范围和查询等。</p>
<p>原理比树状数组要简单，但是代码更复杂。</p>
<span id="more"></span>

<p>推荐文章1：<a href="https://www.acwing.com/blog/content/372/%E3%80%82">https://www.acwing.com/blog/content/372/。</a></p>
<p>推荐文章2：<a href="https://www.acwing.com/blog/content/392/%E3%80%82">https://www.acwing.com/blog/content/392/。</a></p>
<p>推荐文章3：<a href="https://blog.csdn.net/weixin_43914593/article/details/108221534%E3%80%82">https://blog.csdn.net/weixin_43914593/article/details/108221534。</a></p>
<p>线段树,树上面的<strong>所有节点都是线段,都是一个区间</strong>.</p>
<p>在构建线段树之前，我们先阐述<strong>线段树的性质</strong>：</p>
<p>1、线段树的每个节点都代表一个区间。</p>
<p>2、线段树具有唯一的根节点，代表的区间是整个统计范围，如[1,N]。</p>
<p>3、线段树的每个叶节点都代表一个长度为1的元区间[x,x]。</p>
<p>4、对于每个内部节点[l,r]，它的左子结点是[l,mid]，右子节点是[mid+1,r]，其中mid=(l+r)/2（向下取整）。</p>
<p>以结点node的性质为sum为例，构建线段树：</p>
<p><img src="/posts/9e4fb9d0/image-20210607133844216.png" alt="image-20210607133844216"></p>
<p>在声明空间时，一般以查询区间长度的<strong>4倍</strong>来申请存储空间较为“安全”。（结点总数&lt;=4*叶子结点数）</p>
<p>操作1：单点修改，更新指定值的叶子结点，同时更新它的所有祖先结点。O(logn).</p>
<p>操作2：区间查询，对于给定区间，不断二分递归，直到子区间将给定区间完全包含，再合并。O(logn).</p>
<p>对于<strong>区间修改</strong>操作，需要用到<strong>懒惰标记</strong>（lazy tag），会使得线段树的难度陡增，这里就不讨论。</p>
<p>四个核心函数：</p>
<p><img src="/posts/9e4fb9d0/image-20210607145648848.png" alt="image-20210607145648848"></p>
<p><img src="/posts/9e4fb9d0/image-20210607150248115.png" alt="image-20210607150248115"></p>
<p>图解修改操作：</p>
<p><img src="/posts/9e4fb9d0/image-20210607160405433.png" alt="image-20210607160405433"></p>
<p>图解查询操作：</p>
<p><img src="/posts/9e4fb9d0/image-20210607160429723.png" alt="image-20210607160429723"></p>
<h4 id="2-1-acwing-1264-动态求连续区间和"><a href="#2-1-acwing-1264-动态求连续区间和" class="headerlink" title="2.1 acwing.1264. 动态求连续区间和"></a>2.1 acwing.1264. 动态求连续区间和</h4><p>上一讲树状数组的模板题。</p>
<p>线段树写法。比树状数组稍慢一点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span><span class="comment">// 线段树结点</span></span><br><span class="line">    <span class="keyword">int</span> l,r;<span class="comment">// 左孩子和右孩子</span></span><br><span class="line">    <span class="keyword">int</span> sum;<span class="comment">// 结点性质为求和</span></span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;<span class="comment">// 用子结点更新当前结点的sum，上传操作，把信息往上传递</span></span><br><span class="line">    tr[u].sum = tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) tr[u] = &#123;l,r,w[r]&#125;;<span class="comment">// 叶子结点</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        tr[u] = &#123;l,r&#125;;<span class="comment">// 初始化左右端点</span></span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;<span class="comment">// 递归左孩子和右孩子</span></span><br><span class="line">        build(u &lt;&lt; <span class="number">1</span>,l,mid),build(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        pushup(u);<span class="comment">// 更新当前结点的sum</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 给定查询区间完全包含线段树结点的区间，可以直接计算</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 否则二分处理</span></span><br><span class="line">    <span class="keyword">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) sum += query(u &lt;&lt; <span class="number">1</span>,l,r);<span class="comment">// 说明与左孩子有交集</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) sum += query(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,l,r);<span class="comment">// 即r&gt;=mid+1，说明与右孩子有交集</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l == tr[u].r) tr[u].sum += v;<span class="comment">// 叶子结点，目标位置</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) modify(u &lt;&lt; <span class="number">1</span>,x,v);</span><br><span class="line">        <span class="keyword">else</span> modify(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,x,v);</span><br><span class="line">        pushup(u);<span class="comment">// 回溯时更新当前结点的sum</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">    build(<span class="number">1</span>,<span class="number">1</span>,n);<span class="comment">// 初始化线段树，下标从1开始</span></span><br><span class="line">    <span class="keyword">while</span> (m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> k,a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;k,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,query(<span class="number">1</span>,a,b));</span><br><span class="line">        <span class="keyword">else</span> modify(<span class="number">1</span>,a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-acwing-1270-数列区间最大值"><a href="#2-2-acwing-1270-数列区间最大值" class="headerlink" title="2.2 acwing.1270. 数列区间最大值"></a>2.2 acwing.1270. 数列区间最大值</h4><p>《信息学奥赛一本通》</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入一串数字，给你 M 个询问，每次询问就给你两个数字 X,Y，要求你说出 X 到 Y 这段区间内的最大数。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行两个整数 N,M 表示数字的个数和要询问的次数；</span><br><span class="line">接下来一行为 N 个数；</span><br><span class="line">接下来 M 行，每行都有两个整数 X,Y。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出共 M 行，每行输出一个数。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤N≤<span class="number">10</span>^<span class="number">5</span>,</span><br><span class="line"><span class="number">1</span>≤M≤<span class="number">10</span>^<span class="number">6</span>,</span><br><span class="line"><span class="number">1</span>≤X≤Y≤N,</span><br><span class="line">数列中的数字均不超过<span class="number">2</span>^<span class="number">31</span>−<span class="number">1</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">10</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">1</span> <span class="number">2</span> <span class="number">9</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">8</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>维护区间的最大值。这种问题可以归结为RMQ，即询问区间最值。</p>
<p>只要将上一题结点性质由求和改为最大值就行。</p>
<p>代码：</p>
<p>题解1：线段树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> l,r;</span><br><span class="line">  <span class="keyword">int</span> maxv;<span class="comment">// 结点性质为最大值</span></span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) tr[u] = &#123;l,r,w[r]&#125;;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        tr[u] = &#123;l,r&#125;;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(u &lt;&lt; <span class="number">1</span>,l,mid),build(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        tr[u].maxv = max(tr[u &lt;&lt; <span class="number">1</span>].maxv,tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].maxv);<span class="comment">// 更新结点最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r) <span class="keyword">return</span> tr[u].maxv;</span><br><span class="line">    <span class="keyword">int</span> res = INT_MIN;<span class="comment">// 定义在&lt;climits&gt;头文件</span></span><br><span class="line">    <span class="keyword">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) res = query(u &lt;&lt; <span class="number">1</span>,l,r);<span class="comment">// 可以不用和res取max</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) res = max(res,query(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,l,r));<span class="comment">// 下面必须取max</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">    build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span> (m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,query(<span class="number">1</span>,a,b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题解2：<strong>树状数组</strong>求区间最值，本题的树状数组解法和hdu1754比较像。</p>
<p>参考1（思路）：<a href="https://www.cnblogs.com/liyexin/p/12877821.html">https://www.cnblogs.com/liyexin/p/12877821.html</a></p>
<p>参考2（代码）：<a href="https://www.acwing.com/solution/content/25010/">https://www.acwing.com/solution/content/25010/</a></p>
<p>直接照搬求区间合的方法显然是不行的。</p>
<p>因为区间合中，要查询[x,y]的区间合，是求出[1,x-1]的合与[1,y]的和，然后相减就得出了[x,y]区间的和。</p>
<p>而区间最值是没有这个性质的，所以只能够换一个思路。</p>
<p>我们从右往左查询，对于r来讲，它所管辖的有lowbit(r)个区间。所以对于[l,r]如果r-l&gt;=lowbit(r)，那么tr[r]可</p>
<p>以直接拿来用，因为tr[x]表示的是tree[x-lowbit(x)+1,x]的最大值，在范围内。而如果lowbit(r)超出了[l,r]，那</p>
<p>么就r–对L进行逼近，直到满足r-l&gt;=lowbit(r)进入上面的操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> tr[N];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>&#123;<span class="comment">// 更新tr数组最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x;i &lt;= N;i += lowbit(i)) tr[i] = max(tr[i],v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;<span class="comment">// 查询区间[l,r]的最大值</span></span><br><span class="line">    <span class="keyword">int</span> res = INT_MIN;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">        res = max(res,a[r--]);<span class="comment">// 指针r从右往左查询，直到r-l&gt;lowbit(r)进入循环</span></span><br><span class="line">        <span class="keyword">for</span> (;r-l &gt; lowbit(r);r -= lowbit(r)) res = max(res,tr[r]);<span class="comment">// 换成r-l &gt;= lowbit(r)也行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        modify(i,a[i]);<span class="comment">// 边读入边处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span> (m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,query(a,b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>树状数组</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（二四）</title>
    <url>/posts/94df374e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="7-acwing-1247-后缀表达式"><a href="#7-acwing-1247-后缀表达式" class="headerlink" title="7 acwing.1247. 后缀表达式"></a>7 acwing.1247. 后缀表达式</h4><p>第十届蓝桥杯省赛C++B组,第十届蓝桥杯省赛JAVAB组</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定 N 个加号、M 个减号以及 N+M+<span class="number">1</span> 个整数 A1,A2,⋅⋅⋅,AN+M+<span class="number">1</span>，小明想知道在所有由这 N 个加号、M 个减号以及 N+M+<span class="number">1</span> 个整数凑出的合法的后缀表达式中，结果最大的是哪一个？</span><br><span class="line">请你输出这个最大的结果。</span><br><span class="line">例如使用 <span class="number">123</span>+−，则 “<span class="number">23</span>+<span class="number">1</span>−” 这个后缀表达式结果是 <span class="number">4</span>，是最大的。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含两个整数 N 和 M。</span><br><span class="line"></span><br><span class="line">第二行包含 N+M+<span class="number">1</span> 个整数 A1,A2,⋅⋅⋅,AN+M+<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，代表答案。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">0</span>≤N,M≤<span class="number">10</span>^<span class="number">5</span>,</span><br><span class="line">−<span class="number">10</span>^<span class="number">9</span>≤Ai≤<span class="number">10</span>^<span class="number">9</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>后缀表达式又称为逆波兰式。可以用栈来模拟（严奶奶的数据结构），而栈又和树的结构很像，也可以看成树。</p>
<p><img src="/posts/94df374e/image-20210604204148978.png" alt="image-20210604204148978"></p>
<p>树的前、中和后序遍历分别对应前、中和后缀表达式。</p>
<p>我们要将逆波兰式转化成熟悉的中缀表达式。</p>
<p>题目的一个坑：给定M(M&gt;0)个逆波兰式的减号，转化成中缀表达式后减号不一定是M个了。</p>
<p>举个例子：</p>
<p><img src="/posts/94df374e/image-20210604223536465.png" alt="image-20210604223536465"></p>
<p>上图中的M=5个减号，转化成中缀表达式之后只剩下一个减号了。</p>
<p>同理，给定N个逆波兰式的加号，通过把加号放在括号里面，就能变成减号，所以<strong>实际上能构造出1~M+N个</strong></p>
<p><strong>减号</strong>。这一步就是分析的关键所在。</p>
<p>对于转化后的中缀表达式，我们至少要加一个数，因为第一个数之前没有符号；至少要减一个数，因为M&gt;0</p>
<p>时，最少需要一个减号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;<span class="comment">// 有N+M+1个数，开2倍10^5</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">int</span> k = n + m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>)&#123;<span class="comment">// 特判m = 0的情况，没有减号，全部相加</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) res += a[i];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        sort(a,a+k);<span class="comment">// 也可以不排序，只要找出最大、小值即可</span></span><br><span class="line">        res = a[k<span class="number">-1</span>] - a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; k<span class="number">-1</span>;i++) res += <span class="built_in">abs</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>补充一个小知识点：</p>
<p>防止爆int的非常保险的一个做法，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long <span class="comment">// nb!</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x);<span class="comment">// scanf记得lld</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// int == signed int == signed</span></span><br><span class="line"><span class="comment">// unsigned int == unsigned</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="8-acwing-1248-灵能传输"><a href="#8-acwing-1248-灵能传输" class="headerlink" title="8 acwing.1248. 灵能传输"></a>8 acwing.1248. 灵能传输</h4><p>第十届蓝桥杯省赛C++B/研究生组,第十届蓝桥杯省赛JAVAB组</p>
<p>最后一题，比较麻烦，有难度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">在游戏《星际争霸 II》中，高阶圣堂武士作为星灵的重要 AOE 单位，在游戏的中后期发挥着重要的作用，其技能”灵能风暴“可以消耗大量的灵能对一片区域内的敌军造成毁灭性的伤害。</span><br><span class="line">经常用于对抗人类的生化部队和虫族的刺蛇飞龙等低血量单位。</span><br><span class="line">你控制着 n 名高阶圣堂武士，方便起见标为 <span class="number">1</span>,<span class="number">2</span>,⋅⋅⋅,n。</span><br><span class="line">每名高阶圣堂武士需要一定的灵能来战斗，每个人有一个灵能值 ai 表示其拥有的灵能的多少（ai 非负表示这名高阶圣堂武士比在最佳状态下多余了 ai 点灵能，ai 为负则表示这名高阶圣堂武士还需要 −ai 点灵能才能到达最佳战斗状态）。</span><br><span class="line"></span><br><span class="line">现在系统赋予了你的高阶圣堂武士一个能力，传递灵能，每次你可以选择一个 i∈[<span class="number">2</span>,n−<span class="number">1</span>]，若 ai≥<span class="number">0</span> 则其两旁的高阶圣堂武士，也就是 i−<span class="number">1</span>、i+<span class="number">1</span> 这两名高阶圣堂武士会从 i 这名高阶圣堂武士这里各抽取 ai 点灵能；若 ai&lt;<span class="number">0</span> 则其两旁的高阶圣堂武士，也就是 i−<span class="number">1</span>,i+<span class="number">1</span> 这两名高阶圣堂武士会给 i 这名高阶圣堂武士 −ai 点灵能。</span><br><span class="line"></span><br><span class="line">形式化来讲就是 ai−<span class="number">1</span>+=ai,ai+<span class="number">1</span>+=ai,ai−=<span class="number">2</span>ai。</span><br><span class="line"></span><br><span class="line">灵能是非常高效的作战工具，同时也非常危险且不稳定，一位高阶圣堂武士拥有的灵能过多或者过少都不好，定义一组高阶圣堂武士的不稳定度为 max(i from <span class="number">1</span> to n)|ai|，请你通过不限次数的传递灵能操作使得你控制的这一组高阶圣堂武士的不稳定度最小。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">本题包含多组询问。输入的第一行包含一个正整数 T 表示询问组数。</span><br><span class="line">接下来依次输入每一组询问。</span><br><span class="line">每组询问的第一行包含一个正整数 n，表示高阶圣堂武士的数量。</span><br><span class="line">接下来一行包含 n 个数 a1,a2,⋅⋅⋅,an。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出 T 行。</span><br><span class="line">每行一个整数依次表示每组询问的答案。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤T≤<span class="number">3</span>,<span class="number">3</span>≤n≤<span class="number">300000</span>,|ai|≤<span class="number">10</span>^<span class="number">9</span>,</span><br><span class="line">每个评测用例的限制如下：</span><br></pre></td></tr></table></figure>

<p><img src="/posts/94df374e/image-20210604231058940.png" alt="image-20210604231058940"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入样例<span class="number">1</span>：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">-2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">输出样例<span class="number">1</span>：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">输入样例<span class="number">2</span>：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">-1</span> <span class="number">-2</span> <span class="number">-3</span> <span class="number">7</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">-8</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span> <span class="number">6</span> <span class="number">-1</span> <span class="number">-1</span></span><br><span class="line">输出样例<span class="number">2</span>：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">样例解释</span><br><span class="line">样例一</span><br><span class="line">对于第一组询问：</span><br><span class="line">对 <span class="number">2</span> 号高阶圣堂武士进行传输操作后 a1=<span class="number">3</span>，a2=<span class="number">2</span>，a3=<span class="number">1</span>。答案为 <span class="number">3</span>。</span><br><span class="line">对于第二组询问：</span><br><span class="line">这一组高阶圣堂武士拥有的灵能都正好可以让他们达到最佳战斗状态。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>由题意可知，对于中间的圣堂武士来说，无论是吸收还是给出灵能给两边的武士，都可以统一处理：</p>
<p>ai−1+=ai,ai+1+=ai,ai−=2ai。</p>
<p>难点1：想到<strong>前缀和</strong>的做法。</p>
<p><img src="/posts/94df374e/image-20210606155931370.png" alt="image-20210606155931370"></p>
<p>构造前缀和序列，我们每次操作a[i]（i = 2,3,…,n-1）时，相当于交换S[i-1]和S[i]的值，这个性质很重要。</p>
<p>因为<code>a[i] == S[i] - S[i-1]</code>，所以有：<code>max&#123;|a[i]|&#125; == max&#123;|S[i] - S[i-1]|&#125;</code>.</p>
<p>难点2：如何求最小不稳定度，贪心策略。</p>
<p>如果S[0]和S[n]也能参与交换的话，我们只要对前缀和数组排序使得它是单调的，这样差值才会最小，然后就</p>
<p>可以通过直接计算max(s[i]-s[i-1]的值 获得不稳定度的最小值。</p>
<p>然而S[0]和S[n]是不能参与交换的！</p>
<p>我们用数轴来思考会简单很多。前缀和数组S[N]的每个元素分布在一个数轴上，我们需要从S[0]跳到S[n]，每</p>
<p>个点都必须经过且只经过一次。<strong>那所求的最小不稳定度也就是跳步的最短距离。</strong></p>
<p><img src="/posts/94df374e/image-20210606180534745.png" alt="image-20210606180534745"></p>
<p>由上图可知，<strong>最优的贪心策略</strong>必然是：S[0]–&gt;最小值–&gt;最大值–&gt;S[n]。（难点，双指针实现）</p>
<p>必须间隔一个点跳一步，因为每个点只能经过一次。</p>
<p>时间复杂度：O(n*logn)</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line">LL s[N],a[N];</span><br><span class="line"><span class="keyword">int</span> n,T;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;<span class="comment">// 注意细节</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        s[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">// s[0]定义为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">            s[i] = s[i<span class="number">-1</span>] + a[i];<span class="comment">// 计算前缀和数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        LL s0 = s[<span class="number">0</span>],sn = s[n];<span class="comment">// 排序之前拿出s0,sn</span></span><br><span class="line">        <span class="keyword">if</span> (s0 &gt; sn) swap(s0,sn);<span class="comment">// s0必须小于sn，否则交换</span></span><br><span class="line">        sort(s,s+n+<span class="number">1</span>);<span class="comment">// 记得对前缀和数组排序</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s0)&#123;<span class="comment">// 从前往后找到s[0]在排序之后的下标</span></span><br><span class="line">                s0 = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (sn == s[i])&#123;<span class="comment">// 从后往前，因为s[0]可能==s[n]，找到s[n]在排序之后的下标</span></span><br><span class="line">                sn = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);<span class="comment">// 判重数组置零</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r= n;</span><br><span class="line">        <span class="comment">// 第1步：从起点s[s0]跳到最小值s[0]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s0;i &gt;= <span class="number">0</span>;i -= <span class="number">2</span>)&#123;<span class="comment">// 间隔1个点跳一步</span></span><br><span class="line">            a[l++] = s[i];<span class="comment">//a[]存入对s[]调整顺序后的s[i]</span></span><br><span class="line">            st[i] = <span class="literal">true</span>;<span class="comment">// 用于判重</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第3步：从最大值s[n]跳到终点s[sn]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = sn;i &lt;= n;i += <span class="number">2</span>)&#123;<span class="comment">// 间隔1个点跳一步</span></span><br><span class="line">            a[r--] = s[i];<span class="comment">// 反向计算</span></span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//  第2步：从最小值s[0]跳到最大值s[n]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!st[i])&#123;<span class="comment">// 把之前没走过的点都走完</span></span><br><span class="line">                a[l++] = s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) res = max(res,<span class="built_in">abs</span>(a[i] - a[i<span class="number">-1</span>]));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>前缀和</tag>
        <tag>贪心</tag>
        <tag>双指针</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（二十）</title>
    <url>/posts/44dbe297.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="4-习题"><a href="#4-习题" class="headerlink" title="4.习题"></a>4.习题</h3><h4 id="4-1-acwing-1240-完全二叉树的权值"><a href="#4-1-acwing-1240-完全二叉树的权值" class="headerlink" title="4.1 acwing.1240. 完全二叉树的权值"></a>4.1 acwing.1240. 完全二叉树的权值</h4><p>第十届蓝桥杯省赛C++A/B组,第十届蓝桥杯省赛JAVAA组</p>
<span id="more"></span>

<p>给定一棵包含 NN 个节点的完全二叉树，树上每个节点都有一个权值，按从上到下、从左到右的顺序依次是 </p>
<p>A1,A2,⋅⋅⋅ANA1,A2,···AN，如下图所示：</p>
<p><img src="/posts/44dbe297/image-20210527154520270.png" alt="image-20210527154520270"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入格式</span><br><span class="line">第一行包含一个整数 N。</span><br><span class="line">第二行包含 N 个整数 A1,A2,⋅⋅⋅AN。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数代表答案。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤N≤<span class="number">105</span>,</span><br><span class="line">−<span class="number">105</span>≤Ai≤<span class="number">105</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>思路：（比较简单）</p>
<p>双指针算法。时间复杂度：O(n)。</p>
<p>把每个数遍历一次，所以是O(n)。</p>
<p>对层数进行循环，分别求权值之和，更新最大值。</p>
<p><img src="/posts/44dbe297/image-20210527212154148.png" alt="image-20210527212154148"></p>
<p>注意爆int。</p>
<p>满二叉树的深度为log(1e5) 最多可以有 1 &lt;&lt; (log(1e5)) - 1个元素 大概是2^15 ~ 2^16 ，再乘以一个 1e5 所以</p>
<p>就爆了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;<span class="comment">// 无穷大</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> t[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t[i]);</span><br><span class="line"></span><br><span class="line">    LL max = -INF;</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, d = <span class="number">1</span>;i &lt;= n;i *= <span class="number">2</span>,d++)&#123;<span class="comment">// i不能从0开始，从1开始才有*2的规律</span></span><br><span class="line">        LL s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; i + (<span class="number">1</span> &lt;&lt; d<span class="number">-1</span>) &amp;&amp; j &lt;= n;j++) s += t[j];</span><br><span class="line">        <span class="keyword">if</span> (s &gt; max)&#123;</span><br><span class="line">            max = s;</span><br><span class="line">            depth = d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,depth);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-acwing-1096-地牢大师"><a href="#4-2-acwing-1096-地牢大师" class="headerlink" title="4.2 acwing.1096. 地牢大师"></a>4.2 acwing.1096. 地牢大师</h4><p>《信息学奥赛一本通》 , POJ 2251</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">你现在被困在一个三维地牢中，需要找到最快脱离的出路！</span><br><span class="line">地牢由若干个单位立方体组成，其中部分不含岩石障碍可以直接通过，部分包含岩石障碍无法通过。</span><br><span class="line">向北，向南，向东，向西，向上或向下移动一个单元距离均需要一分钟。</span><br><span class="line">你不能沿对角线移动，迷宫边界都是坚硬的岩石，你不能走出边界范围。</span><br><span class="line">请问，你有可能逃脱吗？</span><br><span class="line">如果可以，需要多长时间？</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">输入包含多组测试数据。</span><br><span class="line">每组数据第一行包含三个整数 L,R,C 分别表示地牢层数，以及每一层地牢的行数和列数。</span><br><span class="line">接下来是 L 个 R 行 C 列的字符矩阵，用来表示每一层地牢的具体状况。</span><br><span class="line">每个字符用来描述一个地牢单元的具体状况。</span><br><span class="line">其中, 充满岩石障碍的单元格用”#”表示，不含障碍的空单元格用”.”表示，你的起始位置用”S”表示，终点用”E”表示。</span><br><span class="line">每一个字符矩阵后面都会包含一个空行。</span><br><span class="line">当输入一行为”<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>”时，表示输入终止。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">每组数据输出一个结果，每个结果占一行。</span><br><span class="line">如果能够逃脱地牢，则输出”Escaped in x minute(s).”，其中X为逃脱所需最短时间。</span><br><span class="line">如果不能逃脱地牢，则输出”Trapped!”。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤L,R,C≤<span class="number">100</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">S....</span><br><span class="line">.###.</span><br><span class="line">.##..</span><br><span class="line">###.#</span><br><span class="line"></span><br><span class="line">#####</span><br><span class="line">#####</span><br><span class="line">##.##</span><br><span class="line">##...</span><br><span class="line"></span><br><span class="line">#####</span><br><span class="line">#####</span><br><span class="line">#.###</span><br><span class="line">####E</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line">S##</span><br><span class="line">#E#</span><br><span class="line">###</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">输出样例：</span><br><span class="line">Escaped in <span class="number">11</span> minute(s).</span><br><span class="line">Trapped!</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>这是一个三维的迷宫问题。</p>
<p>根据数据范围：迷宫最多是10^6，所以时间复杂度应当控制为：O(n)。</p>
<p>做法：二维BFS扩展成三维BFS。</p>
<p>二维与三维坐标偏移对比：</p>
<p><img src="/posts/44dbe297/image-20210528202135319.png" alt="image-20210528202135319"></p>
<p>代码：队列，队尾入队，队头出队。</p>
<p>本题用数组实现BFS，用队列queue也行，效率更低一点。可以当作模板记忆了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">101</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,z;<span class="comment">// 对应三个坐标维度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">// 6个方向</span></span><br><span class="line"><span class="keyword">int</span> dy[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dz[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> L,R,C;</span><br><span class="line"><span class="keyword">char</span> g[N][N][N];</span><br><span class="line"><span class="keyword">int</span> dist[N][N][N];<span class="comment">// 距离与判重数组</span></span><br><span class="line">Point q[N*N*N];<span class="comment">// 用数组代替队列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(Point S,Point E)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>,tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = S;<span class="comment">// 入队</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">-1</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[S.x][S.y][S.z] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)&#123;<span class="comment">// 队尾没碰到队头说明队列非空，必须是&lt;=</span></span><br><span class="line">        <span class="keyword">auto</span> t = q[hh++];<span class="comment">// hh相当于队尾指针，元素插入队尾</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">6</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = t.x + dx[i],y = t.y + dy[i],z = t.z + dz[i];</span><br><span class="line">            <span class="comment">// 不能出界</span></span><br><span class="line">            <span class="keyword">if</span> ( x &lt; <span class="number">0</span> || x &gt;= L || y &lt; <span class="number">0</span> || y &gt;= R || z &lt; <span class="number">0</span> || z &gt;= C) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 判断是否走过</span></span><br><span class="line">            <span class="keyword">if</span> (dist[x][y][z] != <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 判断障碍物</span></span><br><span class="line">            <span class="keyword">if</span> (g[x][y][z] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            dist[x][y][z] = dist[t.x][t.y][t.z] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (g[x][y][z] == <span class="string">&#x27;E&#x27;</span>) <span class="keyword">return</span> dist[x][y][z];</span><br><span class="line"></span><br><span class="line">            q[++tt] = &#123;x,y,z&#125;;<span class="comment">// tt相当于队头指针，有hh处插入的元素拓展的元素插入队尾</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Point start,end;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;L,&amp;R,&amp;C),L &amp;&amp; R &amp;&amp; C)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; L;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; R;j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,g[i][j]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; C;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (g[i][j][k] == <span class="string">&#x27;S&#x27;</span>) start = &#123;i,j,k&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> res = bfs(start,end);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">&quot;Trapped!&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Escaped in %d minute(s).\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-acwing-1233-全球变暖"><a href="#4-3-acwing-1233-全球变暖" class="headerlink" title="4.3 acwing.1233. 全球变暖"></a>4.3 acwing.1233. 全球变暖</h4><p>第九届蓝桥杯省赛C++A/B组,第九届蓝桥杯省赛JAVAA/B组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">你有一张某海域 N×N 像素的照片，”.”表示海洋、”#”表示陆地，如下所示：</span><br><span class="line">.......</span><br><span class="line">.##....</span><br><span class="line">.##....</span><br><span class="line">....##.</span><br><span class="line">..####.</span><br><span class="line">...###.</span><br><span class="line">.......</span><br><span class="line">其中”上下左右”四个方向上连在一起的一片陆地组成一座岛屿，例如上图就有 <span class="number">2</span> 座岛屿。</span><br><span class="line">由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。</span><br><span class="line">具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。</span><br><span class="line">例如上图中的海域未来会变成如下样子：</span><br><span class="line">.......</span><br><span class="line">.......</span><br><span class="line">.......</span><br><span class="line">.......</span><br><span class="line">....#..</span><br><span class="line">.......</span><br><span class="line">.......</span><br><span class="line">请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含一个整数N。</span><br><span class="line">以下 N 行 N 列，包含一个由字符”#”和”.”构成的 N×N 字符矩阵，代表一张海域照片，”#”表示陆地，”.”表示海洋。</span><br><span class="line">照片保证第 <span class="number">1</span> 行、第 <span class="number">1</span> 列、第 N 行、第 N 列的像素都是海洋。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">一个整数表示答案。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤N≤<span class="number">1000</span></span><br><span class="line">输入样例<span class="number">1</span>：</span><br><span class="line"><span class="number">7</span></span><br><span class="line">.......</span><br><span class="line">.##....</span><br><span class="line">.##....</span><br><span class="line">....##.</span><br><span class="line">..####.</span><br><span class="line">...###.</span><br><span class="line">.......</span><br><span class="line">输出样例<span class="number">1</span>：</span><br><span class="line"><span class="number">1</span></span><br><span class="line">输入样例<span class="number">2</span>：</span><br><span class="line"><span class="number">9</span></span><br><span class="line">.........</span><br><span class="line">.##.##...</span><br><span class="line">.#####...</span><br><span class="line">.##.##...</span><br><span class="line">.........</span><br><span class="line">.##.#....</span><br><span class="line">.#.###...</span><br><span class="line">.#..#....</span><br><span class="line">.........</span><br><span class="line">输出样例<span class="number">2</span>：</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>这题也是考察Flood Fill（洪水灌溉）算法。</p>
<p>根据数据范围推断时间复杂度要控制为O(n)。</p>
<p><strong>十九讲的红与黑求的是一个连通块的大小，而这题求的是连通块的个数，有多个。</strong></p>
<p>先统计一共有多少连通块，再计算被淹没的连通块有多少个。</p>
<p>如何判断岛屿是否被淹没？</p>
<p>我们可以开两个变量total和bound，分别表示总像素个数和边界像素个数，如果<code>total == bound</code>，说明淹</p>
<p>没。</p>
<p>total怎么算？每拓展一个像素，total+1；</p>
<p>bound怎么算？拓展的像素四个方向有海，bound+1.</p>
<p>代码1：BFS</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line">PII q[N*N];<span class="comment">// bfs数组</span></span><br><span class="line"><span class="keyword">bool</span> st[N][N];<span class="comment">// 判重数组</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,dy[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> &amp;total,<span class="keyword">int</span> &amp;bound)</span></span>&#123;<span class="comment">// 注意total和bound必须是引用传递</span></span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>,tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = &#123;x,y&#125;;</span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q[hh++];</span><br><span class="line">        total++;</span><br><span class="line">        <span class="keyword">bool</span> is_bound = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = t.x + dx[i],b = t.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (st[a][b]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (g[a][b] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                is_bound = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q[++tt] = &#123;a,b&#125;;</span><br><span class="line">            st[a][b] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is_bound) bound++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,g[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[i][j] &amp;&amp; g[i][j] == <span class="string">&#x27;#&#x27;</span>)&#123;<span class="comment">// 对每个陆地像素搜索计算连通块个数</span></span><br><span class="line">                <span class="keyword">int</span> total = <span class="number">0</span>,bound = <span class="number">0</span>;</span><br><span class="line">                bfs(i,j,total,bound);</span><br><span class="line">                <span class="keyword">if</span> (bound == total) cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码2：DFS</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">1010</span>][<span class="number">1010</span>]; <span class="comment">//地图</span></span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">1010</span>][<span class="number">1010</span>]=&#123;<span class="number">0</span>&#125;;  <span class="comment">//标记是否搜过</span></span><br><span class="line"><span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;; <span class="comment">//四个方向</span></span><br><span class="line"><span class="keyword">int</span> flag;  <span class="comment">//用于标记这个岛中是否被完全淹没</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    vis[x][y] = <span class="number">1</span>;      <span class="comment">//标记这个&#x27;#&#x27;被搜过。注意为什么可以放在这里</span></span><br><span class="line">    <span class="keyword">if</span>(a[x][y+<span class="number">1</span>]==<span class="string">&#x27;#&#x27;</span> &amp;&amp; a[x][y<span class="number">-1</span>]==<span class="string">&#x27;#&#x27;</span> &amp;&amp; a[x+<span class="number">1</span>][y]==<span class="string">&#x27;#&#x27;</span> &amp;&amp; a[x<span class="number">-1</span>][y]==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        flag = <span class="number">1</span>;       <span class="comment">//上下左右都是陆地，不会淹没</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123; <span class="comment">//继续DFS周围的陆地</span></span><br><span class="line">        <span class="keyword">int</span> nx = x + d[i][<span class="number">0</span>], ny = y + d[i][<span class="number">1</span>];</span><br><span class="line">      <span class="comment">//if(nx&gt;=1 &amp;&amp; nx&lt;=n &amp;&amp; ny&gt;=1 &amp;&amp; ny&lt;=n &amp;&amp; vis[nx][ny]==0 &amp;&amp; a[nx][ny]==&#x27;#&#x27;) //题目说边上都是水，所以不用这么写了</span></span><br><span class="line">        <span class="keyword">if</span>(vis[nx][ny]==<span class="number">0</span> &amp;&amp; a[nx][ny]==<span class="string">&#x27;#&#x27;</span>) <span class="comment">//继续DFS未搜过的陆地，目的是标记它们</span></span><br><span class="line">            dfs(nx,ny);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  <span class="comment">//DFS所有像素点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;#&#x27;</span> &amp;&amp; vis[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                dfs(i,j);</span><br><span class="line">                <span class="keyword">if</span>(flag == <span class="number">0</span>)  <span class="comment">//这个岛全部被淹</span></span><br><span class="line">                    ans++;     <span class="comment">//统计岛的数量</span></span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者：Ooooooooooops</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/16140/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>DFS：地图从1开始计算，外面多了一圈，就不用单独处理越界情况。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>BFS</tag>
        <tag>图论</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（二）</title>
    <url>/posts/98fd8f6e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>续蓝桥杯学习总结（一）。</p>
</blockquote>
<h4 id="2-3-acwing-93-递归实现组合型枚举"><a href="#2-3-acwing-93-递归实现组合型枚举" class="headerlink" title="2.3 acwing.93.递归实现组合型枚举"></a>2.3 acwing.93.递归实现组合型枚举</h4><p>从 1∼n 这 n 个整数中随机选出 m 个，输出所有可能的选择方案。</p>
<span id="more"></span>

<p><strong>输入格式</strong><br>两个整数 n,m ,在同一行用空格隔开。</p>
<p><strong>输出格式</strong><br>按照<strong>从小到大的顺序输出</strong>所有方案，每行 1 个。</p>
<p>首先，同一行内的数升序排列，相邻两个数用一个空格隔开。</p>
<p>其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如 1 3 5 7 排在 1 3 6 8 前面）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">数据范围</span><br><span class="line">n&gt;<span class="number">0</span> ,</span><br><span class="line"><span class="number">0</span>≤m≤n ,</span><br><span class="line">n+(n−m)≤<span class="number">25</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">5</span> <span class="number">3</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">5</span> </span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span> </span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">5</span> </span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br></pre></td></tr></table></figure>

<p>思考题：如果要求使用非递归方法，该怎么做呢？</p>
<h5 id="1思路："><a href="#1思路：" class="headerlink" title="1思路："></a>1思路：</h5><p>先在纸上模拟一遍（不要空想，为难自己），拿笔写一写。</p>
<p><img src="/posts/98fd8f6e/image-20210312223816678.png" alt="image-20210312223816678"></p>
<p>为避免方案的重复，需要限制方案内部是升序的。（与排列型的关键区别）</p>
<p>排列型枚举对于重复数字不同排序算不同方案，因为是从小到大顺序枚举，所以需要加判重数组才能回溯用到之前更小的数，而本题不需要。</p>
<p><img src="/posts/98fd8f6e/image-20210312224313978.png" alt="image-20210312224313978"></p>
<h5 id="2画出递归搜索树："><a href="#2画出递归搜索树：" class="headerlink" title="2画出递归搜索树："></a>2画出递归搜索树：</h5><p><img src="/posts/98fd8f6e/image-20210312225045977.png" alt="image-20210312225045977"></p>
<p><img src="/posts/98fd8f6e/image-20210312231046206.png" alt="image-20210312231046206"></p>
<h5 id="3代码实现："><a href="#3代码实现：" class="headerlink" title="3代码实现："></a>3代码实现：</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> way[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 当前进行dfs(u...)，已经选u-1个数，剩下n-strat+1个数可选</span></span><br><span class="line">    <span class="comment">// u-1 + n-strat+1 &lt; m，把后面所有的数都选上，加起来也不够m，直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (u + n - start &lt; m) <span class="keyword">return</span>;<span class="comment">// 递归搜索的剪枝优化，快了近三倍</span></span><br><span class="line">    <span class="keyword">if</span> (u == m + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i ++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,way[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        way[u] = i;<span class="comment">// 第u层选择数字i</span></span><br><span class="line">        dfs(u+<span class="number">1</span>,i+<span class="number">1</span>);<span class="comment">// 第u层从数字i+1开始选择</span></span><br><span class="line"></span><br><span class="line">        way[u] = <span class="number">0</span>; <span class="comment">//恢复现场</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-acwing-1209-带分数（cpp-B-C组）"><a href="#2-4-acwing-1209-带分数（cpp-B-C组）" class="headerlink" title="2.4 acwing.1209.带分数（cpp B/C组）"></a>2.4 acwing.1209.带分数（cpp B/C组）</h4><p>100可以表示为带分数的形式：$100=3+\frac{69258}{714}$</p>
<p>还可以表示为：$100=82+\frac{3546}{197}$</p>
<p>注意特征：带分数中，数字 1∼9 分别出现且只出现一次（不包含 0）。</p>
<p>类似这样的带分数，100 有 11种表示法。</p>
<p>输入格式</p>
<p>一个正整数。</p>
<p>输出格式</p>
<p>输出输入数字用数码 1∼9不重复不遗漏地组成带分数表示的全部种数。</p>
<p>数据范围</p>
<p>1≤N&lt;$10^6$</p>
<p>输入样例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure>

<p>输出样例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure>

<p>输入样例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">105</span><br></pre></td></tr></table></figure>

<p>输出样例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>

<h5 id="y总思路："><a href="#y总思路：" class="headerlink" title="y总思路："></a>y总思路：</h5><p><img src="/posts/98fd8f6e/image-20210313103504053.png" alt="image-20210313103504053"></p>
<p>剪枝优化：</p>
<p>根据等式，实际上只需要枚举两个变量，另外一个可以算出来。</p>
<p><img src="/posts/98fd8f6e/image-20210313111557554.png" alt="image-20210313111557554"></p>
<p>补充空间复杂度的计算：</p>
<p><img src="/posts/98fd8f6e/image-20210313112130572.png" alt="image-20210313112130572"></p>
<p>代码如下：</p>
<p>两层dfs嵌套是扩展内容，不要求掌握，会一般的全排列暴力搜索就行。</p>
<p>太难了，恐怖如斯。</p>
<p><a href="https://www.acwing.com/solution/content/38879/">参考思路</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> st[N], backup[N];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> b = n * (<span class="keyword">long</span> <span class="keyword">long</span>)c - a * c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!a || !b || !c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(backup, st, <span class="keyword">sizeof</span> st);<span class="comment">// 将st数组复制到backup</span></span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = b % <span class="number">10</span>;     <span class="comment">// 取个位</span></span><br><span class="line">        b /= <span class="number">10</span>;    <span class="comment">// 个位删掉</span></span><br><span class="line">        <span class="keyword">if</span> (!x || backup[x]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        backup[x] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!backup[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_c</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> a, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &gt; <span class="number">9</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (check(a, c)) ans ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            dfs_c(u + <span class="number">1</span>, a, c * <span class="number">10</span> + i);</span><br><span class="line">            st[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_a</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt;= n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (a) dfs_c(u, a, <span class="number">0</span>);<span class="comment">// 对于每一个a，再对c进行枚举</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            dfs_a(u + <span class="number">1</span>, a * <span class="number">10</span> + i);</span><br><span class="line">            st[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    dfs_a(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/activity/content/code/content/159648/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h5 id="解题思路2（看懂这个就行）："><a href="#解题思路2（看懂这个就行）：" class="headerlink" title="解题思路2（看懂这个就行）："></a>解题思路2（看懂这个就行）：</h5><ul>
<li>暴力枚举出9个数的全排列，然后用一个长度为9的数组保存全排列的结果</li>
<li>从全排列的结果中用两重循环暴力分解出三段，每段代表一个数</li>
<li>验证枚举出来的三个数是否满足题干条件，若满足则计数<br>代码如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> target; <span class="comment">//题目给出的目标数</span></span><br><span class="line"><span class="keyword">int</span> num[N]; <span class="comment">//保存全排列的结果</span></span><br><span class="line"><span class="keyword">bool</span> used[N]; <span class="comment">//生成全排列过程中标记是否使用过</span></span><br><span class="line"><span class="keyword">int</span> cnt; <span class="comment">//计数，最后输出的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算num数组中一段的数是多少</span></span><br><span class="line"><span class="comment">//因为c*n == a*c+b有概率会爆int 保险起见longlong </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;<span class="comment">//l是num[l]之前,r是num[r]之后</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">        res = res * <span class="number">10</span> + num[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="comment">//当全排列生成后进行分段</span></span><br><span class="line">    <span class="comment">//用两层循环分成三段</span></span><br><span class="line">    <span class="keyword">if</span>(u == <span class="number">9</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)<span class="comment">// 枚举分隔点1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="number">8</span>; j++)&#123;<span class="comment">// 枚举分隔点2</span></span><br><span class="line">                <span class="keyword">if</span>(j-i+<span class="number">1</span>&lt;<span class="number">9</span>-j)<span class="keyword">continue</span>; <span class="comment">// 剪枝优化1，b的位数一定&gt;=c的位数</span></span><br><span class="line">                <span class="comment">// 位数,a:i + 1; b:j - i; c:8-j</span></span><br><span class="line">                <span class="keyword">int</span> a = calc(<span class="number">0</span>, i);</span><br><span class="line">                <span class="keyword">if</span> (a &gt;= target) <span class="keyword">continue</span>; <span class="comment">// 剪枝优化2，参考自别人</span></span><br><span class="line">                <span class="keyword">int</span> b = calc(i + <span class="number">1</span>, j);</span><br><span class="line">                <span class="keyword">int</span> c = calc(j + <span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">                <span class="comment">//注意判断条件，因为C++中除法是整除，所以要转化为加减乘来计算</span></span><br><span class="line">                <span class="keyword">if</span>(a * c + b == c * target) cnt++;<span class="comment">// 小心爆int</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成全排列</span></span><br><span class="line">    <span class="comment">//搜索模板</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(!used[i])&#123;</span><br><span class="line">            used[i] = <span class="literal">true</span>; <span class="comment">//标记使用</span></span><br><span class="line">            num[u] = i;</span><br><span class="line">            dfs(u + <span class="number">1</span>);</span><br><span class="line">            used[i] = <span class="literal">false</span>; <span class="comment">//还原现场</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;target);</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：Daniel丶y</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/6724/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p><img src="/posts/98fd8f6e/image-20210426123909755.png" alt="image-20210426123909755"></p>
<p>枚举分隔点也可以从1开始到9，像下面这样。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> st[<span class="number">12</span>];</span><br><span class="line"><span class="keyword">bool</span> used[<span class="number">12</span>];</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a;i &lt;= b;i++) num = <span class="number">10</span>*num + st[i];</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &gt; <span class="number">9</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">7</span>;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt;= <span class="number">8</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (j-i &lt; <span class="number">9</span>-j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> a = calc(<span class="number">1</span>,i);</span><br><span class="line">                <span class="keyword">if</span> (a &gt;= t) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> b = calc(i+<span class="number">1</span>,j);</span><br><span class="line">                <span class="keyword">int</span> c = calc(j+<span class="number">1</span>,<span class="number">9</span>);</span><br><span class="line">                <span class="keyword">if</span> (c*t == a*c + b) cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!used[i])&#123;</span><br><span class="line">            st[u] = i;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            dfs(u+<span class="number">1</span>);</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（五）</title>
    <url>/posts/d50f01e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="二-二分与前缀和"><a href="#二-二分与前缀和" class="headerlink" title="二 二分与前缀和"></a>二 二分与前缀和</h2><span id="more"></span>

<h3 id="1-二分"><a href="#1-二分" class="headerlink" title="1.二分"></a>1.二分</h3><h4 id="1-1-整数二分"><a href="#1-1-整数二分" class="headerlink" title="1.1 整数二分"></a>1.1 整数二分</h4><blockquote>
<p>推荐配合<a href="https://www.grantdrew.top/posts/e8eb0481.html">二分查找</a>食用。最好先看一遍，方便理解。</p>
</blockquote>
<p>对于整数二分，我们可以分成两个模版，下图中给出的是模板1的代码。</p>
<p><img src="/posts/d50f01e/image-20210407173812233.png" alt="image-20210407173812233"></p>
<p>注意：当M取红色时，有<code>L=M</code>，这里的模板1必须保证M等于<code>(L+R+1)/2</code>，括号里加上1对<code>(L+R)/2</code>向上取整，否则会对它向下取整，会导致左边界L一直取到M，陷入死循环。</p>
<p>模板2：</p>
<p><img src="/posts/d50f01e/image-20210407175954091.png" alt="image-20210407175954091"></p>
<p>总结：</p>
<p><img src="/posts/d50f01e/image-20210407180349572.png" alt="image-20210407180349572"></p>
<h4 id="1-2-acwing-789-数的范围（模板题）"><a href="#1-2-acwing-789-数的范围（模板题）" class="headerlink" title="1.2 acwing.789. 数的范围（模板题）"></a>1.2 acwing.789. 数的范围（模板题）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。</span><br><span class="line">对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 <span class="number">0</span> 开始计数）。</span><br><span class="line">如果数组中不存在该元素，则返回 <span class="number">-1</span> <span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含整数 n 和 q，表示数组长度和询问个数。</span><br><span class="line">第二行包含 n 个整数（均在 <span class="number">1</span>∼<span class="number">10000</span> 范围内），表示完整数组。</span><br><span class="line">接下来 q 行，每行包含一个整数 k，表示一个询问元素。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。</span><br><span class="line">如果数组中不存在该元素，则返回 <span class="number">-1</span> <span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤n≤<span class="number">100000</span></span><br><span class="line"><span class="number">1</span>≤q≤<span class="number">10000</span></span><br><span class="line"><span class="number">1</span>≤k≤<span class="number">10000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">6</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>题解1：STL</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// soluition 1，自己写的STL写法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,q,k,i;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">        <span class="keyword">int</span> l = lower_bound(num, num +i, k)-num;</span><br><span class="line">        <span class="keyword">int</span> r = upper_bound(num, num +i, k)-num;</span><br><span class="line">        <span class="comment">//特判一下，l==r时说明上下界重合，未找到</span></span><br><span class="line">        <span class="keyword">if</span> (l==r) <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; r<span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题解2：手打二分</p>
<p><img src="/posts/d50f01e/image-20210410123858425.png" alt="image-20210410123858425"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解，更快一点</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="comment">// 求二分左端点</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = n<span class="number">-1</span>;<span class="comment">// 确定区间范围</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l+r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (q[mid]&gt;=x) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (q[r] == x)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,r);</span><br><span class="line">            <span class="comment">// 求二分x的右端点</span></span><br><span class="line">            r = n<span class="number">-1</span>;<span class="comment">// 右端点一定在[左端点, n - 1] 之间</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">                <span class="comment">// 因为写的是l = mid，所以需要补上1</span></span><br><span class="line">                <span class="keyword">int</span> mid = l+r+<span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (q[mid]&lt;=x) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;-1 -1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-实数二分"><a href="#1-3-实数二分" class="headerlink" title="1.3 实数二分"></a>1.3 实数二分</h4><p>实数二分比整数二分简单多了。</p>
<p><img src="/posts/d50f01e/image-20210410131010056.png" alt="image-20210410131010056"></p>
<p>注意：这里的二分除法是严格的除法，不是整数除法。</p>
<h4 id="1-4-acwing-790-数的三次方根"><a href="#1-4-acwing-790-数的三次方根" class="headerlink" title="1.4 acwing.790.数的三次方根"></a>1.4 acwing.790.数的三次方根</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定一个浮点数 n，求它的三次方根。</span><br><span class="line">输入格式</span><br><span class="line">共一行，包含一个浮点数 n。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">共一行，包含一个浮点数，表示问题的解。</span><br><span class="line">注意，结果保留 <span class="number">6</span> 位小数。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">−<span class="number">10000</span>≤n≤<span class="number">10000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">1000.00</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">10.000000</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">-10000</span>,r = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">while</span> (r-l&gt;<span class="number">1e-8</span>)&#123; <span class="comment">// 比题目要求多求几位</span></span><br><span class="line">        <span class="keyword">double</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid*mid*mid&gt;=n) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>,r); <span class="comment">// 默认输出6位小数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（八）</title>
    <url>/posts/4d35e41b.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="2-2-acwing-796-子矩阵的和（二维模板题）"><a href="#2-2-acwing-796-子矩阵的和（二维模板题）" class="headerlink" title="2.2 acwing.796.子矩阵的和（二维模板题）"></a>2.2 acwing.796.子矩阵的和（二维模板题）</h4><span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入一个 n 行 m 列的整数矩阵，再输入 q 个询问，每个询问包含四个整数 x1,y1,x2,y2，表示一个子矩阵的左上角坐标和右下角坐标。</span><br><span class="line">对于每个询问输出子矩阵中所有数的和。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含三个整数 n，m，q。</span><br><span class="line">接下来 n 行，每行包含 m 个整数，表示整数矩阵。</span><br><span class="line">接下来 q 行，每行包含四个整数 x1,y1,x2,y2，表示一组询问。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">共 q 行，每行输出一个询问的结果。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤n,m≤<span class="number">1000</span>,</span><br><span class="line"><span class="number">1</span>≤q≤<span class="number">200000</span>,</span><br><span class="line"><span class="number">1</span>≤x1≤x2≤n,</span><br><span class="line"><span class="number">1</span>≤y1≤y2≤m,</span><br><span class="line">−<span class="number">1000</span>≤矩阵内元素的值≤<span class="number">1000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">7</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span> <span class="number">2</span> <span class="number">8</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>前缀和矩阵每个格子的数就是从原矩阵(1,1)到当前格子构成矩阵的和。</p>
<p>二维前缀和和一维一样，<strong>有一个起始点</strong>，然后再计算前缀和序列。</p>
<p><img src="/posts/4d35e41b/image-20210428170329381.png" alt="image-20210428170329381"></p>
<p>那么如何计算前缀和矩阵呢？</p>
<p>我们采用<strong>容斥原理</strong>的思想。</p>
<p><img src="/posts/4d35e41b/image-20210428170757661.png" alt="image-20210428170757661"></p>
<p>计算(1,1)到(2,3)的矩阵和：</p>
<p>先计算1,7,3,6，再计算1,7,2，最后加上最后格子的2。</p>
<p>所以黄色格子算了1次，蓝色格子算了2次。</p>
<p>由此可以得到前缀和矩阵的推导公式：$S_{x,y} = S_{x-1,y}+S_{x,y-1}-S_{x-1,y-1}+a_{x,y}$</p>
<p>正如一维一样，二维前缀和也能得到一个类似递推的公式。</p>
<p>这样计算的话是线性时间复杂度，而通过循环将非常费时间。</p>
<p>接下来怎么根据前缀和矩阵计算子矩阵的和呢？</p>
<p><img src="/posts/4d35e41b/image-20210428172127766.png" alt="image-20210428172127766"></p>
<p>计算(1,1)到(2,3)的矩阵和：</p>
<p>原理和上面类似，先减去左边一列，再减去上面一行，最后加上左上角被多减去的部分。</p>
<p>直接给出公式：$S_{x_2,y_2}-S_{x_2,y_1-1}-S_{x_1-1,y_2}+S_{x_1-1,y_1-1}$</p>
<p>通过前缀和算法，我们将查询时间复杂度从$O(n*m)$降低到$O(1)$。</p>
<p>总的时间复杂度取决于前缀和矩阵的预处理，时间复杂度为$O(n*m)$。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N][N],s[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m,q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">            <span class="comment">// 求前缀和矩阵</span></span><br><span class="line">            s[i][j] = s[i<span class="number">-1</span>][j]+s[i][j<span class="number">-1</span>]-s[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[x2][y2]-s[x2][y1<span class="number">-1</span>]-s[x1<span class="number">-1</span>][y2]+s[x1<span class="number">-1</span>][y1<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前缀和知识总结：</p>
<p><img src="/posts/4d35e41b/image-20210610181541537.png" alt="image-20210610181541537"></p>
<h4 id="2-3-acwing-99-激光炸弹（进阶指南）"><a href="#2-3-acwing-99-激光炸弹（进阶指南）" class="headerlink" title="2.3 acwing.99. 激光炸弹（进阶指南）"></a>2.3 acwing.99. 激光炸弹（进阶指南）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">地图上有 N 个目标，用整数 Xi,Yi 表示目标在地图上的位置，每个目标都有一个价值 Wi。</span><br><span class="line">注意：不同目标可能在同一位置。</span><br><span class="line">现在有一种新型的激光炸弹，可以摧毁一个包含 R×R 个位置的正方形内的所有目标。</span><br><span class="line">激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和 x，y 轴平行。</span><br><span class="line">求一颗炸弹最多能炸掉地图上总价值为多少的目标。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行输入正整数 N 和 R，分别代表地图上的目标数目和正方形的边长，数据用空格隔开。</span><br><span class="line">接下来 N 行，每行输入一组数据，每组数据包括三个整数 Xi,Yi,Wi，分别代表目标的 x 坐标，y 坐标和价值，数据用空格隔开。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">0</span>≤R≤<span class="number">10</span>^<span class="number">9</span></span><br><span class="line"><span class="number">0</span>&lt;N≤<span class="number">10000</span>,</span><br><span class="line"><span class="number">0</span>≤Xi,Yi≤<span class="number">5000</span></span><br><span class="line"><span class="number">0</span>≤Wi≤<span class="number">1000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>按照题意，就是求边长为R的正方形的覆盖的最大值。<strong>本质上就是二维前缀和的应用。</strong></p>
<p>参考大佬题解1：<a href="https://www.acwing.com/solution/content/10116/">https://www.acwing.com/solution/content/10116/</a></p>
<p>参考大佬题解2：<a href="https://www.acwing.com/solution/content/31983/">https://www.acwing.com/solution/content/31983/</a></p>
<p><img src="/posts/4d35e41b/image-20210428183858344.png" alt="image-20210428183858344"></p>
<p><strong>注意子矩阵和的公式</strong>，套用上一题的公式时，3-R+1与公式里的x1-1,y1-1抵消了一个1，所以变成x-R,y-R了。</p>
<p><img src="/posts/4d35e41b/image-20210428214224102.png" alt="image-20210428214224102"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="comment">// 目标坐标从0到5000，移动到1到5001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5010</span>;</span><br><span class="line"><span class="keyword">int</span> s[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt,R;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;cnt,&amp;R);</span><br><span class="line">    R = min(<span class="number">5001</span>,R);</span><br><span class="line">    n = m = R;</span><br><span class="line">    <span class="keyword">while</span> (cnt--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;w);</span><br><span class="line">        <span class="comment">// 坐标+1，防止越界问题</span></span><br><span class="line">        x++,y++;</span><br><span class="line">        <span class="comment">// 枚举的上限是最大坐标和R的最大值</span></span><br><span class="line">        n = max(n,x),m = max(m,y);</span><br><span class="line">        <span class="comment">// 这里必须是+=，因为目标可能重复</span></span><br><span class="line">        s[x][y] += w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 预处理前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)</span><br><span class="line">            s[i][j] += s[i<span class="number">-1</span>][j]+s[i][j<span class="number">-1</span>]-s[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 必须保证n,m &gt;= R，才能保证至少循环一次</span></span><br><span class="line">    <span class="comment">// 枚举所有边长是R的矩形，枚举(i, j)为右下角</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = R;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = R;j &lt;= m;j++)&#123;</span><br><span class="line">            res = max(res,s[i][j]-s[i-R][j]-s[i][j-R]+s[i-R][j-R]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意卡空间，题目上限是168MB，开两个<code>s[5000][5000]</code>大概是200MB，所以只开一个数组。</p>
<p>因为同用一个数组，所以求前缀和矩阵的公式里<code>+a[i][j]</code>变成了<code>+s[i][j]</code>。</p>
<p>所以以后用二维前缀和，完全可以只开一个数组。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（六）</title>
    <url>/posts/685ebbc7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p> 续蓝桥杯学习总结（五）。</p>
</blockquote>
<span id="more"></span>

<h4 id="1-5-acwing-730-机器人跳跃问题（头条2019笔试题）"><a href="#1-5-acwing-730-机器人跳跃问题（头条2019笔试题）" class="headerlink" title="1.5 acwing.730. 机器人跳跃问题（头条2019笔试题）"></a>1.5 acwing.730. 机器人跳跃问题（头条2019笔试题）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">机器人正在玩一个古老的基于 DOS 的游戏。</span><br><span class="line">游戏中有 N+<span class="number">1</span> 座建筑——从 <span class="number">0</span> 到 N 编号，从左到右排列。</span><br><span class="line">编号为 <span class="number">0</span> 的建筑高度为 <span class="number">0</span> 个单位，编号为 i 的建筑高度为 H(i) 个单位。</span><br><span class="line">起初，机器人在编号为 <span class="number">0</span> 的建筑处。</span><br><span class="line">每一步，它跳到下一个（右边）建筑。</span><br><span class="line">假设机器人在第 k 个建筑，且它现在的能量值是 E，下一步它将跳到第 k+<span class="number">1</span> 个建筑。</span><br><span class="line">如果 H(k+<span class="number">1</span>)&gt;E，那么机器人就失去 H(k+<span class="number">1</span>)−E 的能量值，否则它将得到 E−H(k+<span class="number">1</span>) 的能量值。</span><br><span class="line">游戏目标是到达第 N 个建筑，在这个过程中能量值不能为负数个单位。</span><br><span class="line">现在的问题是机器人至少以多少能量值开始游戏，才可以保证成功完成游戏？</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行输入整数 N。</span><br><span class="line">第二行是 N 个空格分隔的整数，H(<span class="number">1</span>),H(<span class="number">2</span>),…,H(N) 代表建筑物的高度。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示所需的最少单位的初始能量值上取整后的结果。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤N,H(i)≤<span class="number">105</span>,</span><br><span class="line">输入样例<span class="number">1</span>：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line">输出样例<span class="number">1</span>：</span><br><span class="line"><span class="number">4</span></span><br><span class="line">输入样例<span class="number">2</span>：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line">输出样例<span class="number">2</span>：</span><br><span class="line"><span class="number">4</span></span><br><span class="line">输入样例<span class="number">3</span>：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">4</span></span><br><span class="line">输出样例<span class="number">3</span>：</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>y总思路：</p>
<p><img src="/posts/685ebbc7/image-20210417113943246.png" alt="image-20210417113943246"></p>
<p>题目具有二段性，假设有E满足条件，比E小的数都不满足，比E大的数都满足。这点可以简单论证一下。</p>
<p><img src="/posts/685ebbc7/image-20210417123437384.png" alt="image-20210417123437384"></p>
<p>注意一个坑：如果E接近h的最大值时，<code>E*2</code>容易爆int（记住：int范围约是2*10$^9$.），其实我们只要判断<code>E&gt;=max(h)</code>，满足的话后面E肯定是递增的，就不用再判断是否大于0了。证明如下：</p>
<p><img src="/posts/685ebbc7/image-20210417124151973.png" alt="image-20210417124151973"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解奉上</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> num[N]; <span class="comment">// num[0]默认为0</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)&#123;</span><br><span class="line">        m = <span class="number">2</span>*m - num[i];</span><br><span class="line">        <span class="keyword">if</span> (m &gt;= <span class="number">1e5</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (m &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 这里别忘了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="comment">// 从num[1]开始读，包括num[0]在内是n+1座建筑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num[i]);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">1e5</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid))r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-acwing-1221-四平方和（蓝桥杯省赛C-A-B组）"><a href="#1-6-acwing-1221-四平方和（蓝桥杯省赛C-A-B组）" class="headerlink" title="1.6 acwing.1221. 四平方和（蓝桥杯省赛C++A/B组）"></a>1.6 acwing.1221. 四平方和（蓝桥杯省赛C++A/B组）</h4><p>类似题目：acwing.75.和为S的两个数字，语法（九）题解有暴搜与哈希表两种做法。（PS：本题不可暴搜）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">四平方和定理，又称为拉格朗日定理：</span><br><span class="line">每个正整数都可以表示为至多 <span class="number">4</span> 个正整数的平方和。</span><br><span class="line">如果把 <span class="number">0</span> 包括进去，就正好可以表示为 <span class="number">4</span> 个数的平方和。</span><br><span class="line">比如：</span><br><span class="line"><span class="number">5</span>=<span class="number">0</span>^<span class="number">2</span>+<span class="number">0</span>^<span class="number">2</span>+<span class="number">1</span>^<span class="number">2</span>+<span class="number">2</span>^<span class="number">2</span></span><br><span class="line"><span class="number">7</span>=<span class="number">1</span>^<span class="number">2</span>+<span class="number">1</span>^<span class="number">2</span>+<span class="number">1</span>^<span class="number">2</span>+<span class="number">2</span>^<span class="number">2</span></span><br><span class="line">对于一个给定的正整数，可能存在多种平方和的表示法。</span><br><span class="line">要求你对 <span class="number">4</span> 个数排序：</span><br><span class="line"><span class="number">0</span>≤a≤b≤c≤d</span><br><span class="line">并对所有的可能表示法按 a,b,c,d 为联合主键升序排列，最后输出第一个表示法。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">输入一个正整数 N。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出<span class="number">4</span>个非负整数，按从小到大排序，中间用空格分开。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">0</span>&lt;N&lt;<span class="number">5</span>∗<span class="number">10</span>^<span class="number">6</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">5</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>强行三重循环爆搜会超时的，怎么优化都过不了。Java能过，C++不行，Java时限更长。</p>
<p>y总思路：</p>
<p><img src="/posts/685ebbc7/image-20210417155749683.png" alt="image-20210417155749683"></p>
<p>(与带分数的转换方法类似)</p>
<p>1、a^2+b^2+c^2+d^2=n可以转换成 c^2+d^2=n−a^2−b^2</p>
<p>2、通过排序数组（或哈希表）存储c^2+d^2的值</p>
<p>3、枚举a和b，若n−a^2−b^2在排序数组（或哈希表）中存在，则表示一定存在c和d，满足方程</p>
<p>哈希表由于某些原因过不了。</p>
<h5 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h5><p>时间复杂度：$O(n^2*logn)$，两重循环加一个二分查找</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总二分题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2500010</span>; <span class="comment">// 5*10^6的一半，后面枚举c、d</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s,c,d;</span><br><span class="line">    <span class="comment">// 结构体排序，重载小于号</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Sum&amp; t) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s != t.s) <span class="keyword">return</span> s &lt; t.s; <span class="comment">// s、c、d按字典序排序</span></span><br><span class="line">        <span class="keyword">if</span> (c != t.c) <span class="keyword">return</span> c &lt; t.c;</span><br><span class="line">        <span class="keyword">return</span> d &lt; t.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sum[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>;c*c&lt;= n;c++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = c;c*c+d*d&lt;= n;d++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[m++] = &#123;c*c+d*d,c,d&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    sort(sum,sum+m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>;a*a&lt;= n;a++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> b = a;a*a+b*b&lt;= n;b++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = n-a*a-b*b;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>,r = m<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (sum[mid].s &gt;= t) r = mid;</span><br><span class="line">                <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum[l].s == t)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,a,b,sum[l].c,sum[l].d);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h5><p>时间复杂度$O(n^2)$，本题超时，仅作为思路拓展！</p>
<p>不要轻信时间复杂度，这里二分与哈希表之间的常数不能忽略。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;// 哈希表</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;<span class="comment">// 必须放using...之后</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, PII&gt; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c * c &lt;= n; c ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = c; c * c + d * d &lt;= n; d ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = c * c + d * d;</span><br><span class="line">            <span class="keyword">if</span> (S.count(t) == <span class="number">0</span>) S[t] = &#123;c, d&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a * a &lt;= n; a ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; a * a + b * b &lt;= n; b ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = n - a * a - b * b;</span><br><span class="line">            <span class="keyword">if</span> (S.count(t))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, a, b, S[t].x, S[t].y);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（十一）</title>
    <url>/posts/a75e4e46.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="2-简单DP"><a href="#2-简单DP" class="headerlink" title="2.简单DP"></a>2.简单DP</h3><p>动态规划（Dynamic Programming，DP）是一种用来解决一类<strong>最优化问题</strong>的算法思想。</p>
<p>背包问题是一类经典的DP问题，灵活多变。</p>
<p><a href="https://valen.blog.csdn.net/article/details/87878853?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">背包问题模板整理点这里</a></p>
<p><a href="https://www.acwing.com/blog/content/630/">DP问题整理点这里</a></p>
<p><a href="https://www.iamshuaidi.com/275.html">帅地哥的DP文章</a></p>
<span id="more"></span>

<h4 id="2-1-闫氏DP分析法"><a href="#2-1-闫氏DP分析法" class="headerlink" title="2.1 闫氏DP分析法"></a>2.1 闫氏DP分析法</h4><p>我们从集合角度来分析DP问题。</p>
<p><img src="/posts/a75e4e46/image-20210508224611771.png" alt="image-20210508224611771"></p>
<h4 id="2-2-acwing-2-01背包问题（背包九讲-模板题）"><a href="#2-2-acwing-2-01背包问题（背包九讲-模板题）" class="headerlink" title="2.2 acwing.2. 01背包问题（背包九讲 , 模板题）"></a>2.2 acwing.2. 01背包问题（背包九讲 , 模板题）</h4><p>背包问题的核心其实就是组合问题，在一个背包中有若干物品，在某种限制条件下，选出最好的组合。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。</span><br><span class="line">第 i 件物品的体积是 vi，价值是 wi。</span><br><span class="line">求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</span><br><span class="line">输出最大价值。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。</span><br><span class="line">接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示最大价值。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">0</span>&lt;N,V≤<span class="number">1000</span></span><br><span class="line"><span class="number">0</span>&lt;vi,wi≤<span class="number">1000</span></span><br><span class="line">输入样例</span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>参考1：y总视频讲解，参考2：《算法笔记》，参考3：《LeetCode 101》刷题指南</p>
<p>如果采用暴力枚举每一件物品放或者不放进背包，有两种选择，所以时间复杂度为$O(2^n)$，非常大。</p>
<p>接下来考虑<strong>动态规划</strong>求解。</p>
<h5 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h5><h6 id="先尝试二维解法。"><a href="#先尝试二维解法。" class="headerlink" title="先尝试二维解法。"></a>先尝试二维解法。</h6><p>我们可以定义一个二维数组dp存储最大价值，其中<code>dp[i][j]</code> 表示前i 件物品体积不超过j （<strong>即此时背包容量</strong></p>
<p><strong>为j</strong>）的情况下能达到的最大价值。</p>
<p>在我们遍历到第i 件物品时，在当前背包总容量为j 的情况下，</p>
<ol>
<li><p>如果我们不将物品i 放入背包，那么<code>dp[i][j]= dp[i-1][j]</code>，即前i 个物品的最大价值等于只取前i-1 个</p>
<p>物品时的最大价值；</p>
</li>
<li><p>如果我们将物品i 放入背包，假设第i 件物品体积为wi，价值为vi，那么我们得到</p>
<p><code>dp[i][j] = dp[i-1][j-w[i]] + v[i]</code>。我们只需在遍历过程中对这两种情况取最大值即可，总时间复杂度和空间复杂度都为$O(NV)$。</p>
</li>
</ol>
<p>综合上面提到的2种选择策略，我们可以得到<strong>状态转移方程</strong>：</p>
<p><code>dp[i][j] = max&#123;dp[i-1][j],dp[i-1][j-w[i]] + v[i]&#125;</code></p>
<p>确定初始化边界，<code>dp[0][0] = 0    </code>.</p>
<p>注意<strong>理解误区</strong>：</p>
<p><code>dp[i][j]</code>里的<code>i</code>不是表示选择了前i个物品，而是表示对前i个物品做出两中策略的选择；</p>
<p>里面的<code>j</code>不是表示当前物品的总体积等于j，而是表示前i 件物品体积不超过j 。</p>
<p>这里给出一位大佬的解释：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">无论 j 表示体积正好是 j 还是 不超过 j ，它的式子都是一样的 j - v[i]， 但是理解不同而已。</span><br><span class="line">有一点不同就是：如果 j 表示体积正好是 j 的话，那么答案就需要遍历求max。如果表示的是 不超过 j 的话，答案就是 f[n][m] 。</span><br><span class="line">如果只考虑第<span class="number">1</span>件物品的话，应该只有 f[<span class="number">1</span>][ v[<span class="number">1</span>] ] = w[<span class="number">1</span>] 其他的都是不存在最大质量的（都为<span class="number">0</span>）。</span><br><span class="line">但是按照 原来的初始化的话，f数组的第一行：f[<span class="number">1</span>][ v[<span class="number">1</span>] - v ] = v[<span class="number">1</span>]（而这样的式子却代表的是 j 表示不超过 j 的情况、可以把两种情况的 f 数组画出来）</span><br><span class="line">所以我认为：</span><br><span class="line"><span class="number">1</span>、j 表示 体积正好为 j ：需要 f[<span class="number">1</span>][ v[<span class="number">1</span>] ] = w[<span class="number">1</span>]，其余的赋值为零。这样得到的数组 f 才能被解释赋予意义。答案就需要遍历求max。</span><br><span class="line"><span class="number">2</span>、j 表示 体积不超过 j ：式子不变，初始化不变，只是求答案不需要遍历，答案就是 f[n][m]。</span><br></pre></td></tr></table></figure>

<p>再贴一位大佬的题解：（十分详细了）<a href="https://www.acwing.com/solution/content/1374/">https://www.acwing.com/solution/content/1374/</a></p>
<p>代码：（二维朴素做法）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][N]; <span class="comment">// dp[0][0] = 0</span></span><br><span class="line"><span class="keyword">int</span> v[N],w[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= m;j++)&#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j - v[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-v[i]]+w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="再尝试一维优化。"><a href="#再尝试一维优化。" class="headerlink" title="再尝试一维优化。"></a>再尝试一维优化。</h6><p>我们可以进一步对0-1 背包进行空间优化，将空间复杂度降低为$O(V)$。时间复杂度已经不能再优化了。</p>
<p><img src="/posts/a75e4e46/image-20210430213638586.png" alt="image-20210430213638586"></p>
<p>这里可以发现我们<code>dp[i][j]</code>永远只依赖于上一排左边的信息，之前算过的其他物品都不需要再使用。因此我</p>
<p>们可以去掉dp 矩阵的第一个维度，在考虑物品i 时变成dp[j]= max(dp[j], dp[j-w] + v)。这里要注意我们在遍</p>
<p>历每一行的时候必须<strong>逆向遍历</strong>，这样才能够调用上一行物品i-1 时dp[j-w] 的值；若按照从左往右的顺序进行正</p>
<p>向遍历，则dp[j-w] 的值在遍历到j 之前就已经被更新成物品i 的值了。</p>
<p>从二维变成一维，相当于把二维中第一个维度变成循环滚动只有1行的数组dp[N]。</p>
<p>如果我们仍然从左往右计算dp[j]，那么可能存在污染，因为后面的数据根据前面递推而来，在滚动的时候可能要用到dp[i-1]（即上一次循环的数据时，实际上这个位置的数据已经在这次循环时被更新过了，用到的是dp[i]的数据，那么就出错了。</p>
<p>只有通过逆序枚举v，即从右往左滚动数组，这次计算dp[i]时依然根据上次循环递推而来，而且dp[i-v[i]]并没有被污染，才能得到正确结果。</p>
<p>模拟过程：<a href="https://www.acwing.com/activity/content/code/content/625657/">https://www.acwing.com/activity/content/code/content/625657/</a></p>
<p>我们注意到在处理数据时，我们是一个物品一个物品，一个一个体积的枚举。</p>
<p>因此我们可以不必开两个数组记录体积和价值，而是边输入边处理。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> v,w;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w; <span class="comment">// 边输入边处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m;j &gt;= v;j--)&#123;</span><br><span class="line">            dp[j] = max(dp[j],dp[j-v]+w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="思路二：闫氏DP法"><a href="#思路二：闫氏DP法" class="headerlink" title="思路二：闫氏DP法"></a>思路二：闫氏DP法</h5><p>y总思路，绝了！</p>
<p>根据数据范围，时间复杂度应控制为O(n^2)级别，所以状态表示最多两个维度。</p>
<p><img src="/posts/a75e4e46/image-20210508230814529.png" alt="image-20210508230814529"></p>
<p><img src="/posts/a75e4e46/image-20210508230735929.png" alt="image-20210508230735929"></p>
<h4 id="2-3-acwing-1015-摘花生（信息学奥赛一本通）"><a href="#2-3-acwing-1015-摘花生（信息学奥赛一本通）" class="headerlink" title="2.3 acwing.1015. 摘花生（信息学奥赛一本通）"></a>2.3 acwing.1015. 摘花生（信息学奥赛一本通）</h4><p>Hello Kitty想摘点花生送给她喜欢的米老鼠。</p>
<p>她来到一片有网格状道路的矩形花生地(如下图)，从西北角进去，东南角出来。</p>
<p>地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。</p>
<p>Hello Kitty只能向东或向南走，不能向西或向北走。</p>
<p>问Hello Kitty最多能够摘到多少颗花生。</p>
<p><img src="/posts/a75e4e46/image-20210509090458732.png" alt="image-20210509090458732"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入格式</span><br><span class="line">第一行是一个整数T，代表一共有多少组数据。</span><br><span class="line">接下来是T组数据。</span><br><span class="line">每组数据的第一行是两个整数，分别代表花生苗的行数R和列数 C。</span><br><span class="line">每组数据的接下来R行数据，从北向南依次描述每行花生苗的情况。每行数据有C个整数，按从西向东的顺序描述了该行每株花生苗上的花生数目M。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">对每组输入数据，输出一行，内容为Hello Kitty能摘到得最多的花生颗数。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤T≤<span class="number">100</span>,</span><br><span class="line"><span class="number">1</span>≤R,C≤<span class="number">100</span>,</span><br><span class="line"><span class="number">0</span>≤M≤<span class="number">1000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">5</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure>

<p>提示：2 2是第一组数据，2 3是第二组数据。</p>
<h5 id="思路一：闫氏DP法"><a href="#思路一：闫氏DP法" class="headerlink" title="思路一：闫氏DP法"></a>思路一：闫氏DP法</h5><p><img src="/posts/a75e4e46/image-20210509092231920.png" alt="image-20210509092231920"></p>
<p>关于边界问题，如果涉及到i-1，一般从1开始，否则从0开始，可以认为是一种准则。</p>
<p>时间复杂度为O(n^2)。空间复杂度为O(n^2)。</p>
<p>状态转移方程：<code>f[i][j] = max(f[i - 1][j], f[i][j - 1]) + a[i][j];</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][N],w[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,m;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)&#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; w[i][j];</span><br><span class="line">                <span class="comment">// 边读入边处理</span></span><br><span class="line">                f[i][j] = max(f[i<span class="number">-1</span>][j],f[i][j<span class="number">-1</span>]) + w[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; f[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进一步压缩空间，w[N][N]其实没必要</span></span><br><span class="line"><span class="keyword">while</span> (T--)&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; f[i][j];</span><br><span class="line">            <span class="comment">// 边读入边处理</span></span><br><span class="line">            f[i][j] += max(f[i<span class="number">-1</span>][j],f[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="思路二：滚动数组"><a href="#思路二：滚动数组" class="headerlink" title="思路二：滚动数组"></a>思路二：滚动数组</h5><p>参考自：<a href="https://blog.csdn.net/rabbit_ZAR/article/details/80141632?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162053109216780255296482%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162053109216780255296482&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-80141632.first_rank_v2_pc_rank_v29&utm_term=%E6%91%98%E8%8A%B1%E7%94%9F%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84">CSDN</a></p>
<ol>
<li>状态表示<br> 集合：定义<code>f[i][j]</code>为从(1, 1)到达(i, j)的所有方案<br> 属性：最大值</li>
<li>状态转移<br> (i, j)从(i-1, j)即上方过来<br> (i, j)从(i, j-1)即左方过来</li>
<li>空间压缩<br> <code>f[i][j]</code>只需要用到这一层和上一层的f元素，所以可以压缩成滚动数组。在此之上，还可以直接压缩成一维数组。</li>
</ol>
<p>时间复杂度为O(n^2)。空间复杂度为O(n)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> f[maxn+<span class="number">5</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">		<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));<span class="comment">//这步很重要，每组样例前先将f置零</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">				<span class="keyword">int</span> x;<span class="comment">//每次计算w[i][j]只需要用到当前值，所以用x就行</span></span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">				f[j]=max(f[j],f[j<span class="number">-1</span>])+x;<span class="comment">//滚动优化</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[m]);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>背包问题</tag>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（十七）</title>
    <url>/posts/b5ebe1a8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="4-4-acwing-1241-外卖店优先级"><a href="#4-4-acwing-1241-外卖店优先级" class="headerlink" title="4.4 acwing.1241. 外卖店优先级"></a>4.4 acwing.1241. 外卖店优先级</h4><p>第十届蓝桥杯省赛C++A/C组,第十届蓝桥杯省赛JAVAA/B/C组</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">“饱了么”外卖系统中维护着 N 家外卖店，编号 <span class="number">1</span>∼N。</span><br><span class="line">每家外卖店都有一个优先级，初始时 (<span class="number">0</span> 时刻) 优先级都为 <span class="number">0</span>。</span><br><span class="line">每经过 <span class="number">1</span> 个时间单位，如果外卖店没有订单，则优先级会减少 <span class="number">1</span>，最低减到 <span class="number">0</span>；而如果外卖店有订单，则优先级不减反加，每有一单优先级加 <span class="number">2</span>。</span><br><span class="line">如果某家外卖店某时刻优先级大于 <span class="number">5</span>，则会被系统加入优先缓存中；如果优先级小于等于 <span class="number">3</span>，则会被清除出优先缓存。</span><br><span class="line">给定 T 时刻以内的 M 条订单信息，请你计算 T 时刻时有多少外卖店在优先缓存中。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含 <span class="number">3</span> 个整数 N,M,T。</span><br><span class="line">以下 M 行每行包含两个整数 ts 和 id，表示 ts 时刻编号 id 的外卖店收到一个订单。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数代表答案。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤N,M,T≤<span class="number">10</span>^<span class="number">5</span>,</span><br><span class="line"><span class="number">1</span>≤ts≤T,</span><br><span class="line"><span class="number">1</span>≤id≤N</span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">6</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">6</span> <span class="number">2</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">1</span></span><br><span class="line">样例解释</span><br><span class="line"><span class="number">6</span> 时刻时，<span class="number">1</span> 号店优先级降到 <span class="number">3</span>，被移除出优先缓存；<span class="number">2</span> 号店优先级升到 <span class="number">6</span>，加入优先缓存。</span><br><span class="line">所以是有 <span class="number">1</span> 家店 (<span class="number">2</span> 号) 在优先缓存中。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>首先想到的就是直接按照题目要求模拟。</p>
<p><img src="/posts/b5ebe1a8/image-20210525221437334.png" alt="image-20210525221437334"></p>
<p>对于每个时间点，对有订单和无订单的店分别处理优先级，处理完之后判断状态，最后遍历所有店，输出在优</p>
<p>先缓存中的店的数量。</p>
<p>这种做法比较暴力，计算时间复杂度为O(T*N)，也就是10^10。肯定过不了，只能拿到部分分数。</p>
<p>想想怎么优化？</p>
<p>由于时间段被分割成不连续的一段段，因为不可能每个时刻每个店都有外卖，我们可以压缩没有外卖的时间，</p>
<p>在有外卖的时刻统一处理所有店的情况。</p>
<p><img src="/posts/b5ebe1a8/image-20210525223045237.png" alt="image-20210525223045237"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> score[N],last[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line">PII order[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;order[i].x,&amp;order[i].y);</span><br><span class="line">    sort(order,order + m);<span class="comment">// pair对sort会默认按双关键字排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;)&#123;<span class="comment">// 枚举订单</span></span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; m &amp;&amp; order[i] == order[j]) j++;<span class="comment">// 找到第一个不同的订单</span></span><br><span class="line">        <span class="keyword">int</span> cnt = j-i;</span><br><span class="line">        <span class="keyword">int</span> t = order[i].x,id = order[i].y;</span><br><span class="line">        i = j;<span class="comment">// 直接跳过同一家店同时的订单</span></span><br><span class="line">        score[id] -= t - last[id] - <span class="number">1</span>;<span class="comment">// 上次有订单到这次有订单减去相应的优先级</span></span><br><span class="line">        <span class="comment">// 当前有订单，所以多减1</span></span><br><span class="line">        <span class="keyword">if</span> (score[id] &lt; <span class="number">0</span>) score[id] = <span class="number">0</span>;<span class="comment">// 优先级最低为0</span></span><br><span class="line">        <span class="keyword">if</span> (score[id] &lt;= <span class="number">3</span>) st[id] = <span class="literal">false</span>;<span class="comment">// 如果在本次订单之前就出队就不需要在处理当前订单了</span></span><br><span class="line">		<span class="comment">// 以上是处理t时刻之前的信息</span></span><br><span class="line">        score[id] += cnt*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (score[id] &gt; <span class="number">5</span>) st[id] = <span class="literal">true</span>;<span class="comment">// 处理当前信息</span></span><br><span class="line"></span><br><span class="line">        last[id] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (last[i] &lt; T)&#123;<span class="comment">// 处理上一次有订单时刻到T时刻的信息</span></span><br><span class="line">            score[i] -= T - last[i];<span class="comment">// 对比上面，当前T时刻没有订单，不需要减1</span></span><br><span class="line">            <span class="keyword">if</span> (score[i] &lt;= <span class="number">3</span>) st[i] = <span class="literal">false</span>;<span class="comment">// T时刻没有订单了，只需要出队，不需要入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) res += st[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-acwing-788-逆序对的数量（模板题）"><a href="#4-5-acwing-788-逆序对的数量（模板题）" class="headerlink" title="4.5 acwing.788. 逆序对的数量（模板题）"></a>4.5 acwing.788. 逆序对的数量（模板题）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定一个长度为 n 的整数数列，请你计算数列中的逆序对的数量。</span><br><span class="line">逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i&lt;j 且 a[i]&gt;a[j]，则其为一个逆序对；否则不是。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含整数 n，表示数列的长度。</span><br><span class="line"></span><br><span class="line">第二行包含 n 个整数，表示整个数列。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示逆序对的个数。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤n≤<span class="number">100000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">1</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>首先提一下暴力做法，就是直接两层for循环，遍历数组求解逆序对数量，时间复杂度O(n^2)。</p>
<hr>
<p>再来优化，这题考察归并排序，利用分治思想。</p>
<p>我们先将序列从中间分开，按三种情况计算逆序对数量。</p>
<p>将逆序对分成三类：</p>
<p>1.两个元素都在左边；2.两个元素都在右边；3.两个元素一个在左一个在右；</p>
<p>然后计算逆序对的数量（序列）：</p>
<ol>
<li>递归算左边的；</li>
<li>递归算右边的；</li>
<li>算一个左一个右的；</li>
<li>把他们加到到一起。</li>
</ol>
<p><img src="/posts/b5ebe1a8/image-20210526132802029.png" alt="image-20210526132802029"></p>
<hr>
<p>参考<a href="https://www.bilibili.com/video/BV1Hv41167ft?share_source=copy_web">讲解视频</a>。</p>
<p>我们将单调递增的数组称为有序的。</p>
<p>归并排序的过程，其实也就是将<strong>逆序</strong>变成<strong>有序</strong>的过程，就是消灭逆序对。</p>
<p>只要把从逆序到有序的交换次数记下来，就是逆序对的数量。</p>
<p>涉及到交换元素的排序，首先想到的就是冒泡排序了，这是比暴力做法相对优化一步的做法了，但是不如归并</p>
<p>排序。对于冒泡排序，只要记录交换次数就行了。</p>
<p>这题实际上是归并排序的经典应用。</p>
<p>归并过程：1.将数组一分为二；2.递归划分数组，直到两边只有一个元素（此时有序）；3.归并，注意只有两</p>
<p>边都是有序的才能进行，无序则必须递归划分直到有序。</p>
<p>归并排序，时间复杂度当然是O(n*logn)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：当倒序时逆序对数量最多，等于n/2*(n-1)，约为5*10^9，用long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n,q[N],tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// l == r也可以</span></span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    LL res = merge_sort(l,mid) + merge_sort(mid+<span class="number">1</span>,r);<span class="comment">// 递归</span></span><br><span class="line">    <span class="comment">// 归并过程</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>,i = l,j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tmp[k++] = q[j++];</span><br><span class="line">            res += mid - i + <span class="number">1</span>;<span class="comment">// 计算逆序对</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫尾</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k++] = q[j++];</span><br><span class="line">    <span class="comment">// 物归原主，不要写错了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l,j = <span class="number">0</span>;i &lt;= r;i++,j++) q[i] = tmp[j];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">cin</span> &gt;&gt; q[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; merge_sort(<span class="number">0</span>,n<span class="number">-1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>归并</tag>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（十三）</title>
    <url>/posts/da5601cc.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="2-6-acwing-1214-波动数列"><a href="#2-6-acwing-1214-波动数列" class="headerlink" title="2.6 acwing.1214. 波动数列"></a>2.6 acwing.1214. 波动数列</h4><p>第五届蓝桥杯省赛C++A组,第五届蓝桥杯省赛JAVAA组</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">观察这个数列：</span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">0</span> <span class="number">2</span> <span class="number">-1</span> <span class="number">1</span> <span class="number">-2</span> …</span><br><span class="line">这个数列中后一项总是比前一项增加<span class="number">2</span>或者减少<span class="number">3</span>，且每一项都为整数。</span><br><span class="line">栋栋对这种数列很好奇，他想知道长度为 n 和为 s 而且后一项总是比前一项增加 a 或者减少 b 的整数数列可能有多少种呢？</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">共一行，包含四个整数 n,s,a,b，含义如前面所述。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">共一行，包含一个整数，表示满足条件的方案数。</span><br><span class="line">由于这个数很大，请输出方案数除以 <span class="number">100000007</span> 的余数。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤n≤<span class="number">1000</span>,</span><br><span class="line">−<span class="number">10</span>^<span class="number">9</span>≤s≤<span class="number">10</span>^<span class="number">9</span>,</span><br><span class="line"><span class="number">1</span>≤a,b≤<span class="number">10</span>^<span class="number">6</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">4</span> <span class="number">10</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">2</span></span><br><span class="line">样例解释</span><br><span class="line">两个满足条件的数列分别是<span class="number">2</span> <span class="number">4</span> <span class="number">1</span> <span class="number">3</span>和<span class="number">7</span> <span class="number">4</span> <span class="number">1</span> <span class="number">-2</span>。</span><br></pre></td></tr></table></figure>

<p>这题很有难度。（连y总都说有难度）</p>
<p>思路：</p>
<p>本质上是个组合问题。</p>
<p>这题组合维度太多，不能用dfs爆搜。</p>
<p>y总配套详细题解：<a href="https://www.acwing.com/solution/content/9223/">https://www.acwing.com/solution/content/9223/</a></p>
<p><img src="/posts/da5601cc/image-20210512171542868.png" alt="image-20210512171542868"></p>
<p>注意：数列的下标更换了，但是意义不变。</p>
<p><img src="/posts/da5601cc/image-20210512172520066.png" alt="image-20210512172520066"></p>
<p><img src="/posts/da5601cc/image-20210512172242772.png" alt="image-20210512172242772"></p>
<p>初始化条件：<code>f[0][0]=1</code>。</p>
<p>这题数组第二维不是单调变化的，不能去掉一维。</p>
<p>在数论中，余数都是非负的，例如：-2 % 10 = 8.但是C++中会得到负余数，所以要处理一下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>,MOD = <span class="number">100000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="keyword">int</span> n,s,a,b;</span><br><span class="line"><span class="comment">// 求a mod b的正余数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_mod</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a % b + b) % b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">            <span class="comment">//进行求正余数处理，否则会有负数出现，导致计算错误</span></span><br><span class="line">            f[i][j] = (f[i<span class="number">-1</span>][get_mod(j -i*a,n)] + f[i<span class="number">-1</span>][get_mod(j + i*b,n)]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 注意这里要求s mod n的正余数</span></span><br><span class="line">    <span class="comment">// 注意第一位是n-1，不是n</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n<span class="number">-1</span>][get_mod(s, n)] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不交换数组下标，写成这样也是可行（等价）的。</p>
<blockquote>
<p>系数和下标之和为n，所以第i项的的系数为n-i。</p>
<p>所以：<code>f[i][j] = f[i - 1][j - (n - i) * a]</code></p>
<p>第i个选b：同理：<code>f[i][j] = f[i - 1][j + (n - i) * b]</code></p>
</blockquote>
<h2 id="四-枚举、模拟与排序"><a href="#四-枚举、模拟与排序" class="headerlink" title="四 枚举、模拟与排序"></a>四 枚举、模拟与排序</h2><h3 id="1-枚举"><a href="#1-枚举" class="headerlink" title="1.枚举"></a>1.枚举</h3><h4 id="1-1-acwing-1210-连号区间数"><a href="#1-1-acwing-1210-连号区间数" class="headerlink" title="1.1 acwing.1210. 连号区间数"></a>1.1 acwing.1210. 连号区间数</h4><p>第四届蓝桥杯省赛C++B组,第四届蓝桥杯省赛JAVAB组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">小明这些天一直在思考这样一个奇怪而有趣的问题：</span><br><span class="line">在 <span class="number">1</span>∼N 的某个排列中有多少个连号区间呢？</span><br><span class="line">这里所说的连号区间的定义是：</span><br><span class="line">如果区间 [L,R] 里的所有元素（即此排列的第 L 个到第 R 个元素）递增排序后能得到一个长度为 R−L+<span class="number">1</span> 的“连续”数列，则称这个区间连号区间。</span><br><span class="line">当 N 很小的时候，小明可以很快地算出答案，但是当 N 变大的时候，问题就不是那么简单了，现在小明需要你的帮助。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行是一个正整数 N，表示排列的规模。</span><br><span class="line">第二行是 N 个不同的数字 Pi，表示这 N 个数字的某一排列。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示不同连号区间的数目。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤N≤<span class="number">10000</span>,</span><br><span class="line"><span class="number">1</span>≤Pi≤N</span><br><span class="line">输入样例<span class="number">1</span>：</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line">输出样例<span class="number">1</span>：</span><br><span class="line"><span class="number">7</span></span><br><span class="line">输入样例<span class="number">2</span>：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">2</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line">输出样例<span class="number">2</span>：</span><br><span class="line"><span class="number">9</span></span><br><span class="line">样例解释</span><br><span class="line">第一个用例中，有 <span class="number">7</span> 个连号区间分别是：[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">第二个用例中，有 <span class="number">9</span> 个连号区间分别是：[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>考察数据范围10000，知道时间复杂度大致是O(n*logn)比较合理，实在不行O(n^2)也勉强能行。</p>
<p>先写暴力解法，再优化。</p>
<p><img src="/posts/da5601cc/image-20210512214728921.png" alt="image-20210512214728921"></p>
<p>排列说明无重复数字。</p>
<p>”不难“发现，连续区间等价于<code>Max - Min = b - a</code>。因为没有重复数字，刚好填满区间，无空缺。</p>
<p>优化之后，枚举第二重循环同时求最大最小值并判断连续区间。</p>
<p><img src="/posts/da5601cc/image-20210512215551164.png" alt="image-20210512215551164"></p>
<p>由于代码量比较小，所以执行的指令较少，时间复杂度的常数比较小，是能AC的。</p>
<p>时间复杂度：O(n^2)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>,INF = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i  = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;<span class="comment">// 枚举区间左端点</span></span><br><span class="line">        <span class="keyword">int</span> maxv = -INF,minv = INF;<span class="comment">// 注意不要写反了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; n;j ++)&#123;<span class="comment">// 枚举区间右端点</span></span><br><span class="line">            maxv  = max(maxv,a[j]);</span><br><span class="line">            minv = min(minv,a[j]);</span><br><span class="line">            <span class="keyword">if</span> (maxv - minv == j - i) res ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（十二）</title>
    <url>/posts/9748a29e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="2-4-acwing-895-最长上升子序列（模板题）"><a href="#2-4-acwing-895-最长上升子序列（模板题）" class="headerlink" title="2.4 acwing.895. 最长上升子序列（模板题）"></a>2.4 acwing.895. 最长上升子序列（模板题）</h4><p>最长上升子序列也是一类经典的DP问题。</p>
<p>Longest Increasing Sequence，简称LIS。 </p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。</span><br><span class="line">    </span><br><span class="line">输入格式</span><br><span class="line">第一行包含整数 N。</span><br><span class="line">第二行包含 N 个整数，表示完整序列。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示最大长度。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤N≤<span class="number">1000</span>，</span><br><span class="line">−<span class="number">10</span>^<span class="number">9</span>≤数列中的数≤<span class="number">10</span>^<span class="number">9</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">8</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">输出样例：（<span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">6</span>）</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>附上一份优秀题解：<a href="https://www.acwing.com/solution/content/4807/">https://www.acwing.com/solution/content/4807/</a></p>
<h5 id="思路一：闫氏DP法"><a href="#思路一：闫氏DP法" class="headerlink" title="思路一：闫氏DP法"></a>思路一：闫氏DP法</h5><p><img src="/posts/9748a29e/image-20210509155456233.png" alt="image-20210509155456233"></p>
<p>代码：</p>
<p>时间复杂度：O(n^2)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N],a[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;<span class="comment">//边界初始条件，假设倒数第二个数不存在</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[i])&#123;</span><br><span class="line">                f[i] = max(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) res = max(res,f[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="思路二：DP-二分"><a href="#思路二：DP-二分" class="headerlink" title="思路二：DP+二分"></a>思路二：DP+二分</h5><p>时间复杂度：O(n*logn)。</p>
<p><img src="/posts/9748a29e/image-20210509163844107.png" alt="image-20210509163844107"></p>
<ul>
<li>状态表示：f[i]表示长度为i的最长上升子序列，末尾最小的数字。(长度为i的最长上升子序列所有结尾中，结尾最小min的) 即长度为i的子序列末尾最小元素是什么。</li>
</ul>
<ul>
<li>状态计算：对于每一个w[i], 如果大于<code>f[cnt-1]</code>(<strong>下标从0开始</strong>，cnt长度的最长上升子序列，末尾最小的数字)，那就cnt+1，使得最长上升序列长度+1，当前末尾最小元素为w[i]。 若w[i]小于等于f[cnt-1],说明不会更新当前的长度，但之前末尾的最小元素要发生变化，找到第一个大于或等于 (这里不能是大于) w[i]，更新以那时候末尾的最小元素。</li>
</ul>
<ul>
<li>f[i]一定是一个单调递增的数组，所以可以用二分法来找第一个大于或等于w[i]的数字。（可以用STL）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N],w[N];</span><br><span class="line"><span class="keyword">int</span> n,cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    f[cnt++] = w[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (w[i] &gt; f[cnt<span class="number">-1</span>]) f[cnt++] = w[i];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//注意二分的左边界一定要是f[0]</span></span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>,r = cnt<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = l+r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (w[i] &lt;= f[mid]) r = mid;</span><br><span class="line">                <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// STL写法</span></span><br><span class="line">            <span class="comment">//int r = lower_bound(f,f+cnt-1,w[i])-f;</span></span><br><span class="line">            f[r] = w[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-acwing-1212-地宫取宝"><a href="#2-5-acwing-1212-地宫取宝" class="headerlink" title="2.5 acwing.1212. 地宫取宝"></a>2.5 acwing.1212. 地宫取宝</h4><p>第五届蓝桥杯省赛C++A/B/C组,第五届蓝桥杯省赛JAVAB/C组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">X 国王有一个地宫宝库，是 n×m 个格子的矩阵，每个格子放一件宝贝，每个宝贝贴着价值标签。</span><br><span class="line">地宫的入口在左上角，出口在右下角。</span><br><span class="line">小明被带到地宫的入口，国王要求他只能向右或向下行走。</span><br><span class="line">走过某个格子时，如果那个格子中的宝贝价值比小明手中任意宝贝价值都大，小明就可以拿起它（当然，也可以不拿）。</span><br><span class="line">当小明走到出口时，如果他手中的宝贝恰好是 k 件，则这些宝贝就可以送给小明。</span><br><span class="line">请你帮小明算一算，在给定的局面下，他有多少种不同的行动方案能获得这 k 件宝贝。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行 <span class="number">3</span> 个整数，n,m,k，含义见题目描述。</span><br><span class="line">接下来 n 行，每行有 m 个整数 Ci 用来描述宝库矩阵每个格子的宝贝价值。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示正好取 k 个宝贝的行动方案数。</span><br><span class="line">该数字可能很大，输出它对 <span class="number">1000000007</span> 取模的结果。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤n,m≤<span class="number">50</span>,</span><br><span class="line"><span class="number">1</span>≤k≤<span class="number">12</span>,</span><br><span class="line"><span class="number">0</span>≤Ci≤<span class="number">12</span></span><br><span class="line">输入样例<span class="number">1</span>：</span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line">输出样例<span class="number">1</span>：</span><br><span class="line"><span class="number">2</span></span><br><span class="line">输入样例<span class="number">2</span>：</span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">5</span></span><br><span class="line">输出样例<span class="number">2</span>：</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure>

<p>摘花生的拓展题。这道题有难度，其实是摘花生和最长上升子序列的结合题。</p>
<h5 id="思路一：闫氏DP法-1"><a href="#思路一：闫氏DP法-1" class="headerlink" title="思路一：闫氏DP法"></a>思路一：闫氏DP法</h5><p>注意：f数组表示的是满足条件的<strong>方案个数</strong>。</p>
<p><img src="/posts/9748a29e/image-20210509192255287.png" alt="image-20210509192255287"></p>
<p>初始化条件：</p>
<ol>
<li><code>f(1,1,1,w(1,1)) = 1</code>，取第一件宝物，1种方案；</li>
<li><code>f(1,1,0,-1） = 1</code>，不取第一件宝物，1种方案，下标不能为负数，要处理一下，设为-1是保证之后遇到的第一件任何宝物都能取到。（考虑-1到12，注意不能是0，题目Ci可以等于0且要求严格递增，转化为0到13）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">55</span>,MOD = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> w[N][N];</span><br><span class="line"><span class="keyword">int</span> f[N][N][<span class="number">13</span>][<span class="number">14</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w[i][j];</span><br><span class="line">            w[i][j]++;</span><br><span class="line">        &#125;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>][w[<span class="number">1</span>][<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>;u &lt;= k;u++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>;v &lt;= <span class="number">13</span>;v++)&#123;</span><br><span class="line">                    <span class="comment">//引用，因为要对数组修改</span></span><br><span class="line">                    <span class="keyword">int</span> &amp;val = f[i][j][u][v];</span><br><span class="line">                    <span class="comment">//最多加上两个数取模，不然爆int</span></span><br><span class="line">                    val = (val + f[i<span class="number">-1</span>][j][u][v]) % MOD;</span><br><span class="line">                    val = (val + f[i][j<span class="number">-1</span>][u][v]) % MOD;</span><br><span class="line">                    <span class="keyword">if</span> (u &gt; <span class="number">0</span> &amp;&amp; v == w[i][j])&#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>;c &lt; v;c++)&#123;</span><br><span class="line">                            val = (val + f[i<span class="number">-1</span>][j][u<span class="number">-1</span>][c]) % MOD;</span><br><span class="line">                            val = (val + f[i][j<span class="number">-1</span>][u<span class="number">-1</span>][c]) % MOD;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">13</span>;i++) res = (res + f[n][m][k][i]) % MOD;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h5><p>附上一份大佬题解：<a href="https://www.acwing.com/solution/content/7116/">https://www.acwing.com/solution/content/7116/</a></p>
<p>这两种方法都是枚举当前状态 第一种方法是不是就是由当前状态往前推 第二种就是由当前状态往后推 也就是 1. 之前——&gt; 当前 2. 当前——&gt; 后面</p>
<p>y总的DP分析就是由当前状态往前推。</p>
<p>两种枚举方法最好都要掌握。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>二分</tag>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（十九）</title>
    <url>/posts/384de8b4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="2-2-acwing-1113-红与黑（信息学奥赛一本通）"><a href="#2-2-acwing-1113-红与黑（信息学奥赛一本通）" class="headerlink" title="2.2 acwing.1113. 红与黑（信息学奥赛一本通）"></a>2.2 acwing.1113. 红与黑（信息学奥赛一本通）</h4><span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。</span><br><span class="line">你站在其中一块黑色的瓷砖上，只能向相邻（上下左右四个方向）的黑色瓷砖移动。</span><br><span class="line">请写一个程序，计算你总共能够到达多少块黑色的瓷砖。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">输入包括多个数据集合。</span><br><span class="line">每个数据集合的第一行是两个整数 W 和 H，分别表示 x 方向和 y 方向瓷砖的数量。</span><br><span class="line">在接下来的 H 行中，每行包括 W 个字符。每个字符表示一块瓷砖的颜色，规则如下</span><br><span class="line"><span class="number">1</span>）‘.’：黑色的瓷砖；</span><br><span class="line"><span class="number">2</span>）‘#’：红色的瓷砖；</span><br><span class="line"><span class="number">3</span>）‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。</span><br><span class="line">当在一行中读入的是两个零时，表示输入结束。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤W,H≤<span class="number">20</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">6</span> <span class="number">9</span> </span><br><span class="line">....#. </span><br><span class="line">.....# </span><br><span class="line">...... </span><br><span class="line">...... </span><br><span class="line">...... </span><br><span class="line">...... </span><br><span class="line">...... </span><br><span class="line">#@...# </span><br><span class="line">.#..#. </span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">45</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>考察Flood Fill（洪水灌溉）算法。</p>
<p>对于一个网格图，部分是陆地，部分是海洋，给定一个初始陆地块，找出它所在的连通块，用到上述算法。</p>
<p>可以用BFS和DFS实现，BFS可以求出最短距离，但是DFS用起来更方便一写，在某些情况下可能有爆栈风</p>
<p>险。</p>
<p><strong>1.BFS算法</strong></p>
<p>时间复杂度：O(W*H)。</p>
<p>BFS伪代码：</p>
<p><img src="/posts/384de8b4/image-20210527111336765.png" alt="image-20210527111336765"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(PII start)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;PII&gt; q;</span><br><span class="line">    q.push(start);</span><br><span class="line">    g[start.x][start.y] = <span class="string">&#x27;#&#x27;</span>;<span class="comment">// 走过的格子标记为#</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dx[] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.size())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        res++;<span class="comment">// 每出队一个格子，答案+1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = t.x + dx[i],y = t.y + dy[i];</span><br><span class="line">            <span class="comment">// 判断是否出界或者走过</span></span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m || g[x][y] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            g[x][y] = <span class="string">&#x27;#&#x27;</span>;<span class="comment">// 走过的格子标记为#</span></span><br><span class="line">            q.push(&#123;x,y&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n,n &amp;&amp; m)&#123;</span><br><span class="line">        PII start;</span><br><span class="line">        <span class="comment">// 对于g数组，因为下一个样例会读入新的数据将g数组覆盖，所以初始化可做可不做</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">cin</span> &gt;&gt; g[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;@&#x27;</span>) start = &#123;i,j&#125;;<span class="comment">// 可以break提前退出</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,bfs(start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.DFS算法</strong></p>
<p>时间复杂度：O(W*H)。代码量比BFS稍短。</p>
<p><img src="/posts/384de8b4/image-20210527131046394.png" alt="image-20210527131046394"></p>
<p>DFS：从一个格子搜到底，然后回溯到上一层，继续搜到底，最后回溯到起点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    g[x][y] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> xx = x+dx[i],yy = y+dy[i];</span><br><span class="line">        <span class="keyword">if</span> (xx &gt;= <span class="number">0</span> &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= <span class="number">0</span> &amp;&amp; yy &lt; m &amp;&amp; g[xx][yy] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            res += dfs(xx,yy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n))&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,g[i]);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>,y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;@&#x27;</span>)&#123;</span><br><span class="line">                    x = i,y = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dfs(x,y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-图论"><a href="#3-图论" class="headerlink" title="3.图论"></a>3.图论</h3><h4 id="3-1-acwing-1224-交换瓶子"><a href="#3-1-acwing-1224-交换瓶子" class="headerlink" title="3.1 acwing.1224. 交换瓶子"></a>3.1 acwing.1224. 交换瓶子</h4><p>第七届蓝桥杯省赛C++B组,第七届蓝桥杯省赛JAVAA组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">有 N 个瓶子，编号 <span class="number">1</span>∼N，放在架子上。</span><br><span class="line">比如有 <span class="number">5</span> 个瓶子：</span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line">要求每次拿起 <span class="number">2</span> 个瓶子，交换它们的位置。</span><br><span class="line">经过若干次后，使得瓶子的序号为：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">对于这么简单的情况，显然，至少需要交换 <span class="number">2</span> 次就可以复位。</span><br><span class="line">如果瓶子更多呢？你可以通过编程来解决。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含一个整数 N，表示瓶子数量。</span><br><span class="line">第二行包含 N 个整数，表示瓶子目前的排列状况。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个正整数，表示至少交换多少次，才能完成排序。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤N≤<span class="number">10000</span>,</span><br><span class="line"></span><br><span class="line">输入样例<span class="number">1</span>：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line">输出样例<span class="number">1</span>：</span><br><span class="line"><span class="number">3</span></span><br><span class="line">输入样例<span class="number">2</span>：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line">输出样例<span class="number">2</span>：</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>算法1：暴力枚举，时间复杂度：O(n^2)</p>
<p>这道题是一道类似于模拟的题，实际思路就是遍历数位，发现和他应有顺序不同的，就从他后面（i+1-&gt;n)寻</p>
<p>找相同的，然后将二者交换，之后再往后遍历到n即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],n,t;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[j]==i)</span><br><span class="line">                &#123;</span><br><span class="line">                    t=a[i];</span><br><span class="line">                    a[i]=a[j];</span><br><span class="line">                    a[j]=t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">作者：田所浩二</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/6983/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>算法2：图论，时间复杂度：O(n)</p>
<p>把每个点都遍历一次，O(n)。</p>
<p>图片来源：<a href="https://www.acwing.com/solution/content/7917/%E3%80%82">https://www.acwing.com/solution/content/7917/。</a></p>
<p><img src="/posts/384de8b4/image-20210527144519837.png" alt="image-20210527144519837"></p>
<p><img src="/posts/384de8b4/image-20210527144700090.png" alt="image-20210527144700090"></p>
<p>一般来看：</p>
<p>情况1：交换同一个环内的点，会裂成两个环。</p>
<p>情况2：交换不同环内的点，会合成一个环。</p>
<p>下图是我手绘的。</p>
<p><img src="/posts/384de8b4/image-20210527150734505.png" alt="image-20210527150734505"></p>
<p>假设对于给定的瓶子顺序，构成k个环，我们把它们从小到大排列，一共是n个环，<strong>至少需要n-k次</strong>。</p>
<p>所以原问题就转化成了如何<strong>求环的数量k</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> st[N];<span class="comment">// 判重数组</span></span><br><span class="line"><span class="keyword">int</span> b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="comment">// 下标从1开始，编号与位置统一</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;<span class="comment">// 计算环的数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">if</span> (!st[i])&#123;<span class="comment">//如果没有标记过, 说明这个点在一个新的环中</span></span><br><span class="line">            cnt ++;<span class="comment">// 环数+1</span></span><br><span class="line">            <span class="comment">// 把这个点能到的所有点全部标记一下</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;!st[j];j = b[j])<span class="comment">// 遍历环</span></span><br><span class="line">                st[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n-cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>BFS</tag>
        <tag>图论</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（十五）</title>
    <url>/posts/2e5ddee.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="2-模拟"><a href="#2-模拟" class="headerlink" title="2.模拟"></a>2.模拟</h3><h4 id="2-1-acwing-1204-错误票据"><a href="#2-1-acwing-1204-错误票据" class="headerlink" title="2.1 acwing.1204. 错误票据"></a>2.1 acwing.1204. 错误票据</h4><p>第四届蓝桥杯省赛C++A/B组,第四届蓝桥杯省赛JAVAA/B组</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">某涉密单位下发了某种票据，并要在年终全部收回。</span><br><span class="line">每张票据有唯一的ID号。</span><br><span class="line">全年所有票据的ID号是连续的，但ID的开始数码是随机选定的。</span><br><span class="line">因为工作人员疏忽，在录入ID号的时候发生了一处错误，造成了某个ID断号，另外一个ID重号。</span><br><span class="line">你的任务是通过编程，找出断号的ID和重号的ID。</span><br><span class="line">假设断号不可能发生在最大和最小号。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含整数 N，表示后面共有 N 行数据。</span><br><span class="line">接下来 N 行，每行包含空格分开的若干个（不大于<span class="number">100</span>个）正整数（不大于<span class="number">100000</span>），每个整数代表一个ID号。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">要求程序输出<span class="number">1</span>行，含两个整数 m,n，用空格分隔。</span><br><span class="line">其中，m表示断号ID，n表示重号ID。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤N≤<span class="number">100</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">11</span> <span class="number">9</span> </span><br><span class="line"><span class="number">10</span> <span class="number">12</span> <span class="number">9</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">7</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>这题关键在于输入的处理问题。</p>
<p>两种解法，时间差不多。</p>
<p><img src="/posts/2e5ddee/image-20210515203853514.png" alt="image-20210515203853514"></p>
<p>断号：应该是<code>m = a[i]-1</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题解1，y总代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="built_in">string</span> line;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; cnt;</span><br><span class="line">    getline(<span class="built_in">cin</span>,line);</span><br><span class="line">    <span class="keyword">while</span> (cnt --)&#123;</span><br><span class="line">        getline(<span class="built_in">cin</span>,line);</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ssin</span><span class="params">(line)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (ssin &gt;&gt; a[n]) n++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(a,a+n);</span><br><span class="line">    <span class="keyword">int</span> res1,res2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == a[i<span class="number">-1</span>]) res2 = a[i]; <span class="comment">// 重号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == a[i<span class="number">-1</span>] + <span class="number">2</span>) res1 = a[i]<span class="number">-1</span>; <span class="comment">// 断号</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; res2 &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line"><span class="comment">// 题解2</span></span><br><span class="line"><span class="comment">// 找出最大和最小的数，同时再用一个数组记录每个数字的个数，最后遍历一遍即可</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>,M=<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> line,i=<span class="number">0</span>,Min=<span class="number">100001</span>,Max=<span class="number">0</span>,a;</span><br><span class="line">    <span class="keyword">int</span> n,m; <span class="comment">//m表示断号ID，n表示重号ID</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;line;</span><br><span class="line">    <span class="keyword">while</span>(line--)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a)&#123;</span><br><span class="line">            cnt[a]++;</span><br><span class="line">            Max=max(Max,a);</span><br><span class="line">            Min=min(Min,a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=Min;j&lt;Max;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[j]==<span class="number">0</span>) m=j;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt[j]==<span class="number">2</span>) n=j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-acwing-466-回文日期"><a href="#2-2-acwing-466-回文日期" class="headerlink" title="2.2 acwing.466. 回文日期"></a>2.2 acwing.466. 回文日期</h4><p>NOIP2016普及组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">在日常生活中，通过年、月、日这三个要素可以表示出一个唯一确定的日期。</span><br><span class="line">牛牛习惯用 <span class="number">8</span> 位数字表示一个日期，其中，前 <span class="number">4</span> 位代表年份，接下来 <span class="number">2</span> 位代表月份，最后 <span class="number">2</span> 位代表日期。</span><br><span class="line">显然：一个日期只有一种表示方法，而两个不同的日期的表示方法不会相同。</span><br><span class="line">牛牛认为，一个日期是回文的，当且仅当表示这个日期的 <span class="number">8</span> 位数字是回文的。</span><br><span class="line">现在，牛牛想知道：在他指定的两个日期之间（包含这两个日期本身），有多少个真实存在的日期是回文的。</span><br><span class="line">一个 <span class="number">8</span> 位数字是回文的，当且仅当对于所有的 i(<span class="number">1</span>≤i≤<span class="number">8</span>) 从左向右数的第 i 个数字和第 <span class="number">9</span>−i 个数字（即从右向左数的第 i 个数字）是相同的。</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">对于 <span class="number">2016</span> 年 <span class="number">11</span> 月 <span class="number">19</span> 日，用 <span class="number">8</span> 位数字 <span class="number">20161119</span> 表示，它不是回文的。</span><br><span class="line">对于 <span class="number">2010</span> 年 <span class="number">1</span> 月 <span class="number">2</span> 日，用 <span class="number">8</span> 位数字 <span class="number">20100102</span> 表示，它是回文的。</span><br><span class="line">对于 <span class="number">2010</span> 年 <span class="number">10</span> 月 <span class="number">2</span> 日，用 <span class="number">8</span> 位数字 <span class="number">20101002</span> 表示，它不是回文的。</span><br><span class="line">输入格式</span><br><span class="line">输入包括两行，每行包括一个 <span class="number">8</span> 位数字。</span><br><span class="line"></span><br><span class="line">第一行表示牛牛指定的起始日期 date1，第二行表示牛牛指定的终止日期 date2。保证 date1 和 date2 都是真实存在的日期，且年份部分一定为 <span class="number">4</span> 位数字，且首位数字不为 <span class="number">0</span>。</span><br><span class="line">保证 date1 一定不晚于 date2。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出共一行，包含一个整数，表示在 date1 和 date2 之间，有多少个日期是回文的。</span><br><span class="line"></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">20110101</span></span><br><span class="line"><span class="number">20111231</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ol>
<li>先枚举回文数（1000~9999）</li>
<li>再判断是否在给定范围内</li>
<li>最后判断日期是否合法</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> days[<span class="number">13</span>] = &#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_valid</span><span class="params">(<span class="keyword">int</span> date)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = date / <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">int</span> m = date % <span class="number">10000</span> / <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> d = date % <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span> || m &gt;= <span class="number">13</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (d == <span class="number">0</span> || d &gt; days[m] &amp;&amp; m != <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> leap = y % <span class="number">100</span> &amp;&amp; y % <span class="number">4</span> == <span class="number">0</span> || y % <span class="number">400</span> == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (d &gt; <span class="number">28</span> + leap) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> date1,date2;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; date1 &gt;&gt; date2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1000</span>;i &lt; <span class="number">10000</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> date = i,x = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j++) date = date*<span class="number">10</span> + x%<span class="number">10</span>,x /= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (date &gt;= date1 &amp;&amp; date &lt;= date2 &amp;&amp; check_valid(date))&#123;</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-排序"><a href="#3-排序" class="headerlink" title="3.排序"></a>3.排序</h3><h4 id="3-1-acwing-787-归并排序（模板题）"><a href="#3-1-acwing-787-归并排序（模板题）" class="headerlink" title="3.1 acwing.787. 归并排序（模板题）"></a>3.1 acwing.787. 归并排序（模板题）</h4><p>建议先看看这篇文章<a href="https://www.grantdrew.top/posts/2aed1d1d.html">two pointers思想与归并排序</a>，会更好理解归并排序。</p>
<p>蓝桥杯里遇到要用快速排序解决的问题，一般用库函数sort就行了，在基础课再写快排。</p>
<!--more-->

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给定你一个长度为 n 的整数数列。</span><br><span class="line">请你使用归并排序对这个数列按照从小到大进行排序。</span><br><span class="line">并将排好序的数列按顺序输出。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">输入共两行，第一行包含整数 n。</span><br><span class="line">第二行包含 n 个整数（所有整数均在 <span class="number">1</span>∼<span class="number">109</span> 范围内），表示整个数列。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出共一行，包含 n 个整数，表示排好序的数列。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤n≤<span class="number">100000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>归并排序的关键在于如何将两个区间合二为一。</p>
<p>我们要用到双指针算法。</p>
<p>时间复杂度：O(n*logn)。</p>
<p>将长度为n的数组递归，不断划分为两个子区间，一共logn层。</p>
<p>每一层又需要O(n)的时间复杂度进行扫描两个区间。</p>
<ol>
<li>先确定数组中点mid作为分界点</li>
<li>再递归将数组分为两半排序</li>
<li>最后归并，将两半数组有序合并</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> q[N],tmp[N];<span class="comment">// tmp临时存放合并的数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = l+r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    merge_sort(q,l,mid),merge_sort(q,mid+<span class="number">1</span>,r);<span class="comment">// 递归</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>,i = l,j = mid + <span class="number">1</span>;<span class="comment">// 合并两个有序数组</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">        <span class="comment">// 这里取等号使排序稳定</span></span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k++] = q[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k++] = q[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l,j = <span class="number">0</span>;i &lt;= r;i++,j++) q[i] = tmp[j];<span class="comment">// 合并后的数组存回q</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line"></span><br><span class="line">    merge_sort(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 题解2，python实现</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">list1 = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">list1</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(list1) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    mid = <span class="built_in">len</span>(list1) // <span class="number">2</span></span><br><span class="line">    <span class="comment"># 将一个list分为两份地时候产生两个新list，L和R，从而避免了边界问题和映射时地对齐问题</span></span><br><span class="line">    L = list1[:mid]</span><br><span class="line">    R = list1[mid:]</span><br><span class="line">    merge_sort(L)</span><br><span class="line">    merge_sort(R)</span><br><span class="line"></span><br><span class="line">    i = j = k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(L) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(R):</span><br><span class="line">        <span class="keyword">if</span> L[i] &lt;= R[j]:</span><br><span class="line">            list1[k] = L[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            list1[k] = R[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(L):</span><br><span class="line">        list1[k] = L[i]</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(R):</span><br><span class="line">        list1[k] = R[j]</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    merge_sort(list1)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> list1:</span><br><span class="line">        print(i, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line">作者：Crispin</span><br><span class="line">链接：https://www.acwing.com/solution/content/<span class="number">4628</span>/</span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（十八）</title>
    <url>/posts/4280c9eb.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="五-双指针、BFS与图论"><a href="#五-双指针、BFS与图论" class="headerlink" title="五 双指针、BFS与图论"></a>五 双指针、BFS与图论</h2><p>暂时先跳过树状数组与线段树了。（在基础的算法中好像用不太多，比较高级）</p>
<h3 id="1-双指针算法"><a href="#1-双指针算法" class="headerlink" title="1.双指针算法"></a>1.双指针算法</h3><p>双指针思想可以参考：<a href="https://www.grantdrew.top/posts/2aed1d1d.html">这篇文章</a>。</p>
<p>语法课也简单介绍过第一类双指针算法。 </p>
<h4 id="1-1-acwing-1238-日志统计"><a href="#1-1-acwing-1238-日志统计" class="headerlink" title="1.1 acwing.1238. 日志统计"></a>1.1 acwing.1238. 日志统计</h4><p>第九届蓝桥杯省赛C++B组,第九届蓝桥杯省赛JAVAB组</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">小明维护着一个程序员论坛。现在他收集了一份”点赞”日志，日志共有 N 行。</span><br><span class="line">其中每一行的格式是：</span><br><span class="line">ts id  </span><br><span class="line">表示在 ts 时刻编号 id 的帖子收到一个”赞”。</span><br><span class="line">现在小明想统计有哪些帖子曾经是”热帖”。</span><br><span class="line">如果一个帖子曾在任意一个长度为 D 的时间段内收到不少于 K 个赞，小明就认为这个帖子曾是”热帖”。</span><br><span class="line">具体来说，如果存在某个时刻 T 满足该帖在 [T,T+D) 这段时间内(注意是左闭右开区间)收到不少于 K 个赞，该帖就曾是”热帖”。</span><br><span class="line">给定日志，请你帮助小明统计出所有曾是”热帖”的帖子编号。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含三个整数 N,D,K。</span><br><span class="line">以下 N 行每行一条日志，包含两个整数 ts 和 id。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">按从小到大的顺序输出热帖 id。</span><br><span class="line">每个 id 占一行。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤K≤N≤<span class="number">10</span>^<span class="number">5</span>,</span><br><span class="line"><span class="number">0</span>≤ts,id≤<span class="number">10</span>^<span class="number">5</span>,</span><br><span class="line"><span class="number">1</span>≤D≤<span class="number">10000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">7</span> <span class="number">10</span> <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">10</span></span><br><span class="line"><span class="number">10</span> <span class="number">10</span></span><br><span class="line"><span class="number">10</span> <span class="number">1</span></span><br><span class="line"><span class="number">9</span> <span class="number">1</span></span><br><span class="line"><span class="number">100</span> <span class="number">3</span></span><br><span class="line"><span class="number">100</span> <span class="number">3</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>思路：（这题和外卖优先级特别像）</p>
<p>暴力做法：枚举时间段，再枚举id，判断该时间段内每个id的点赞数量是否达到k，达到就退出，设为热帖。</p>
<p>最后枚举所有帖子，统计热帖数量。时间复杂度为O(n^2)。</p>
<p><img src="/posts/4280c9eb/image-20210526174211746.png" alt="image-20210526174211746"></p>
<p>然后再看看怎么优化？</p>
<p><img src="/posts/4280c9eb/image-20210526175137209.png" alt="image-20210526175137209"></p>
<p>统计时间段内每个id的点赞数量时，我们发现两个时间段会有重复计算的部分，可以优化，对于第2个时间段的点赞数量，只要再第1个时间段的基础上减去i时间的数量，再加上j时间的数量就行。</p>
<p>核心步骤：i在前面走，j跟着后面走，i和j维护长度不大于d的区间，若超过了d，则j前进进行区间回缩</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">// 放前面</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">PII logs[N];</span><br><span class="line"><span class="keyword">int</span> n,d,k;</span><br><span class="line"><span class="keyword">bool</span> st[N];<span class="comment">// 热帖标志</span></span><br><span class="line"><span class="keyword">int</span> cnt[N];<span class="comment">// 统计点赞数量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;d,&amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;logs[i].x,&amp;logs[i].y);</span><br><span class="line">    sort(logs,logs + n);<span class="comment">// 对帖子按时间、id排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双指针算法，i走前面，j走后面</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = logs[i].y;</span><br><span class="line">        cnt[t] ++;<span class="comment">// id为t的帖子点赞+1</span></span><br><span class="line">        <span class="keyword">while</span> (logs[i].x - logs[j].x &gt;= d)&#123;</span><br><span class="line">            cnt[logs[j].y] --;<span class="comment">// 当i和j时间跨度&gt;=d时，j处的点赞失效</span></span><br><span class="line">            j ++;<span class="comment">// j向前移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt[t] &gt;= k) st[t] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有帖子的id，输出热帖，id &lt;= 1e5</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">1e5</span>;i++) <span class="keyword">if</span> (st[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-BFS算法"><a href="#2-BFS算法" class="headerlink" title="2.BFS算法"></a>2.BFS算法</h3><p>BFS，也即广度优先搜索。</p>
<p>深搜与宽搜的区别：BFS一般用队列实现，DFS一般用递归实现。</p>
<p><img src="/posts/4280c9eb/image-20210526222122194.png" alt="image-20210526222122194"></p>
<p>与树的遍历的关系：</p>
<p>DFS是先序遍历，BFS是层次遍历。</p>
<p>BFS算法过程：队列实现，加入和取出元素的顺序就是层次遍历。</p>
<p><img src="/posts/4280c9eb/image-20210526222608466.png" alt="image-20210526222608466"></p>
<p>模板：</p>
<p><img src="/posts/4280c9eb/image-20210526222954401.png" alt="image-20210526222954401"></p>
<p>y总推荐：CSAPP，神书，很费时间；算法导论，当字典查，有些东西已经过时。</p>
<h4 id="2-1-acwing-1101-献给阿尔吉侬的花束（信息学奥赛一本通）"><a href="#2-1-acwing-1101-献给阿尔吉侬的花束（信息学奥赛一本通）" class="headerlink" title="2.1 acwing.1101. 献给阿尔吉侬的花束（信息学奥赛一本通）"></a>2.1 acwing.1101. 献给阿尔吉侬的花束（信息学奥赛一本通）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">阿尔吉侬是一只聪明又慵懒的小白鼠，它最擅长的就是走各种各样的迷宫。</span><br><span class="line">今天它要挑战一个非常大的迷宫，研究员们为了鼓励阿尔吉侬尽快到达终点，就在终点放了一块阿尔吉侬最喜欢的奶酪。</span><br><span class="line">现在研究员们想知道，如果阿尔吉侬足够聪明，它最少需要多少时间就能吃到奶酪。</span><br><span class="line">迷宫用一个 R×C 的字符矩阵来表示。</span><br><span class="line">字符 S 表示阿尔吉侬所在的位置，字符 E 表示奶酪所在的位置，字符 # 表示墙壁，字符 . 表示可以通行。</span><br><span class="line">阿尔吉侬在 <span class="number">1</span> 个单位时间内可以从当前的位置走到它上下左右四个方向上的任意一个位置，但不能走出地图边界。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行是一个正整数 T，表示一共有 T 组数据。</span><br><span class="line">每一组数据的第一行包含了两个用空格分开的正整数 R 和 C，表示地图是一个 R×C 的矩阵。</span><br><span class="line">接下来的 R 行描述了地图的具体内容，每一行包含了 C 个字符。字符含义如题目描述中所述。保证有且仅有一个 S 和 E。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">对于每一组数据，输出阿尔吉侬吃到奶酪的最少单位时间。</span><br><span class="line">若阿尔吉侬无法吃到奶酪，则输出“oop!”（只输出引号里面的内容，不输出引号）。</span><br><span class="line">每组数据的输出结果占一行。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>&lt;T≤<span class="number">10</span>,</span><br><span class="line"><span class="number">2</span>≤R,C≤<span class="number">200</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line">.S..</span><br><span class="line">###.</span><br><span class="line">..E.</span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line">.S..</span><br><span class="line">.E..</span><br><span class="line">....</span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line">.S..</span><br><span class="line">####</span><br><span class="line">..E.</span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">oop!</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>根据数据范围，<code>T*R*C = 400,000</code>，时间复杂度应该是O(n)或O(logn)。</p>
<p>对于路径问题，BFS和DFS都能用，但只有BFS能找到一条合法的最短路径。</p>
<p><img src="/posts/4280c9eb/image-20210527085252135.png" alt="image-20210527085252135"></p>
<p>队列可以自己实现，也可以用STL（效率稍低，大部分题目差别不大）。</p>
<p>BFS：先把初始状态入队，然后进入循环，1.弹出队头 2.拓展队头的子节点( 判个重) ，然后压入队尾。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">210</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dist[N][N];<span class="comment">// 把判重和距离数组合为一个</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(PII start,PII end)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;PII&gt; q;</span><br><span class="line">    <span class="comment">// 多个输入数据，每次重置dist数组</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">-1</span>,<span class="keyword">sizeof</span> dist);<span class="comment">// 把距离数组都初始化成-1，表示没走过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (end == start) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    dist[start.x][start.y] = <span class="number">0</span>;<span class="comment">// 起点开始，距离为0</span></span><br><span class="line">    q.push(start);<span class="comment">// 起点 入队</span></span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;<span class="comment">// 设置四个方向的坐标偏移量</span></span><br><span class="line">    <span class="keyword">while</span> (q.size())&#123;</span><br><span class="line">        PII t = q.front();<span class="comment">// 拿到队头</span></span><br><span class="line">        q.pop();<span class="comment">// 队头出队</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = t.x + dx[i],y = t.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m) <span class="keyword">continue</span>;<span class="comment">// 出界</span></span><br><span class="line">            <span class="keyword">if</span> (g[x][y] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;<span class="comment">// 撞墙</span></span><br><span class="line">            <span class="keyword">if</span> (dist[x][y] != <span class="number">-1</span>) <span class="keyword">continue</span>;<span class="comment">// 判重，走过就不再计算</span></span><br><span class="line">            </span><br><span class="line">            dist[x][y] = dist[t.x][t.y] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (end == <span class="built_in">make_pair</span>(x,y)) <span class="keyword">return</span> dist[x][y];<span class="comment">// 走到终点了，返回距离</span></span><br><span class="line">            q.push(<span class="built_in">make_pair</span>(x,y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,g[i]);</span><br><span class="line"></span><br><span class="line">        PII start,end;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;S&#x27;</span>) start = <span class="built_in">make_pair</span>(i,j);</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;E&#x27;</span>) end = <span class="built_in">make_pair</span>(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> distance = bfs(start,end);</span><br><span class="line">        <span class="keyword">if</span> (distance == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;oop!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,distance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>BFS</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（十六）</title>
    <url>/posts/67eb9637.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="4-习题"><a href="#4-习题" class="headerlink" title="4.习题"></a>4.习题</h3><h4 id="4-1-acwing-1219-移动距离"><a href="#4-1-acwing-1219-移动距离" class="headerlink" title="4.1 acwing.1219. 移动距离"></a>4.1 acwing.1219. 移动距离</h4><p>第六届蓝桥杯省赛C++B组,第六届蓝桥杯省赛JAVAA/C组</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">X星球居民小区的楼房全是一样的，并且按矩阵样式排列。</span><br><span class="line">其楼房的编号为 <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>…</span><br><span class="line">当排满一行时，从下一行相邻的楼往反方向排号。</span><br><span class="line">比如：当小区排号宽度为 <span class="number">6</span> 时，开始情形如下：</span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></span><br><span class="line"><span class="number">12</span> <span class="number">11</span> <span class="number">10</span> <span class="number">9</span>  <span class="number">8</span>  <span class="number">7</span></span><br><span class="line"><span class="number">13</span> <span class="number">14</span> <span class="number">15</span> .....</span><br><span class="line">我们的问题是：已知了两个楼号 m 和 n，需要求出它们之间的最短移动距离（不能斜线方向移动）。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">输入共一行，包含三个整数 w,m,n，w 为排号宽度，m,n 为待计算的楼号。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示 m,n 两楼间最短移动距离。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤w,m,n≤<span class="number">10000</span>,</span><br><span class="line"></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">6</span> <span class="number">8</span> <span class="number">2</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>算法题中涉及到的距离一般分为两种：曼哈顿距离与欧几里得距离。</p>
<p>曼哈顿距离在语法课中介绍过了，欧几里得距离就是直线距离。</p>
<p>本题要求的就是曼哈顿距离。</p>
<p><img src="/posts/67eb9637/image-20210517231325279.png" alt="image-20210517231325279"></p>
<p>处理编号时，我们全部都减去1，这样每一行编号对宽度w取模是相同的值。</p>
<p>如果不处理，假设第一行是1到6，那么它们模6的结果是0,0,0,0,0,1，需要特殊处理。</p>
<p>这也是C++为什么很多地方下标都从0开始的原因之一。</p>
<p>行号和列号以及编号都设定为从0开始。</p>
<p>接下来的问题就是如何表示大楼的行号和列号，</p>
<p>很容易得到：分别是<code>n/w</code>和<code>行号%2 ? w-1-n%w : n%w</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,w;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; w &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    n--,m--;<span class="comment">// 这里别忘记</span></span><br><span class="line">    <span class="keyword">int</span> x1 = n/w,x2 = m/w;</span><br><span class="line">    <span class="keyword">int</span> y1 = n%w,y2 = m%w;</span><br><span class="line">    <span class="keyword">if</span> (x1%<span class="number">2</span>) y1 = w<span class="number">-1</span>-y1;<span class="comment">//if(x1 &amp; 1)更快一点</span></span><br><span class="line">    <span class="comment">//&amp;、|的优先级比大小等于号低</span></span><br><span class="line">    <span class="comment">//反正不确定加括号就没事了</span></span><br><span class="line">    <span class="keyword">if</span> (x2%<span class="number">2</span>) y2 = w<span class="number">-1</span>-y2;</span><br><span class="line">    <span class="comment">// 曼哈顿距离</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">abs</span>(x1-x2) + <span class="built_in">abs</span>(y1-y2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-acwing-1229-日期问题"><a href="#4-2-acwing-1229-日期问题" class="headerlink" title="4.2 acwing.1229. 日期问题"></a>4.2 acwing.1229. 日期问题</h4><p>第八届蓝桥杯省赛C++B组,第八届蓝桥杯省赛JAVAB组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">小明正在整理一批历史文献。这些历史文献中出现了很多日期。</span><br><span class="line">小明知道这些日期都在<span class="number">1960</span>年<span class="number">1</span>月<span class="number">1</span>日至<span class="number">2059</span>年<span class="number">12</span>月<span class="number">31</span>日。</span><br><span class="line">令小明头疼的是，这些日期采用的格式非常不统一，有采用年/月/日的，有采用月/日/年的，还有采用日/月/年的。</span><br><span class="line">更加麻烦的是，年份也都省略了前两位，使得文献上的一个日期，存在很多可能的日期与其对应。</span><br><span class="line">比如<span class="number">02</span>/<span class="number">03</span>/<span class="number">04</span>，可能是<span class="number">2002</span>年<span class="number">03</span>月<span class="number">04</span>日、<span class="number">2004</span>年<span class="number">02</span>月<span class="number">03</span>日或<span class="number">2004</span>年<span class="number">03</span>月<span class="number">02</span>日。</span><br><span class="line">给出一个文献上的日期，你能帮助小明判断有哪些可能的日期对其对应吗？</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">一个日期，格式是”AA/BB/CC”。</span><br><span class="line">即每个’/’隔开的部分由两个 <span class="number">0</span><span class="number">-9</span> 之间的数字（不一定相同）组成。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出若干个不相同的日期，每个日期一行，格式是”yyyy-MM-dd”。</span><br><span class="line">多个日期按从早到晚排列。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">0</span>≤A,B,C≤<span class="number">9</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">02</span>/<span class="number">03</span>/<span class="number">04</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">2002</span><span class="number">-03</span><span class="number">-04</span></span><br><span class="line"><span class="number">2004</span><span class="number">-02</span><span class="number">-03</span></span><br><span class="line"><span class="number">2004</span><span class="number">-03</span><span class="number">-02</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>和回文日期非常像。</p>
<p>我们可以直接按给定的日期范围进行枚举，把日期看成是整数。</p>
<p>先判断日期是否合法，再判断是否满足题目要求。</p>
<p>简单计算一下，日期范围内大概一百万个数，&lt;10^6。</p>
<p>因为我们是从小到大枚举的，所以输出的时间肯定是从早到晚排列的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> days[<span class="number">13</span>] = &#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_valid</span><span class="params">(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> day)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (month == <span class="number">0</span> || month &gt; <span class="number">12</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (month != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (day == <span class="number">0</span> || day &gt; days[month]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leap = year%<span class="number">4</span>==<span class="number">0</span> &amp;&amp; year%<span class="number">100</span> || year%<span class="number">400</span> == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (day &gt; <span class="number">28</span>+leap) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d/%d/%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> date = <span class="number">19600101</span>;date &lt;= <span class="number">20591231</span>;date++)&#123;</span><br><span class="line">        <span class="keyword">int</span> year = date/<span class="number">10000</span>,month = date%<span class="number">10000</span>/<span class="number">100</span>,day = date%<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (check_valid(year,month,day))&#123;</span><br><span class="line">            <span class="comment">// 年/月/日的，有采用月/日/年的，还有采用日/月/年</span></span><br><span class="line">            <span class="keyword">if</span> (year%<span class="number">100</span> == a &amp;&amp; month == b &amp;&amp; day == c ||</span><br><span class="line">            month == a &amp;&amp; day == b &amp;&amp; year%<span class="number">100</span> == c ||</span><br><span class="line">            day == a &amp;&amp; month == b &amp;&amp; year%<span class="number">100</span> == c)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d-%02d-%02d\n&quot;</span>,year,month,day);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种思路，就是根据读入的日期，直接反推合理的日期，但是还要判断日期是否合法，还要按大小排序，</p>
<p>时间复杂度可以控制到O(1)，但是可能写起来很麻烦，所以这里还是用暴力但简单的做法。</p>
<p>附上大佬题解：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> y, m, d;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Date &amp;t)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y != t.y) <span class="keyword">return</span> y &lt; t.y;</span><br><span class="line">        <span class="keyword">if</span>(m != t.m) <span class="keyword">return</span> m &lt; t.m;</span><br><span class="line">        <span class="keyword">return</span> d &lt; t.d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>== (<span class="keyword">const</span> Date &amp;t)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> y == t.y &amp;&amp; m == t.m &amp;&amp; d == t.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Date&gt; date;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> days[<span class="number">13</span>] = &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> m, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y &lt; <span class="number">1960</span> || y &gt;= <span class="number">2060</span> || m &lt; <span class="number">1</span> || m &gt; <span class="number">12</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> maxd = days[m];</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">2</span> &amp;&amp; (y % <span class="number">400</span> == <span class="number">0</span> || (y % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; y % <span class="number">100</span>))) maxd++;</span><br><span class="line">    <span class="keyword">if</span>(d &lt; <span class="number">1</span> || d &gt; maxd) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    a[<span class="number">0</span>] = (s[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + s[<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    a[<span class="number">1</span>] = (s[<span class="number">3</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + s[<span class="number">4</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    a[<span class="number">2</span>] = (s[<span class="number">6</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + s[<span class="number">7</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(check(<span class="number">1900</span> + a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>])) date.push_back(&#123;<span class="number">1900</span> + a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>]&#125;);</span><br><span class="line">    <span class="keyword">if</span>(check(<span class="number">2000</span> + a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>])) date.push_back(&#123;<span class="number">2000</span> + a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>]&#125;);</span><br><span class="line">    <span class="keyword">if</span>(check(<span class="number">1900</span> + a[<span class="number">2</span>], a[<span class="number">0</span>], a[<span class="number">1</span>])) date.push_back(&#123;<span class="number">1900</span> + a[<span class="number">2</span>], a[<span class="number">0</span>], a[<span class="number">1</span>]&#125;);</span><br><span class="line">    <span class="keyword">if</span>(check(<span class="number">2000</span> + a[<span class="number">2</span>], a[<span class="number">0</span>], a[<span class="number">1</span>])) date.push_back(&#123;<span class="number">2000</span> + a[<span class="number">2</span>], a[<span class="number">0</span>], a[<span class="number">1</span>]&#125;);</span><br><span class="line">    <span class="keyword">if</span>(check(<span class="number">1900</span> + a[<span class="number">2</span>], a[<span class="number">1</span>], a[<span class="number">0</span>])) date.push_back(&#123;<span class="number">1900</span> + a[<span class="number">2</span>], a[<span class="number">1</span>], a[<span class="number">0</span>]&#125;);</span><br><span class="line">    <span class="keyword">if</span>(check(<span class="number">2000</span> + a[<span class="number">2</span>], a[<span class="number">1</span>], a[<span class="number">0</span>])) date.push_back(&#123;<span class="number">2000</span> + a[<span class="number">2</span>], a[<span class="number">1</span>], a[<span class="number">0</span>]&#125;);</span><br><span class="line">    sort(date.begin(), date.end());</span><br><span class="line">    date.erase(unique(date.begin(), date.end()), date.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; date.size(); i++) <span class="built_in">printf</span>(<span class="string">&quot;%d-%02d-%02d\n&quot;</span>, date[i].y, date[i].m, date[i].d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者：NumPy</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/42353/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>补充知识点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    ------<span class="comment">//整型转字符串//-----</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">its</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line">ss &lt;&lt; x;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">ss &gt;&gt; s;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    -----<span class="comment">//字符串转整型//-----</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sti</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line">ss &lt;&lt; s;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">ss &gt;&gt; x;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    -----<span class="comment">//判断闰年//-----</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is</span><span class="params">(<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (y % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; y % <span class="number">100</span> != <span class="number">0</span> || y % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-acwing-1231-航班时间"><a href="#4-3-acwing-1231-航班时间" class="headerlink" title="4.3 acwing.1231. 航班时间"></a>4.3 acwing.1231. 航班时间</h4><p>第九届蓝桥杯省赛C++A组,第九届蓝桥杯省赛JAVAA组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">小 h 前往美国参加了蓝桥杯国际赛。</span><br><span class="line">小 h 的女朋友发现小 h 上午十点出发，上午十二点到达美国，于是感叹到“现在飞机飞得真快，两小时就能到美国了”。</span><br><span class="line">小 h 对超音速飞行感到十分恐惧。</span><br><span class="line">仔细观察后发现飞机的起降时间都是当地时间。</span><br><span class="line">由于北京和美国东部有 <span class="number">12</span> 小时时差，故飞机总共需要 <span class="number">14</span> 小时的飞行时间。</span><br><span class="line">不久后小 h 的女朋友去中东交换。</span><br><span class="line">小 h 并不知道中东与北京的时差。</span><br><span class="line">但是小 h 得到了女朋友来回航班的起降时间。</span><br><span class="line">小 h 想知道女朋友的航班飞行时间是多少。</span><br><span class="line">对于一个可能跨时区的航班，给定来回程的起降时间。</span><br><span class="line">假设飞机来回飞行时间相同，求飞机的飞行时间。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">一个输入包含多组数据。</span><br><span class="line">输入第一行为一个正整数 T，表示输入数据组数。</span><br><span class="line">每组数据包含两行，第一行为去程的起降时间，第二行为回程的起降时间。</span><br><span class="line">起降时间的格式如下:</span><br><span class="line">h1:m1:s1 h2:m2:s2</span><br><span class="line">h1:m1:s1 h3:m3:s3 (+<span class="number">1</span>)</span><br><span class="line">h1:m1:s1 h4:m4:s4 (+<span class="number">2</span>)</span><br><span class="line">第一种格式表示该航班在当地时间h1时m1分s1秒起飞，在当地时间当日h2时m2分s2秒降落。</span><br><span class="line">第二种格式表示该航班在当地时间h1时m1分s1秒起飞，在当地时间次日h2时m2分s2秒降落。</span><br><span class="line">第三种格式表示该航班在当地时间h1时m1分s1秒起飞，在当地时间第三日h2时m2分s2秒降落。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">对于每一组数据输出一行一个时间hh:mm:ss，表示飞行时间为hh小时mm分ss秒。</span><br><span class="line">注意，当时间为一位数时，要补齐前导零，如三小时四分五秒应写为<span class="number">03</span>:<span class="number">04</span>:<span class="number">05</span>。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">保证输入时间合法（<span class="number">0</span>≤h≤<span class="number">23</span>,<span class="number">0</span>≤m,s≤<span class="number">59</span>），飞行时间不超过<span class="number">24</span>小时。</span><br><span class="line"></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">17</span>:<span class="number">48</span>:<span class="number">19</span> <span class="number">21</span>:<span class="number">57</span>:<span class="number">24</span></span><br><span class="line"><span class="number">11</span>:<span class="number">05</span>:<span class="number">18</span> <span class="number">15</span>:<span class="number">14</span>:<span class="number">23</span></span><br><span class="line"><span class="number">17</span>:<span class="number">21</span>:<span class="number">07</span> <span class="number">00</span>:<span class="number">31</span>:<span class="number">46</span> (+<span class="number">1</span>)</span><br><span class="line"><span class="number">23</span>:<span class="number">02</span>:<span class="number">41</span> <span class="number">16</span>:<span class="number">13</span>:<span class="number">20</span> (+<span class="number">1</span>)</span><br><span class="line"><span class="number">10</span>:<span class="number">19</span>:<span class="number">19</span> <span class="number">20</span>:<span class="number">41</span>:<span class="number">24</span></span><br><span class="line"><span class="number">22</span>:<span class="number">19</span>:<span class="number">04</span> <span class="number">16</span>:<span class="number">41</span>:<span class="number">09</span> (+<span class="number">1</span>)</span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">04</span>:<span class="number">09</span>:<span class="number">05</span></span><br><span class="line"><span class="number">12</span>:<span class="number">10</span>:<span class="number">39</span></span><br><span class="line"><span class="number">14</span>:<span class="number">22</span>:<span class="number">05</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>首先要了解时差、时区的概念。</p>
<p>飞行时长计算公式：</p>
<p>往西飞，飞行的时长是相差+时差。往东飞，飞行的时长是相差-时差。</p>
<p>区时计算公式：</p>
<p>计算的区时=已知区时－（已知区时的时区-要计算区时的时区）</p>
<p>这题重点在于处理输入，需要记住一些技巧。</p>
<p>第一步，先将所有时间转化成距离当天00:00:00的秒数，一天大概86400秒。这样方便后续加减计算。</p>
<p>第二步，根据秒数再还原成时间，利用%和/运算。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_seconds</span><span class="params">(<span class="keyword">int</span> h,<span class="keyword">int</span> m,<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h*<span class="number">3600</span> + m*<span class="number">60</span> + s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_time</span><span class="params">()</span></span>&#123;<span class="comment">// 求时间差对应的秒数</span></span><br><span class="line">    <span class="built_in">string</span> line;</span><br><span class="line">    getline(<span class="built_in">cin</span>,line);</span><br><span class="line">    <span class="comment">// 注意不要写成&quot;)&quot;，这是一个字符</span></span><br><span class="line">    <span class="keyword">if</span> (line.back() != <span class="string">&#x27;)&#x27;</span>) line += <span class="string">&quot; (+0)&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> h1,m1,s1,h2,m2,s2,d;</span><br><span class="line">    <span class="comment">// 注意是sscanf，不是scanf</span></span><br><span class="line">    <span class="comment">// string.c_str()将string转化成const char*，指向相应char数组，C语言标准字符串形式</span></span><br><span class="line">    <span class="built_in">sscanf</span>(line.c_str(),<span class="string">&quot;%d:%d:%d %d:%d:%d (+%d)&quot;</span>,&amp;h1,&amp;m1,&amp;s1,&amp;h2,&amp;m2,&amp;s2,&amp;d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> get_seconds(h2,m2,s2) - get_seconds(h1,m1,s1) + d*<span class="number">24</span>*<span class="number">3600</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">string</span> line;</span><br><span class="line">    getline(<span class="built_in">cin</span>,line);<span class="comment">// 过滤第一行的回车符</span></span><br><span class="line">    <span class="keyword">while</span> (n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> time = (get_time() + get_time()) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> hour = time/<span class="number">3600</span>,minute = time%<span class="number">3600</span>/<span class="number">60</span>,second = time%<span class="number">60</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d:%02d\n&quot;</span>,hour,minute,second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sscanf的用法：</p>
<p>从一个字符串中读进于指定格式相符的数据。利用它可以从字符串中取出整数、浮点数和字符串。</p>
<p>sscanf和scanf的区别：scanf是以键盘作为输入源，sscanf是以字符串作为输入源。</p>
<p>函数原型：<code>int sscanf(const char *str, const char *format,......);</code></p>
<p>提示：以下代码存在风险，请谨慎参考！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一份朴实无华的题解，%%%</span></span><br><span class="line"><span class="comment">// y总建议最好不要这样写，读入可能有问题</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTime</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h1,m1,s1,h2,m2,s2,d=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d:%d:%d %d:%d:%d (+%d)&quot;</span>,&amp;h1,&amp;m1,&amp;s1,&amp;h2,&amp;m2,&amp;s2,&amp;d);</span><br><span class="line">    <span class="keyword">int</span> time=d*<span class="number">24</span>*<span class="number">3600</span>+h2*<span class="number">3600</span>+m2*<span class="number">60</span>+s2-(h1*<span class="number">3600</span>+m1*<span class="number">60</span>+s1);</span><br><span class="line">    <span class="keyword">return</span> time;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> time1=getTime();</span><br><span class="line">        <span class="keyword">int</span> time2=getTime();</span><br><span class="line">        <span class="keyword">int</span> t=(time1+time2)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d:%02d\n&quot;</span>, t/<span class="number">3600</span>, t/<span class="number">60</span>%<span class="number">60</span>, t%<span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（十四）</title>
    <url>/posts/6d7b18a9.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="1-2-acwing-1236-递增三元组"><a href="#1-2-acwing-1236-递增三元组" class="headerlink" title="1.2 acwing.1236. 递增三元组"></a>1.2 acwing.1236. 递增三元组</h4><p>第九届蓝桥杯省赛C++B组,第九届蓝桥杯省赛JAVAB组</p>
<span id="more"></span>

<p>给定三个整数数组</p>
<p>$A=\left[A_{1}, A_{2}, \ldots A_{N}\right]$</p>
<p>$B=\left[B_{1}, B_{2}, \ldots B_{N}\right]$,</p>
<p>$C=\left[C_{1}, C_{2}, \ldots C_{N}\right]$<br>请你统计有多少个三元组 $(i, j, k)$ 满足:</p>
<ol>
<li>$1 \leq i, j, k \leq N$</li>
<li>$A_{i}&lt;B_{j}&lt;C_{k}$</li>
</ol>
<p><strong>输入格式</strong></p>
<p>第一行包含一个整数 $N$。</p>
<p>第二行包含 $N$ 个整数 $A_{1}, A_{2}, \ldots A_{N}$ 。</p>
<p>第三行包含 $N$ 个整数 $B_{1}, B_{2}, \ldots B_{N}$ 。</p>
<p>第四行包含 $N$ 个整数 $C_{1}, C_{2}, \ldots C_{N}$ 。</p>
<p><strong>输出格式</strong></p>
<p>一个整数表示答案。</p>
<p><strong>数据范围</strong></p>
<p>$1 \leq N \leq 10^{5}$</p>
<p>$0 \leq A_{i}, B_{i}, C_{i} \leq 10^{5}$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入样例：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">27</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>由数据范围推测时间复杂度大致为O(n*logn)。</p>
<p>所以最多枚举一个数组。应该先<strong>枚举中间的数组B</strong>（关键思路），才好确定两边的A和C，计算满足要求的A和</p>
<p>C是并列关系。</p>
<p>对于每个Bj：</p>
<ol>
<li>求在A中有多少个数小于Bj；</li>
<li>求在C中有多少个数大于Bj；</li>
</ol>
<h5 id="算法1：前缀和"><a href="#算法1：前缀和" class="headerlink" title="算法1：前缀和"></a>算法1：前缀和</h5><p>时间复杂度：O(n)。</p>
<p>用空间换时间。时间最短。约166 ms。</p>
<p><code>cnt[i]</code>表示在A中i这个值出现多少次，前缀和数组<code>s[i] == cnt[0] + cnt[1] + ... + cnt[i]</code>，表示在</p>
<p>A中，0~i出现了多少次。</p>
<p>根据题目，A中i最大为10^5。</p>
<p>Java题解与输入输出优化：<a href="https://www.acwing.com/solution/content/7392/">https://www.acwing.com/solution/content/7392/</a></p>
<h6 id="C-版本："><a href="#C-版本：" class="headerlink" title="C++版本："></a>C++版本：</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N],b[N],c[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N],s[N];</span><br><span class="line"><span class="keyword">int</span> as[N],cs[N];<span class="comment">// 分别表示在A、C中有多少个数&gt;、&lt;b[i]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),a[i]++;<span class="comment">//a[i]可以为0，+1避免前缀和问题</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]),b[i]++;<span class="comment">//a、b、c只需考虑相对大小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[i]),c[i]++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意循环细节</span></span><br><span class="line">    <span class="comment">// 求as[N]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) cnt[a[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; N;i++) s[i] = s[i<span class="number">-1</span>] + cnt[i];<span class="comment">// 求cnt[]的前缀和，从1开始避免越界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) as[i] = s[b[i]<span class="number">-1</span>];</span><br><span class="line">    <span class="comment">// 求cs[N]</span></span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span> s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) cnt[c[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; N;i++) s[i] = s[i<span class="number">-1</span>] + cnt[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) cs[i] = s[N<span class="number">-1</span>] - s[b[i]];</span><br><span class="line"></span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) res += (LL)as[i]*cs[i];<span class="comment">//一个数转LL就行</span></span><br><span class="line">    <span class="comment">// 注意：LL(as[i]*cs[i])是错的，有精度损失</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Java版本："><a href="#Java版本：" class="headerlink" title="Java版本："></a>Java版本：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] acnt = <span class="keyword">new</span> <span class="keyword">int</span>[N];<span class="comment">//acnt和ccnt开两个数组，因为开一个不能完全覆盖</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] ccnt = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] as = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] cs = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] s = <span class="keyword">new</span> <span class="keyword">int</span>[N];<span class="comment">//s只需开一个，因为能完全覆盖</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NumberFormatException,IOException</span>&#123;</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(reader.readLine().trim());<span class="comment">//去掉空格、回车</span></span><br><span class="line">        String[] s1 = reader.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        String[] s2 = reader.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        String[] s3 = reader.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = Integer.parseInt(s1[i-<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//String转int</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) b[i] = Integer.parseInt(s2[i-<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) c[i] = Integer.parseInt(s3[i-<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) acnt[a[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= N-<span class="number">1</span>;i ++) s[i]= s[i-<span class="number">1</span>] + acnt[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) as[i] = s[b[i]-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) ccnt[c[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= N-<span class="number">1</span>;i ++) s[i] = s[i-<span class="number">1</span>] + ccnt[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) cs[i] = s[N-<span class="number">1</span>] - s[b[i]];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) res += (<span class="keyword">long</span>)as[i]*cs[i];</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于Arrays.sort()的三种用法：</p>
<p>1、<code>Arrays.sort(int[] a)</code></p>
<p>这种形式是对一个数组的所有元素进行排序，并且是按从小到大的顺序。例如：<code>Arrays.sort(a);</code></p>
<p>2、<code>Arrays.sort(int[] a, int fromIndex, int toIndex)</code></p>
<p>这种形式是对数组部分排序，也就是对数组a的下标从fromIndex到toIndex-1的元素排序，注意：下标为toIndex的元素不参与排序哦！例如：<code>Arrays.sort(a, 0, 3);</code></p>
<p>3、<code>public static &lt;T&gt; void sort(T[] a,int fromIndex, int toIndex, Comparator&lt;? super T&gt; c)</code></p>
<p>也就是重写comparator，详见Java入门笔记（十二）Java比较器。</p>
<h5 id="算法2：二分"><a href="#算法2：二分" class="headerlink" title="算法2：二分"></a>算法2：二分</h5><p>时间复杂度：O(n*logn)。约703 ms。时间最长。</p>
<p>注意边界条件，下标也可以从1开始，不过比从0开始要麻烦一点。</p>
<h6 id="C-STL版本："><a href="#C-STL版本：" class="headerlink" title="C++STL版本："></a>C++STL版本：</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N],b[N],c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[i]);</span><br><span class="line"></span><br><span class="line">	sort(a,a+n);</span><br><span class="line">	sort(b,b+n);</span><br><span class="line">	sort(c,c+n);</span><br><span class="line"></span><br><span class="line">	LL res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> la = lower_bound(a,a+n,b[i]) - a;<span class="comment">//在数组a中找比b[i]小的数</span></span><br><span class="line">		<span class="keyword">int</span> rc = upper_bound(c,c+n,b[i]) - c;<span class="comment">//在数组c中找比b[i]大的数</span></span><br><span class="line">		<span class="keyword">if</span> (la == <span class="number">0</span> || rc == n) <span class="keyword">continue</span>;<span class="comment">//这句可以不加，计算会得到0，加上能优化几毫秒</span></span><br><span class="line">		res += LL(la)*(n-rc);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,res);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Java手写版本："><a href="#Java手写版本：" class="headerlink" title="Java手写版本："></a>Java手写版本：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NumberFormatException,IOException</span>&#123;</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(reader.readLine().trim());</span><br><span class="line">        String[] s1 = reader.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        String[] s2 = reader.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        String[] s3 = reader.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) a[i] = Integer.parseInt(s1[i-<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) b[i] = Integer.parseInt(s2[i-<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) c[i] = Integer.parseInt(s3[i-<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(a,<span class="number">1</span>,n + <span class="number">1</span>);<span class="comment">// 对a[1]到a[n]从小到大排序</span></span><br><span class="line">        Arrays.sort(b,<span class="number">1</span>,n + <span class="number">1</span>);</span><br><span class="line">        Arrays.sort(c,<span class="number">1</span>,n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 求满足最小的&lt;=b[i]的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> la = <span class="number">0</span>,ra = n+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (la &lt; ra)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (la + ra) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (a[mid] &lt; b[i]) la = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> ra = mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 求满足最小的&gt;=b[i]的下标</span></span><br><span class="line">            <span class="keyword">int</span> lc = <span class="number">0</span>,rc = n + <span class="number">1</span>; </span><br><span class="line">            <span class="keyword">while</span>(lc &lt; rc)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (lc + rc + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(c[mid] &lt;= b[i]) lc = mid;</span><br><span class="line">                <span class="keyword">else</span> rc = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (la == <span class="number">0</span> || lc == n+<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            res += (<span class="keyword">long</span>)(la-<span class="number">1</span>)*(n-lc);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于二分区间的说明：</p>
<p>若不能找到则一定会在0或者n + 1的位置，否则就表示能找到。</p>
<p>所以不设置从1到n。</p>
<p>特别提醒：</p>
<p>如果二分区间是0到n+1，就必须严格的&gt;=或者&lt;=，因为真正的搜索区间是1到n，0和n+1只是作为找不到的缓冲区，保证最后得到的下标一定是能找到的，否则返回值是0或n+1；如果二分区间是1到n，也能做，也就是求&gt;的第一个位置，upper_bound。</p>
<h5 id="算法3：双指针"><a href="#算法3：双指针" class="headerlink" title="算法3：双指针"></a>算法3：双指针</h5><p>时间复杂度：O(n)。约444 ms。</p>
<p>参考题解：<a href="https://www.acwing.com/solution/content/19218/">https://www.acwing.com/solution/content/19218/</a></p>
<p>双指针笔记：<a href="https://www.acwing.com/blog/content/235/">https://www.acwing.com/blog/content/235/</a></p>
<p>进一步对查找进行优化，对于排过序的数组A和B，寻找A中小于B[i]的元素的个数可以考虑双指针算法，因为每个指针最多移动n次，故查找的时间复杂度降到O(n)，查找C与查找A同理，只是找第一个大于B的位置。</p>
<p>只需要将二分部分修改为双指针就行。</p>
<p>分别对数组a和c进行指针扫描。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N],b[N],c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[i]);</span><br><span class="line"></span><br><span class="line">	sort(a,a+n);</span><br><span class="line">	sort(b,b+n);</span><br><span class="line">	sort(c,c+n);</span><br><span class="line"></span><br><span class="line">	LL res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> la = <span class="number">0</span>,rc = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> key = b[i];</span><br><span class="line">		<span class="keyword">while</span> (la &lt;= n<span class="number">-1</span> &amp;&amp; a[la] &lt; b[i]) la++;</span><br><span class="line">		<span class="keyword">while</span> (rc &lt;= n<span class="number">-1</span> &amp;&amp; c[rc] &lt;= b[i]) rc++;</span><br><span class="line">		res += LL(la)*(n-rc);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,res);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-acwing-1245-特别数的和"><a href="#1-3-acwing-1245-特别数的和" class="headerlink" title="1.3 acwing.1245. 特别数的和"></a>1.3 acwing.1245. 特别数的和</h4><p>第十届蓝桥杯省赛C++B组,第十届蓝桥杯省赛JAVAB组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">小明对数位中含有 <span class="number">2</span>、<span class="number">0</span>、<span class="number">1</span>、<span class="number">9</span> 的数字很感兴趣（不包括前导 <span class="number">0</span>），在 <span class="number">1</span> 到 <span class="number">40</span> 中这样的数包括 <span class="number">1</span>、<span class="number">2</span>、<span class="number">9</span>、<span class="number">10</span> 至 <span class="number">32</span>、<span class="number">39</span> 和 <span class="number">40</span>，共 <span class="number">28</span> 个，他们的和是 <span class="number">574</span>。</span><br><span class="line">请问，在 <span class="number">1</span> 到 n 中，所有这样的数的和是多少？</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">共一行，包含一个整数 n。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">共一行，包含一个整数，表示满足条件的数的和。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤n≤<span class="number">10000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">40</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">574</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>观察数据范围，发现很小，可以直接枚举n。</p>
<p>如果数据范围很大，就需要用到数位DP，很恐怖。</p>
<p>思路很简单。</p>
<p><img src="/posts/6d7b18a9/image-20210513104856743.png" alt="image-20210513104856743"></p>
<p>将int数字中的每一位取出并判断，对应的一个问题是如何将字符串形式转化为int数字。</p>
<p>这两种做法是比较常见的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = i;</span><br><span class="line">        <span class="keyword">while</span> (x)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = x % <span class="number">10</span>;<span class="comment">//取出个位</span></span><br><span class="line">            x = x / <span class="number">10</span>;<span class="comment">//删除个位</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="number">0</span> || t == <span class="number">1</span> || t == <span class="number">2</span> || t == <span class="number">9</span>)&#123;</span><br><span class="line">                res += i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>常用小技巧</strong>：关于取出x的每位数字 和 将字符数字转为数字</p>
<p>1.取出x的每位数字</p>
<p><code>int t = x % 10;</code></p>
<p><code>x /= 10;</code></p>
<p>2.将字符数字转为数字</p>
<p><code>int x = 0;</code></p>
<p><code>for (int i = 0; i &lt; str.size(); i ++ )</code></p>
<p> <code>x = x * 10 + str[i] - &#39;0&#39;;</code></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（十）</title>
    <url>/posts/b2cae080.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="1-2-acwing-1211-蚂蚁感冒（第五届AB组）"><a href="#1-2-acwing-1211-蚂蚁感冒（第五届AB组）" class="headerlink" title="1.2 acwing.1211. 蚂蚁感冒（第五届AB组）"></a>1.2 acwing.1211. 蚂蚁感冒（第五届AB组）</h4><span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">长 <span class="number">100</span> 厘米的细长直杆子上有 n 只蚂蚁。</span><br><span class="line">它们的头有的朝左，有的朝右。</span><br><span class="line">每只蚂蚁都只能沿着杆子向前爬，速度是 <span class="number">1</span> 厘米/秒。</span><br><span class="line">当两只蚂蚁碰面时，它们会同时掉头往相反的方向爬行。</span><br><span class="line">这些蚂蚁中，有 <span class="number">1</span> 只蚂蚁感冒了。</span><br><span class="line">并且在和其它蚂蚁碰面时，会把感冒传染给碰到的蚂蚁。</span><br><span class="line">请你计算，当所有蚂蚁都爬离杆子时，有多少只蚂蚁患上了感冒。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行输入一个整数 n, 表示蚂蚁的总数。</span><br><span class="line">接着的一行是 n 个用空格分开的整数 Xi, Xi 的绝对值表示蚂蚁离开杆子左边端点的距离。</span><br><span class="line">正值表示头朝右，负值表示头朝左，数据中不会出现 <span class="number">0</span> 值，也不会出现两只蚂蚁占用同一位置。</span><br><span class="line">其中，第一个数据代表的蚂蚁感冒了。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出<span class="number">1</span>个整数，表示最后感冒蚂蚁的数目。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>&lt;n&lt;<span class="number">50</span>,</span><br><span class="line"><span class="number">0</span>&lt;|Xi|&lt;<span class="number">100</span></span><br><span class="line">输入样例<span class="number">1</span>：</span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">5</span> <span class="number">-2</span> <span class="number">8</span></span><br><span class="line">输出样例<span class="number">1</span>：</span><br><span class="line"><span class="number">1</span></span><br><span class="line">输入样例<span class="number">2</span>：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">-10</span> <span class="number">8</span> <span class="number">-20</span> <span class="number">12</span> <span class="number">25</span></span><br><span class="line">输出样例<span class="number">2</span>：</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>本题不属于任何算法。</p>
<p>首先要看出来，这里两只蚂蚁碰面掉头，其实等价于穿过去。掉头只是幌子，不要想复杂了。</p>
<p>因为相撞之后两只蚂蚁都感冒了，掉不掉头其实无所谓，毕竟都感冒了，这样的话这题就简单多了。</p>
<p><img src="/posts/b2cae080/image-20210429141227746.png" alt="image-20210429141227746"></p>
<p>以第一只感冒蚂蚁<strong>（向右走）</strong>为分界，考虑左右两边的蚂蚁。</p>
<p><img src="/posts/b2cae080/image-20210429142058395.png" alt="image-20210429142058395"></p>
<p>第一只感冒蚂蚁<strong>（向左走）</strong>情况类似。</p>
<p><img src="/posts/b2cae080/image-20210429143438497.png" alt="image-20210429143438497"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> x[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">cin</span> &gt;&gt; x[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 分别表示左边向有走的蚂蚁数量，和右边向左走的蚂蚁数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(x[i]) &lt; <span class="built_in">abs</span>(x[<span class="number">0</span>]) &amp;&amp; x[i] &gt; <span class="number">0</span>) left++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">abs</span>(x[i]) &gt; <span class="built_in">abs</span>(x[<span class="number">0</span>]) &amp;&amp; x[i] &lt; <span class="number">0</span>) right++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x[<span class="number">0</span>] &gt; <span class="number">0</span> &amp;&amp; right == <span class="number">0</span> || x[<span class="number">0</span>] &lt; <span class="number">0</span> &amp;&amp; left == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; left + right + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-acwing-1216-饮料换购（第六届C-A-C组）"><a href="#1-3-acwing-1216-饮料换购（第六届C-A-C组）" class="headerlink" title="1.3 acwing.1216. 饮料换购（第六届C++A/C组）"></a>1.3 acwing.1216. 饮料换购（第六届C++A/C组）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">乐羊羊饮料厂正在举办一次促销优惠活动。乐羊羊C型饮料，凭<span class="number">3</span>个瓶盖可以再换一瓶C型饮料，并且可以一直循环下去(但不允许暂借或赊账)。</span><br><span class="line">请你计算一下，如果小明不浪费瓶盖，尽量地参加活动，那么，对于他初始买入的 n 瓶饮料，最后他一共能喝到多少瓶饮料。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">输入一个整数 n,表示初始买入的饮料数量。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示一共能够喝到的饮料数量。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">0</span>&lt;n&lt;<span class="number">10000</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">100</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">149</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>先手动模拟一下。</p>
<p><img src="/posts/b2cae080/image-20210430183558295.png" alt="image-20210430183558295"></p>
<p><img src="/posts/b2cae080/image-20210430184112849.png" alt="image-20210430184112849"></p>
<p>粗略计算一下，取n=10000时，每次除以3，大概需要迭代8,9次，时间完全没问题。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> res = n;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">        res += n / <span class="number">3</span>;</span><br><span class="line">        n = n / <span class="number">3</span> + n % <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充小知识：如何求上取整？</p>
<p>有一个公式，将上取整转化为下取整，因为C++计算int除法时默认下取整，$\lceil \frac a b \rceil = \lfloor \frac {a+b-1} b \rfloor$</p>
<p>证明如下：（PS：严格证明请参考<a href="https://blog.csdn.net/lanuage/article/details/78746606?ops_request_misc=&request_id=&biz_id=102&utm_term=%E6%80%8E%E4%B9%88%E6%B1%82%E5%90%91%E4%B8%8A%E5%8F%96%E6%95%B4&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-78746606.first_rank_v2_pc_rank_v29">这里</a>）</p>
<p>分情况讨论：</p>
<ol>
<li>当<code>a mod b = 1,2,...,b-1</code>时，<code>(a mod b)+b-1 = b,b+1,...,b+b-2 </code>，这多余部分除以b下取整都是1，而左右两边的整数部分又相同，所以成立；（即<code>a%b != 0</code>时，上取整等于下取整+1）</li>
<li>当<code>a mod b = 0</code>时，<code>(a mod b)+b-1 = b-1</code>，而$\frac {b-1}b$下取整是0，而左右两边的整数部分又相同，所以成立。（即<code>a%b = 0</code>时，上取整等于下取整）</li>
</ol>
<p>向下取整的运算称为Floor，用数学符号⌊⌋表示；向上取整的运算称为Ceiling，用数学符号⌈⌉表示。</p>
<p>例如：</p>
<p>⌊59/60⌋=0    ⌈59/60⌉=1    ⌊-59/60⌋=-1    ⌈-59/60⌉=0</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（四十）</title>
    <url>/posts/c405365c.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="6-acwing-1171-距离"><a href="#6-acwing-1171-距离" class="headerlink" title="6 acwing.1171. 距离"></a>6 acwing.1171. 距离</h4><p>《信息学奥赛一本通》</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给出 n 个点的一棵树，多次询问两点之间的最短距离。</span><br><span class="line">注意：</span><br><span class="line">边是无向的。</span><br><span class="line">所有节点的编号是 <span class="number">1</span>,<span class="number">2</span>,…,n。</span><br><span class="line">    </span><br><span class="line">输入格式</span><br><span class="line">第一行为两个整数 n 和 m。n 表示点数，m 表示询问次数；</span><br><span class="line">下来 n−<span class="number">1</span> 行，每行三个整数 x,y,k，表示点 x 和点 y 之间存在一条边长度为 k；</span><br><span class="line">再接下来 m 行，每行两个整数 x,y，表示询问点 x 到点 y 的最短距离。</span><br><span class="line">树中结点编号从 <span class="number">1</span> 到 n。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">共 m 行，对于每次询问，输出一行询问结果。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">2</span>≤n≤<span class="number">10</span>^<span class="number">4</span>,</span><br><span class="line"><span class="number">1</span>≤m≤<span class="number">2</span>×<span class="number">10</span>^<span class="number">4</span>,</span><br><span class="line"><span class="number">0</span>&lt;k≤<span class="number">100</span>,</span><br><span class="line"><span class="number">1</span>≤x,y≤n</span><br><span class="line">输入样例<span class="number">1</span>：</span><br><span class="line"><span class="number">2</span> <span class="number">2</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">100</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> </span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line">输出样例<span class="number">1</span>：</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line">输入样例<span class="number">2</span>：</span><br><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">10</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">15</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line">输出样例<span class="number">2</span>：</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>考察LCA问题。</p>
<hr>
<p>参考1：算法训练营进阶篇。</p>
<p>参考2：<a href="https://oi-wiki.org/graph/lca/%E3%80%82">https://oi-wiki.org/graph/lca/。</a></p>
<p>最近公共祖先简称 LCA（Lowest Common Ancestor），指有根树中距离2个节点最近的公共祖先。祖先指当前节点到树根路径上的所有节点。</p>
<p>求解LCA的方法有很多，包括暴力搜索法、树上倍增法、RMQ、Tarjan算法等。</p>
<p>LCA问题参考视频讲解：<a href="https://www.bilibili.com/video/BV1nE411L7rz?share_source=copy_web%E3%80%82">https://www.bilibili.com/video/BV1nE411L7rz?share_source=copy_web。</a></p>
<hr>
<p>补充一下关于离线与在线查询的区别：</p>
<p>在线做法：边读边做。</p>
<p>离线做法：先读完，再全部处理，最后全部输出。</p>
<p><strong>更直观地讲，就是离线算法途中拿出来的结果就是最终结果的一部分，而在线算法可能到了最后一步才能得到需要的结果，而过程中产生中间结果都是为最后结果的输出而服务的。</strong></p>
<p>参考题解：<a href="https://www.acwing.com/solution/content/24569/%E3%80%82">https://www.acwing.com/solution/content/24569/。</a></p>
<p>参考题解：<a href="https://www.acwing.com/solution/content/9034/%E3%80%82">https://www.acwing.com/solution/content/9034/。</a></p>
<p><strong>Tarjan算法离线</strong>求解LCA。（建议参考算法训练营的“完美图解”掌握tarjan的具体执行过程细节）</p>
<p>回到题目，注意边是无向的，所以要存两遍。</p>
<p>这里用数组模拟邻接表的形式存储树，与之前稍有不同的是多了边权，还有并查集的知识，忘了的回头复习。<br>在tarjan函数的深度优先遍历时,将所有点分成三大类：st数组的值作为标志<br>[2] 已经遍历过,且回溯过<br>[1] 正在搜索的分支<br>[0] 还未搜索到的点</p>
<p>其中<strong>所有2号点</strong>和<strong>正在搜索的1号点</strong>路径中已经通过并查集合并成一个集合。</p>
<p>在深度优先遍历1号点中的u点的时候，需要把u的查询的另外一个点的最短距离进行计算并存储，最后把u点合并到上一结点的集合，这样确保查询祖宗的时候不出错。</p>
<p>关于<code>tarjan(j);p[j] = u;</code>的顺序说明：如果交换顺序，2号点将无法被并查集合并，必须回溯完再合并，就是说需要把当前节点的所有子节点都处理完，再都合并到父节点中。如果顺序反了，<strong>每个节点在并查集的根节点都是它的父节点</strong>，都属于独立的集合，就无法正确计算最近公共祖先了，除非这棵树只有一层。</p>
<p>参考题解：<a href="https://www.cnblogs.com/JVxie/p/4854719.html%E3%80%82%EF%BC%88%E6%9C%89%E5%9B%BE%E6%9D%A5%E6%A8%A1%E6%8B%9F%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B%EF%BC%89">https://www.cnblogs.com/JVxie/p/4854719.html。（有图来模拟详细过程）</a></p>
<p>基本流程：</p>
<p><strong>1.任选一个点为根节点，从根节点开始。</strong></p>
<p><strong>2.遍历该点u所有子节点v，并标记这些子节点v已被访问过。</strong></p>
<p><strong>3.若是v还有子节点，返回2，否则下一步。</strong></p>
<p><strong>4.合并v到u上。</strong></p>
<p><strong>5.寻找与当前点u有询问关系的点v。</strong></p>
<p><strong>6.若是v已经被访问过了，则可以确认u和v的最近公共祖先为v被合并到的父亲节点a。</strong></p>
<p>遍历的话需要用到<strong>dfs</strong>来遍历，至于合并，最优化的方式就是利用<strong>并查集</strong>来合并两个节点。</p>
<p>时间复杂度：O(n+m)，常数比倍增法大。时间主要看tarjan函数，遍历n个点，处理m次查询，O((n+m)*Alpha(n))，Alpha(n)可近似看成O(1)，所以是O(n+m)。</p>
<p>在仅使用路径压缩优化的情况下，单次调用 <code>find()</code> 函数的时间复杂度为均摊O(1)，而不是O(logn)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10005</span>,M = <span class="number">2</span>*N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;<span class="comment">// w存边权</span></span><br><span class="line"><span class="keyword">int</span> p[N];<span class="comment">// 并查集数组</span></span><br><span class="line"><span class="keyword">int</span> res[<span class="number">2</span>*M];<span class="comment">// 存放对应编号的询问答案，需要2倍询问，类似无向图的边</span></span><br><span class="line"><span class="built_in">vector</span>&lt;PII&gt; query[N];<span class="comment">// 离线Tarjan，存下所有询问</span></span><br><span class="line"><span class="comment">// query[i][first][second] first存查询距离i的另外一个点j，second存查询编号idx</span></span><br><span class="line"><span class="keyword">int</span> st[N];<span class="comment">// tarjan的标记数组</span></span><br><span class="line"><span class="keyword">int</span> dist[N];<span class="comment">// 存每个点和1号点的距离</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;<span class="comment">// 加边，带权值</span></span><br><span class="line">    e[idx] = b,w[idx] = c,ne[idx] = h[a],h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;<span class="comment">// dfs求各编号到1号点的距离dist</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dist[j] = dist[u] + w[i];<span class="comment">// 注意不要写错，u是j的父亲，i对应邻接表的游标idx，是边权w[i]</span></span><br><span class="line">        dfs(j,u);<span class="comment">// 先算父亲，再算儿子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">// 并查集的查找，路径压缩</span></span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = find(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;<span class="comment">// 求解LCA</span></span><br><span class="line">    st[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// u这条路上的根节点的左下的点用并查集合并到根节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i;i = ne[i])&#123;<span class="comment">// 求dist也可以放在tarjan中进行</span></span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])&#123;<span class="comment">// st[j]为0表示还没走过，1表示正在访问，2表示已经访问完且已经回溯过</span></span><br><span class="line">            tarjan(j);<span class="comment">// 往下搜到叶子节点，必须放合并操作之前，先处理询问</span></span><br><span class="line">            p[j] = u;<span class="comment">// 并查集的合并操作，从下面回溯后把u往下搜到的点并入u</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对于当前节点u，处理和u相关的所有查询</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item:query[u])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = item.first,id = item.second;</span><br><span class="line">        <span class="keyword">if</span> (st[y] == <span class="number">2</span>)&#123;<span class="comment">// 如果和u相关的点y已经访问过且回溯过</span></span><br><span class="line">            <span class="keyword">int</span> anc = find(y);<span class="comment">// u和y的LCA就是y在并查集的根节点</span></span><br><span class="line">            <span class="comment">// 查找祖宗的时候一并更新路径上所有节点的根节点</span></span><br><span class="line">            res[id] = dist[u] + dist[y] - <span class="number">2</span>*dist[anc];</span><br><span class="line">            <span class="comment">// 根据询问编号，通过LCA计算u和j的最短距离</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    st[u] = <span class="number">2</span>;<span class="comment">// u已经访问过且要回溯，标记为2，放在遍历节点和处理询问之间也行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++)&#123;<span class="comment">// 建图</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        add(a,b,c),add(b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入询问</span></span><br><span class="line">    <span class="keyword">int</span> e,f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;e,&amp;f);</span><br><span class="line">        <span class="keyword">if</span> (e != f)&#123;<span class="comment">// e = f，距离就是0，不用处理</span></span><br><span class="line">            query[e].push_back(&#123;f,i&#125;);<span class="comment">// 两个点之前的询问是相互的，和边类似</span></span><br><span class="line">            query[f].push_back(&#123;e,i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">-1</span>);<span class="comment">// 求距离</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) p[i] = i;<span class="comment">// 初始化并查集</span></span><br><span class="line">    tarjan(<span class="number">1</span>);<span class="comment">// 从1号点往下搜</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res[i]);<span class="comment">// 输出每次询问答案</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-acwing-840-模拟散列表（模板题）"><a href="#7-acwing-840-模拟散列表（模板题）" class="headerlink" title="7 acwing.840. 模拟散列表（模板题）"></a>7 acwing.840. 模拟散列表（模板题）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">维护一个集合，支持如下几种操作：</span><br><span class="line">I x，插入一个数 x；</span><br><span class="line">Q x，询问数 x 是否在集合中出现过；</span><br><span class="line">现在要进行 N 次操作，对于每个询问操作输出对应的结果。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含整数 N，表示操作数量。</span><br><span class="line">接下来 N 行，每行包含一个操作指令，操作指令为 I x，Q x 中的一种。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">对于每个询问指令 Q x，输出一个询问结果，如果 x 在集合中出现过，则输出 Yes，否则输出 No。</span><br><span class="line">每个结果占一行。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤N≤<span class="number">10</span>^<span class="number">5</span></span><br><span class="line">−<span class="number">10</span>^<span class="number">9</span>≤x≤<span class="number">10</span>^<span class="number">9</span></span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">5</span></span><br><span class="line">I <span class="number">1</span></span><br><span class="line">I <span class="number">2</span></span><br><span class="line">I <span class="number">3</span></span><br><span class="line">Q <span class="number">2</span></span><br><span class="line">Q <span class="number">5</span></span><br><span class="line">输出样例：</span><br><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p><strong>哈希表</strong>的模板题。</p>
<p>参考：算法笔记。</p>
<p>哈希表是又称散列表，一种以 “key-value” 形式存储数据的数据结构。</p>
<p>可以把哈希表理解为一种高级的数组，这种数组的下标可以是很大的整数，浮点数，字符串甚至结构体。</p>
<p>也就是把复杂的结构（内容庞杂）映射到一个小范围（一般取0~N，N一般较小）。</p>
<p>哈希可以用一句话说明：<strong>将元素通过一个函数转换为整数，使得该整数可以尽量唯一地代表这个元素</strong>。</p>
<p>常见的解决冲突的方法（哈希表的存储结构）有：<strong>开放寻址法</strong>、<strong>拉链法</strong>。</p>
<p>算法题中的哈希表一般只涉及到添加和查找2种操作，不涉及删除操作。</p>
<p>1.拉链法： 52 ms。时间复杂度：O(n)，处理n次询问。</p>
<p>注意：哈希函数中的模数一般都取成<strong>质数</strong>且离2的次幂较远。（这样能有效降低冲突概率）</p>
<p><img src="/posts/c405365c/image-20210708214906658.png" alt="image-20210708214906658"></p>
<p>还是用数组模拟链表，和（三五）树形DP存图的方式一模一样。（忘了的回去复习）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100003</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">// 通过hash函数插入x</span></span><br><span class="line">    <span class="keyword">int</span> k = (x % N + N) % N;<span class="comment">// 转正余数</span></span><br><span class="line">    e[idx] = x,ne[idx] = h[k],h[k] = idx++;<span class="comment">// 新节点插入链表中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">// 通过hash函数查找x</span></span><br><span class="line">    <span class="keyword">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[k]; ~i;i = ne[i])&#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i] == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 计算hash函数的模数，取离10^5最近的质数，10^5+3</span></span><br><span class="line">    <span class="comment">// for (int i = 100000; ;i++)&#123;</span></span><br><span class="line">    <span class="comment">//     bool flag = true;</span></span><br><span class="line">    <span class="comment">//     for (int j = 2;j * j &lt;= i;j++)&#123;</span></span><br><span class="line">    <span class="comment">//         if (i % j == 0)&#123;</span></span><br><span class="line">    <span class="comment">//             flag = false;</span></span><br><span class="line">    <span class="comment">//             break;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     if (flag)&#123;</span></span><br><span class="line">    <span class="comment">//         printf(&quot;%d\n&quot;,i);</span></span><br><span class="line">    <span class="comment">//         break;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);<span class="comment">// 建立链表前记得置-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">2</span>];<span class="comment">// 存1个字符的字符串</span></span><br><span class="line">    <span class="keyword">while</span> (n--)&#123;<span class="comment">// 尽量用scanf读入字符串，忽略回车空格制表符等</span></span><br><span class="line">        <span class="comment">// 这里用字符读入会读到空格！！！</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,op,&amp;x);</span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;I&#x27;</span>) insert(x);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (find(x)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.开放寻址法： 52 ms。时间复杂度：O(n)，处理n次询问。</p>
<p>开一个一维数组（经验上开数据范围的2到3倍）。</p>
<p><img src="/posts/c405365c/image-20210718191124541.png" alt="image-20210718191124541"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200003</span>,null = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> h[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">// 开放寻址法的核心操作</span></span><br><span class="line">    <span class="keyword">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span> (h[k] != null &amp;&amp; h[k] != x)&#123;</span><br><span class="line">        k ++;</span><br><span class="line">        <span class="keyword">if</span> (k == N) k = <span class="number">0</span>;<span class="comment">// 找到最后一个空位，返回开头继续找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;<span class="comment">// 1.如果x在数组h中存在，返回其位置;2.如果x在数组h中不存在，返回下一个空位</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 计算hash函数的模数，取离20^5最近的质数，200003</span></span><br><span class="line">    <span class="comment">// for (int i = 200000; ;i++)&#123;</span></span><br><span class="line">    <span class="comment">//     bool flag = true;</span></span><br><span class="line">    <span class="comment">//     for (int j = 2;j * j &lt;= i;j++)&#123;</span></span><br><span class="line">    <span class="comment">//         if (i % j == 0)&#123;</span></span><br><span class="line">    <span class="comment">//             flag = false;</span></span><br><span class="line">    <span class="comment">//             break;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     if (flag)&#123;</span></span><br><span class="line">    <span class="comment">//         printf(&quot;%d\n&quot;,i);</span></span><br><span class="line">    <span class="comment">//         break;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> h);<span class="comment">// 将h初始化为不在x范围的数null，表示位置没用过</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span> (n--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,op,&amp;x);</span><br><span class="line">        <span class="keyword">int</span> k = find(x);</span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;I&#x27;</span>) h[k] = x;<span class="comment">// 返回空位，插入x</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (h[k] != null) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);<span class="comment">// 返回空位说明没找到x</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.STL–&gt;unordered_map：91 ms。map：274 ms。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> n,x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,s,&amp;x);</span><br><span class="line">        <span class="keyword">if</span> (*s == <span class="string">&#x27;I&#x27;</span>) a[x] = x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[x] == <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>y总模板：</p>
<p>(1) 拉链法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="comment">// 向哈希表中插入一个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = (x % N + N) % N;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在哈希表中查询某个数是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2) 开放寻址法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> h[N];</span><br><span class="line"><span class="comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        t ++ ;</span><br><span class="line">        <span class="keyword">if</span> (t == N) t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是蓝桥杯学习总结系列的最后一篇！蓝桥杯系列正式完结！</p>
<p>整理题目86道，完成题解85篇，竞赛内容10章，系列文章40篇，时间跨度134天。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>LCA</tag>
        <tag>Tarjan</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯学习总结（四）</title>
    <url>/posts/62ce3559.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>续蓝桥杯学习总结（三）。</p>
</blockquote>
<span id="more"></span>

<h4 id="3-3-acwing-1208-翻硬币-（简单）"><a href="#3-3-acwing-1208-翻硬币-（简单）" class="headerlink" title="3.3 acwing.1208. 翻硬币 （简单）"></a>3.3 acwing.1208. 翻硬币 （简单）</h4><blockquote>
<p>第四届C++ B组原题</p>
</blockquote>
<p>小明正在玩一个“翻硬币”的游戏。</p>
<p>桌上放着排成一排的若干硬币。我们用 * 表示正面，用 o 表示反面（是小写字母，不是零）。</p>
<p>比如，可能情形是：<code>**oo***oooo</code></p>
<p>如果同时翻转左边的两个硬币，则变为：<code>oooo***oooo</code></p>
<p>现在小明的问题是：如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币,那么对特定的局面，最少要翻动多少次呢？</p>
<p>我们约定：把翻动相邻的两个硬币叫做一步操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入格式</span><br><span class="line">两行等长的字符串，分别表示初始状态和要达到的目标状态。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">一个整数，表示最小操作步数</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">输入字符串的长度均不超过<span class="number">100</span>。</span><br><span class="line">数据保证答案一定有解。</span><br><span class="line"></span><br><span class="line">输入样例<span class="number">1</span>：</span><br><span class="line">**********</span><br><span class="line">o****o****</span><br><span class="line">输出样例<span class="number">1</span>：</span><br><span class="line"><span class="number">5</span></span><br><span class="line">输入样例<span class="number">2</span>：</span><br><span class="line">*o**o***o***</span><br><span class="line">*o***o**o***</span><br><span class="line">输出样例<span class="number">2</span>：</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>想象一下，每两个硬币中间看作由一个灯泡控制。其实就是费解的开关的简化版。</p>
<p>模拟法：</p>
<p>从最左侧开始遍历，如果该位置硬币状态与目标不同，就翻动该位置和该位置后面的两枚硬币。<br>因为题目说了有解，所以遍历到倒数第二枚的时候，所有硬币状态就与目标相同了。</p>
<p><img src="/posts/62ce3559/image-20210329205656532.png" alt="image-20210329205656532"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">char</span> start[N],aim[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start[a] == <span class="string">&#x27;*&#x27;</span>) start[a] = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> start[a] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; start &gt;&gt; aim;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(start);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (start[i] != aim[i])</span><br><span class="line">        &#123;</span><br><span class="line">            turn(i),turn(i+<span class="number">1</span>);</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：遍历了一边输出，时间复杂度是 O(n)。</p>
<p>该思路时间复杂度已是最优，要使起始状态变为目标状态，至少遍历一边来进行判断，时间复杂度最少是 O(n)。</p>
<p>空间复杂度：没有开辟与输入输出有关的空间，空间复杂度是O(1)。</p>
<h4 id="3-4-acwing-116-飞行员兄弟-（超长代码预警）"><a href="#3-4-acwing-116-飞行员兄弟-（超长代码预警）" class="headerlink" title="3.4 acwing.116.飞行员兄弟 （超长代码预警）"></a>3.4 acwing.116.飞行员兄弟 （超长代码预警）</h4><p>“飞行员兄弟”这个游戏，需要玩家顺利的打开一个拥有 16个把手的冰箱。</p>
<p>已知每个把手可以处于以下两种状态之一：打开或关闭。</p>
<p>只有当所有把手都打开时，冰箱才会打开。</p>
<p>把手可以表示为一个 4×4 的矩阵，您可以改变任何一个位置 [i,j]上把手的状态。</p>
<p>但是，这也会使得第 i 行和第 j列上的所有把手的状态也随着改变。</p>
<p>请你求出打开冰箱所需的切换把手的次数最小值是多少。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入格式</span><br><span class="line">输入一共包含四行，每行包含四个把手的初始状态。</span><br><span class="line">符号 + 表示把手处于闭合状态，而符号 - 表示把手处于打开状态。</span><br><span class="line">至少一个手柄的初始状态是关闭的。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">第一行输出一个整数 N，表示所需的最小切换把手次数。</span><br><span class="line">接下来 N 行描述切换顺序，每行输出两个整数，代表被切换状态的把手的行号和列号，数字之间用空格隔开。</span><br><span class="line">注意：如果存在多种打开冰箱的方式，则按照优先级整体从上到下，同行从左到右打开。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤i,j≤<span class="number">4</span></span><br><span class="line">输入样例：</span><br><span class="line">-+--</span><br><span class="line">----</span><br><span class="line">----</span><br><span class="line">-+--</span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>Solution 1:数组枚举法，对于所有操作暴力枚举</p>
<p><img src="/posts/62ce3559/image-20210329210942984.png" alt="image-20210329210942984"></p>
<p>注意：题中如果存在多种打开冰箱的方式，则按照优先级整体从上到下，同行从左到右打开。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second  <span class="comment">// 简化</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> g[N][N],backup[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*<span class="number">4</span> + y; <span class="comment">// 求二维坐标对应的0,1,2,...,15中的映射</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn_one</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g[x][y] == <span class="string">&#x27;+&#x27;</span>) g[x][y] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> g[x][y] = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把十字上的把手都反转</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn_all</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        turn_one(x,i);</span><br><span class="line">        turn_one(i,y);</span><br><span class="line">    &#125;</span><br><span class="line">    turn_one(x,y);<span class="comment">//前面操作把手两次，所以要多操作一次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) <span class="built_in">cin</span> &gt;&gt; g[i];</span><br><span class="line">    <span class="built_in">vector</span>&lt;PII&gt; res; <span class="comment">// 存放最终答案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> op = <span class="number">0</span>;op &lt; <span class="number">1</span> &lt;&lt; <span class="number">16</span>;op++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;PII&gt; temp; <span class="comment">// 存放当前答案</span></span><br><span class="line">        <span class="built_in">memcpy</span>(backup,g,<span class="keyword">sizeof</span> g); <span class="comment">// 备份</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据枚举的op进行反转操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (op &gt;&gt; get(i,j) &amp; <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.push_back(&#123;i,j&#125;);</span><br><span class="line">                    turn_all(i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 判断是否满足把手全部打开</span></span><br><span class="line">        <span class="keyword">bool</span> has_closed = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    has_closed = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(has_closed == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="comment">// 判断res是否已经求出或是否最优解</span></span><br><span class="line">            <span class="keyword">if</span> (res.empty() || res.size()&gt;temp.size()) res = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(g,backup,<span class="keyword">sizeof</span> g);  <span class="comment">// 还原</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;res.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> op:res) <span class="built_in">cout</span> &lt;&lt; op.x + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt;op.y+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// 输出实际坐标</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Solution 2:枚举+位运算法，对solution1的二进制优化</p>
<p>看不懂的话请参考：<a href="https://www.acwing.com/solution/content/983/">算法2：枚举+位运算</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4</span>, INF = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> change[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * N + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )<span class="comment">// change每个位置二进制表示将哪些位置取反</span></span><br><span class="line">        <span class="comment">//对照着solution1的turn_all &amp; turn_one函数就比较好理解啦</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; N; k ++ ) change[i][j] += (<span class="number">1</span> &lt;&lt; get(i, k)) + (<span class="number">1</span> &lt;&lt; get(k, j));</span><br><span class="line">            change[i][j] -= <span class="number">1</span> &lt;&lt; get(i, j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> state = <span class="number">0</span>;<span class="comment">// state用于存放所有把手的当前状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> line;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; line;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (line[j] == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">                state += <span class="number">1</span> &lt;&lt; get(i, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;PII&gt; path;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; <span class="number">16</span>; i ++ )<span class="comment">// 枚举对把手的所有操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now = state;</span><br><span class="line">        <span class="built_in">vector</span>&lt;PII&gt; temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>) <span class="comment">// 求i的第j位数字</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x = j / <span class="number">4</span>, y = j % <span class="number">4</span>;</span><br><span class="line">                now ^= change[x][y]; <span class="comment">// 对now的把手进行反转，异或取反</span></span><br><span class="line">                temp.push_back(&#123;x, y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 判断解存在且是最优解</span></span><br><span class="line">        <span class="keyword">if</span> (!now &amp;&amp; (path.empty() || path.size() &gt; temp.size())) path = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; path.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : path)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p.first + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p.second + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Solution 3:DFS法</p>
<p>对于每个把手，有选和不选两种情况。</p>
<p>这种写法满足题意：如果存在多种打开冰箱的方式，则按照优先级整体从上到下，同行从左到右打开。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dalao的优化版本，比solution1快了近10倍</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="built_in">vector</span>&lt;PII&gt; ans, tmp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn_one</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g[x][y] == <span class="string">&#x27;+&#x27;</span>) g[x][y] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> g[x][y] = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn_all</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        turn_one(x, i);</span><br><span class="line">        turn_one(i, y);</span><br><span class="line">    &#125;</span><br><span class="line">    turn_one(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果说所有的把手都操作完了就看看冰箱能否打开</span></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">3</span> &amp;&amp; y == <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> success = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;<span class="number">4</span>; j++)</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">                &#123;    </span><br><span class="line">                    success = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">goto</span> end;</span><br><span class="line">                &#125;</span><br><span class="line">        end:</span><br><span class="line">        <span class="keyword">if</span> (success)</span><br><span class="line">            <span class="comment">// 判断是否最优解</span></span><br><span class="line">            <span class="keyword">if</span> (ans.empty() || tmp.size() &lt; ans.size())</span><br><span class="line">                ans = tmp;</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">// 递归结束千万记得退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断边界，如果y出界了就往下一行移动</span></span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">4</span>) x++, y = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 操作把手(x, y)</span></span><br><span class="line">    turn_all(x, y);</span><br><span class="line">    tmp.push_back(&#123; x, y &#125;);</span><br><span class="line">    dfs(x, y + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 恢复现场，关键所在</span></span><br><span class="line">    tmp.pop_back();</span><br><span class="line">    turn_all(x, y);</span><br><span class="line">    <span class="comment">// 不操作把手(x, y)</span></span><br><span class="line">    dfs(x, y + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i]);</span><br><span class="line">    <span class="comment">// 从(0, 0)开始DFS</span></span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, ans[i].first + <span class="number">1</span>, ans[i].second + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>竞赛</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title>记一道C++作业题</title>
    <url>/posts/a83020d5.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>如题：题目要求根据初始化时的日期加上一定的天数后计算得到的日期，这里用到的计算思路来自<a href="https://grant1499.github.io/2021/03/26/%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86%E4%B8%8E%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98/">这里</a>。</p>
<span id="more"></span>

<p><img src="/posts/a83020d5/image-20210412221018035.png" alt="image-20210412221018035"></p>
<p>只要稍做改动，就能写出代码来了，不过要注意原题计算的是日期差+1！</p>
<p>这题主要考察了日期问题、++前缀与后缀重载等知识点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// 判断闰年，是闰年返回true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeap</span><span class="params">(<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (y%<span class="number">4</span>==<span class="number">0</span> &amp;&amp;y%<span class="number">100</span>!=<span class="number">0</span>) || (y%<span class="number">400</span>==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//顺序存放平年、闰年每月对应天数</span></span><br><span class="line"><span class="keyword">int</span> month[<span class="number">13</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">28</span>,<span class="number">29</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,</span><br><span class="line">	&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Date()&#123;</span><br><span class="line">            y = <span class="number">2000</span>,m = <span class="number">1</span>,d = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Date(<span class="keyword">int</span> _y,<span class="keyword">int</span> _m,<span class="keyword">int</span> _d):</span><br><span class="line">        y(_y),m(_m),d(_d)&#123;&#125;</span><br><span class="line">        <span class="comment">// Copy Constructor</span></span><br><span class="line">        Date(Date&amp; t)&#123;</span><br><span class="line">            y = t.y,m = t.m,d = t.d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Y:%d,M:%2d,D:%2d\n&quot;</span>,y,m,d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">friend</span> Date <span class="keyword">operator</span>+ (Date&amp; D,<span class="keyword">int</span> n);<span class="comment">// 重载加号</span></span><br><span class="line">        <span class="keyword">friend</span> Date <span class="keyword">operator</span>++ (Date&amp; D,<span class="keyword">int</span>);<span class="comment">// 重载后缀++</span></span><br><span class="line">        <span class="keyword">friend</span> Date <span class="keyword">operator</span>++ (Date&amp; D);<span class="comment">// 重载++前缀</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line">Date <span class="keyword">operator</span>+ (Date&amp; D,<span class="keyword">int</span> n)&#123;</span><br><span class="line">    Date temp = D;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;<span class="comment">// 累加ans到n</span></span><br><span class="line">    <span class="comment">// ans == n退出</span></span><br><span class="line">    <span class="keyword">while</span> (ans &lt; n)&#123;</span><br><span class="line">        <span class="comment">// 优化，降低循环次数</span></span><br><span class="line">        <span class="keyword">if</span> (n- ans &gt; <span class="number">366</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (isLeap(temp.y)) ans += <span class="number">366</span>;</span><br><span class="line">            <span class="keyword">else</span> ans += <span class="number">365</span>;</span><br><span class="line">            temp.y ++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.d ++;</span><br><span class="line">        <span class="keyword">if</span> (temp.d == month[temp.m][isLeap(temp.y)]+<span class="number">1</span>)&#123;</span><br><span class="line">            temp.d = <span class="number">1</span>;temp.m ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp.m == <span class="number">13</span>)&#123;</span><br><span class="line">            temp.m = <span class="number">1</span>;temp.y ++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载后缀++</span></span><br><span class="line">Date <span class="keyword">operator</span>++ (Date&amp; D,<span class="keyword">int</span>)&#123;</span><br><span class="line">    Date temp = D;</span><br><span class="line">    D.d ++;</span><br><span class="line">    <span class="keyword">if</span> (D.d == month[D.m][isLeap(D.y)]+<span class="number">1</span>)&#123;</span><br><span class="line">        D.d = <span class="number">1</span>;D.m ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (D.m == <span class="number">13</span>)&#123;</span><br><span class="line">        D.m = <span class="number">1</span>;D.y ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载++前缀</span></span><br><span class="line">Date <span class="keyword">operator</span>++ (Date&amp; D)&#123;</span><br><span class="line">    D.d ++;</span><br><span class="line">    <span class="keyword">if</span> (D.d == month[D.m][isLeap(D.y)]+<span class="number">1</span>)&#123;</span><br><span class="line">        D.d = <span class="number">1</span>;D.m ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (D.m == <span class="number">13</span>)&#123;</span><br><span class="line">        D.m = <span class="number">1</span>;D.y ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> D;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Date d1(2019,12,31),d2,d3;</span><br><span class="line">    d2 = d1++;</span><br><span class="line">    d1.print();</span><br><span class="line">    d2.print();</span><br><span class="line">    d3 = ++d1;</span><br><span class="line">    d1.print();</span><br><span class="line">    d3.print();</span><br><span class="line">    d1 = d1 + <span class="number">365</span>;</span><br><span class="line">    d1.print();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag>日期处理</tag>
      </tags>
  </entry>
  <entry>
    <title>设计一个二维数组类并重载运算符</title>
    <url>/posts/ca18faac.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>如题：设计一个M*N的二维数组类，要求重载+、-运算符。</p>
<span id="more"></span>

<p><img src="/posts/ca18faac/image-20210415102641989.png" alt="image-20210415102641989"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">        Array()&#123;&#125;</span><br><span class="line">		Array(<span class="keyword">int</span> n[M][N])&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i ++)</span><br><span class="line">			    <span class="built_in">memcpy</span>(arr[i],n[i],<span class="keyword">sizeof</span>(n[N]));</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)&#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\t&#x27;</span> &lt;&lt; arr[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入2*3的整型数组：\n&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++) <span class="built_in">cin</span> &gt;&gt; arr[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        Array <span class="keyword">operator</span>+ (Array&amp; a)&#123;</span><br><span class="line">                Array temp;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)&#123;</span><br><span class="line">                        temp.arr[i][j] = <span class="keyword">this</span>-&gt;arr[i][j]+a.arr[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        Array <span class="keyword">operator</span>- (Array&amp; a)&#123;</span><br><span class="line">                Array temp;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)&#123;</span><br><span class="line">                        temp.arr[i][j] = <span class="keyword">this</span>-&gt;arr[i][j]-a.arr[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span> arr[M][N];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[M][N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">	Array A(a),B,C,D;</span><br><span class="line">	B.<span class="built_in">set</span>();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Array A:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	A.show();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Array B:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	B.show();</span><br><span class="line">	C = A + B;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Array C=A+B:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	C.show();</span><br><span class="line">	D = A - B;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Array D=A-B:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	D.show();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法专题</title>
    <url>/posts/fcd79b01.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="b8f71c84c6d42a2e13c69c1df1dab003c9ad1bd40543e2817935b2fc68a0751d">fb26124e0d85f363a66baed35993e1a0948953cce3d484fb31660455b92ccb286ba4467b12dd2afdc0f8bd795964707216933c479f00faf5302337078027ef66e68c754bf0232403ae44399aa06a2cad741400e24549082709cdee4a1c1e38f29d8bb6993c43448bafc4543d636ea5bfe35062ad225c74a80f232ba51d9af45093f5220e616be2d57e02341ffad661bef2886dba249b54377d8b3961fd62e8e7033554e6a1a85b429bcdccd8e910eaca84c8e447cedd760cd76a16c64ec7f94ad050108487716cc544f1ca685285a120a1c590efd559bdca18a90707fae890221e2912f079f089d10fb816e69e85944586941b721161d200273028ce2f3cb2d1a6a47461dcfac58b4612622383de37911e7101936179b0ecfeb18f3600111afc0a3048b3a9bc8162408d2cdd766c056081be36f6984d0fc9924355cadc0cde3eb9b769df924e862815f18fb7ec6ae1a8ada8a2df47af423b4e8e44ff9bec9e117db3bd653c19d4db138c3ba4f8a9920b2f45909a6ad29b5163897bb51b0d5d0695c1c7e0edca6045fdf1ef0a78d5fc5e2ab3bc25c0ce06c5a85aeb7da7cc7176</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>趣谈计算机网络协议（一）</title>
    <url>/posts/64abf487.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="cf57d2f9e2257deb7027c54a33cff3dfd768eaa042391c79918c3328d2a146f0">fb26124e0d85f363a66baed35993e1a0948953cce3d484fb31660455b92ccb286ba4467b12dd2afdc0f8bd795964707216933c479f00faf5302337078027ef66e68c754bf0232403ae44399aa06a2cad741400e24549082709cdee4a1c1e38f29d8bb6993c43448bafc4543d636ea5bfe35062ad225c74a80f232ba51d9af45093f5220e616be2d57e02341ffad661bef2886dba249b54377d8b3961fd62e8e7033554e6a1a85b429bcdccd8e910eaca84c8e447cedd760cd76a16c64ec7f94ad050108487716cc544f1ca685285a120a1c590efd559bdca18a90707fae890221e2912f079f089d10fb816e69e85944586941b721161d200273028ce2f3cb2d1a6a47461dcfac58b4612622383de37911e7101936179b0ecfeb18f3600111afc775a9e1f79696dae92585891ef4dfac11d9f3be22cf97722064b1ab128625b743406017ad9d95aec0435dac99930e0072cdbaded2c7115a36b5b5b42dafaffb6dac788fb14d6f015c20160a0393676051ef461952cc24cae74dc9e95b7431865f28504a5cf0105bb1cd9595858a317748417c59eb4c7fb2c2c0703f4c365029d3289354351557897fa5a5fc7910b63bf93a054d852af2293fef26e04261a952ba5328dd4c469bd01e9cd6c66571eb1db7b667025482cae36fe58bde6556f56f72ecdd81d44ae47a4df776930786c5021af1db8558a20744347d91934710edb63df32d103b28eae9a7208db68f2d949d7a59b86ac49ee490c80cb3476527744596dc00e6edeae2f4e56ee2dc8ab54e5966122b4c029c746883f11f2a48b8df48eea2818d015775adc3bc6b762523b0c6fa01265293781132eb3d1fd232055e9616f78314ce22daa571f9dbf832bb05beb7e9d7137b736f261b44d73c020aed96c070a5636f09e69309c6f1dbda49c0296423b3a5f8b76a4a8ca18c81a711b581f7bd20791aecd226f6267fdff6842ad230e2679b206f835f9d0d369c8112d34f9cf4de0e8d0ffedf2163bdfb00c51f0e34c9d0825f4426714a1321df9238546bc43717ed9ab7821abad79f4768a1f0d8fa3aaf5c81f9e3aac9e3db546b3e18cc4644d5f75a992ddf755f781fd87e2de7754beba74370e52763c69e0871ef14ab2860a6d3da0a5dc1353ed3e82cbf693d0a8546a697c84c170970c572aee0b575c33770fb6e29430ab5701e380797afa46dca4601e5fb9e51d86e0808cc9cbb57ed0add49429a819268295b434c2542aacb32f15228fb8f802ab11905596dd605f05581e5f08892e0636880f50d3926c71dcc42677ef22078d7579e446be609a3d58ee5b6ff7deeb7c60e501f2623c59248d4f36ea73475c376463080551970e0602fdcdfb9824ae007f765b6c366de22df943b43a13cad9466c7de9c7f5f968ad3f56899913601df979095fda0760c12452a304867287db7eab884d1008dfa0561b9c299f7ace7a83db81e67cee906cf0c69264a3989fead1252dff781f982d0acc8af9582f523cb2b91017113ac9f9e335a5e0bdb6ad4995a4e3945a03d4be48276f294248551506b4d5281ea62274986d59c7c349b1fa031d999ca0ae8f6a8de727d4b3fa8bd7cdf415261dccaaaf4022369c20912c6ff366fc3982f17f51714638c1f9041e4d1fdc7561c3592d6beac89df6ce7f21e01795bafb73eef89d9bfa6d1bd33f4768dd76ab21081668e223f805fc6a81e243f7541324ad3982a903b6a6673fbb00a63e6b4cf254f8a95df201e0eaa2030e6cd5f4b3f24e76b1c6fe3ec7f98f87ded0aa1e844bab5665cf3028d8f1df7580f3661961094333d8b5b1657e92d304a671d1e0427f5e04e9c3b623bdb4d4425efb8553315de3a570bf200d37041e02cb15142a8ad8198029fbb0e890167a748f58cc3dd30d66444d3662142ba9d3ec851bfafdf979532ae178ad726f5b13f4ccc82b9f9e4ca9361e83a430d1cfa394ecd11453227acc69e2404947ba0e2d6e4031b6d41cfbef2bab3bf26352a2305d67a30cf6a240d39d7d4a3efc73639056c8529e2c4ab379380d5131510a95a422613fa2653924613e448b7a2ab547a1e6378f49914dabfb69d6208bd253a27aea1f26afde53e6a0bd54d50d6902a98041559b737d49f2dfbef3c54ba9efe53c5f935682fd931a72c8c22df276fcb8591fd83df490a8a577716284df354f9ec6a7376075b0569da5120e59d5cf0e7779806e31e117ae911b3ebe81b3751cc2f5282f3626a7d8814f862ac2df3b239d4b6c70f0b64d34b1734a8a071ed5fa8fcea5221b78b7441b01fb8a87d4043f660930d2164170bcef5ffd7b8571bb7d56ccf3cc60c87db5537d7c36768e21ed2d78d8e7bd43e1544e110e64de3db5e9b2399fa73f1fadb2aedd2e0bdc53b45a7750ae287cdffc3309d88c2ef8a6d91490f8e5a9ee5f8147e281252f478871041cb81319c524fa4c8d243d5e1f7211f7d6bb3597c32d9c69f4252348a054ca628b10c525ddcc6e4c39f3891fba3bffd8486283ee98ed3a67de63bf9be7b71f559e894e2ecefae7d48afec134903ba1978f8a336c9af8165903e6241e4bb13ca3e7c2a7360f4ea56a3bcdc5101b6ecb75cfe972853a91442589a3a8b4c4d5c0c3d3dfc0d6be8363cd0b464d22f790df5598cb58b482c9ad430f3c92e8dc0a74e78ed5a6e3188afd8c7a39dc130dceb3efdc3dd92f9e6eb1bb7802722a73d23cd79c8e4fe2eb549de2a7fe4ad6efd6ba5ffc287d728a71dae3a8684bee91eb7844587794cfb2cf6676f7cc38a898ef29279256d5da552f503974305d8bf8c5f21bad768293b301c36ad833caa47b42597fac1218237b8587236f0c9c289973b2f403fa8e03cda63abfe42a787ea9ae0d4e5c036be6469f4201b8dd2c227c052e06b34a6ee73d6bb14f099a953b2204c59852127bf4920767ba25bf06af353a869f0b5b1226a7c53c3e95ecb32f653a88318e697d1135a54ee5e17afb15592fe719e78447c8b7c7cafc0e11bf1592c6f5768a6d7b9c5605d2be29d0342e532be5a48e6b1736db5c36fe45f5c199d3ab662eb6a1ada3e8fab72a5ade402c92d387a88e8975829ebbc2daaf4b55799d10a42c8fb84aa8be9ef0f2a0181d9dfa67d7c540583564acd4bdd94074949ba0a4588a005a2a125c55cc26c6b3160eabecdfdde5367ad88051a788639967ad740ceb95bee496996a2bfae6df212c0c3157f5b4090e623880fa2ef346e8b2000fce317311faff466965c9284348e66f794054dfb0994bf34463e81f7c3e68e442c6cfb51fad99b0a479647d0ba706088289df1a728e27a0335c6d91eb9d8909fc1fcfcea91b910642c8feb4f694996b49eb2d4f194edb11e89da3eeae6a8c5eef41872df5ae0005f4c9780d621f0cc8d6b9af76533e3726ad2c93fd115f5d9cbfd64b687737c86219b9c32d4473e0966aa1beff6a67c62f651af2a250c449628f2298120d498dfcfa321be6f6dd1cf63f2756780064cbebb7a9f658b760dc5eafbcd7031467c571a65ab43e84c93991d7305cfaa7af4ce7fff213ee650544454d88b214923b947ccfb2a41f3a85d992b84fcfd6b2a3cc15e56b171ba497f7fe47f207db66c8043d654aeec1aea6cb93087b6a2707062e21ef74ad2f74340ad12d327e5206b61cc4dd63077d79c46b30081cf282ee48fca106828a333ce480d1089e41b56e10f0b2da496a1831fcd2df2ad323a48628b31e1f942b7c0404efcbf1639b5e03973e13e924ba38fff7fc9ed2625f8be90ba273d2a6cfb1dedad44f799144d43449e2a74d9d27894ef3edd7f2706cb182c2e2f84cf9f0d76a1772f37c3c442de68c27addd15d2194cba8fef535e2b97f4f43ed17879530d358371671904dcb18bb5323c68e3cfecfe6219c925218e7911552aeb3d9470dc89c7d3f6bc8a387208230f9c9ff47cdc4cda961bea0cd993eef1bb1bda6ac980f9b34b581e7b29cd700ae8c7d57c26919ce2cfd515efa763e2c2793c4a94cfe08ee1213feebf6503a416762eadbe6b579fd13b0c86db9ba364b5a0ce56cfb973015143f252e71ad25b7dc096003868c51721fd150300e64acecb405366a0065bff8dad3a888d0f551d2f12e9d66b55b0b0770742e49c5a6c9da3716d89d4d743cbbe2cc2fb7e1b26dfb4396dac3d197f133f4271bb3b80b4bbb59f58125042cdf534926cf97b7496d1d0e5f9d0e2121fdae8fdcebf2907c873329384da2aa35685285019217442ed3e86098fd3e2f47a1eb9074fc63aaadf7e4864f8f10d270c2654a371e302b5d747288866d8a600bb2daaa5131dd6e8698c73a984a88a226d3888a4b33670</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>重磅推荐 | 史上最全面最标准的数学符号、公式的英语读法</title>
    <url>/posts/45403fc4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>转载自<a href="https://mp.weixin.qq.com/s/gaHfVbXLSP3-hC5bMrdQHA">英文茶馆</a> <em>2017-10-29</em></p>
<p>说起英语和数学，大概每个人都有难忘的回忆。可是学了十几、二十年的英语和数学，你会用英语来表达数学吗？烂熟于心的数学符号和表达式用英语会说吗？想不想挑战一下自己？</p>
<span id="more"></span>

<p>先来一个最简单的：1+2=3 用英语怎么说？</p>
<p>One plus two equals three. 哎呦不错哦， 继续！</p>
<p> 尝试：$\sqrt {x + y}$英语怎么说？</p>
<p>就知道你说不出来咯～今天这篇文章，将从小学到博士后的数学符号和表达式的英文读法一网打尽，全都总结好了！惊不惊喜？意不意外？！</p>
<p>数学是所有理工学科的基础，是认识科学世界基本工具，数学的重要性不言而喻。所以，这篇文章是老少咸宜的、吐血总结的干货。可以帮助：</p>
<p><strong>中小学生：</strong>了解英语不仅是“I am a student.My name is XXX.”,而是真正用于学习数学、学习知识的工具。</p>
<p><strong>大学生：</strong>在外教课堂、国际会议、外企，面对常见的数学符号，简单得不能再简单的数学问题时，不再茶壶里煮饺子倒不出来。</p>
<p><strong>留学党：</strong>缩短刚到国外听懂老师课堂讲课的过渡期。</p>
<p><strong>学生家长</strong>可以为你家宝宝留着哦～</p>
<h2 id="基本数学符号"><a href="#基本数学符号" class="headerlink" title="基本数学符号"></a><strong>基本数学符号</strong></h2><h3 id="1-加减乘除"><a href="#1-加减乘除" class="headerlink" title="1. 加减乘除"></a><strong>1. 加减乘除</strong></h3><p><img src="/posts/45403fc4/image-20210310194431214.png" alt="image-20210310194431214"></p>
<p><strong>“+”**当作运算符</strong>加号**时读作plus，比如：</p>
<p>1+2 ➡️ one plus two</p>
<p>当”+”放在数字前表示<strong>正数</strong>时，读作positive，比如：</p>
<p>+4 ➡️ positive four</p>
<p>同样，<strong>“-”</strong>也有minus和negative两种读法，分别是<strong>减号</strong>和<strong>负数</strong>。</p>
<p><strong>“×”</strong> 两种读法都可以，国外的教授会常常读成times，可能因为比较简单吧，比如：</p>
<p>9x6 ➡️ nine times six</p>
<p><strong>“÷”</strong>只有一种读法divided by，就是被…分成几份</p>
<p>15÷3 ➡️ fifteen is divided by three</p>
<p><strong>注意</strong>：</p>
<p>其中plus和minus是不用第三人称单数形式的，因为plus和minus根本就不是动词，而是介词。</p>
<p>但是乘和除，的的确确是动词，出现第三人称单数的形式。您记住了吗？</p>
<h3 id="2-比较运算符"><a href="#2-比较运算符" class="headerlink" title="2. 比较运算符"></a><strong>2. 比较运算符</strong></h3><p><img src="/posts/45403fc4/image-20210310194516520.png" alt="image-20210310194516520"></p>
<p>比较运算符用来比较两个表达式的大小关系，比如：1+4&gt;3 ➡️ one plus four is greater than three</p>
<p>为什么用<strong>is</strong>？</p>
<p>这里one plus four 是介词plus 连接两个名词，但是one plus four 作为一个整体当作主语，因此不用are，而是is</p>
<p>4+5=9 ➡️ four plus five equals nine 或 four plus five is equal to nine</p>
<p>其他的类推，只要你认识数学符号，应该不难用英语说出来。</p>
<h3 id="3-括号"><a href="#3-括号" class="headerlink" title="3. 括号"></a><strong>3. 括号</strong></h3><p><img src="/posts/45403fc4/image-20210310194547442.png" alt="image-20210310194547442"></p>
<p>括号是最常见的数学符号了。</p>
<p>中文里同类词习惯有相同的部分，比如：卡车、消防车、救护车都有“车”字。<strong>小括号，中括号，大括号</strong>都是括号。（多么科学啊！）</p>
<p>而英语里卡车、消防车、救护车分别是truck, fire engine, ambulance一点都不像。</p>
<p>英语里<strong>小括号，中括号，大括号</strong>这三个词也是没有一点相似，分别是：parenthesis，bracket，brace.（太不科学了！）</p>
<p><strong>左括号</strong>叫做left或open，<strong>右括号</strong>叫做right或closed. 下次碰到了就大胆地说出来吧！</p>
<h3 id="4-级数表示"><a href="#4-级数表示" class="headerlink" title="4. 级数表示"></a><strong>4. 级数表示</strong></h3><p><img src="/posts/45403fc4/image-20210310194619498.png" alt="image-20210310194619498"></p>
<p>哇～到中学数学了～这张表里的**<em>“a”**</em>是变量，而不是冠词“一个”的意思哦。</p>
<p><strong><em>|a|</em></strong>是<em>a</em>的绝对值或绝对值<em>a</em>， 英文读作absolute value of <em>a</em>, 非常好理解。</p>
<p><strong><em>a’</em></strong>是什么？**<em>a****</em>撇*<em>就是与</em>a<em>相关又不想重复的时候会用一下，英语里读成</em>a* prime, 同样有两撇a double prime，三撇a triple prime…</p>
<p>但是注意了，如果**<em>a’**</em>表示时间分秒里的分，或者其他有具体意义的时候，就要按照具体意义读了。</p>
<p><strong>$a^n$是a的n次方</strong>，是n个<em>a</em>相乘的结果，读作<em>a</em> superscript <em>n</em>或者<em>a</em> to the <em>n</em></p>
<p>$\bar a$,$a^ <em>$这两个初中代数就出现了，读作</em>a* bar和<em>a</em> star. <strong>Bar</strong> 就是<strong>杆</strong>的意思。<em>a</em>上面有个杆。中文怎么读？<em>a</em>杠，<em>a</em>星。</p>
<p>square是数学里的平方，cube是立方，root是根号，这几个词用于表示<strong>开方</strong></p>
<p>$a_ n$是最常出现的了，读作<em>a</em> sub <em>n</em>，<strong>一定要记住了</strong>！！在数学上大量出现。<strong>根号a</strong>和<strong>三次方a</strong>读作square root of <em>a</em>和cube root of a</p>
<h3 id="5-微分和偏微分"><a href="#5-微分和偏微分" class="headerlink" title="5. 微分和偏微分"></a><strong>5. 微分和偏微分</strong></h3><p><img src="/posts/45403fc4/image-20210310195701402.png" alt="image-20210310195701402"></p>
<p>升级到了高等数学，经过高考的学生才会碰到这两个。</p>
<p>$d/dx$这是什么鬼？这是一个变量对<em>x</em>微分或偏微分的运算符，符号后面还要加上某一个变量。首先，小伙伴知道中文怎么念吗？</p>
<p>嘿嘿，<em>d</em>比<em>d x</em>？英文读作<em>d</em> by <em>d x</em>，严谨地读作the derivative with respect to <em>x</em>， with respect to 是<strong>关于</strong>的意思，就是关于<em>x</em>的微分。</p>
<p>$\partial/\partial x$偏 比偏x？英文读作the partial derivative with respect to <em>x</em>或者简单地读作partial over partial<em>x</em>，partial是部分的意思。</p>
<p>顺便显摆一下，<strong>微分是单变量时候叫法，如果是多变量就是偏微分喽</strong>！看咱这数学是不是杠杠滴！</p>
<h3 id="6-其他数学符号"><a href="#6-其他数学符号" class="headerlink" title="6. 其他数学符号"></a><strong>6. 其他数学符号</strong></h3><p><img src="/posts/45403fc4/image-20210310200651457.png" alt="image-20210310200651457"></p>
<h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a><strong>进阶篇</strong></h2><p>有点数学基础了吧，来点实用的！进阶篇！</p>
<h3 id="1-代数-1"><a href="#1-代数-1" class="headerlink" title="1. 代数(1)"></a><strong>1. 代数(1)</strong></h3><p><img src="/posts/45403fc4/image-20210310200750422.png" alt="image-20210310200750422"></p>
<p>以上几个是<strong>代数表达式</strong>，是符号之间的运算。表达式不是等式，所以其英文翻译也不是一个句子，类似一个名词短语。</p>
<p>比如*<strong>ab-c**<em>读作</em>a b* minus <em>c</em>，介词minus连接两个名词变量，结果还是一堆名词变量。*</strong>ab***直接读 <em>a b</em> 就行。</p>
<p>因为语言的本质是传递信息，懂数学的人已经明白了，没有二义性。</p>
<p>如要更清晰地表达**<em>ab****</em>，**是 <em>a</em> times <em>b</em>，times是谓语动词 time的第三人称单数。</p>
<p><strong><em>a-(b-c)</em></strong>和**<em>a(b+c)**</em>里有一对括号，不用把括号读出来，读出来是赵本山，读信件时读逗号、括号、括号完了(liǎo)</p>
<p><strong><em>a-(b-c)</em></strong>数学上的意思是<em>a</em>减去<em>b</em>与<em>c</em>的差，英文也是这个逻辑，读作<em>a</em> minus the difference <em>b</em> minus <em>c</em>，没有of，其中the difference是<strong>差</strong>的意思。</p>
<p><strong><em>a(b+c)</em></strong>读作<em>a</em> times the sum <em>b</em> plus <em>c</em>，应该很好理解了。</p>
<p><strong><em>a-(-b-c)</em></strong>读作a minus the quantity minus <em>b</em> minus <em>c</em>，使用quantity是英语语言习惯，避免plus和minus连在一起说。</p>
<h3 id="2-代数-2"><a href="#2-代数-2" class="headerlink" title="2. 代数(2)"></a><strong>2. 代数(2)</strong></h3><p><img src="/posts/45403fc4/image-20210310201140222.png" alt="image-20210310201140222"></p>
<p>这几个单独拿来说事，是因为太重要了！</p>
<p>在国外课堂上，老师一边写公式一边嘴里叨咕着，公式里分数是很多，一般都念做over！因为快！比如<strong>8/9</strong>直接念eight over nine</p>
<p>复杂点的第二个</p>
<p>$\frac {a+b} c + d$</p>
<p>中文读<strong>c分之a加b加d</strong>，中文读法有歧义，分不清加**<em>d**</em>是在分子上还是分数后面。</p>
<p>英文读作the quantity <em>a</em> plus <em>b</em> over <em>c</em>, that fraction plus <em>d</em>, 没有歧义！perfect！ </p>
<p>$\frac {x^2}{a^2}+\frac {y^2}{b^2}=1$</p>
<p>是拿来绕嘴的，读作the fraction <em>x</em> squared over <em>a</em> squared plus the fraction <em>y</em></p>
<p>squared over <em>b</em> squared equals 1，其中fraction是分数的意思。</p>
<p>$ax^2+bxy+cy^2+dx+ey+f=0$</p>
<p>这个是拿来是给你找信心的，很简单吧：<em>a x</em> squared plus <em>b x y</em> plus <em>c y</em> squared plus <em>d x</em> plus <em>e y</em> plus <em>f</em> equals zero完全读对的童鞋奖励自己一根棒棒糖。</p>
<h3 id="3-几个特殊的"><a href="#3-几个特殊的" class="headerlink" title="3. 几个特殊的"></a><strong>3. 几个特殊的</strong></h3><p><img src="/posts/45403fc4/image-20210310202105712.png" alt="image-20210310202105712"></p>
<p>这几个特殊的每一个都很珍贵！拿走不谢。</p>
<p>第一个</p>
<p>$a^x$简单读成<em>a</em> to the <em>x</em>，例子非常多，比如$3^4$读作three to four，也可以读的更完整点，three raised to the four power</p>
<p>$\log_ba$是以b为底的a的对数，log to the base <em>b</em> of <em>a</em>，其中the base就是为底了，介词严谨地表达了准确的数学定义。</p>
<p>$\lg3*4$是以10为底的3乘4的积的对数，读作log to the base 10 of the product 3 times 4</p>
<p>以此类推，</p>
<p>$\ln \frac2 5$中注意the fraction和the ratio是一样的，分数就是比的意思嘛。</p>
<p>$\ln x$是<em>x</em>的自然对数，读作the natural log of <em>x</em>。</p>
<p>自然对数底是多少？哼哼，百度啊，e=2.71828</p>
<p>注意：</p>
<p>$a_1+a_2+…+a_n$中的“点点点”就读做dot dot dot</p>
<p><strong><em>p(x)</em></strong>数学上是表示一个以<em>x</em>为自变量的函数<em>p</em>，读作p of x。为什么不读成<em>p x,</em> 汉语就是这么读的.应该是避免和<em>px</em>搞混吧。</p>
<p>另外注意，</p>
<p>$\ln x$里也有个<strong>of</strong></p>
<h3 id="4-带of的函数"><a href="#4-带of的函数" class="headerlink" title="4. 带of的函数"></a><strong>4. 带of的函数</strong></h3><p><img src="/posts/45403fc4/image-20210310203206521.png" alt="image-20210310203206521"></p>
<p>单独总结一下<strong>带of 的函数</strong>，数学上是以<em>x</em>为自变量的函数<em>p</em>，其他的都不复杂。</p>
<h3 id="5-专业课里常出的数学符号"><a href="#5-专业课里常出的数学符号" class="headerlink" title="5. 专业课里常出的数学符号"></a><strong>5. 专业课里常出的数学符号</strong></h3><p><img src="/posts/45403fc4/image-20210310203321975.png" alt="image-20210310203321975"></p>
<p>这些在工程学科的专业课里很容易见到，理论力学里用</p>
<p>$\sigma_x$表示正应力，读作sigma sub <em>x</em>，注意 sub 表示下标。</p>
<p>$Q_1$当有大写字母时，读作Capital <em>q</em> sub one。</p>
<p>$E(x)$有括号，读作Capital <em>e</em> of <em>x</em>，结合上面的**<em>p(x)**</em>印象应该很深吧。</p>
<p>$j_{(p)}$这个比较怪，下标带括号，汉语一般读成j 下标括号p，英文读作<em>j</em> sub <em>p</em> in parentheses，parentheses是括号的意思。</p>
<h3 id="6-高等数学里面的几个符号"><a href="#6-高等数学里面的几个符号" class="headerlink" title="6. 高等数学里面的几个符号"></a><strong>6. 高等数学里面的几个符号</strong></h3><p><img src="/posts/45403fc4/image-20210310203722674.png" alt="image-20210310203722674"></p>
<p> 这几个表达式是求和、求积和求极限。</p>
<p>$\sum\limits_{1}^{N}$汉语读<strong>西格玛1到大n</strong>，英文读作summation from one to capital <em>n</em></p>
<p>$\sum\limits_{i=1}^{\infty}x_i$英文里把希腊字母的意思说出来了，求和(summation), 这里多了<strong>正无穷</strong>，读作summation from <em>i</em> equals one to infinity of <em>x</em> sub <em>i</em></p>
<p>$\prod$是infinity就是正无穷。数学上是多个量求积的符号，英文<strong>积</strong>是product，是名词。</p>
<p>$\prod\limits_{1}^{n}$结构和求和一样，product from one to <em>n</em></p>
<p>同理，</p>
<p>$\prod\limits_{i=1}^{\infty}y_i$读成product from <em>i</em> equals one to infinity of <em>y</em> sub <em>i</em></p>
<p>$\displaystyle\lim_{x \rightarrow a}y = b$的意思是当x趋近a时y的极限等于b，limit as <em>x</em> approaches <em>a</em> of <em>y</em> equals <em>b</em>，limit是极限，名词，approaches 是趋紧的第三人称单数。</p>
<p>$\displaystyle\lim_{x \rightarrow a^-}f(x)$的数学意思是<strong>当x从左边趋紧a时关于x的函数f的极限</strong>，英文读作limit as <em>x</em> approaches <em>a</em> minus of <em>f</em>of <em>x</em>，从左边就是从minus方向</p>
<p>$\int f(x)dx$数学意思是<strong>函数fx的不定积分</strong>，英文读作integral of <em>f</em> of <em>x d x</em>，其中integral是积分的意思。</p>
<h3 id="7-线性代数中的英文读法"><a href="#7-线性代数中的英文读法" class="headerlink" title="7. 线性代数中的英文读法"></a><strong>7. 线性代数中的英文读法</strong></h3><p><img src="/posts/45403fc4/image-20210310210858177.png" alt="image-20210310210858177"></p>
<p>线性代数是大学生必学的科目，里面全是<strong>矩阵</strong>和<strong>向量</strong>，英文分别是matrix和vector，不明觉厉！</p>
<p>表里第一个是个矩阵，有四个元素，第一行是2 和 7, 第二行是3和10，用英文读时也和中文表达类似。</p>
<p>Two by two matrix (意思是2x2 矩阵)，first row two seven, second row tree ten</p>
<p>注意此处没有is 等动词。 </p>
<p>第二个是<strong>行向量</strong>，读作row vector </p>
<p>第三个是<strong>列向量</strong>，读作column vector</p>
<h3 id="8-其他常用的表达式"><a href="#8-其他常用的表达式" class="headerlink" title="8. 其他常用的表达式"></a><strong>8. 其他常用的表达式</strong></h3><p><img src="/posts/45403fc4/image-20210310211606203.png" alt="image-20210310211606203"></p>
<p>$\Delta y$读时汉语从不强调<strong>大写delta</strong>，英文要读capital delta <em>y</em></p>
<p>其他的都在前面出现过，列在此处再此强调一下。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a><strong>后记</strong></h2><p>目前国内绝大部分的英语学习，仍然停留在日常交流和一些常识性知识的英语。</p>
<p>说的直白一些，口语练的再棒，英语水平也仅相当于英语国家受教育程度低的人的英语水平。</p>
<p>很多人native speakers没有读过书，照样可以交流。但是在他们的语言里找不到自然科学、文学、艺术等英语的痕迹。</p>
<p>我们虽然受过高等教育，但是专业的、学术的英语学习仍然匮乏。我们的课本是中文的、老师用中文授课、我们的知识体系也是中文的。</p>
<p>所以在阅读原版教材、写英文论文、参加国际学术交流等很多时候，会遇到英语瓶颈。真正能够应用英语来进行知识的学习，工作等，起码需要明白数学中的英语，希望这篇文章能给您带来帮助。</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学专业词汇</tag>
      </tags>
  </entry>
  <entry>
    <title>高等排序算法</title>
    <url>/posts/7ff5bb67.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="高等排序算法"><a href="#高等排序算法" class="headerlink" title="高等排序算法"></a>高等排序算法</h1><p>参考：极客时间数据结构与算法之美专栏</p>
<p>非常推荐，王争老师写的很棒！</p>
<span id="more"></span>

<h2 id="1-如何用快排思想在O-n-内查找第K大元素？"><a href="#1-如何用快排思想在O-n-内查找第K大元素？" class="headerlink" title="1.如何用快排思想在O(n)内查找第K大元素？"></a>1.如何用快排思想在O(n)内查找第K大元素？</h2><p>本文会以这个问题为主线，介绍一些高等排序算法。</p>
<p>在初等排序中介绍的几种算法的时间复杂度都是$O(n^2)$。</p>
<p>接下来会介绍归并排序与快速排序，适合大规模的数据排序，比初等排序算法要更常用。</p>
<p>归并排序和快速排序都用到了分治思想，非常巧妙。</p>
<h2 id="2-Merge-Sort（归并排序）"><a href="#2-Merge-Sort（归并排序）" class="headerlink" title="2.Merge Sort（归并排序）"></a>2.Merge Sort（归并排序）</h2><p>归并排序见我的另一篇<a href="https://www.grantdrew.top/posts/2aed1d1d.html">文章</a>。</p>
<p>在<a href="https://www.grantdrew.top/posts/2e5ddee.html">蓝桥杯学习总结（十五）</a>中有y总归并排序板子。</p>
<p>这里不再重复介绍。</p>
<h2 id="3-Quick-Sort（快速排序）"><a href="#3-Quick-Sort（快速排序）" class="headerlink" title="3.Quick Sort（快速排序）"></a>3.Quick Sort（快速排序）</h2><p>时间复杂度：$O(nlogn)$.</p>
<p>快排利用的也是分治思想。乍看起来，它有点像归并排序，但是思路其实完全不一样。</p>
<p>快排的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。</p>
<p>我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。</p>
<p><img src="/posts/7ff5bb67/image-20210524133448419.png" alt="image-20210524133448419"></p>
<p>根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。</p>
<p>归并排序中有一个 merge() 合并函数，我们这里有一个 partition() 分区函数。就是随机选择一个元素作为 pivot（一般情况下，可以选择 p 到 r 区间的最后一个元素），然后对 A[p…r]分区，函数返回 pivot 的下标。</p>
<p>如果我们不考虑<strong>空间消耗</strong>的话，partition() 分区函数可以写得非常简单。我们申请两个临时数组 X 和 Y，遍历 A[p…r]，将小于 pivot 的元素都拷贝到临时数组 X，将大于 pivot 的元素都拷贝到临时数组 Y，最后再将数组 X 和数组 Y 中数据顺序拷贝到 A[p….r]。</p>
<p>这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = a[p];</span><br><span class="line">    <span class="keyword">while</span> (p &lt; r)&#123;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; r &amp;&amp; a[r] &gt; pivot) r--;</span><br><span class="line">        a[p] = a[r];</span><br><span class="line">        <span class="keyword">while</span> (p &lt; r &amp;&amp; a[r] &lt;= pivot) p++;</span><br><span class="line">        a[r] = a[p];</span><br><span class="line">    &#125;</span><br><span class="line">    a[p] = pivot;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，如果按照这种思路实现的话，partition() 函数就需要很多额外的内存空间，所以快排就不是原地排序算法了。如果我们希望快排是<strong>原地排序算法</strong>，那它的空间复杂度得是 O(1)，那 partition() 分区函数就不能占用太多额外的内存空间，我们就需要在 A[p…r]的原地完成分区操作。</p>
<p>原地分区这样写：</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line">partition(A, p, r) <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  pivot := A[r]</span></span><br><span class="line"><span class="comment">  i := p</span></span><br><span class="line"><span class="comment">  for j := p to r-1 do &#123;</span></span><br><span class="line"><span class="comment">    if A[j] &lt; pivot &#123;</span></span><br><span class="line"><span class="comment">      swap A[i] with A[j]</span></span><br><span class="line"><span class="comment">      i := i+1</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  swap A[i] <span class="keyword">with</span> A[r]</span><br><span class="line">  return i</span><br></pre></td></tr></table></figure>

<p>这里的处理有点类似<strong>选择排序</strong>。我们通过游标 i 把 A[p…r-1]分成两部分。A[p…i-1]的元素都是小于 pivot 的，我们暂且叫它“已处理区间”，A[i…r-1]是“未处理区间”。我们每次都从未处理的区间 A[i…r-1]中取一个元素 A[j]，与 pivot 对比，如果小于 pivot，则将其加入到已处理区间的尾部，也就是 A[i]的位置。</p>
<p>数组的插入操作还记得吗？在数组某个位置插入元素，需要搬移数据，非常耗时。当时我们也讲了一种处理技巧，就是<strong>交换</strong>，在 O(1) 的时间复杂度内完成插入操作。这里我们也借助这个思想，只需要将 A[i]与 A[j]交换，就可以在 O(1) 时间复杂度内将 A[j]放到下标为 i 的位置。</p>
<p><img src="/posts/7ff5bb67/image-20210524135808177.png" alt="image-20210524135808177"></p>
<p>因为分区的过程涉及交换操作，如果数组中有两个相同的元素，比如序列 6，8，7，6，3，5，9，4，在经过第一次分区操作之后，两个 6 的相对先后顺序就会改变。所以，快速排序并不是一个稳定的排序算法。</p>
<p>对照上面图片会更容易理解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 快速排序，a是数组，n表示数组的大小</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    quickSortInternally(a, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 快速排序递归函数，p,r为下标</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortInternally</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> q = partition(a, p, r); <span class="comment">// 获取分区点</span></span><br><span class="line">    quickSortInternally(a, p, q-<span class="number">1</span>);</span><br><span class="line">    quickSortInternally(a, q+<span class="number">1</span>, r);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = a[r];</span><br><span class="line">    <span class="keyword">int</span> i = p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = p; j &lt; r; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &lt; pivot) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == j) &#123;<span class="comment">// 相等说明a[i]和a[j]是同一个数</span></span><br><span class="line">          ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 不等则交换a[i]和a[j]</span></span><br><span class="line">          <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">          a[i++] = a[j];</span><br><span class="line">          a[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">    a[i] = a[r];</span><br><span class="line">    a[r] = tmp;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;i=&quot;</span> + i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-归并与快排的区别"><a href="#4-归并与快排的区别" class="headerlink" title="4.归并与快排的区别"></a>4.归并与快排的区别</h2><p><img src="/posts/7ff5bb67/image-20210524135905185.png" alt="image-20210524135905185"></p>
<p>可以发现，归并排序的处理过程是<strong>由下到上</strong>的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是<strong>由上到下</strong>的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</p>
<p>快速排序算法虽然最坏情况下的时间复杂度是 O(n^2)，但是平均情况下时间复杂度都是 O(nlogn)。不仅如此，快速排序算法时间复杂度退化到 O(n^2) 的概率非常小，我们可以通过合理地选择 pivot 来避免这种情况。</p>
<h2 id="5-解答开篇"><a href="#5-解答开篇" class="headerlink" title="5.解答开篇"></a>5.解答开篇</h2><p>快排核心思想就是分治和分区，我们可以利用分区的思想，来解答开篇的问题：O(n) 时间复杂度内求无 序数组中的第 K 大元素。比如，4， 2， 5， 12， 3 这样一组数据，第 3 大元素就是 4。</p>
<p>我们选择数组区间 A[0…n-1]的最后一个元素 A[n-1]作为 pivot，对数组 A[0…n-1]原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。</p>
<p>如果 p+1=K，那 A[p]就是要求解的元素；如果 K&gt;p+1, 说明第 K 大元素出现在 A[p+1…n-1]区间，我们再按照上面的思路递归地在 A[p+1…n-1]这个区间内查找。同理，如果 K&lt;p+1，那我们就在 A[0…p-1]区间查找。</p>
<p>时间复杂度是 O(n)。</p>
<p>第一次分区查找，我们需要对大小为 n 的数组执行分区操作，需要遍历 n 个元素。第二次分区查找，我们只需要对大小为 n/2 的数组执行分区操作，需要遍历 n/2 个元素。</p>
<p>如果我们把每次分区遍历的元素个数加起来，就是：n+n/2+n/4+n/8+…+1。这是一个等比数列求和，最后的和等于 2n-1。所以，上述解决思路的时间复杂度就为 O(n)。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>快排</tag>
      </tags>
  </entry>
  <entry>
    <title>C++竞赛语法总结（九）</title>
    <url>/posts/cc84a5fd.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-常用库函数"><a href="#1-常用库函数" class="headerlink" title="1.常用库函数"></a>1.常用库函数</h2><p>这些库函数大都在<code>&lt;algorithm&gt;</code>中。</p>
<span id="more"></span>

<h3 id="1-reverse-翻转"><a href="#1-reverse-翻转" class="headerlink" title="(1)  reverse 翻转"></a>(1)  reverse 翻转</h3><p>既可以用于一般的数组，也能够用于vector。</p>
<p>翻转一个vector：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">reverse(a.begin(), a.end());</span><br></pre></td></tr></table></figure>

<p>翻转一个数组，元素存放在下标1~n：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">reverse(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;)</span></span>;</span><br><span class="line">    reverse(a.begin(), a.end());<span class="comment">// 左闭右开</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x:a) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    reverse(b,b + <span class="number">5</span>);<span class="comment">// 左闭右开</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x:a) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-unique-去重"><a href="#2-unique-去重" class="headerlink" title="(2)  unique 去重"></a>(2)  unique 去重</h3><p>去除容器中相邻的重复元素。(<strong>必须保证重复元素是相邻排列的</strong>)</p>
<p>返回去重之后的尾迭代器（或指针），仍然为前闭后开，即这个迭代器是去重之后末尾元素的下一个位置。该函数常用于离散化，<strong>利用迭代器（或指针）的减法，可计算出去重后的元素个数</strong>。</p>
<p>注：数组去重之后，<strong>去重之后的多余元素并没有删除，而是放在后面</strong>。</p>
<p>把一个vector去重：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = unique(a.begin(), a.end()) – a.begin();</span><br></pre></td></tr></table></figure>

<p>把一个数组去重，元素存放在下标1~n：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = unique(a + <span class="number">1</span>, a + <span class="number">1</span> + n) – (a + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><strong>补充<code>vector::erase</code>：（左闭右开）</strong></p>
<p>从指定容器删除指定位置的元素或某段范围内的元素，vector::erase()方法有两种重载形式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">如下： <span class="function">iterator <span class="title">erase</span><span class="params">(  iterator _Where)</span></span>; <span class="function">iterator <span class="title">erase</span><span class="params">(  iterator _First,  iterator _Last)</span></span>; </span><br></pre></td></tr></table></figure>

<p>  如果是删除指定位置的元素时：返回值是一个迭代器，指向删除元素下一个元素 ；</p>
<p> 如果是删除某范围内的元素时：返回值也表示一个迭代器，指向最后一个删除元素的下一个元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> m = unique(a,a + <span class="number">7</span>) - a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i ++) <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">7</span>;i ++) <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 去重之后的多余元素并没有删除</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>&#125;)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> n = unique(b.begin(),b.end()) - b.begin();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">c</span><span class="params">(&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>&#125;)</span></span>;</span><br><span class="line">    c.erase(unique(c.begin(),c.end()),c.end());<span class="comment">// 常见的用法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: c) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-random-shuffle-随机打乱"><a href="#3-random-shuffle-随机打乱" class="headerlink" title="(3)  random_shuffle 随机打乱"></a>(3)  random_shuffle 随机打乱</h3><p>用法与reverse相同 ,参数与reverse一样。生成随机数排列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;)</span></span>;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    random_shuffle(a.begin(),a.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x:a) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-sort-非常非常重要"><a href="#4-sort-非常非常重要" class="headerlink" title="(4)  sort(非常非常重要)"></a>(4)  sort(非常非常重要)</h3><p>前两个参数与reverse完全一样。</p>
<p>对两个迭代器（或指针）指定的部分进行快速排序。可以在第三个参数传入定义大小比较的函数，或者重载“小于号”运算符。</p>
<p>把一个int数组（元素存放在下标1~n）从大到小排序，传入比较函数：</p>
<p> <code>int a[MAX_SIZE];</code></p>
<p><code>bool cmp(int a, int b) &#123;return a &gt; b;&#125;</code></p>
<p><code>sort(a + 1, a + 1 + n, cmp);</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><span class="comment">// a是否应该排在b的前面</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;<span class="comment">// 从大到小</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;)</span></span>;</span><br><span class="line">    sort(a.begin(),a.end());<span class="comment">// 从小到大</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x :a) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    sort(a.begin(),a.end(),greater&lt;<span class="keyword">int</span>&gt;());<span class="comment">// 从大到小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x :a) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    sort(a.begin(),a.end(),cmp);<span class="comment">// 根据cmp排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x :a) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结构体排序"><a href="#结构体排序" class="headerlink" title="结构体排序"></a>结构体排序</h4><p>solution 1:自定义比较函数cmp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rec</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">    &#125;a[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Rec a,Rec b)</span><span class="comment">// a是否应该排在b的前面</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;<span class="comment">// 从小到大</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i].x =-i;</span><br><span class="line">        a[i].y = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i ++) <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d) &quot;</span>,a[i].x,a[i].y);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    sort(a,a + <span class="number">5</span>,cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i ++) <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d) &quot;</span>,a[i].x,a[i].y);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>solution 2:把自定义的结构体vector排序，重载“小于号”运算符：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rec</span>&#123;</span> <span class="keyword">int</span> id, x, y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;rec&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> rec &amp;a, <span class="keyword">const</span> rec &amp;b) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> a.x &lt; b.x || a.x == b.x &amp;&amp; a.y &lt; b.y;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(a.begin(), a.end());</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rec</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Rec&amp;t) <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x &lt; t.x;<span class="comment">// 从小到大排序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;a[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i].x =-i;</span><br><span class="line">        a[i].y = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i ++) <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d) &quot;</span>,a[i].x,a[i].y);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    sort(a,a + <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i ++) <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d) &quot;</span>,a[i].x,a[i].y);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-lower-bound-upper-bound-二分"><a href="#5-lower-bound-upper-bound-二分" class="headerlink" title="(5)  lower_bound/upper_bound 二分"></a>(5)  lower_bound/upper_bound 二分</h3><p>二分的前提是<strong>数组或者结构体已经从小到排好序了</strong>。</p>
<p>lower_bound 的第三个参数传入一个元素x，在两个迭代器（指针）指定的部分上执行二分查找，返回指向第一个<strong>大于等于x的元素的位置</strong>的迭代器（指针）。</p>
<p>upper_bound 的用法和lower_bound大致相同，唯一的区别是<strong>查找第一个大于x的元素</strong>。当然，两个迭代器（指针）指定的部分应该是提前排好序的。</p>
<p>在有序int数组（元素存放在下标1~n）中查找大于等于x的最小整数的下标：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法1</span></span><br><span class="line"><span class="keyword">int</span>* l = lower_bound(a + <span class="number">1</span>, a + <span class="number">1</span> + n, x);</span><br><span class="line"><span class="keyword">int</span> t = l - a;</span><br><span class="line"><span class="comment">// 写法2</span></span><br><span class="line"><span class="keyword">int</span> l = lower_bound(a + <span class="number">1</span>, a + <span class="number">1</span> + n, x) - a;</span><br></pre></td></tr></table></figure>

<p>在有序<code>vector&lt;int&gt;</code> 中查找小于等于x的最大整数（假设一定存在）：</p>
<p><code>int y = *--upper_bound(a.begin(), a.end(), x);</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>* p = lower_bound(a,a + <span class="number">5</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span>* q = lower_bound(a,a + <span class="number">5</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">int</span> t1 = lower_bound(a,a + <span class="number">5</span>,<span class="number">6</span>) - a;<span class="comment">// 返回第一个&gt;=6的元素的下标</span></span><br><span class="line">    <span class="keyword">int</span> t2 = lower_bound(a,a + <span class="number">5</span>,<span class="number">7</span>) - a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; t2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; *q &lt;&lt;  <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;<span class="comment">// 去掉()也能初始化vector</span></span><br><span class="line">    <span class="keyword">int</span> t = upper_bound(b.begin(),b.end(),<span class="number">4</span>) - b.begin();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b[t] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-next-permutation-（全排列函数）"><a href="#6-next-permutation-（全排列函数）" class="headerlink" title="(6) next_permutation()（全排列函数）"></a>(6) next_permutation()（全排列函数）</h3><p>将当前排列更改为 <strong>全排列中的下一个排列</strong>。如果当前排列已经是 <strong>全排列中的最后一个排列</strong>（元素完全从大到小排列），函数返回 <code>false</code> 并将排列更改为 <strong>全排列中的第一个排列</strong>（元素完全从小到大排列）；否则，函数返回 <code>true</code>。<code>next_permutation(v.begin(), v.end())</code> 或 <code>next_permutation(v + begin, v + end)</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">next_permutation()将按字母表顺序生成给定序列的下一个较大的排列,直到整个序列为降序为止。</span></span><br><span class="line"><span class="comment">prev_permutation()与之相反,是生成给定序列的上一个较小的排列。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (next_permutation(num,num + <span class="number">5</span>)) &#123;</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : num) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; cnt;<span class="comment">// cnt == 5! == 120</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*1 2 3 5 4 </span></span><br><span class="line"><span class="comment">1 2 4 3 5</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">5 4 3 2 1</span></span><br><span class="line"><span class="comment">120*/</span></span><br></pre></td></tr></table></figure>

<h2 id="2-acwing-53-最小的k个数"><a href="#2-acwing-53-最小的k个数" class="headerlink" title="2.acwing.53.最小的k个数"></a>2.acwing.53.最小的k个数</h2><p>输入n个整数，找出其中最小的k个数。</p>
<p><strong>注意：</strong></p>
<ul>
<li>数据保证k一定小于等于输入数组的长度;</li>
<li>输出数组内元素请按从小到大顺序排序;</li>
</ul>
<p>样例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>] , k=<span class="number">4</span></span><br><span class="line"></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1,我的题解，利用优先队列（堆）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; p;<span class="comment">// 小根堆</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; input.size();i ++) p.push(input[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i ++) &#123;res.push_back(p.top());p.pop();&#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// solution 2,y总题解，练习sort</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        sort(input.begin(),input.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i ++) res.push_back(input[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-acwing-75-和为S的两个数字"><a href="#3-acwing-75-和为S的两个数字" class="headerlink" title="3.acwing.75.和为S的两个数字"></a>3.acwing.75.和为S的两个数字</h2><p>输入一个数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。</p>
<p>如果有多对数字的和等于s，输出任意一对即可。</p>
<p>你可以认为每组输入中都至少含有一组满足条件的输出。</p>
<p>样例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] , sum=<span class="number">7</span></span><br><span class="line"></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1，暴力枚举</span></span><br><span class="line"><span class="comment">//两个遍历数组的循环，所以时间复杂度是O(n^2)</span></span><br><span class="line"><span class="comment">//没有开辟与数组大小相关的空间，所以空间复杂度是O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findNumbersWithSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size();i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; nums.size();j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(nums[i]);</span><br><span class="line">                    res.push_back(nums[j]);</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// solution 2，y总题解，哈希表</span></span><br><span class="line"><span class="comment">//时间复杂度O(n)；开辟了数组大小的哈希表，所以空间复杂度是O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findNumbersWithSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(S.count(target-x)) <span class="keyword">return</span> &#123;x,target-x&#125;;</span><br><span class="line">            S.insert(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-acwing-51-数字排列"><a href="#4-acwing-51-数字排列" class="headerlink" title="4.acwing.51.数字排列"></a>4.acwing.51.数字排列</h2><p>有难度！！不会了！</p>
<p>输入一组数字（可能包含重复数字），输出其所有的排列方式。</p>
<p>样例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">      [</span><br><span class="line">        [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">        [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">        [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">        [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">        [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">        [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">      ]</span><br></pre></td></tr></table></figure>

<p><strong><code>next_permutation</code>全排列函数详解：</strong></p>
<ul>
<li><code>next_permutation</code>：将当前排列更改为 <strong>全排列中的下一个排列</strong>。如果当前排列已经是 <strong>全排列中的最后一个排列</strong>（元素完全从大到小排列），函数返回 <code>false</code> 并将排列更改为 <strong>全排列中的第一个排列</strong>（元素完全从小到大排列）；否则，函数返回 <code>true</code>。<code>next_permutation(v.begin(), v.end())</code> 或 <code>next_permutation(v + begin, v + end)</code>。</li>
<li>使用 <code>next_permutation</code> 生成 到 的全排列。例题：<a href="https://www.luogu.com.cn/problem/P1706">Luogu P1706 全排列问题</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> N = <span class="number">9</span>, a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (next_permutation(a, a + N));</span><br></pre></td></tr></table></figure>

<p><strong>题解：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1,STLnb!!!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permutation(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">do</span> res.push_back(nums);<span class="keyword">while</span> (next_permutation(nums.begin(),nums.end()));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5-acwing-26-二进制中1的个数"><a href="#5-acwing-26-二进制中1的个数" class="headerlink" title="5.acwing.26.二进制中1的个数"></a>5.acwing.26.二进制中1的个数</h2><p>输入一个32位整数，输出该数二进制表示中1的个数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1，我的题解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>;i &gt;= <span class="number">0</span>;i --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &gt;&gt; i &amp; <span class="number">1</span>) == <span class="number">1</span>) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// solution 2，y总题解，lowbit写法，更快一点</span></span><br><span class="line"><span class="comment">//lowbit(x) = x &amp; -x，取二进制最后一位1及以后的数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;n -= n &amp; -n; res++;&#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="6-acwing-862-三元组排序"><a href="#6-acwing-862-三元组排序" class="headerlink" title="6.acwing.862.三元组排序"></a>6.acwing.862.三元组排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1，我的题解，结构体普通做法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">float</span> b;</span><br><span class="line">    <span class="built_in">string</span> c;</span><br><span class="line">&#125;R[<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Rec x,Rec y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x.a &lt; y.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (N--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; R[i].a &gt;&gt; R[i].b &gt;&gt; R[i].c;</span><br><span class="line">		i ++;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(R,R+i,cmp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j ++)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;%d %.2f %s\n&quot;</span>,R[j].a,R[j].b,R[j].c.c_str());</span><br><span class="line">        <span class="comment">// 注意printf输出string得用string.c_str()</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// solution 2</span></span><br><span class="line"><span class="comment">//STL:vector 这里用了pair&lt;int, pair&lt;double, string &gt;&gt; 嵌套pair构成三元组</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="built_in">pair</span>&lt;<span class="keyword">double</span>, <span class="built_in">string</span> &gt;&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;PII&gt; ans;</span><br><span class="line"><span class="keyword">int</span> n, a;</span><br><span class="line"><span class="keyword">double</span> b;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">        ans.push_back(&#123;a, &#123;b, s&#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(ans.begin(), ans.end());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: ans)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %.2lf %s\n&quot;</span>,i.x, i.y.x, i.y.y.c_str());   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">作者：小张同学</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/9475/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class="line"><span class="comment">// solution 3,STL : map</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">double</span>, <span class="built_in">string</span>&gt; PII;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, PII&gt; ans;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    <span class="built_in">string</span> c;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        ans.insert(&#123;a, &#123;b, c&#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// map&lt;int, PII&gt;::iterator iter; 迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, PII&gt;::iterator iter = ans.begin(); iter != ans.end(); iter ++ )</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %.2f %s\n&quot;</span>, iter-&gt;x, iter-&gt;y.x, iter-&gt;y.y.c_str());  <span class="comment">//这里 iter -&gt; x/y 是map ，后面两个是pair ：PII.first/second</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">作者：小张同学</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/9475/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h2 id="7-acwing-20-用两个栈实现队列（剑指offer）"><a href="#7-acwing-20-用两个栈实现队列（剑指offer）" class="headerlink" title="7.acwing.20.用两个栈实现队列（剑指offer）"></a>7.acwing.20.用两个栈实现队列（剑指offer）</h2><p>请用栈实现一个队列，支持如下四种操作：</p>
<ul>
<li>push(x) – 将元素x插到队尾；</li>
<li>pop() – 将队首的元素弹出，并返回该元素；</li>
<li>peek() – 返回队首元素；</li>
<li>empty() – 返回队列是否为空；</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>你只能使用栈的标准操作：<code>push to top</code>，<code>peek/pop from top</code>, <code>size</code> 和 <code>is empty</code>；</li>
<li>如果你选择的编程语言没有栈的标准库，你可以使用list或者deque等模拟栈的操作；</li>
<li>输入数据保证合法，例如，在队列为空时，不会进行<code>pop</code>或者<code>peek</code>等操作；</li>
</ul>
<p>样例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MyQueue <span class="built_in">queue</span> = <span class="keyword">new</span> MyQueue();</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>.push(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">queue</span>.push(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">queue</span>.peek();  <span class="comment">// returns 1</span></span><br><span class="line"><span class="built_in">queue</span>.pop();   <span class="comment">// returns 1</span></span><br><span class="line"><span class="built_in">queue</span>.empty(); <span class="comment">// returns false</span></span><br></pre></td></tr></table></figure>

<p><strong>算法：</strong>(栈，队列) O(n)<br>这是一道基础题，只要把功能实现对就可以，不需要考虑运行效率。</p>
<p><strong>我们用两个栈来做，一个主栈，用来存储数据；一个辅助栈，用来当缓存</strong>。</p>
<ul>
<li><code>push(x)</code>，我们直接将x插入主栈中即可。</li>
<li><code>pop()</code>，此时我们需要弹出最先进入栈的元素，也就是栈底元素。我们可以先将所有元素从主栈中弹出，压入辅助栈中。则辅助栈的栈顶元素就是我们要弹出的元素，将其弹出即可。然后再将辅助栈中的元素全部弹出，压入主栈中。</li>
<li><code>peek()</code>，可以用和pop()操作类似的方式，得到最先压入栈的元素。</li>
<li><code>empty()</code>，直接判断主栈是否为空即可。<br>时间复杂度分析</li>
<li><code>push()</code>：O(1)；</li>
<li><code>pop()</code>: 每次需要将主栈元素全部弹出，再压入，所以需要 O(n)的时间；</li>
<li><code>peek()</code>：类似于pop()，需要 O(n) 的时间；</li>
<li><code>empty()</code>：O(1)；</li>
</ul>
<p>作者：yxc<br>链接：<a href="https://www.acwing.com/solution/content/725/">https://www.acwing.com/solution/content/725/</a><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1,s2;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyQueue() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s1.push(x);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (s1.size() &gt; <span class="number">1</span>) s2.push(s1.top()),s1.pop();<span class="comment">// 注意这里是逗号</span></span><br><span class="line">        <span class="keyword">int</span> t = s1.top();</span><br><span class="line">        s1.pop();</span><br><span class="line">        <span class="keyword">while</span> (s2.size()) s1.push(s2.top()),s2.pop();</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (s1.size() &gt; <span class="number">1</span>) s2.push(s1.top()),s1.pop();</span><br><span class="line">        <span class="keyword">int</span> t = s1.top();</span><br><span class="line">        <span class="keyword">while</span> (s2.size()) s1.push(s2.top()),s2.pop();</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Acwing：语法基础课系列正式完结！！！"><a href="#Acwing：语法基础课系列正式完结！！！" class="headerlink" title="Acwing：语法基础课系列正式完结！！！"></a>Acwing：语法基础课系列正式完结！！！</h1>]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>竞赛语法</tag>
        <tag>位运算</tag>
        <tag>库函数</tag>
        <tag>栈实现队列</tag>
      </tags>
  </entry>
  <entry>
    <title>C++竞赛语法总结（四）</title>
    <url>/posts/99b255e0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="1-acwing768-忽略大小写比较字符串大小"><a href="#1-acwing768-忽略大小写比较字符串大小" class="headerlink" title="1.acwing768.忽略大小写比较字符串大小"></a>1.acwing768.忽略大小写比较字符串大小</h4><p>一般我们用strcmp可比较两个字符串的大小，比较方法为对两个字符串从前往后逐个字符相比较（按ASCII码值大小比较），直到出现不同的字符或遇到’\0’为止。</p>
<span id="more"></span>

<p>如果全部字符都相同，则认为相同；如果出现不相同的字符，则以第一个不相同的字符的比较结果为准。</p>
<p>但在有些时候，我们比较字符串的大小时，希望忽略字母的大小，例如”Hello”和”hello”在忽略字母大小写时是相等的。</p>
<p>请写一个程序，实现对两个字符串进行忽略字母大小写的大小比较。</p>
<p> 输入格式</p>
<p>输入为两行，每行一个字符串，共两个字符串。注意字符串中可能包含空格。</p>
<p>数据保证每个字符串的长度都不超过80。</p>
<p> 输出格式</p>
<p>如果第一个字符串比第二个字符串小，输出一个字符”&lt;”。</p>
<p>如果第一个字符串比第二个字符串大，输出一个字符”&gt;”。</p>
<p>如果两个字符串相等，输出一个字符”=”。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自己写的题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a,b;</span><br><span class="line">    getline(<span class="built_in">cin</span>,a);</span><br><span class="line">    getline(<span class="built_in">cin</span>,b);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">3</span>] = &#123;<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;=&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;a[i] &amp;&amp; b[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = a[i] &lt; <span class="string">&#x27;a&#x27;</span>? a[i] + <span class="number">32</span>:a[i];</span><br><span class="line">        b[i] = b[i] &lt; <span class="string">&#x27;a&#x27;</span>? b[i] + <span class="number">32</span>:b[i];</span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[i]) k = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &gt; b[i]) &#123;k = <span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;k = <span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.size() &gt; b.size()) k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a.size() &lt; b.size()) k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; op[k];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 题解2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a,b;</span><br><span class="line">    getline(<span class="built_in">cin</span>,a);</span><br><span class="line">    getline(<span class="built_in">cin</span>,b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i ++)</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; a[i] &lt;= <span class="string">&#x27;Z&#x27;</span>) a[i] += <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.size(); i ++)</span><br><span class="line">        <span class="keyword">if</span> (b[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; b[i] &lt;= <span class="string">&#x27;Z&#x27;</span>) b[i] += <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    c = <span class="built_in">strcmp</span>(a.c_str(),b.c_str());</span><br><span class="line">    <span class="keyword">if</span>(c &lt; <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&lt;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;=&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(c &gt; <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">此题如果使用<span class="built_in">string</span>类型，也想用<span class="built_in">strcmp</span>比较大小，可以使用<span class="built_in">string</span>的成员函数c_str()把<span class="built_in">string</span>转换为<span class="keyword">const</span> <span class="keyword">char</span> *，然后比较。</span><br><span class="line">作者：paprika</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/12573/</span></span><br><span class="line">来源：AcWing</span><br></pre></td></tr></table></figure>

<h2 id="2-acwing-766-去掉多余的空格"><a href="#2-acwing-766-去掉多余的空格" class="headerlink" title="2.acwing.766.去掉多余的空格"></a>2.acwing.766.去掉多余的空格</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有想到好的思路</span></span><br><span class="line"><span class="comment">// y总简单题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s) <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">&#x27; &#x27;</span>;<span class="comment">// cin遇到空格停止</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// y总题解2、3，自己过滤多余的空格</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    getline(<span class="built_in">cin</span>,s);</span><br><span class="line">    <span class="built_in">string</span> r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>) r += s[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            r += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">int</span> j = i;<span class="comment">// 这三行代码是常用的算法，第一类双指针算法</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; s.size() &amp;&amp; s[j] == <span class="string">&#x27; &#x27;</span>) j++;</span><br><span class="line">            i = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将26,27,28,29改成 if(!i || s[i-1] != &#x27; &#x27;) r += s[i];也可以</span></span><br><span class="line"><span class="comment">// 加上!i避免i=0时索引越界</span></span><br><span class="line"><span class="comment">// 局部性判断方法</span></span><br></pre></td></tr></table></figure>

<h2 id="3-string"><a href="#3-string" class="headerlink" title="3.string!!!"></a>3.string!!!</h2><p>标准库类型string，非常强大，大部分场合可用string而不用char数组。</p>
<p>一般情况下，不超时的话用string，如果输入量比较大则使用字符串。</p>
<p><img src="/posts/99b255e0/image-20210116183048237.png" alt="image-20210116183048237"></p>
<p>string里有c_str()函数用于string转char数组。</p>
<p>使用方法为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,str.c_str());</span><br></pre></td></tr></table></figure>

<p>string.c_str()方法可以将string转换成char类型！！！（string为变量名）</p>
<p>puts() 也是一样，<code>puts(s.c_str());</code></p>
<p><strong>注意：不能使用scanf读取string类型变量！！！</strong></p>
<p><img src="/posts/99b255e0/image-20210117092853170.png" alt="image-20210117092853170"></p>
<p>empty函数：测试string是否为空（即长度是否为0），如果为空，输出1，否则输出0.这里的1,0代表真假。</p>
<p>size函数：求string长度，不像strlen函数会进行循环，它的时间复杂度是O(1)，很快。</p>
<p><img src="/posts/99b255e0/image-20210117093630721.png" alt="image-20210117093630721"></p>
<p><code>s4 = s1 + “asdafd” + ‘s’;// 这种也是支持的</code></p>
<p><img src="/posts/99b255e0/image-20210117094315743.png" alt="image-20210117094315743"></p>
<p><strong>注意：必须确保每个“+”的两侧至少有一个是string！！！</strong></p>
<p>上面s6正确是因为左边s1 + “,”已经变成了一个string，所以可以通过编译。</p>
<p>下面展示遍历string：</p>
<p><img src="/posts/99b255e0/image-20210117094823940.png" alt="image-20210117094823940"></p>
<p>注意：上面这种遍历相当于是把s中的每个字符复制给c，并不会修改原s中的字符！！但是下面加上了&amp;就可以进行修改，此时c完全等价于s中的字符，而且下面的效率更高一点！</p>
<h2 id="4-acwing770-单词替换"><a href="#4-acwing770-单词替换" class="headerlink" title="4.acwing770.单词替换"></a>4.acwing770.单词替换</h2><p> 输入格式</p>
<p>输入共3行。</p>
<p>第1行是包含多个单词的字符串 s;</p>
<p>第2行是待替换的单词a(长度不超过100);</p>
<p>第3行是a将被替换的单词b(长度不超过100)。</p>
<p>共一行，输出将s中所有单词a替换成b之后的字符串。</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">You want someone to help you</span><br><span class="line">You</span><br><span class="line">I</span><br></pre></td></tr></table></figure>

<p> 输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I want someone to help you</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1，y总解法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s,a,b;</span><br><span class="line">    getline(<span class="built_in">cin</span>,s);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="function"><span class="built_in">stringstream</span> <span class="title">ssin</span><span class="params">(s)</span></span>;<span class="comment">// ssin从string流中读取string，类似cin</span></span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">while</span> （(ssin &gt;&gt; str)&#123;</span><br><span class="line">     	<span class="keyword">if</span>(str == a) &#123;<span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// solution 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> a[<span class="number">10000</span>],b,d;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a[c])</span><br><span class="line">    &#123;</span><br><span class="line">        c++;</span><br><span class="line">        <span class="keyword">char</span> x=getchar();</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;b&gt;&gt;d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==b)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;d&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：SLL</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/12105/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h3 id="sstream讲解："><a href="#sstream讲解：" class="headerlink" title="sstream讲解："></a>sstream讲解：</h3><p>ssin用于从string字符串中提取出需要的信息，同样地有sscanf()函数。</p>
<p>大部分情况下还是用ssin，很少用到sscanf。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    getline(<span class="built_in">cin</span>,s);</span><br><span class="line">    <span class="function"><span class="built_in">stringstream</span> <span class="title">ssin</span><span class="params">(s)</span></span>;<span class="comment">// 把strnig初始化成string流</span></span><br><span class="line">    <span class="comment">// 用法类似cin</span></span><br><span class="line">    <span class="keyword">int</span> a,b;<span class="built_in">string</span> str;<span class="keyword">double</span> c;</span><br><span class="line">    ssin &gt;&gt; a &gt;&gt; str &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span> &lt;&lt;c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"># <span class="number">12</span> llx <span class="number">23</span> <span class="number">23.34</span>(输入)</span><br><span class="line"># (输出)</span><br><span class="line"><span class="number">12</span></span><br><span class="line">llx</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">23.34</span></span><br><span class="line"><span class="comment">// char[]字符串的类似用法    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">1000</span>];</span><br><span class="line">    fgets(s,<span class="number">1000</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">    <span class="built_in">sscanf</span>(s,<span class="string">&quot;%d%s%d%lf&quot;</span>,&amp;a,str,&amp;b,&amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%s\n%d\n%lf\n&quot;</span>,a,str,b,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-acwing-771-字符串中最长的连续出现的字符"><a href="#5-acwing-771-字符串中最长的连续出现的字符" class="headerlink" title="5.acwing.771.字符串中最长的连续出现的字符"></a>5.acwing.771.字符串中最长的连续出现的字符</h2><p>又不会了，字符串很多题都没有思路。</p>
<p>这题用到第一类双指针算法，前面已经提过！</p>
<p>求一个字符串中最长的连续出现的字符，输出该字符及其出现次数，字符串中无空白字符（空格、回车和tab），如果这样的字符不止一个，则输出第一个。</p>
<p>输入格式</p>
<p>第一行输入整数N，表示测试数据的组数。</p>
<p>每组数据占一行，包含一个不含空白字符的字符串，字符串长度不超过200。</p>
<p>输出格式</p>
<p>共一行，输出最长的连续出现的字符及其出现次数，中间用空格隔开。</p>
<p> 输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">aaaaabbbbbcccccccdddddddddd</span><br><span class="line">abcdefghigk</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d 10</span><br><span class="line">a 1</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">    <span class="keyword">while</span> (num--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;<span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;<span class="comment">// 第一类双指针算法</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt;s.size() &amp;&amp; s[i] == s[j]) j++;</span><br><span class="line">            <span class="comment">// 此时j是和s[i]不相等的第一个字符的下标</span></span><br><span class="line">            <span class="keyword">if</span> (j - i &gt; cnt) &#123;cnt = j-i;c = s[i];&#125;</span><br><span class="line">            i = j - <span class="number">1</span>;<span class="comment">// 特别注意是i-1，因为循环中有i++</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-acwing-774-最长单词"><a href="#6-acwing-774-最长单词" class="headerlink" title="6.acwing.774.最长单词"></a>6.acwing.774.最长单词</h2><p>一个以’.’结尾的简单英文句子，单词之间用空格分隔，没有缩写形式和其它特殊形式，求句子中的最长单词。</p>
<p>输入格式</p>
<p>输入这个简单英文句子，长度不超过500。</p>
<p> 输出格式</p>
<p>该句子中最长的单词。如果多于一个，则输出第一个。</p>
<p> 输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I am a student of Peking University.</span><br><span class="line">University</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1，自己的解法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> s[<span class="number">500</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>,p = <span class="number">0</span>,len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s[i]) i++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = s[j].size();</span><br><span class="line">        <span class="keyword">if</span> (j == i - <span class="number">1</span>) t -= <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span> (len &lt; t) &#123;len = t;p = j;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == i - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; s[p].size() - <span class="number">1</span>;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; s[p][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; s[p];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// solution 2，y总解法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res,str;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.back() == <span class="string">&#x27;.&#x27;</span>) str.pop_back();</span><br><span class="line">        <span class="comment">// str.back()函数返回string的最后一个字符</span></span><br><span class="line">        <span class="comment">// str.pop_back()去掉string的最后一个字符</span></span><br><span class="line">        <span class="keyword">if</span> (str.size() &gt; res.size()) res = str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// solution 3，双指针算法，字符串中的常用算法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    getline(<span class="built_in">cin</span>, a);</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>, tag_i, tag_j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; a.size() &amp;&amp; a[j] != <span class="string">&#x27; &#x27;</span>) j ++;</span><br><span class="line">        <span class="keyword">if</span>(max &lt; j - i)</span><br><span class="line">        &#123;</span><br><span class="line">            max = j - i + <span class="number">1</span>;</span><br><span class="line">            tag_i = i;</span><br><span class="line">            tag_j = j;</span><br><span class="line">        &#125;</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = tag_i; i &lt;= tag_j &amp;&amp; a[i] != <span class="string">&#x27;.&#x27;</span>; i ++) <span class="built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line">	<span class="comment">// 这里的max并不是单词最大长度，结果多输出了一个空格</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：Logic</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/11742/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h2 id="7-acwing-775-倒排单词"><a href="#7-acwing-775-倒排单词" class="headerlink" title="7.acwing.775.倒排单词"></a>7.acwing.775.倒排单词</h2><p>编写程序，读入一行英文(只包含字母和空格，单词间以单个空格分隔)，将所有单词的顺序倒排并输出，依然以单个空格分隔。</p>
<p>输入格式</p>
<p>输入为一个字符串（字符串长度至多为100）。</p>
<p>输出格式输出为按要求排序后的字符串。</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I am a student</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">student a am I</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str, res;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str)</span><br><span class="line">        res = str + <span class="string">&#x27; &#x27;</span> + res;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// solution 2，y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str[n]) n ++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i --) <span class="built_in">cout</span> &lt;&lt; str[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-acwing-776-字符串移位包含问题"><a href="#8-acwing-776-字符串移位包含问题" class="headerlink" title="8.acwing.776.字符串移位包含问题"></a>8.acwing.776.字符串移位包含问题</h2><p>对于一个字符串来说，定义一次循环移位操作为：将字符串的第一个字符移动到末尾形成新的字符串。</p>
<p>给定两个字符串s1和s2，要求判定其中一个字符串是否是另一字符串通过若干次循环移位后的新字符串的子串。</p>
<p>例如CDAA是由AABCD两次移位后产生的新串BCDAA的子串，而ABCD与ACBD则不能通过多次移位来得到其中一个字符串是新串的子串。</p>
<p> 输入格式</p>
<p>共一行，包含两个字符串，中间由单个空格隔开。</p>
<p>字符串只包含字母和数字，长度不超过30。</p>
<p> 输出格式</p>
<p>如果一个字符串是另一字符串通过若干次循环移位产生的新串的子串，则输出true，否则输出false。</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AABCD CDAA</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>

<p>难度：困难，不知道怎么判断子串。（y总：本章压轴题，最难的问题之一）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a,b;<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span> (a.size() &lt; b.size()) swap(a,b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; a.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a = a.substr(<span class="number">1</span>) + a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j + b.size() &lt;= a.size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>;k &lt; b.size();k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[j+k] != b[k])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == b.size())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-acwing-777-字符串乘方"><a href="#9-acwing-777-字符串乘方" class="headerlink" title="9.acwing.777.字符串乘方"></a>9.acwing.777.字符串乘方</h2><p>又不会了！困难题。</p>
<p>给定两个字符串a和b,我们定义a*b为他们的连接。</p>
<p>例如，如果a=”abc” 而b=”def”， 则a*b=”abcdef”。 </p>
<p>如果我们将连接考虑成乘法，一个非负整数的乘方将用一种通常的方式定义：</p>
<p>a$^0$=””(空字符串)，a$^{(n+1)}$=a∗(a$^n$)。</p>
<p>输入格式</p>
<p>输入包含多组测试样例，每组测试样例占一行。</p>
<p>每组样例包含一个字符串s，s的长度不超过100。</p>
<p>最后的测试样例后面将是一个点号作为一行。</p>
<p>输出格式</p>
<p>对于每一个s，你需要输出最大的n，使得存在一个字符串a，让s=ans=an。</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abcd</span><br><span class="line">aaaa</span><br><span class="line">ababab</span><br><span class="line">.</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">4</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; s,s != <span class="string">&quot;.&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = len; n;n--)<span class="comment">// n从大到小枚举，因为求最大的n值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (len % n == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> m = len / n;</span><br><span class="line">                <span class="built_in">string</span> str = s.substr(<span class="number">0</span>,m);</span><br><span class="line">                <span class="built_in">string</span> res;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) res += str;</span><br><span class="line">                <span class="keyword">if</span> (res == s)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-acwing-778-字符串最大跨距"><a href="#10-acwing-778-字符串最大跨距" class="headerlink" title="10.acwing.778.字符串最大跨距"></a>10.acwing.778.字符串最大跨距</h2><p>难度确实不小，又白给了:slightly_smiling_face:大概思路还是对的，具体代码细节不会了:cold_sweat:</p>
<p>有三个字符串S,S1,S2，其中，S长度不超过300，S1和S2的长度不超过10。</p>
<p>现在，我们想要检测S1和S2是否同时在S中出现，且S1位于S2的左边，并在S中互不交叉（即，S1的右边界点在S2的左边界点的左侧）。</p>
<p>计算满足上述条件的最大跨距（即，最大间隔距离：最右边的S2的起始点与最左边的S1的终止点之间的字符数目）。</p>
<p>如果没有满足条件的S1，S2存在，则输出-1。</p>
<p>例如，S = “abcd123ab888efghij45ef67kl”, S1=”ab”, S2=”ef”，其中，S1在S中出现了2次，S2也在S中出现了2次，最大跨距为：18。</p>
<p>输入格式</p>
<p>输入共一行，包含三个字符串S,S1,S2，字符串之间用逗号隔开。</p>
<p>数据保证三个字符串中不含空格和逗号。</p>
<p>输出格式</p>
<p>输出一个整数，表示最大跨距。</p>
<p>如果没有满足条件的S1和S2存在，则输出-1.</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abcd123ab888efghij45ef67kl,ab,ef</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">18</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总题解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s,s1,s2;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; c,c != <span class="string">&#x27;,&#x27;</span>) s += c;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; c,c != <span class="string">&#x27;,&#x27;</span>) s1 += c;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; c) s2 += c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s.size() &lt;= s1.size() || s.size() &lt;= s2.size()) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l + s1.size() &lt;= s.size())<span class="comment">// 这里用到的结构与上一题类似</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; s1.size())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s1[k] != s[l+k]) <span class="keyword">break</span>;</span><br><span class="line">                k ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == s1.size()) <span class="keyword">break</span>;</span><br><span class="line">            l ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> r = s.size() - s2.size();</span><br><span class="line">        <span class="keyword">while</span> (r &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; s2.size())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s2[k] != s[r+k]) <span class="keyword">break</span>;</span><br><span class="line">                k ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == s2.size()) <span class="keyword">break</span>;</span><br><span class="line">            r --;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        l += s1.size() <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,r - l <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>str.find()简介\</em></strong></p>
<p>查找第一次出现的目标字符串：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">&quot;de&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = s1.find(s2) ;   <span class="comment">//在S1中查找子串S2</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：如果查找成功则输出查找到的第一个位置，否则返回-1. </p>
<p><strong><em>查找从指定位置开始的第一次出现的目标字符串：</em></strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;csdtio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">&quot;de&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = s1.find(s2, <span class="number">2</span>) ;   <span class="comment">//从S1的第二个字符开始查找子串S2</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 2，使用了STL中的find函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> S,S1,S2;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a!=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>) S+=a;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>) S1+=a;</span><br><span class="line">            <span class="keyword">else</span> S2+=a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s,s1,s2;</span><br><span class="line">    s1=S.find(S1);</span><br><span class="line">    s2=S.rfind(S2);</span><br><span class="line">    <span class="keyword">if</span>(s1!=<span class="number">-1</span>&amp;&amp;s2!=<span class="number">-1</span>&amp;&amp;(s1+S1.length()<span class="number">-1</span>)&lt;s2)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s2-s1-S1.length()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;-1&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：Sir.Guo</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/7213/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>竞赛语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab快速入门笔记（配套代码）</title>
    <url>/posts/fcc74e6c.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>本文参考自B站西电通院科协glanny的1小时matlab速成视频！</p>
</blockquote>
<p><a href="https://www.bilibili.com/video/BV1hE411Q7T4?from=search&seid=16973427387965814013">视频链接</a></p>
<span id="more"></span>

<h2 id="第1部分：变量定义和基本运算"><a href="#第1部分：变量定义和基本运算" class="headerlink" title="第1部分：变量定义和基本运算"></a>第1部分：变量定义和基本运算</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">% 建议有C语言或其他编程基础，了解线性代数和矩阵相关知识</span></span><br><span class="line"><span class="comment">% https://ww2.mathworks.cn/help/matlab/</span></span><br><span class="line"><span class="comment">% 加*为了解内容</span></span><br><span class="line"><span class="comment">% 生成矩阵</span></span><br><span class="line">    <span class="comment">% 直接法</span></span><br><span class="line">        a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line">    <span class="comment">% 冒号一维矩阵 a = 开始：步长：结束，步长为1可省略</span></span><br><span class="line">        b = <span class="number">1</span>:<span class="number">1</span>:<span class="number">10</span>;  <span class="comment">% 1,2,...10</span></span><br><span class="line">        b = <span class="number">1</span>:<span class="number">10</span>;  <span class="comment">%与上一个等价</span></span><br><span class="line">    <span class="comment">% 函数生成</span></span><br><span class="line">        <span class="comment">% linspace(开始，结束，元素个数)，等差生成指定元素数的一维矩阵，省略个数则生成100个</span></span><br><span class="line">            c = <span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">10</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="comment">% 特殊矩阵</span></span><br><span class="line">            e = <span class="built_in">eye</span>(<span class="number">4</span>);  <span class="comment">% eye(维数)单位阵</span></span><br><span class="line">            z = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">4</span>);  <span class="comment">% zeros(维数)全零阵</span></span><br><span class="line">            o = <span class="built_in">ones</span>(<span class="number">4</span>,<span class="number">1</span>);  <span class="comment">% ones(维数)全1阵</span></span><br><span class="line">            r = <span class="built_in">rand</span>(<span class="number">4</span>);  <span class="comment">% rand(维数)0~1分布随机阵</span></span><br><span class="line">            rn = <span class="built_in">randn</span>(<span class="number">4</span>);  <span class="comment">% randn(维数)0均值Gaussian分布随机阵</span></span><br><span class="line">                      </span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">% 矩阵运算</span></span><br><span class="line">    diag_a = <span class="built_in">diag</span>(a,<span class="number">1</span>);  <span class="comment">% diag(行向量，主对角线上方第k条斜线)用行向量生成对角阵</span></span><br><span class="line">    tril_a = <span class="built_in">tril</span>(a,<span class="number">1</span>);  <span class="comment">% tril(矩阵，主对角线上方第k条斜线)生成矩阵的下三角阵，triu上三角阵</span></span><br><span class="line">    <span class="comment">% 加、减、乘、乘方</span></span><br><span class="line">        a*a</span><br><span class="line">    <span class="comment">% 点运算</span></span><br><span class="line">        <span class="comment">% a.*b , a./b , a.\b , a.^b  对应元素的*,/,\,^运算</span></span><br><span class="line">        a.*a</span><br><span class="line">    <span class="comment">% 逆矩阵</span></span><br><span class="line">        pinv(a)  <span class="comment">% 伪逆矩阵，当a不是方阵，求广义逆矩阵；当a是可逆方阵，结果与逆矩阵相同</span></span><br><span class="line">    <span class="comment">% 特征值，特征向量</span></span><br><span class="line">        [v,D] = eig(a);  <span class="comment">% 输出v为特征向量，D为特征值对角阵</span></span><br><span class="line">    <span class="comment">% *行列式</span></span><br><span class="line">        det(a)</span><br><span class="line">    <span class="comment">% *秩</span></span><br><span class="line">        rank(a)</span><br><span class="line">    <span class="comment">% *伴随</span></span><br><span class="line">        <span class="built_in">compan</span>(b)</span><br><span class="line">        </span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">% 矩阵的修改</span></span><br><span class="line">    <span class="comment">%部分替换</span></span><br><span class="line">        chg_a = a;</span><br><span class="line">        chg_a(<span class="number">2</span>,<span class="number">3</span>) = <span class="number">4</span>;  <span class="comment">% (行，列)元素替换</span></span><br><span class="line">        chg_a(<span class="number">1</span>,:) = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>];  <span class="comment">% (行,:)替换行，为[]删除该行</span></span><br><span class="line">        chg_a(:,<span class="number">1</span>) = [];  <span class="comment">% (:,列)替换列，为[]删除该列</span></span><br><span class="line">    <span class="comment">% 转置</span></span><br><span class="line">        T_a = a&#x27;;</span><br><span class="line">    <span class="comment">% 指定维数拼接</span></span><br><span class="line">        c1_a = <span class="built_in">cat</span>(<span class="number">1</span>,a,a);  <span class="comment">% 垂直拼接</span></span><br><span class="line">        c2_a = <span class="built_in">cat</span>(<span class="number">2</span>,a,a);  <span class="comment">% 水平拼接</span></span><br><span class="line">    <span class="comment">% *变维</span></span><br><span class="line">        rs_a = <span class="built_in">reshape</span>(a,<span class="number">1</span>,<span class="number">9</span>);  <span class="comment">% 元素个数不变，矩阵变为m*n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">% 信息获取</span></span><br><span class="line">    <span class="comment">% 矩阵的行列数</span></span><br><span class="line">        [row_a, col_a] = <span class="built_in">size</span>(a);  <span class="comment">% [行数，列数]</span></span><br><span class="line">    <span class="comment">% 行列中最大的</span></span><br><span class="line">        len_a = <span class="built_in">length</span>(a);</span><br><span class="line">        </span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">% 多维数组</span></span><br><span class="line">    <span class="comment">% 创建</span></span><br><span class="line">        <span class="comment">% 直接法</span></span><br><span class="line">            mul_1(:,:,<span class="number">1</span>) = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">            mul_1(:,:,<span class="number">2</span>) = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">        <span class="comment">% *扩展法</span></span><br><span class="line">            mul_2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">            mul_2(:,:,<span class="number">2</span>) = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];  <span class="comment">% 若不赋值第一页，第一页全为0</span></span><br><span class="line">        <span class="comment">% cat法</span></span><br><span class="line">            mul_31 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">            mul_32 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">            mul_3 = <span class="built_in">cat</span>(<span class="number">3</span>,mul_31,mul_32);  <span class="comment">% 把a1a2按照“3”维连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">% *字符串</span></span><br><span class="line">    <span class="comment">% 创建</span></span><br><span class="line">        str0 = <span class="string">&#x27;hello world&#x27;</span>;  <span class="comment">% 单引号引起</span></span><br><span class="line">        str1 = <span class="string">&#x27;I&#x27;&#x27;m a student&#x27;</span>;  <span class="comment">% 字符串中单引号写两遍</span></span><br><span class="line">        str3 = [<span class="string">&#x27;I&#x27;&#x27;m&#x27;</span> <span class="string">&#x27;a&#x27;</span> <span class="string">&#x27;student&#x27;</span>];  <span class="comment">% 方括号链接多字符串</span></span><br><span class="line">        str4 = strcat(str0, str1);  <span class="comment">% strcat连接字符串函数</span></span><br><span class="line">        str5 = strvcat(str0, str1);  <span class="comment">% strvcat连接产生多行字符串</span></span><br><span class="line">        str6 = double(str0);  <span class="comment">% 取str0的ASCII值，也可用abs函数</span></span><br><span class="line">        str7 = char(str6);  <span class="comment">% 把ASCII转为字符串</span></span><br><span class="line">    <span class="comment">% 操作</span></span><br><span class="line">        <span class="comment">% 比较</span></span><br><span class="line">            strcmp(str0, str1);  <span class="comment">% 相等为1，不等为0</span></span><br><span class="line">            strncmp(str0, str1, <span class="number">3</span>);  <span class="comment">% 比较前3个是否相等(n)</span></span><br><span class="line">            strcmpi(str0, str1);  <span class="comment">% 忽略大小写比较(i)</span></span><br><span class="line">            strncmpi(str0, str1, <span class="number">3</span>);  <span class="comment">% 忽略大小写比较前3个是否相等</span></span><br><span class="line">        <span class="comment">% 查找替换</span></span><br><span class="line">            strfind(str0, str1);  <span class="comment">% 在str0找到str1的位置</span></span><br><span class="line">            strmatch(str1, str0);  <span class="comment">% 在str0字符串数组中找到str1开头的行数</span></span><br><span class="line">            strtok(str0);  <span class="comment">% 截取str0第一个分隔符（空格，tab，回车）前的部分</span></span><br><span class="line">            strrep(str0, str1, str2);  <span class="comment">% 在str0中用str2替换str1</span></span><br><span class="line">        <span class="comment">% 其他</span></span><br><span class="line">            upper(str0);  <span class="comment">% 转大写，lower转小写</span></span><br><span class="line">            strjust(str0, <span class="string">&#x27;right&#x27;</span>);  <span class="comment">% 将str0右对齐，left左对齐，center中间对齐</span></span><br><span class="line">            strtrim(str0);  <span class="comment">% 删除str0开头结尾空格</span></span><br><span class="line">            eval(str0);  <span class="comment">% 将str0作为代码执行</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">%转换</span></span><br><span class="line">    <span class="comment">% ___2___  --&gt;  如num2str，将数字转字符串； dec2hex，将十进制转十六进制</span></span><br><span class="line">    str_b = num2str(b);</span><br><span class="line">    <span class="comment">% abs，double取ASCII码；char把ASCII转字符串</span></span><br><span class="line">    abs_str = <span class="built_in">abs</span>(<span class="string">&#x27;aAaA&#x27;</span>);  </span><br></pre></td></tr></table></figure>

<h2 id="第2部分：程序结构"><a href="#第2部分：程序结构" class="headerlink" title="第2部分：程序结构"></a>第2部分：程序结构</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%%</span></span><br><span class="line">a = <span class="number">5</span>;</span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>]; y =[<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">%选择结构</span></span><br><span class="line">    <span class="comment">%if-elseif-else-end</span></span><br><span class="line">        <span class="keyword">if</span> a&gt;<span class="number">0</span></span><br><span class="line">            <span class="built_in">disp</span>(x);</span><br><span class="line">        <span class="keyword">elseif</span> a==<span class="number">0</span></span><br><span class="line">            <span class="built_in">disp</span>(a);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">disp</span>(a<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">%switch-case-otherwise-end</span></span><br><span class="line">        <span class="keyword">switch</span> a</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span></span><br><span class="line">                <span class="built_in">disp</span>(a);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span></span><br><span class="line">                <span class="built_in">disp</span>(a+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">otherwise</span></span><br><span class="line">                <span class="built_in">disp</span>(<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">%try-catch</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">            z = x*y;</span><br><span class="line">        <span class="keyword">catch</span></span><br><span class="line">            z = x.*y;  <span class="comment">% 若try出错，则执行</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">disp</span>(z);</span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">% 循环结构</span></span><br><span class="line">    <span class="comment">% for 循环变量=初值:步长:终值 - end</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">0</span>:<span class="number">1</span>:<span class="number">10</span>  <span class="comment">% 步长为负，则初值大于终值</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="built_in">i</span>);  <span class="comment">% 循环体内不可对循环变量做修改</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% while-end</span></span><br><span class="line">    <span class="keyword">while</span> a&gt;<span class="number">2</span></span><br><span class="line">        <span class="built_in">disp</span>(a);</span><br><span class="line">        a = a<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">%程序控制</span></span><br><span class="line">    <span class="comment">%continue 跳过当次循环剩下语句，进入下一循环</span></span><br><span class="line">    <span class="comment">%break 跳出当前循环</span></span><br><span class="line">    <span class="comment">%return 跳出程序并返回</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">%m文件</span></span><br><span class="line">    <span class="comment">%脚本文件：没有输入输出参数，执行后变量结果返回工作空间，可直接运行</span></span><br><span class="line">        <span class="comment">%以下是脚本文件，文件名假设为exp.m</span></span><br><span class="line">        <span class="comment">%**********************************************</span></span><br><span class="line">            clear</span><br><span class="line">            r = <span class="number">5</span>;</span><br><span class="line">            s = <span class="built_in">pi</span>*r*r;</span><br><span class="line">            p = <span class="number">2</span>*<span class="built_in">pi</span>*r;</span><br><span class="line">            <span class="built_in">disp</span>(s)</span><br><span class="line">            <span class="built_in">disp</span>(p)</span><br><span class="line">        <span class="comment">%**********************************************</span></span><br><span class="line">        <span class="comment">%以下是调用</span></span><br><span class="line">        <span class="comment">%**********************************************</span></span><br><span class="line">            <span class="built_in">exp</span></span><br><span class="line">        <span class="comment">%**********************************************</span></span><br><span class="line">    <span class="comment">%函数文件：以function开头，有输入输出，变量为局部变量不返回工作空间，需要调用</span></span><br><span class="line">        <span class="comment">%以下是函数文件</span></span><br><span class="line">        <span class="comment">%**********************************************</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="params">[s, p]</span> = <span class="title">circ</span><span class="params">(r)</span>  % 文件命名应与函数名一致，系统找文件名<span class="title">circ</span>.<span class="title">m</span></span></span><br><span class="line">            <span class="comment">%CIRC 计算圆面积和周长  % 简单说明</span></span><br><span class="line">            <span class="comment">%参数：输入参数r:圆半径；输出参数s:圆面积，p:周长  % 详细说明</span></span><br><span class="line">                s = <span class="built_in">pi</span>*r*r;</span><br><span class="line">                p = <span class="number">2</span>*<span class="built_in">pi</span>*r;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="comment">%**********************************************</span></span><br><span class="line">        <span class="comment">%以下是调用</span></span><br><span class="line">        <span class="comment">%**********************************************</span></span><br><span class="line">            [a, b] = circ(<span class="number">5</span>);  <span class="comment">% 返回为多个参数时，若写a = circ(5)则保留第一个返回值</span></span><br><span class="line">        <span class="comment">%**********************************************</span></span><br><span class="line">        <span class="comment">%*以下是带子函数的函数文件</span></span><br><span class="line">        <span class="comment">%**********************************************</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">key</span><span class="params">(w)</span>  % 主函数放第一个，函数名为<span class="title">key</span></span></span><br><span class="line">            <span class="keyword">if</span> w==<span class="number">0</span></span><br><span class="line">                y = type0(w);  <span class="comment">% 调用子函数type0</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                y = type1(w);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">y0</span> = <span class="title">type0</span><span class="params">(a)</span>  % 子函数，各子函数之间顺序无所谓</span></span><br><span class="line">            y0 = a+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">y1</span> = <span class="title">type1</span><span class="params">(a)</span></span></span><br><span class="line">            y1 = a+<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">%**********************************************</span></span><br><span class="line">        <span class="comment">%*函数输入输出参数可以不定</span></span><br><span class="line">        <span class="comment">%nargin：输入参数个数，nargout：输出参数个数</span></span><br><span class="line">        <span class="comment">%varargin：输入参数内容的元胞数组，varargout：输出参数</span></span><br><span class="line">        <span class="comment">%以下是函数文件</span></span><br><span class="line">        <span class="comment">%**********************************************</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">varargout</span> = <span class="title">idk</span><span class="params">(varargin)</span></span></span><br><span class="line">            x = <span class="built_in">length</span>(varargin);</span><br><span class="line">            varargout&#123;<span class="number">1</span>&#125; = x;</span><br><span class="line">            varargout&#123;<span class="number">2</span>&#125; = x+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">%**********************************************  </span></span><br></pre></td></tr></table></figure>

<h2 id="第3部分：图像绘制"><a href="#第3部分：图像绘制" class="headerlink" title="第3部分：图像绘制"></a>第3部分：图像绘制</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%%</span></span><br><span class="line">x = <span class="number">0</span>:<span class="number">0.1</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">y1 = <span class="built_in">sin</span>(x);</span><br><span class="line">y2 = <span class="built_in">cos</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">% 二维曲线绘制</span></span><br><span class="line">    <span class="comment">% 基本函数</span></span><br><span class="line">        <span class="comment">% plot(y)</span></span><br><span class="line">            <span class="comment">% y为向量</span></span><br><span class="line">                <span class="built_in">plot</span>(y1);  <span class="comment">% 纵坐标为y的值；横坐标自动为元素序号(角标+1)，此处为1~9</span></span><br><span class="line">            <span class="comment">% y为矩阵</span></span><br><span class="line">                <span class="built_in">figure</span>;  <span class="comment">% 开启新绘图窗口，下一次绘图在新窗口</span></span><br><span class="line">                y = [y1&#x27;, y2&#x27;];</span><br><span class="line">                <span class="built_in">plot</span>(y);  <span class="comment">% 当y为矩阵，按每一列画出曲线，颜色自动区分</span></span><br><span class="line">        <span class="comment">% plot(x, y)</span></span><br><span class="line">            <span class="comment">% xy为向量</span></span><br><span class="line">                <span class="built_in">plot</span>(x, y1);  <span class="comment">% 先绘制曲线</span></span><br><span class="line">        <span class="comment">% plot(x1, y1, x2, y2...)</span></span><br><span class="line">            <span class="built_in">plot</span>(x, y1, x, y2);  <span class="comment">% 在同一个窗口同一坐标轴绘制多条曲线</span></span><br><span class="line">    <span class="comment">% 线性图形格式设置</span></span><br><span class="line">        <span class="comment">% 线形颜色数据点</span></span><br><span class="line">            <span class="built_in">plot</span>(x, y1, <span class="string">&#x27;b:o&#x27;</span>);  <span class="comment">% 蓝色 点线 圆圈</span></span><br><span class="line">            <span class="comment">% b蓝 g绿 r红 c青 m紫 y黄 k黑 w白</span></span><br><span class="line">            <span class="comment">% -实线 :点线 --虚线 -.点画线</span></span><br><span class="line">            <span class="comment">% .实点 o圆圈 x叉 +十字 *星号 s方块 d钻石 v下三角 ^上三角 &lt;左三角 &gt;右三角 p五角星 h六角星</span></span><br><span class="line">        <span class="comment">% 坐标轴</span></span><br><span class="line">            <span class="built_in">plot</span>(x, y1);</span><br><span class="line">            axis([<span class="number">-1</span>*<span class="built_in">pi</span>, <span class="number">3</span>*<span class="built_in">pi</span>, <span class="number">-1.5</span>, <span class="number">1.5</span>]);  <span class="comment">% 规定横纵坐标范围</span></span><br><span class="line">    <span class="comment">% 图形修饰</span></span><br><span class="line">        <span class="comment">% 标题标签</span></span><br><span class="line">            title(<span class="string">&#x27;a title&#x27;</span>);  <span class="comment">% 图像标题</span></span><br><span class="line">            xlabel(<span class="string">&#x27;this is x&#x27;</span>);  <span class="comment">% x轴标记，同理还有ylabel，zlabel</span></span><br><span class="line">        <span class="comment">%图例设置</span></span><br><span class="line">            <span class="built_in">legend</span>(<span class="string">&#x27;hahaha&#x27;</span>, <span class="string">&#x27;location&#x27;</span>, <span class="string">&#x27;best&#x27;</span>);  <span class="comment">% str的顺序与绘图顺序一致; &#x27;best&#x27;指图例位置最佳化，还有其他位置</span></span><br><span class="line">        <span class="comment">%图形保持</span></span><br><span class="line">            <span class="built_in">plot</span>(x, y1);</span><br><span class="line">            <span class="built_in">hold</span> on;  <span class="comment">% 在原有窗口y1曲线上增加绘制下一个图形</span></span><br><span class="line">            <span class="built_in">plot</span>(x, y2);  <span class="comment">% y2在同一窗口内被绘制</span></span><br><span class="line">            <span class="built_in">hold</span> off;</span><br><span class="line">        <span class="comment">%分割绘制</span></span><br><span class="line">            subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>);  <span class="comment">% 分割成2x2区域，在第一块区域绘制下一个图形</span></span><br><span class="line">            <span class="built_in">plot</span>(x, y1);  <span class="comment">% y1被绘制在4块区域的第一块</span></span><br><span class="line">            subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>);  <span class="comment">% 分割方法相同，区域改变</span></span><br><span class="line">            <span class="built_in">plot</span>(x, y2);  <span class="comment">% y2在第二块区域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">%*二维特殊图形绘制</span></span><br><span class="line">    <span class="comment">%柱状图</span></span><br><span class="line">        bar(x, y, width, <span class="string">&#x27;参数&#x27;</span>);  <span class="comment">% x横坐标向量，m个元素; y为向量时，每个x画一竖条共m条，矩阵mxn时，每个x画n条;</span></span><br><span class="line">                                   <span class="comment">% width宽度默认0.8，超过1各条会重叠;</span></span><br><span class="line">                                   <span class="comment">% 参数有grouped分组式，stacked堆栈式; 默认grouped</span></span><br><span class="line">                                   <span class="comment">% bar垂直柱状图,barh水平柱状图,bar3三维柱状图,barh3水平三维柱状图(三维多一个参数detached, 且为默认)</span></span><br><span class="line">    <span class="comment">%饼形图</span></span><br><span class="line">        pie(x, explode, <span class="string">&#x27;lable&#x27;</span>);  <span class="comment">% x为向量显示每个元素占总和百分比, 为矩阵显示每个元素占所有总和百分比</span></span><br><span class="line">                                   <span class="comment">% explode向量与x同长度，为1表示该元素被分离突出显示，默认全0不分离</span></span><br><span class="line">                                   <span class="comment">% pie3绘制三维饼图</span></span><br><span class="line">    <span class="comment">%直方图</span></span><br><span class="line">        hist(y, n);  <span class="comment">% y为向量，把横坐标分为n段绘制</span></span><br><span class="line">        hist(y, x);  <span class="comment">% x为向量，用于指定每段中间值, 若取N = hist(y, x), N为每段元素个数</span></span><br><span class="line">    <span class="comment">%离散数据图</span></span><br><span class="line">        stairs(x, y, <span class="string">&#x27;b-o&#x27;</span>);  <span class="comment">% 阶梯图，参数同plot</span></span><br><span class="line">        stem(x, y, <span class="string">&#x27;fill&#x27;</span>);  <span class="comment">% 火柴杆图，参数fill是填充火柴杆，或定义线形</span></span><br><span class="line">        candle(HI, LO, CL, OP);  <span class="comment">% 蜡烛图:HI为最高价格向量,LO为最低价格向量,CL为收盘价格向量,OP为开盘价格向量</span></span><br><span class="line">    <span class="comment">%向量图</span></span><br><span class="line">        compass(u, v, <span class="string">&#x27;b-o&#x27;</span>);  <span class="comment">% 罗盘图横坐标u纵坐标v</span></span><br><span class="line">        compass(Z, <span class="string">&#x27;b-o&#x27;</span>);  <span class="comment">% 罗盘图复向量Z</span></span><br><span class="line">        feather(u, v, <span class="string">&#x27;b-o&#x27;</span>);  <span class="comment">% 羽毛图横坐标u纵坐标v</span></span><br><span class="line">        feather(Z, <span class="string">&#x27;b-o&#x27;</span>);  <span class="comment">% 羽毛图复向量Z</span></span><br><span class="line">        quiver(x, y, u, v);  <span class="comment">% 以(x, y)为起点(u, v)为终点向量场图</span></span><br><span class="line">    <span class="comment">%极坐标图</span></span><br><span class="line">        <span class="comment">% polar(theta, rho, &#x27;b-o&#x27;);  % 极角theta, 半径rho</span></span><br><span class="line">        theta = -<span class="built_in">pi</span>:<span class="number">0.01</span>:<span class="built_in">pi</span>;</span><br><span class="line">        rho = <span class="built_in">sin</span>(theta);</span><br><span class="line">        polar(theta, rho, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    <span class="comment">%对数坐标图</span></span><br><span class="line">        semilogx(x1, y1, <span class="string">&#x27;b-o&#x27;</span>);  <span class="comment">% 把x轴对数刻度表示, semilogy是y轴对数刻度表示，loglog是两个坐标都用对数表示</span></span><br><span class="line">    <span class="comment">%双纵坐标</span></span><br><span class="line">        plotyy(x1, y1, x2, y2, <span class="string">&#x27;fun1&#x27;</span>, <span class="string">&#x27;fun2&#x27;</span>);  <span class="comment">% fun规定了两条条线的绘制方式，如plot,semilogx,semilogy,loglog,stem等</span></span><br><span class="line">    <span class="comment">%函数绘图</span></span><br><span class="line">        f = <span class="string">&#x27;sin(2*x)&#x27;</span>;</span><br><span class="line">        ezplot(f, [<span class="number">0</span>, <span class="number">2</span>*<span class="built_in">pi</span>]);  <span class="comment">% 绘制f并规定横坐标范围，也有[xmin, xmax, ymin, ymax]</span></span><br><span class="line">        x = <span class="string">&#x27;2*cos(t)&#x27;</span>;</span><br><span class="line">        y = <span class="string">&#x27;4*sin(t)&#x27;</span>;</span><br><span class="line">        ezplot(x, y);  <span class="comment">% 绘制x(t),y(t)在[0, 2*pi]图像, 也可以在最后用[tmin, tmax]规定t的范围</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">%三维曲线曲面绘制</span></span><br><span class="line">    <span class="comment">%三维曲线</span></span><br><span class="line">        x = <span class="number">0</span>:<span class="number">0.1</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">        y = <span class="built_in">sin</span>(x); z = <span class="built_in">cos</span>(x);</span><br><span class="line">        <span class="built_in">plot3</span>(x, y, z, <span class="string">&#x27;b-*&#x27;</span>);</span><br><span class="line">    <span class="comment">%三维曲面</span></span><br><span class="line">        <span class="comment">%三维网格</span></span><br><span class="line">            x = <span class="number">-5</span>:<span class="number">0.1</span>:<span class="number">5</span>;  <span class="comment">% 规定了x轴采样点，也规定了x轴范围</span></span><br><span class="line">            y = <span class="number">-4</span>:<span class="number">0.1</span>:<span class="number">4</span>;  <span class="comment">% 规定了y轴采样点，也规定了y轴范围</span></span><br><span class="line">            [X, Y] = <span class="built_in">meshgrid</span>(x, y);  <span class="comment">% 得到了xoy面网格点</span></span><br><span class="line">            Z = X.^<span class="number">2</span>+Y.^<span class="number">2</span>;</span><br><span class="line">            mesh(X, Y, Z)  <span class="comment">% XY是meshgrid得到的网格点，Z是网格顶点，c是用色矩阵可省略</span></span><br><span class="line">        <span class="comment">%三维表面图</span></span><br><span class="line">            x = <span class="number">-5</span>:<span class="number">0.1</span>:<span class="number">5</span>;  </span><br><span class="line">            y = <span class="number">-4</span>:<span class="number">0.1</span>:<span class="number">4</span>;</span><br><span class="line">            [X, Y] = <span class="built_in">meshgrid</span>(x, y);</span><br><span class="line">            Z = X.^<span class="number">2</span>+Y.^<span class="number">2</span>;  <span class="comment">% 以上部分同上</span></span><br><span class="line">            surf(X, Y, Z)  <span class="comment">% 与上一个类似</span></span><br></pre></td></tr></table></figure>

<h2 id="第4部分：多项式"><a href="#第4部分：多项式" class="headerlink" title="第4部分：多项式"></a>第4部分：多项式</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">%多项式</span></span><br><span class="line">    <span class="comment">%创建</span></span><br><span class="line">        p = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];  <span class="comment">% 系数向量，按x降幂排列，最右边是常数</span></span><br><span class="line">        f1 = poly2str(p, <span class="string">&#x27;x&#x27;</span>);  <span class="comment">% 生成好看的字符串 f1 = x^3 + 2 x^2 + 3 x + 4，不被认可的运算式</span></span><br><span class="line">        f2 = poly2sym(p);  <span class="comment">% 生成可用的符号函数 f2 = x^3 + 2*x^2 + 3*x + 4</span></span><br><span class="line">    <span class="comment">%求值</span></span><br><span class="line">        x = <span class="number">4</span>;</span><br><span class="line">        y1 = polyval(p, x);  <span class="comment">% 代入求值；若x1为矩阵，则对每个值单独求值</span></span><br><span class="line">    <span class="comment">%求根</span></span><br><span class="line">        r = roots(p); <span class="comment">% p同上，由系数求根，结果为根植矩阵</span></span><br><span class="line">        p0 = poly(r);  <span class="comment">% 由根求系数，结果为系数矩阵</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">%数据插值</span></span><br><span class="line">    <span class="comment">%一维插值</span></span><br><span class="line">        <span class="comment">%yi = interp1(X, Y, xi, &#x27;method&#x27;)</span></span><br><span class="line">        X = [<span class="number">-3</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>];</span><br><span class="line">        Y = [<span class="number">9</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">9</span>];  <span class="comment">% XY为已知点横纵坐标向量</span></span><br><span class="line">        y2 = interp1(X, Y, <span class="number">2</span>);  <span class="comment">% 差值预估在x=2的y的值，x不能超过已知范围(此处x&lt;3)</span></span><br><span class="line">        y2m = interp1(X, Y, <span class="number">2</span>, <span class="string">&#x27;spline&#x27;</span>);  <span class="comment">% 用spline方法(三次样条)差值预估在x=2的y的值</span></span><br><span class="line">    <span class="comment">%二维插值</span></span><br><span class="line">        <span class="comment">%zi = interp1(X, Y, Z, xi, yi, &#x27;method&#x27;)</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">%%</span></span><br><span class="line">X = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>];</span><br><span class="line">A = [<span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>; <span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>; <span class="number">8</span>, <span class="number">4</span> ,<span class="number">6</span>];</span><br><span class="line">B = [<span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>; <span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>; <span class="number">8</span>, <span class="number">4</span> ,<span class="number">6</span>];</span><br><span class="line"><span class="comment">%数据统计</span></span><br><span class="line">    <span class="comment">%矩阵最大最小值</span></span><br><span class="line">        y = <span class="built_in">max</span>(X);  <span class="comment">% 求矩阵X的最大值，min最小值</span></span><br><span class="line">        [y, k] = <span class="built_in">max</span>(X);  <span class="comment">% 求最大值，k为该值的角标</span></span><br><span class="line">        [y, k] = <span class="built_in">max</span>(A, [], <span class="number">2</span>);  <span class="comment">% A是矩阵，&#x27;2&#x27;时返回y每一行最大元素构成的列向量，k元素所在列；&#x27;1&#x27;时与上述相同</span></span><br><span class="line">    <span class="comment">%均值和中值</span></span><br><span class="line">        y = <span class="built_in">mean</span>(X);  <span class="comment">% 均值</span></span><br><span class="line">        y = median(X);  <span class="comment">% 中值</span></span><br><span class="line">        y = <span class="built_in">mean</span>(A, <span class="number">2</span>);  <span class="comment">% &#x27;2&#x27;时返回y每一行均值构成的列向量；&#x27;1&#x27;时与上述相同</span></span><br><span class="line">        y = median(A, <span class="number">2</span>);  <span class="comment">% &#x27;2&#x27;时返回y每一行中值构成的列向量；&#x27;1&#x27;时与上述相同</span></span><br><span class="line">    <span class="comment">%排序</span></span><br><span class="line">        Y = <span class="built_in">sort</span>(A, <span class="number">1</span>, <span class="string">&#x27;ascend&#x27;</span>);  <span class="comment">% sort(矩阵, dim, &#x27;method&#x27;)dim为1按列排序，2按行排序；ascend升序，descend降序</span></span><br><span class="line">        [Y, I] = <span class="built_in">sort</span>(A, <span class="number">1</span>, <span class="string">&#x27;ascend&#x27;</span>);  <span class="comment">% I保留了元素之前在A的位置</span></span><br><span class="line">    <span class="comment">%求和求积累加累乘</span></span><br><span class="line">        y = sum(X);  <span class="comment">% 求和</span></span><br><span class="line">        y = prod(X);  <span class="comment">% 求积</span></span><br><span class="line">        y = cumsum(X);  <span class="comment">% 累加</span></span><br><span class="line">        y = cumprod(X);  <span class="comment">% 累乘</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">%*数值计算</span></span><br><span class="line">    <span class="comment">%最(极)值</span></span><br><span class="line">        <span class="comment">%多元函数在给定初值附近找最小值点</span></span><br><span class="line">        x = fminsearch(fun, x0);</span><br><span class="line">    <span class="comment">%函数零点</span></span><br><span class="line">        x = fzero(fun, x0);  <span class="comment">% 在给定初值x0附近找零点</span></span><br></pre></td></tr></table></figure>

<h2 id="第5部分：符号函数"><a href="#第5部分：符号函数" class="headerlink" title="第5部分：符号函数"></a>第5部分：符号函数</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">%符号对象创建</span></span><br><span class="line">    <span class="comment">%sym函数</span></span><br><span class="line">        p = <span class="built_in">sin</span>(<span class="built_in">pi</span>/<span class="number">3</span>);</span><br><span class="line">        P = sym(p, <span class="string">&#x27;r&#x27;</span>);  <span class="comment">% 用数值p创建符号常量P；&#x27;d&#x27;浮点数&#x27;f&#x27;有理分式的浮点数&#x27;e&#x27;有理数和误差&#x27;r&#x27;有理数</span></span><br><span class="line">    <span class="comment">%syms函数</span></span><br><span class="line">        syms x;  <span class="comment">% 声明符号变量</span></span><br><span class="line">        f = <span class="number">7</span>*x^<span class="number">2</span> + <span class="number">2</span>*x+<span class="number">9</span>;  <span class="comment">% 创建符号函数</span></span><br><span class="line">    <span class="comment">%符号运算</span></span><br><span class="line">        <span class="comment">% 加减乘除外</span></span><br><span class="line">        <span class="comment">% &#x27;转置 ； ==相等 ； ~=不等</span></span><br><span class="line">        <span class="comment">% sin, cos, tan; asin, acos, atan 三角反三角</span></span><br><span class="line">        <span class="comment">% sinh, cosh, tanh; asinh, acosh, atanh 双曲反双曲</span></span><br><span class="line">        <span class="comment">% conj复数共轭；real复数实部；imag复数虚部；abs复数模；angle复数幅角</span></span><br><span class="line">        <span class="comment">% diag矩阵对角；triu矩阵上三角；tril矩阵下三角；inv逆矩阵；det行列式；rank秩；poly特征多项式；</span></span><br><span class="line">        <span class="comment">% |----expm矩阵指数函数；eig矩阵特征值和特征向量；svd奇异值分解；</span></span><br><span class="line">    <span class="comment">%符号对象精度转换</span></span><br><span class="line">        digits;  <span class="comment">% 显示当前用于计算的精度</span></span><br><span class="line">        digits(<span class="number">16</span>);  <span class="comment">% 将计算精度改为16位，降低精度有时可以加快程序运算速度或减少空间占用</span></span><br><span class="line">        a16 = vpa(<span class="built_in">sqrt</span>(<span class="number">2</span>));  <span class="comment">% vpa括起的运算使sqrt(2)运算按照规定的精度执行</span></span><br><span class="line">        a8 = vpa(<span class="built_in">sqrt</span>(<span class="number">2</span>), <span class="number">8</span>);  <span class="comment">% 在vpa内控制精度，离开这一步精度恢复</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">%符号多项式函数运算</span></span><br><span class="line">    <span class="comment">%*符号表达形式与相互转化</span></span><br><span class="line">        <span class="comment">%多项式展开整理</span></span><br><span class="line">            g = expand(f);  <span class="comment">% 展开</span></span><br><span class="line">            h = collect(g);  <span class="comment">% 整理(默认按x整理)</span></span><br><span class="line">            h1 = collect(f, x);  <span class="comment">% 按x整理（降幂排列）</span></span><br><span class="line">        <span class="comment">%因式分解展开质因数</span></span><br><span class="line">            fac = <span class="built_in">factor</span>(h);  <span class="comment">% 因式分解</span></span><br><span class="line">            <span class="built_in">factor</span>(<span class="number">12</span>);  <span class="comment">% 对12分解质因数</span></span><br><span class="line">    <span class="comment">%符号多项式向量形式与计算</span></span><br><span class="line">        syms a b c;</span><br><span class="line">        n = [a, b, c];</span><br><span class="line">        roots(n);  <span class="comment">% 求符号多项式ax^2+bx+c的根</span></span><br><span class="line">        n = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">        roots(n);  <span class="comment">% 求符号多项式带入a=1, b=2, c=3的根</span></span><br><span class="line">    <span class="comment">%*反函数</span></span><br><span class="line">        fi = finverse(f, x);  <span class="comment">% 对f中的变量x求反函数</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">%符号微积分</span></span><br><span class="line">    <span class="comment">%函数的极限和级数运算</span></span><br><span class="line">        <span class="comment">% 常量a，b</span></span><br><span class="line">        <span class="comment">%极限</span></span><br><span class="line">            limit(f, x, <span class="number">4</span>);  <span class="comment">% 求f(x), x-&gt;4</span></span><br><span class="line">            limit(f, <span class="number">4</span>);  <span class="comment">% 默认变量-&gt;4</span></span><br><span class="line">            limit(f);  <span class="comment">% 默认变量-&gt;0</span></span><br><span class="line">            limit(f, x, <span class="number">4</span>, <span class="string">&#x27;right&#x27;</span>);  <span class="comment">% 求f(x), x-&gt;4+, &#x27;left&#x27; x-&gt;4-</span></span><br><span class="line">        <span class="comment">%*基本级数运算</span></span><br><span class="line">            <span class="comment">%求和</span></span><br><span class="line">                symsum(s, x, <span class="number">3</span>, <span class="number">5</span>);  <span class="comment">% 计算表达式s变量x从3到5的级数和，或symsum(s, x, [a b])或symsum(s, x, [a;b])</span></span><br><span class="line">                symsum(s, <span class="number">3</span>, <span class="number">5</span>);  <span class="comment">% 计算s默认变量从3到5的级数和</span></span><br><span class="line">                symsum(s);  <span class="comment">% 计算s默认变量从0到n-1的级数和</span></span><br><span class="line">            <span class="comment">%一维泰勒展开</span></span><br><span class="line">                taylor(f, x, <span class="number">4</span>);  <span class="comment">% f在x=4处展开为五阶泰勒级数</span></span><br><span class="line">                taylor(f, x);  <span class="comment">% f在x=0处展开为五阶泰勒级数</span></span><br><span class="line">                taylor(f);  <span class="comment">% f在默认变量=0处展开为五阶泰勒级数</span></span><br><span class="line">    <span class="comment">%符号微分</span></span><br><span class="line">        <span class="comment">%单变量求导（单变量偏导）</span></span><br><span class="line">            n = <span class="number">1</span>;  <span class="comment">% 常量n</span></span><br><span class="line">            fn = diff(f, x, n);  <span class="comment">% f对x的n阶导</span></span><br><span class="line">            f1 = diff(f, x);  <span class="comment">% f对x的1阶导</span></span><br><span class="line">            diff(f, n);  <span class="comment">% f对默认变量的n阶导</span></span><br><span class="line">            diff(f);  <span class="comment">% 默认变量1阶导</span></span><br><span class="line">        <span class="comment">%多元偏导</span></span><br><span class="line">            fxy = diff(f, x, y);  <span class="comment">% 先求x偏导，再求y偏导</span></span><br><span class="line">            fxyz = diff(f, x, y, z);  <span class="comment">% 先求x偏导，再求y偏导,再求z偏导</span></span><br><span class="line">    <span class="comment">%符号积分</span></span><br><span class="line">        <span class="comment">%积分命令</span></span><br><span class="line">            int(f, x, <span class="number">1</span>, <span class="number">2</span>);  <span class="comment">% 函数f变量x在1~2区间定积分</span></span><br><span class="line">            int(f, <span class="number">1</span>, <span class="number">2</span>);  <span class="comment">% 函数f默认变量在ab区间定积分</span></span><br><span class="line">            int(f, x);  <span class="comment">% 函数f变量x不定积分</span></span><br><span class="line">            int(f);  <span class="comment">% 函数f默认变量不定积分</span></span><br><span class="line">            <span class="comment">% 傅里叶，拉普拉斯，Z变换</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">%*符号方程求解</span></span><br><span class="line">    <span class="comment">%符号代数方程</span></span><br><span class="line">        <span class="comment">%一元方程</span></span><br><span class="line">            eqn1 = a*x==b;</span><br><span class="line">            S = solve(eqn1);  <span class="comment">% 返回eqn符号解</span></span><br><span class="line">        <span class="comment">%多元方程组</span></span><br><span class="line">            eqn21 = x-y==a;</span><br><span class="line">            eqn22 = <span class="number">2</span>*x+y==b;</span><br><span class="line">            [Sx, Sy] = solve(eqn21, eqn22, x, y);  <span class="comment">% [Svar1,...SvarN]=solve(eqn1,...eqnM, var1,...varN),MN不一定相等</span></span><br><span class="line">            [Sxn, Syn] = solve(eqn21, eqn22, x, y, <span class="string">&#x27;ReturnCondition&#x27;</span>, <span class="built_in">true</span>);  <span class="comment">% 加上参数ReturnCondition可返回通解及解的条件</span></span><br><span class="line">            <span class="comment">% 其他参数(参数加上true生效)</span></span><br><span class="line">                <span class="comment">% IgnoreProperty，忽略变量定义时一些假设</span></span><br><span class="line">                <span class="comment">% IgnoreAnalyticConstraints，忽略分析限制；</span></span><br><span class="line">                <span class="comment">% MaxDegree，大于3解显性解；</span></span><br><span class="line">                <span class="comment">% PrincipleValue，仅主值</span></span><br><span class="line">                <span class="comment">% Real，仅实数解</span></span><br><span class="line">        <span class="comment">%非线性fsolve</span></span><br><span class="line">            X = fsolve(fun, X0, optimset(option));  <span class="comment">% fun函数.m文件名；X0求根初值；option选项如(&#x27;Display&#x27;,&#x27;off&#x27;)不显示中间结果等</span></span><br></pre></td></tr></table></figure>
<p>作者：glanny</p>
<p><a href="https://www.bilibili.com/read/cv7966685?spm_id_from=333.788.b_636f6d6d656e74.6">原文地址</a></p>
<p>出处： bilibili</p>
]]></content>
      <categories>
        <category>Matlab</category>
      </categories>
      <tags>
        <tag>Matlab入门</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL语法总结</title>
    <url>/posts/7009b76e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="SQL-语法"><a href="#SQL-语法" class="headerlink" title="SQL 语法"></a>SQL 语法</h1><p>转载自：<a href="https://github.com/CyC2018/CS-Notes#coffee-java">https://github.com/CyC2018/CS-Notes#coffee-java</a></p>
<span id="more"></span>

<ul>
<li><a href="#sql-%E8%AF%AD%E6%B3%95">SQL 语法</a><ul>
<li><a href="#%E4%B8%80%E5%9F%BA%E7%A1%80">一、基础</a></li>
<li><a href="#%E4%BA%8C%E5%88%9B%E5%BB%BA%E8%A1%A8">二、创建表</a></li>
<li><a href="#%E4%B8%89%E4%BF%AE%E6%94%B9%E8%A1%A8">三、修改表</a></li>
<li><a href="#%E5%9B%9B%E6%8F%92%E5%85%A5">四、插入</a></li>
<li><a href="#%E4%BA%94%E6%9B%B4%E6%96%B0">五、更新</a></li>
<li><a href="#%E5%85%AD%E5%88%A0%E9%99%A4">六、删除</a></li>
<li><a href="#%E4%B8%83%E6%9F%A5%E8%AF%A2">七、查询</a><ul>
<li><a href="#distinct">DISTINCT</a></li>
<li><a href="#limit">LIMIT</a></li>
</ul>
</li>
<li><a href="#%E5%85%AB%E6%8E%92%E5%BA%8F">八、排序</a></li>
<li><a href="#%E4%B9%9D%E8%BF%87%E6%BB%A4">九、过滤</a></li>
<li><a href="#%E5%8D%81%E9%80%9A%E9%85%8D%E7%AC%A6">十、通配符</a></li>
<li><a href="#%E5%8D%81%E4%B8%80%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5">十一、计算字段</a></li>
<li><a href="#%E5%8D%81%E4%BA%8C%E5%87%BD%E6%95%B0">十二、函数</a><ul>
<li><a href="#%E6%B1%87%E6%80%BB">汇总</a></li>
<li><a href="#%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86">文本处理</a></li>
<li><a href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86">日期和时间处理</a></li>
<li><a href="#%E6%95%B0%E5%80%BC%E5%A4%84%E7%90%86">数值处理</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E4%B8%89%E5%88%86%E7%BB%84">十三、分组</a></li>
<li><a href="#%E5%8D%81%E5%9B%9B%E5%AD%90%E6%9F%A5%E8%AF%A2">十四、子查询</a></li>
<li><a href="#%E5%8D%81%E4%BA%94%E8%BF%9E%E6%8E%A5">十五、连接</a><ul>
<li><a href="#%E5%86%85%E8%BF%9E%E6%8E%A5">内连接</a></li>
<li><a href="#%E8%87%AA%E8%BF%9E%E6%8E%A5">自连接</a></li>
<li><a href="#%E8%87%AA%E7%84%B6%E8%BF%9E%E6%8E%A5">自然连接</a></li>
<li><a href="#%E5%A4%96%E8%BF%9E%E6%8E%A5">外连接</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E5%85%AD%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2">十六、组合查询</a></li>
<li><a href="#%E5%8D%81%E4%B8%83%E8%A7%86%E5%9B%BE">十七、视图</a></li>
<li><a href="#%E5%8D%81%E5%85%AB%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B">十八、存储过程</a></li>
<li><a href="#%E5%8D%81%E4%B9%9D%E6%B8%B8%E6%A0%87">十九、游标</a></li>
<li><a href="#%E4%BA%8C%E5%8D%81%E8%A7%A6%E5%8F%91%E5%99%A8">二十、触发器</a></li>
<li><a href="#%E4%BA%8C%E5%8D%81%E4%B8%80%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86">二十一、事务管理</a></li>
<li><a href="#%E4%BA%8C%E5%8D%81%E4%BA%8C%E5%AD%97%E7%AC%A6%E9%9B%86">二十二、字符集</a></li>
<li><a href="#%E4%BA%8C%E5%8D%81%E4%B8%89%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86">二十三、权限管理</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a><!-- GFM-TOC -->


</li>
</ul>
</li>
</ul>
<h2 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h2><p>模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。</p>
<p>主键的值不允许修改，也不允许复用（不能将已经删除的主键值赋给新数据行的主键）。</p>
<p>SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。</p>
<p>SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。</p>
<p>SQL 支持以下三种注释：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">## 注释</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable; <span class="comment">-- 注释</span></span><br><span class="line"><span class="comment">/* 注释1</span></span><br><span class="line"><span class="comment">   注释2 */</span></span><br></pre></td></tr></table></figure>

<p>数据库创建与使用：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE test;</span><br><span class="line">USE test;</span><br></pre></td></tr></table></figure>

<h2 id="二、创建表"><a href="#二、创建表" class="headerlink" title="二、创建表"></a>二、创建表</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable (</span><br><span class="line">  # <span class="type">int</span> 类型，不为空，自增</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  # <span class="type">int</span> 类型，不可为空，默认值为 <span class="number">1</span>，不为空</span><br><span class="line">  col1 <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">  # 变长字符串类型，最长为 <span class="number">45</span> 个字符，可以为空</span><br><span class="line">  col2 <span class="type">VARCHAR</span>(<span class="number">45</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  # 日期类型，可为空</span><br><span class="line">  col3 <span class="type">DATE</span> <span class="keyword">NULL</span>,</span><br><span class="line">  # 设置主键为 id</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`));</span><br></pre></td></tr></table></figure>

<h2 id="三、修改表"><a href="#三、修改表" class="headerlink" title="三、修改表"></a>三、修改表</h2><p>添加列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line"><span class="keyword">ADD</span> col <span class="type">CHAR</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>删除列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> col;</span><br></pre></td></tr></table></figure>

<p>删除表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> mytable;</span><br></pre></td></tr></table></figure>

<h2 id="四、插入"><a href="#四、插入" class="headerlink" title="四、插入"></a>四、插入</h2><p>普通插入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mytable(col1, col2)</span><br><span class="line"><span class="keyword">VALUES</span>(val1, val2);</span><br></pre></td></tr></table></figure>

<p>插入检索出来的数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mytable1(col1, col2)</span><br><span class="line"><span class="keyword">SELECT</span> col1, col2</span><br><span class="line"><span class="keyword">FROM</span> mytable2;</span><br></pre></td></tr></table></figure>

<p>将一个表的内容插入到一个新表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> newtable <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure>

<h2 id="五、更新"><a href="#五、更新" class="headerlink" title="五、更新"></a>五、更新</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE mytable</span><br><span class="line"><span class="keyword">SET</span> col <span class="operator">=</span> val</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="六、删除"><a href="#六、删除" class="headerlink" title="六、删除"></a>六、删除</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>TRUNCATE TABLE</strong>   可以清空表，也就是删除所有行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> mytable;</span><br></pre></td></tr></table></figure>

<p>使用更新和删除操作时一定要用 WHERE 子句，不然会把整张表的数据都破坏。可以先用 SELECT 语句进行测试，防止错误删除。</p>
<h2 id="七、查询"><a href="#七、查询" class="headerlink" title="七、查询"></a>七、查询</h2><h3 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h3><p>相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> col1, col2</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure>

<h3 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h3><p>限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p>
<p>返回前 5 行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line">LIMIT <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line">LIMIT <span class="number">0</span>, <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>返回第 3 ~ 5 行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line">LIMIT <span class="number">2</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h2 id="八、排序"><a href="#八、排序" class="headerlink" title="八、排序"></a>八、排序</h2><ul>
<li>  <strong>ASC</strong>  ：升序（默认）</li>
<li>  <strong>DESC</strong>  ：降序</li>
</ul>
<p>可以按多个列进行排序，并且为每个列指定不同的排序方式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> col1 <span class="keyword">DESC</span>, col2 <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<h2 id="九、过滤"><a href="#九、过滤" class="headerlink" title="九、过滤"></a>九、过滤</h2><p>不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>下表显示了 WHERE 子句可用的操作符</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">=</td>
<td align="center">等于</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">小于</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">大于</td>
</tr>
<tr>
<td align="center">&lt;&gt; !=</td>
<td align="center">不等于</td>
</tr>
<tr>
<td align="center">&lt;= !&gt;</td>
<td align="center">小于等于</td>
</tr>
<tr>
<td align="center">&gt;= !&lt;</td>
<td align="center">大于等于</td>
</tr>
<tr>
<td align="center">BETWEEN</td>
<td align="center">在两个值之间</td>
</tr>
<tr>
<td align="center">IS NULL</td>
<td align="center">为 NULL 值</td>
</tr>
</tbody></table>
<p>应该注意到，NULL 与 0、空字符串都不同。</p>
<p><strong>AND 和 OR</strong>   用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。</p>
<p><strong>IN</strong>   操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。</p>
<p><strong>NOT</strong>   操作符用于否定一个条件。</p>
<h2 id="十、通配符"><a href="#十、通配符" class="headerlink" title="十、通配符"></a>十、通配符</h2><p>通配符也是用在过滤语句中，但它只能用于文本字段。</p>
<ul>
<li><p>  <strong>%</strong>   匹配 &gt;=0 个任意字符；</p>
</li>
<li><p>  <strong>_</strong>   匹配 ==1 个任意字符；</p>
</li>
<li><p>  <strong>[ ]</strong>   可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。</p>
</li>
</ul>
<p>使用 Like 来进行通配符匹配。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col <span class="keyword">LIKE</span> <span class="string">&#x27;[^AB]%&#x27;</span>; <span class="comment">-- 不以 A 和 B 开头的任意文本</span></span><br></pre></td></tr></table></figure>

<p>不要滥用通配符，通配符位于开头处匹配会非常慢。</p>
<h2 id="十一、计算字段"><a href="#十一、计算字段" class="headerlink" title="十一、计算字段"></a>十一、计算字段</h2><p>在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。</p>
<p>计算字段通常需要使用   <strong>AS</strong>   来取别名，否则输出的时候字段名为计算表达式。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1 <span class="operator">*</span> col2 <span class="keyword">AS</span> alias</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure>

<p><strong>CONCAT()</strong>   用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 <strong>TRIM()</strong> 可以去除首尾空格。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="built_in">TRIM</span>(col1), <span class="string">&#x27;(&#x27;</span>, <span class="built_in">TRIM</span>(col2), <span class="string">&#x27;)&#x27;</span>) <span class="keyword">AS</span> concat_col</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure>

<h2 id="十二、函数"><a href="#十二、函数" class="headerlink" title="十二、函数"></a>十二、函数</h2><p>各个 DBMS 的函数都是不相同的，因此不可移植，以下主要是 MySQL 的函数。</p>
<h3 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h3><table>
<thead>
<tr>
<th align="center">函 数</th>
<th align="center">说 明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AVG()</td>
<td align="center">返回某列的平均值</td>
</tr>
<tr>
<td align="center">COUNT()</td>
<td align="center">返回某列的行数</td>
</tr>
<tr>
<td align="center">MAX()</td>
<td align="center">返回某列的最大值</td>
</tr>
<tr>
<td align="center">MIN()</td>
<td align="center">返回某列的最小值</td>
</tr>
<tr>
<td align="center">SUM()</td>
<td align="center">返回某列值之和</td>
</tr>
</tbody></table>
<p>AVG() 会忽略 NULL 行。</p>
<p>使用 DISTINCT 可以汇总不同的值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(<span class="keyword">DISTINCT</span> col1) <span class="keyword">AS</span> avg_col</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure>

<h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LEFT()</td>
<td align="center">左边的字符</td>
</tr>
<tr>
<td align="center">RIGHT()</td>
<td align="center">右边的字符</td>
</tr>
<tr>
<td align="center">LOWER()</td>
<td align="center">转换为小写字符</td>
</tr>
<tr>
<td align="center">UPPER()</td>
<td align="center">转换为大写字符</td>
</tr>
<tr>
<td align="center">LTRIM()</td>
<td align="center">去除左边的空格</td>
</tr>
<tr>
<td align="center">RTRIM()</td>
<td align="center">去除右边的空格</td>
</tr>
<tr>
<td align="center">LENGTH()</td>
<td align="center">长度</td>
</tr>
<tr>
<td align="center">SOUNDEX()</td>
<td align="center">转换为语音值</td>
</tr>
</tbody></table>
<p>其中，  <strong>SOUNDEX()</strong>   可以将一个字符串转换为描述其语音表示的字母数字模式。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> SOUNDEX(col1) <span class="operator">=</span> SOUNDEX(<span class="string">&#x27;apple&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="日期和时间处理"><a href="#日期和时间处理" class="headerlink" title="日期和时间处理"></a>日期和时间处理</h3><ul>
<li>日期格式：YYYY-MM-DD</li>
<li>时间格式：HH:&lt;zero-width space&gt;MM:SS</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函 数</th>
<th align="center">说 明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ADDDATE()</td>
<td align="center">增加一个日期（天、周等）</td>
</tr>
<tr>
<td align="center">ADDTIME()</td>
<td align="center">增加一个时间（时、分等）</td>
</tr>
<tr>
<td align="center">CURDATE()</td>
<td align="center">返回当前日期</td>
</tr>
<tr>
<td align="center">CURTIME()</td>
<td align="center">返回当前时间</td>
</tr>
<tr>
<td align="center">DATE()</td>
<td align="center">返回日期时间的日期部分</td>
</tr>
<tr>
<td align="center">DATEDIFF()</td>
<td align="center">计算两个日期之差</td>
</tr>
<tr>
<td align="center">DATE_ADD()</td>
<td align="center">高度灵活的日期运算函数</td>
</tr>
<tr>
<td align="center">DATE_FORMAT()</td>
<td align="center">返回一个格式化的日期或时间串</td>
</tr>
<tr>
<td align="center">DAY()</td>
<td align="center">返回一个日期的天数部分</td>
</tr>
<tr>
<td align="center">DAYOFWEEK()</td>
<td align="center">对于一个日期，返回对应的星期几</td>
</tr>
<tr>
<td align="center">HOUR()</td>
<td align="center">返回一个时间的小时部分</td>
</tr>
<tr>
<td align="center">MINUTE()</td>
<td align="center">返回一个时间的分钟部分</td>
</tr>
<tr>
<td align="center">MONTH()</td>
<td align="center">返回一个日期的月份部分</td>
</tr>
<tr>
<td align="center">NOW()</td>
<td align="center">返回当前日期和时间</td>
</tr>
<tr>
<td align="center">SECOND()</td>
<td align="center">返回一个时间的秒部分</td>
</tr>
<tr>
<td align="center">TIME()</td>
<td align="center">返回一个日期时间的时间部分</td>
</tr>
<tr>
<td align="center">YEAR()</td>
<td align="center">返回一个日期的年份部分</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> NOW();</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-4-14 20:25:11</span><br></pre></td></tr></table></figure>

<h3 id="数值处理"><a href="#数值处理" class="headerlink" title="数值处理"></a>数值处理</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SIN()</td>
<td align="center">正弦</td>
</tr>
<tr>
<td align="center">COS()</td>
<td align="center">余弦</td>
</tr>
<tr>
<td align="center">TAN()</td>
<td align="center">正切</td>
</tr>
<tr>
<td align="center">ABS()</td>
<td align="center">绝对值</td>
</tr>
<tr>
<td align="center">SQRT()</td>
<td align="center">平方根</td>
</tr>
<tr>
<td align="center">MOD()</td>
<td align="center">余数</td>
</tr>
<tr>
<td align="center">EXP()</td>
<td align="center">指数</td>
</tr>
<tr>
<td align="center">PI()</td>
<td align="center">圆周率</td>
</tr>
<tr>
<td align="center">RAND()</td>
<td align="center">随机数</td>
</tr>
</tbody></table>
<h2 id="十三、分组"><a href="#十三、分组" class="headerlink" title="十三、分组"></a>十三、分组</h2><p>把具有相同的数据值的行放在同一组中。</p>
<p>可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。</p>
<p>指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> col;</span><br></pre></td></tr></table></figure>

<p>GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> col</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> num;</span><br></pre></td></tr></table></figure>

<p>WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col <span class="operator">&gt;</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> col</span><br><span class="line"><span class="keyword">HAVING</span> num <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>分组规定：</p>
<ul>
<li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；</li>
<li>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</li>
<li>NULL 的行会单独分为一组；</li>
<li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。</li>
</ul>
<h2 id="十四、子查询"><a href="#十四、子查询" class="headerlink" title="十四、子查询"></a>十四、子查询</h2><p>子查询中只能返回一个字段的数据。</p>
<p>可以将子查询的结果作为 WHRER 语句的过滤条件：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable1</span><br><span class="line"><span class="keyword">WHERE</span> col1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> col2</span><br><span class="line">               <span class="keyword">FROM</span> mytable2);</span><br></pre></td></tr></table></figure>

<p>下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line">                   <span class="keyword">FROM</span> Orders</span><br><span class="line">                   <span class="keyword">WHERE</span> Orders.cust_id <span class="operator">=</span> Customers.cust_id)</span><br><span class="line">                   <span class="keyword">AS</span> orders_num</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure>

<h2 id="十五、连接"><a href="#十五、连接" class="headerlink" title="十五、连接"></a>十五、连接</h2><p>连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。</p>
<p>连接可以替换子查询，并且比子查询的效率一般会更快。</p>
<p>可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。</p>
<h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>内连接又称等值连接，使用 INNER JOIN 关键字。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tableb <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">ON</span> A.key <span class="operator">=</span> B.key;</span><br></pre></td></tr></table></figure>

<p>可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A, tableb <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">WHERE</span> A.key <span class="operator">=</span> B.key;</span><br></pre></td></tr></table></figure>

<h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>自连接可以看成内连接的一种，只是连接的表是自身而已。</p>
<p>一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。</p>
<p>子查询版本</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> employee</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> (</span><br><span class="line">      <span class="keyword">SELECT</span> department</span><br><span class="line">      <span class="keyword">FROM</span> employee</span><br><span class="line">      <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;Jim&quot;);</span><br></pre></td></tr></table></figure>

<p>自连接版本</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e1.name</span><br><span class="line"><span class="keyword">FROM</span> employee <span class="keyword">AS</span> e1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> employee <span class="keyword">AS</span> e2</span><br><span class="line"><span class="keyword">ON</span> e1.department <span class="operator">=</span> e2.department</span><br><span class="line">      <span class="keyword">AND</span> e2.name <span class="operator">=</span> &quot;Jim&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h3><p>自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。</p>
<p>内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> tableb <span class="keyword">AS</span> B;</span><br></pre></td></tr></table></figure>

<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。</p>
<p>检索所有顾客的订单信息，包括还没有订单信息的顾客。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id, Customer.cust_name, Orders.order_id</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id <span class="operator">=</span> Orders.cust_id;</span><br></pre></td></tr></table></figure>

<p>customers 表：</p>
<table>
<thead>
<tr>
<th align="center">cust_id</th>
<th align="center">cust_name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">a</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">b</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">c</td>
</tr>
</tbody></table>
<p>orders 表：</p>
<table>
<thead>
<tr>
<th align="center">order_id</th>
<th align="center">cust_id</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">3</td>
</tr>
</tbody></table>
<p>结果：</p>
<table>
<thead>
<tr>
<th align="center">cust_id</th>
<th align="center">cust_name</th>
<th align="center">order_id</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">a</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">a</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">c</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">c</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">b</td>
<td align="center">Null</td>
</tr>
</tbody></table>
<h2 id="十六、组合查询"><a href="#十六、组合查询" class="headerlink" title="十六、组合查询"></a>十六、组合查询</h2><p>使用   <strong>UNION</strong>   来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。</p>
<p>每个查询必须包含相同的列、表达式和聚集函数。</p>
<p>默认会去除相同行，如果需要保留相同行，使用 UNION ALL。</p>
<p>只能包含一个 ORDER BY 子句，并且必须位于语句的最后。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col <span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h2 id="十七、视图"><a href="#十七、视图" class="headerlink" title="十七、视图"></a>十七、视图</h2><p>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。</p>
<p>对视图的操作和对普通表的操作一样。</p>
<p>视图具有如下好处：</p>
<ul>
<li>简化复杂的 SQL 操作，比如复杂的连接；</li>
<li>只使用实际表的一部分数据；</li>
<li>通过只给用户访问视图的权限，保证数据的安全性；</li>
<li>更改数据格式和表示。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myview <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> Concat(col1, col2) <span class="keyword">AS</span> concat_col, col3<span class="operator">*</span>col4 <span class="keyword">AS</span> compute_col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col5 <span class="operator">=</span> val;</span><br></pre></td></tr></table></figure>

<h2 id="十八、存储过程"><a href="#十八、存储过程" class="headerlink" title="十八、存储过程"></a>十八、存储过程</h2><p>存储过程可以看成是对一系列 SQL 操作的批处理。</p>
<p>使用存储过程的好处：</p>
<ul>
<li>代码封装，保证了一定的安全性；</li>
<li>代码复用；</li>
<li>由于是预先编译，因此具有很高的性能。</li>
</ul>
<p>命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</p>
<p>包含 in、out 和 inout 三种参数。</p>
<p>给变量赋值都需要用 select into 语句。</p>
<p>每次只能给一个变量赋值，不支持集合的操作。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> myprocedure( <span class="keyword">out</span> ret <span class="type">int</span> )</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">declare</span> y <span class="type">int</span>;</span><br><span class="line">        <span class="keyword">select</span> <span class="built_in">sum</span>(col1)</span><br><span class="line">        <span class="keyword">from</span> mytable</span><br><span class="line">        <span class="keyword">into</span> y;</span><br><span class="line">        <span class="keyword">select</span> y<span class="operator">*</span>y <span class="keyword">into</span> ret;</span><br><span class="line">    <span class="keyword">end</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> myprocedure(<span class="variable">@ret</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@ret</span>;</span><br></pre></td></tr></table></figure>

<h2 id="十九、游标"><a href="#十九、游标" class="headerlink" title="十九、游标"></a>十九、游标</h2><p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p>
<p>游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。</p>
<p>使用游标的四个步骤：</p>
<ol>
<li>声明游标，这个过程没有实际检索出数据；</li>
<li>打开游标；</li>
<li>取出数据；</li>
<li>关闭游标；</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> myprocedure(<span class="keyword">out</span> ret <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">declare</span> done <span class="type">boolean</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">declare</span> mycursor <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">        <span class="keyword">select</span> col1 <span class="keyword">from</span> mytable;</span><br><span class="line">        # 定义了一个 continue handler，当 <span class="keyword">sqlstate</span> <span class="string">&#x27;02000&#x27;</span> 这个条件出现时，会执行 <span class="keyword">set</span> done <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">declare</span> continue handler <span class="keyword">for</span> <span class="keyword">sqlstate</span> <span class="string">&#x27;02000&#x27;</span> <span class="keyword">set</span> done <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">open</span> mycursor;</span><br><span class="line"></span><br><span class="line">        repeat</span><br><span class="line">            <span class="keyword">fetch</span> mycursor <span class="keyword">into</span> ret;</span><br><span class="line">            <span class="keyword">select</span> ret;</span><br><span class="line">        until done <span class="keyword">end</span> repeat;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">close</span> mycursor;</span><br><span class="line">    <span class="keyword">end</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"> delimiter ;</span><br></pre></td></tr></table></figure>

<h2 id="二十、触发器"><a href="#二十、触发器" class="headerlink" title="二十、触发器"></a>二十、触发器</h2><p>触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE。</p>
<p>触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中。</p>
<p>INSERT 触发器包含一个名为 NEW 的虚拟表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> mytrigger AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> mytable</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">SELECT</span> NEW.col <span class="keyword">into</span> <span class="variable">@result</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@result</span>; <span class="comment">-- 获取结果</span></span><br></pre></td></tr></table></figure>

<p>DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。</p>
<p>UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改的，而 OLD 是只读的。</p>
<p>MySQL 不允许在触发器中使用 CALL 语句，也就是不能调用存储过程。</p>
<h2 id="二十一、事务管理"><a href="#二十一、事务管理" class="headerlink" title="二十一、事务管理"></a>二十一、事务管理</h2><p>基本术语：</p>
<ul>
<li>事务（transaction）指一组 SQL 语句；</li>
<li>回退（rollback）指撤销指定 SQL 语句的过程；</li>
<li>提交（commit）指将未存储的 SQL 语句结果写入数据库表；</li>
<li>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。</li>
</ul>
<p>不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。</p>
<p>MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。</p>
<p>设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。</p>
<p>如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> ...</span><br><span class="line"><span class="keyword">SAVEPOINT</span> delete1</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> ...</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> delete1</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> ...</span><br><span class="line"><span class="keyword">COMMIT</span></span><br></pre></td></tr></table></figure>

<h2 id="二十二、字符集"><a href="#二十二、字符集" class="headerlink" title="二十二、字符集"></a>二十二、字符集</h2><p>基本术语：</p>
<ul>
<li>字符集为字母和符号的集合；</li>
<li>编码为某个字符集成员的内部表示；</li>
<li>校对字符指定如何比较，主要用于排序和分组。</li>
</ul>
<p>除了给表指定字符集和校对外，也可以给列指定：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line">(col <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> latin <span class="keyword">COLLATE</span> latin1_general_ci )</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> hebrew <span class="keyword">COLLATE</span> hebrew_general_ci;</span><br></pre></td></tr></table></figure>

<p>可以在排序、分组时指定校对：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> col <span class="keyword">COLLATE</span> latin1_general_ci;</span><br></pre></td></tr></table></figure>

<h2 id="二十三、权限管理"><a href="#二十三、权限管理" class="headerlink" title="二十三、权限管理"></a>二十三、权限管理</h2><p>MySQL 的账户信息保存在 mysql 这个数据库中。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p><strong>创建账户</strong>  </p>
<p>新创建的账户没有任何权限。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> myuser IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;mypassword&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>修改账户名</strong>  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">RENAME <span class="keyword">USER</span> myuser <span class="keyword">TO</span> newuser;</span><br></pre></td></tr></table></figure>

<p><strong>删除账户</strong>  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> myuser;</span><br></pre></td></tr></table></figure>

<p><strong>查看权限</strong>  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> myuser;</span><br></pre></td></tr></table></figure>

<p><strong>授予权限</strong>  </p>
<p>账户用 username@host 的形式定义，username@% 使用的是默认主机名。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> mydatabase.<span class="operator">*</span> <span class="keyword">TO</span> myuser;</span><br></pre></td></tr></table></figure>

<p><strong>删除权限</strong>  </p>
<p>GRANT 和 REVOKE 可在几个层次上控制访问权限：</p>
<ul>
<li>整个服务器，使用 GRANT ALL 和 REVOKE ALL；</li>
<li>整个数据库，使用 ON database.*；</li>
<li>特定的表，使用 ON database.table；</li>
<li>特定的列；</li>
<li>特定的存储过程。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> mydatabase.<span class="operator">*</span> <span class="keyword">FROM</span> myuser;</span><br></pre></td></tr></table></figure>

<p><strong>更改密码</strong>  </p>
<p>必须使用 Password() 函数进行加密。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWROD <span class="keyword">FOR</span> myuser <span class="operator">=</span> Password(<span class="string">&#x27;new_password&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>BenForta. SQL 必知必会 [M]. 人民邮电出版社, 2013.</li>
</ul>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心基础总结</title>
    <url>/posts/651b324b.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Java-核心基础总结"><a href="#Java-核心基础总结" class="headerlink" title="Java 核心基础总结"></a>Java 核心基础总结</h1><p>转载自：<a href="https://github.com/CyC2018/CS-Notes#coffee-java">https://github.com/CyC2018/CS-Notes#coffee-java</a></p>
<span id="more"></span>

<ul>
<li><a href="#java-%E5%9F%BA%E7%A1%80">Java 基础</a><ul>
<li><a href="#%E4%B8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">一、数据类型</a><ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B">基本类型</a></li>
<li><a href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B">包装类型</a></li>
<li><a href="#%E7%BC%93%E5%AD%98%E6%B1%A0">缓存池</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8Cstring">二、String</a><ul>
<li><a href="#%E6%A6%82%E8%A7%88">概览</a></li>
<li><a href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%A5%BD%E5%A4%84">不可变的好处</a></li>
<li><a href="#string-stringbuffer-and-stringbuilder">String, StringBuffer and StringBuilder    </a></li>
<li><a href="#string-pool">String Pool</a></li>
<li><a href="#new-stringabc">new String(“abc”)</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E8%BF%90%E7%AE%97">三、运算</a><ul>
<li><a href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">参数传递</a></li>
<li><a href="#float-%E4%B8%8E-double">float 与 double</a></li>
<li><a href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">隐式类型转换</a></li>
<li><a href="#switch">switch</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B%E5%85%B3%E9%94%AE%E5%AD%97">四、关键字</a><ul>
<li><a href="#final">final</a></li>
<li><a href="#static">static</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94object-%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95">五、Object 通用方法</a><ul>
<li><a href="#%E6%A6%82%E8%A7%88">概览</a></li>
<li><a href="#equals">equals()</a></li>
<li><a href="#hashcode">hashCode()</a></li>
<li><a href="#tostring">toString()</a></li>
<li><a href="#clone">clone()</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD%E7%BB%A7%E6%89%BF">六、继承</a><ul>
<li><a href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90">访问权限</a></li>
<li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3">抽象类与接口</a></li>
<li><a href="#super">super</a></li>
<li><a href="#%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD">重写与重载</a></li>
</ul>
</li>
<li><a href="#%E4%B8%83%E5%8F%8D%E5%B0%84">七、反射</a></li>
<li><a href="#%E5%85%AB%E5%BC%82%E5%B8%B8">八、异常</a></li>
<li><a href="#%E4%B9%9D%E6%B3%9B%E5%9E%8B">九、泛型</a></li>
<li><a href="#%E5%8D%81%E6%B3%A8%E8%A7%A3">十、注解</a></li>
<li><a href="#%E5%8D%81%E4%B8%80%E7%89%B9%E6%80%A7">十一、特性</a><ul>
<li><a href="#java-%E5%90%84%E7%89%88%E6%9C%AC%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7">Java 各版本的新特性</a></li>
<li><a href="#java-%E4%B8%8E-c-%E7%9A%84%E5%8C%BA%E5%88%AB">Java 与 C++ 的区别</a></li>
<li><a href="#jre-or-jdk">JRE or JDK</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a><!-- GFM-TOC -->


</li>
</ul>
</li>
</ul>
<h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ul>
<li>byte/8</li>
<li>char/16</li>
<li>short/16</li>
<li>int/32</li>
<li>float/32</li>
<li>long/64</li>
<li>double/64</li>
<li>boolean/~</li>
</ul>
<p>boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。</p>
<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">Primitive Data Types</a></li>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf">The Java® Virtual Machine Specification</a></li>
</ul>
<h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer x = <span class="number">2</span>;     <span class="comment">// 装箱 调用了 Integer.valueOf(2)</span></span><br><span class="line"><span class="keyword">int</span> y = x;         <span class="comment">// 拆箱 调用了 X.intValue()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html">Autoboxing and Unboxing</a></li>
</ul>
<h3 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h3><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p>
<ul>
<li>new Integer(123) 每次都会新建一个对象；</li>
<li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line">Integer z = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">Integer k = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// high value may be configured by property</span></span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">    String integerCacheHighPropValue =</span><br><span class="line">        sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">            i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">            <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">            <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    high = h;</span><br><span class="line"></span><br><span class="line">    cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> j = low;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">        cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">    <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer m = <span class="number">123</span>;</span><br><span class="line">Integer n = <span class="number">123</span>;</span><br><span class="line">System.out.println(m == n); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>基本类型对应的缓冲池如下：</p>
<ul>
<li>boolean values true and false</li>
<li>all byte values</li>
<li>short values between -128 and 127</li>
<li>int values between -128 and 127</li>
<li>char in the range \u0000 to \u007F</li>
</ul>
<p>在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。</p>
<p>在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax=&lt;size&gt; 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。</p>
<p><a href="https://stackoverflow.com/questions/9030817/differences-between-new-integer123-integer-valueof123-and-just-123">StackOverflow : Differences between new Integer(123), Integer.valueOf(123) and just 123
</a></p>
<h2 id="二、String"><a href="#二、String" class="headerlink" title="二、String"></a>二、String</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）</p>
<p>在 Java 8 中，String 内部使用 char 数组存储数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The identifier of the encoding used to encode the bytes in &#123;<span class="doctag">@code</span> value&#125;. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p>
<h3 id="不可变的好处"><a href="#不可变的好处" class="headerlink" title="不可变的好处"></a>不可变的好处</h3><p><strong>1. 可以缓存 hash 值</strong>  </p>
<p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p>
<p><strong>2. String Pool 的需要</strong>  </p>
<p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191210004132894.png"> </div><br>

<p><strong>3. 安全性</strong>  </p>
<p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p>
<p><strong>4. 线程安全</strong>  </p>
<p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p>
<p><a href="https://www.programcreek.com/2013/04/why-string-is-immutable-in-java/">Program Creek : Why String is immutable in Java?</a></p>
<h3 id="String-StringBuffer-and-StringBuilder"><a href="#String-StringBuffer-and-StringBuilder" class="headerlink" title="String, StringBuffer and StringBuilder"></a>String, StringBuffer and StringBuilder</h3><p><strong>1. 可变性</strong>  </p>
<ul>
<li>String 不可变</li>
<li>StringBuffer 和 StringBuilder 可变</li>
</ul>
<p><strong>2. 线程安全</strong>  </p>
<ul>
<li>String 不可变，因此是线程安全的</li>
<li>StringBuilder 不是线程安全的</li>
<li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li>
</ul>
<p><a href="https://stackoverflow.com/questions/2971315/string-stringbuffer-and-stringbuilder">StackOverflow : String, StringBuffer, and StringBuilder</a></p>
<h3 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h3><p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。</p>
<p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p>
<p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 和 s2.intern() 方法取得同一个字符串引用。intern() 首先把 “aaa” 放到 String Pool 中，然后返回这个字符串引用，因此 s3 和 s4 引用的是同一个字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false</span></span><br><span class="line">String s3 = s1.intern();</span><br><span class="line">String s4 = s2.intern();</span><br><span class="line">System.out.println(s3 == s4);           <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s5 = <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">String s6 = <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">System.out.println(s5 == s6);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p>
<ul>
<li><a href="https://stackoverflow.com/questions/10578984/what-is-string-interning">StackOverflow : What is String interning?</a></li>
<li><a href="https://tech.meituan.com/in_depth_understanding_string_intern.html">深入解析 String#intern</a></li>
</ul>
<h3 id="new-String-“abc”"><a href="#new-String-“abc”" class="headerlink" title="new String(“abc”)"></a>new String(“abc”)</h3><p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。</p>
<ul>
<li>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量；</li>
<li>而使用 new 的方式会在堆中创建一个字符串对象。</li>
</ul>
<p>创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewStringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 javap -verbose 进行反编译，得到以下内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">Constant pool:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">   #2 = Class              #18            // java/lang/String</span><br><span class="line">   #3 = String             #19            // abc</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  #18 = Utf8               java/lang/String</span><br><span class="line">  #19 = Utf8               abc</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: new           #2                  // class java/lang/String</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: ldc           #3                  // String abc</span><br><span class="line">         6: invokespecial #4                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">9</span>: astore_1</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>在 Constant Pool 中，#19 存储这字符串字面量 “abc”，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。</p>
<p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、运算"><a href="#三、运算" class="headerlink" title="三、运算"></a>三、运算</h2><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>Java 的参数是以值传递的形式传入方法中，而不是引用传递。</p>
<p>以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Dog(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getObjectAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PassByValueExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        func(dog);</span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Dog dog)</span> </span>&#123;</span><br><span class="line">        dog.setName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在方法中将指针引用了其它对象，那么此时方法里和方法外的两个指针指向了不同的对象，在一个指针改变其所指向对象的内容对另一个指针所指向的对象没有影响。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassByValueExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        func(dog);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// A</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Dog dog)</span> </span>&#123;</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        dog = <span class="keyword">new</span> Dog(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@74a14482</span></span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value">StackOverflow: Is Java “pass-by-reference” or “pass-by-value”?</a></p>
<h3 id="float-与-double"><a href="#float-与-double" class="headerlink" title="float 与 double"></a>float 与 double</h3><p>Java 不能隐式执行向下转型，因为这会使得精度降低。</p>
<p>1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// float f = 1.1;</span></span><br></pre></td></tr></table></figure>

<p>1.1f 字面量才是 float 类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">1.1f</span>;</span><br></pre></td></tr></table></figure>

<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// s1 = s1 + 1;</span></span><br></pre></td></tr></table></figure>

<p>但是使用 += 或者 ++ 运算符会执行隐式类型转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s1 += <span class="number">1</span>;</span><br><span class="line">s1++;</span><br></pre></td></tr></table></figure>

<p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s1 = (<span class="keyword">short</span>) (s1 + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><a href="https://stackoverflow.com/questions/8710619/why-dont-javas-compound-assignment-operators-require-casting">StackOverflow : Why don’t Java’s +=, -=, *=, /= compound assignment operators require casting?</a></p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;b&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch 不支持 long、float、double，是因为 switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// long x = 111;</span></span><br><span class="line"><span class="comment">// switch (x) &#123; // Incompatible types. Found: &#x27;long&#x27;, required: &#x27;char, byte, short, int, Character, Byte, Short, Integer, String, or an enum&#x27;</span></span><br><span class="line"><span class="comment">//     case 111:</span></span><br><span class="line"><span class="comment">//         System.out.println(111);</span></span><br><span class="line"><span class="comment">//         break;</span></span><br><span class="line"><span class="comment">//     case 222:</span></span><br><span class="line"><span class="comment">//         System.out.println(222);</span></span><br><span class="line"><span class="comment">//         break;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://stackoverflow.com/questions/2676210/why-cant-your-switch-statement-data-type-be-long-java">StackOverflow : Why can’t your switch statement data type be long, Java?</a></p>
<h2 id="四、关键字"><a href="#四、关键字" class="headerlink" title="四、关键字"></a>四、关键字</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p><strong>1. 数据</strong>  </p>
<p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p>
<ul>
<li>对于基本类型，final 使数值不变；</li>
<li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// x = 2;  // cannot assign value to final variable &#x27;x&#x27;</span></span><br><span class="line"><span class="keyword">final</span> A y = <span class="keyword">new</span> A();</span><br><span class="line">y.a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>2. 方法</strong>  </p>
<p>声明方法不能被子类重写。</p>
<p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p>
<p><strong>3. 类</strong>  </p>
<p>声明类不允许被继承。</p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><strong>1. 静态变量</strong>  </p>
<ul>
<li>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。</li>
<li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;         <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> y;  <span class="comment">// 静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// int x = A.x;  // Non-static field &#x27;x&#x27; cannot be referenced from a static context</span></span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="keyword">int</span> x = a.x;</span><br><span class="line">        <span class="keyword">int</span> y = A.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 静态方法</strong>  </p>
<p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// public abstract static void func2();  // Illegal combination of modifiers: &#x27;abstract&#x27; and &#x27;static&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因为这两个关键字与具体对象关联。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = x;</span><br><span class="line">        <span class="comment">// int b = y;  // Non-static field &#x27;y&#x27; cannot be referenced from a static context</span></span><br><span class="line">        <span class="comment">// int b = this.y;     // &#x27;A.this&#x27; cannot be referenced from a static context</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 静态语句块</strong>  </p>
<p>静态语句块在类初始化时运行一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a1 = <span class="keyword">new</span> A();</span><br><span class="line">        A a2 = <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure>

<p><strong>4. 静态内部类</strong>  </p>
<p>非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// InnerClass innerClass = new InnerClass(); // &#x27;OuterClass.this&#x27; cannot be referenced from a static context</span></span><br><span class="line">        OuterClass outerClass = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        InnerClass innerClass = outerClass.n<span class="function">ew <span class="title">InnerClass</span><span class="params">()</span></span>;</span><br><span class="line">        StaticInnerClass staticInnerClass = <span class="keyword">new</span> StaticInnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类不能访问外部类的非静态的变量和方法。</p>
<p><strong>5. 静态导包</strong>  </p>
<p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.xxx.ClassName.*</span><br></pre></td></tr></table></figure>

<p><strong>6. 初始化顺序</strong>  </p>
<p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String staticField = <span class="string">&quot;静态变量&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;静态语句块&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String field = <span class="string">&quot;实例变量&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;普通语句块&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后才是构造函数的初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InitialOrderTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;构造函数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在继承的情况下，初始化顺序为：</p>
<ul>
<li>父类（静态变量、静态语句块）</li>
<li>子类（静态变量、静态语句块）</li>
<li>父类（实例变量、普通语句块）</li>
<li>父类（构造函数）</li>
<li>子类（实例变量、普通语句块）</li>
<li>子类（构造函数）</li>
</ul>
<h2 id="五、Object-通用方法"><a href="#五、Object-通用方法" class="headerlink" title="五、Object 通用方法"></a>五、Object 通用方法</h2><h3 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; <span class="title">getClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure>

<h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p><strong>1. 等价关系</strong>  </p>
<p>两个对象具有等价关系，需要满足以下五个条件：</p>
<p>Ⅰ 自反性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Ⅱ 对称性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(y) == y.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Ⅲ 传递性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x.equals(y) &amp;&amp; y.equals(z))</span><br><span class="line">    x.equals(z); <span class="comment">// true;</span></span><br></pre></td></tr></table></figure>

<p>Ⅳ 一致性</p>
<p>多次调用 equals() 方法结果不变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(y) == x.equals(y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Ⅴ 与 null 的比较</p>
<p>对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(<span class="keyword">null</span>); <span class="comment">// false;</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 等价与相等</strong>  </p>
<ul>
<li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li>
<li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x == y);      <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 实现</strong>  </p>
<ul>
<li>检查是否为同一个对象的引用，如果是直接返回 true；</li>
<li>检查是否是同一个类型，如果不是，直接返回 false；</li>
<li>将 Object 对象进行转型；</li>
<li>判断每个关键域是否相等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EqualExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        EqualExample that = (EqualExample) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x != that.x) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (y != that.y) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> z == that.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><p>hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。</p>
<p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。</p>
<p>HashSet  和 HashMap 等集合类使用了 hashCode()  方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode()  方法。</p>
<p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象。但是 EqualExample 没有实现 hashCode() 方法，因此这两个对象的哈希值是不同的，最终导致集合添加了两个等价的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EqualExample e1 = <span class="keyword">new</span> EqualExample(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">EqualExample e2 = <span class="keyword">new</span> EqualExample(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(e1.equals(e2)); <span class="comment">// true</span></span><br><span class="line">HashSet&lt;EqualExample&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">set.add(e1);</span><br><span class="line">set.add(e2);</span><br><span class="line">System.out.println(set.size());   <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。</p>
<p>R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">17</span>;</span><br><span class="line">    result = <span class="number">31</span> * result + x;</span><br><span class="line">    result = <span class="number">31</span> * result + y;</span><br><span class="line">    result = <span class="number">31</span> * result + z;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToStringExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ToStringExample</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ToStringExample example = <span class="keyword">new</span> ToStringExample(<span class="number">123</span>);</span><br><span class="line">System.out.println(example.toString());</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">ToStringExample@4554617c</span><br></pre></td></tr></table></figure>

<h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><p><strong>1. cloneable</strong>  </p>
<p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CloneExample e1 = <span class="keyword">new</span> CloneExample();</span><br><span class="line"><span class="comment">// CloneExample e2 = e1.clone(); // &#x27;clone()&#x27; has protected access in &#x27;java.lang.Object&#x27;</span></span><br></pre></td></tr></table></figure>

<p>重写 clone() 得到以下实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (CloneExample)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CloneExample e1 = <span class="keyword">new</span> CloneExample();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    CloneExample e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">java.lang.CloneNotSupportedException: CloneExample</span><br></pre></td></tr></table></figure>

<p>以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。</p>
<p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 浅拷贝</strong>  </p>
<p>拷贝对象和原始对象的引用类型引用同一个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShallowCloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShallowCloneExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ShallowCloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ShallowCloneExample) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ShallowCloneExample e1 = <span class="keyword">new</span> ShallowCloneExample();</span><br><span class="line">ShallowCloneExample e2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 222</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 深拷贝</strong>  </p>
<p>拷贝对象和原始对象的引用类型引用不同对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepCloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeepCloneExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DeepCloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        DeepCloneExample result = (DeepCloneExample) <span class="keyword">super</span>.clone();</span><br><span class="line">        result.arr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            result.arr[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DeepCloneExample e1 = <span class="keyword">new</span> DeepCloneExample();</span><br><span class="line">DeepCloneExample e2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><strong>4. clone() 的替代方案</strong>  </p>
<p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneConstructorExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CloneConstructorExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CloneConstructorExample</span><span class="params">(CloneConstructorExample original)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[original.arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; original.arr.length; i++) &#123;</span><br><span class="line">            arr[i] = original.arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CloneConstructorExample e1 = <span class="keyword">new</span> CloneConstructorExample();</span><br><span class="line">CloneConstructorExample e2 = <span class="keyword">new</span> CloneConstructorExample(e1);</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h2 id="六、继承"><a href="#六、继承" class="headerlink" title="六、继承"></a>六、继承</h2><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。</p>
<p>可以对类或类中的成员（字段和方法）加上访问修饰符。</p>
<ul>
<li>类可见表示其它类可以用这个类创建实例对象。</li>
<li>成员可见表示其它类可以用这个类的实例对象访问到该成员；</li>
</ul>
<p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p>
<p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。</p>
<p>如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例去代替，也就是确保满足里氏替换原则。</p>
<p>字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = Integer.valueOf(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessWithInnerClassExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InnerClass innerClass;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccessWithInnerClassExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        innerClass = <span class="keyword">new</span> InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> innerClass.x;  <span class="comment">// 直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h3><p><strong>1. 抽象类</strong>  </p>
<p>抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。</p>
<p>抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClassExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExtendClassExample</span> <span class="keyword">extends</span> <span class="title">AbstractClassExample</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractClassExample ac1 = new AbstractClassExample(); // &#x27;AbstractClassExample&#x27; is abstract; cannot be instantiated</span></span><br><span class="line">AbstractClassExample ac2 = <span class="keyword">new</span> AbstractExtendClassExample();</span><br><span class="line">ac2.func1();</span><br></pre></td></tr></table></figure>

<p><strong>2. 接口</strong>  </p>
<p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p>
<p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。</p>
<p>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。从 Java 9 开始，允许将方法定义为 private，这样就能定义某些复用的代码又不会把方法暴露出去。</p>
<p>接口的字段默认都是 static 和 final 的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">123</span>;</span><br><span class="line">    <span class="comment">// int y;               // Variable &#x27;y&#x27; might not have been initialized</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> z = <span class="number">0</span>;       <span class="comment">// Modifier &#x27;public&#x27; is redundant for interface fields</span></span><br><span class="line">    <span class="comment">// private int k = 0;   // Modifier &#x27;private&#x27; not allowed here</span></span><br><span class="line">    <span class="comment">// protected int l = 0; // Modifier &#x27;protected&#x27; not allowed here</span></span><br><span class="line">    <span class="comment">// private void fun3(); // Modifier &#x27;private&#x27; not allowed here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceImplementExample</span> <span class="keyword">implements</span> <span class="title">InterfaceExample</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// InterfaceExample ie1 = new InterfaceExample(); // &#x27;InterfaceExample&#x27; is abstract; cannot be instantiated</span></span><br><span class="line">InterfaceExample ie2 = <span class="keyword">new</span> InterfaceImplementExample();</span><br><span class="line">ie2.func1();</span><br><span class="line">System.out.println(InterfaceExample.x);</span><br></pre></td></tr></table></figure>

<p><strong>3. 比较</strong>  </p>
<ul>
<li>从设计层面上看，抽象类提供了一种 IS-A 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li>
<li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li>
<li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li>
<li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li>
</ul>
<p><strong>4. 使用选择</strong>  </p>
<p>使用接口：</p>
<ul>
<li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Comparable 接口中的 compareTo() 方法；</li>
<li>需要使用多重继承。</li>
</ul>
<p>使用抽象类：</p>
<ul>
<li>需要在几个相关的类中共享代码。</li>
<li>需要能控制继承来的成员的访问权限，而不是都为 public。</li>
<li>需要继承非静态和非常量字段。</li>
</ul>
<p>在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p>
<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html">Abstract Methods and Classes</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/l-javainterface-abstract/">深入理解 abstract class 和 interface</a></li>
<li><a href="https://dzone.com/articles/when-to-use-abstract-class-and-intreface">When to Use Abstract Class and Interface</a></li>
<li><a href="https://www.journaldev.com/12850/java-9-private-methods-interfaces">Java 9 Private Methods in Interfaces</a></li>
</ul>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><ul>
<li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。</li>
<li>访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperExample.func()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperExtendExample</span> <span class="keyword">extends</span> <span class="title">SuperExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperExtendExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(x, y);</span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.func();</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperExtendExample.func()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SuperExample e = <span class="keyword">new</span> SuperExtendExample(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">e.func();</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">SuperExample.func()</span><br><span class="line">SuperExtendExample.func()</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.oracle.com/javase/tutorial/java/IandI/super.html">Using the Keyword super</a></p>
<h3 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h3><p><strong>1. 重写（Override）</strong>  </p>
<p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</p>
<p>为了满足里式替换原则，重写有以下三个限制：</p>
<ul>
<li>子类方法的访问权限必须大于等于父类方法；</li>
<li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li>
<li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</li>
</ul>
<p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。</p>
<p>下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：</p>
<ul>
<li>子类方法访问权限为 public，大于父类的 protected。</li>
<li>子类的返回类型为 ArrayList&lt;Integer&gt;，是父类返回类型 List&lt;Integer&gt; 的子类。</li>
<li>子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。</li>
<li>子类重写方法使用 @Override 注解，从而让编译器自动检查是否满足限制条件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List&lt;Integer&gt; <span class="title">func</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">func</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：</p>
<ul>
<li>this.func(this)</li>
<li>super.func(this)</li>
<li>this.func(super)</li>
<li>super.func(super)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    A</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    B</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    C</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    D</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(A obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A.show(A)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(C obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A.show(C)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(A obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B.show(A)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    B b = <span class="keyword">new</span> B();</span><br><span class="line">    C c = <span class="keyword">new</span> C();</span><br><span class="line">    D d = <span class="keyword">new</span> D();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 A 中存在 show(A obj)，直接调用</span></span><br><span class="line">    a.show(a); <span class="comment">// A.show(A)</span></span><br><span class="line">    <span class="comment">// 在 A 中不存在 show(B obj)，将 B 转型成其父类 A</span></span><br><span class="line">    a.show(b); <span class="comment">// A.show(A)</span></span><br><span class="line">    <span class="comment">// 在 B 中存在从 A 继承来的 show(C obj)，直接调用</span></span><br><span class="line">    b.show(c); <span class="comment">// A.show(C)</span></span><br><span class="line">    <span class="comment">// 在 B 中不存在 show(D obj)，但是存在从 A 继承来的 show(C obj)，将 D 转型成其父类 C</span></span><br><span class="line">    b.show(d); <span class="comment">// A.show(C)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用的还是 B 对象，所以 ba 和 b 的调用结果一样</span></span><br><span class="line">    A ba = <span class="keyword">new</span> B();</span><br><span class="line">    ba.show(c); <span class="comment">// A.show(C)</span></span><br><span class="line">    ba.show(d); <span class="comment">// A.show(C)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 重载（Overload）</strong>  </p>
<p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</p>
<p>应该注意的是，返回值不同，其它都相同不算是重载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverloadingExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> x, String y)</span> </span>&#123;</span><br><span class="line">        System.out.println(x + <span class="string">&quot; &quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    OverloadingExample example = <span class="keyword">new</span> OverloadingExample();</span><br><span class="line">    example.show(<span class="number">1</span>);</span><br><span class="line">    example.show(<span class="number">1</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、反射"><a href="#七、反射" class="headerlink" title="七、反射"></a>七、反射</h2><p>每个类都有一个   <strong>Class</strong>   对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p>
<p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p>
<p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p>
<p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p>
<ul>
<li> <strong>Field</strong>  ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li>
<li> <strong>Method</strong>  ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</li>
<li> <strong>Constructor</strong>  ：可以用 Constructor 的 newInstance() 创建新的对象。</li>
</ul>
<p><strong>反射的优点：</strong>  </p>
<ul>
<li> <strong>可扩展性</strong>   ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</li>
<li> <strong>类浏览器和可视化开发环境</strong>   ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。</li>
<li> <strong>调试器和测试工具</strong>   ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。</li>
</ul>
<p><strong>反射的缺点：</strong>  </p>
<p>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。</p>
<ul>
<li><p> <strong>性能开销</strong>   ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。</p>
</li>
<li><p> <strong>安全限制</strong>   ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</p>
</li>
<li><p> <strong>内部暴露</strong>   ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</p>
</li>
<li><p><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html">Trail: The Reflection API</a></p>
</li>
<li><p><a href="http://www.sczyh30.com/posts/Java/java-reflection-1/">深入解析 Java 反射（1）- 基础</a></p>
</li>
</ul>
<h2 id="八、异常"><a href="#八、异常" class="headerlink" title="八、异常"></a>八、异常</h2><p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种：  <strong>Error</strong>   和 <strong>Exception</strong>。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：</p>
<ul>
<li>  <strong>受检异常</strong>  ：需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复；</li>
<li>  <strong>非受检异常</strong>  ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/PPjwP.png" width="600"> </div><br>

<ul>
<li><p><a href="https://www.journaldev.com/2167/java-exception-interview-questions-and-answersl">Java Exception Interview Questions and Answers</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/Qian123/p/5715402.html">Java提高篇——Java 异常处理</a></p>
</li>
</ul>
<h2 id="九、泛型"><a href="#九、泛型" class="headerlink" title="九、泛型"></a>九、泛型</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// T stands for &quot;Type&quot;</span></span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123; <span class="keyword">this</span>.t = t; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://www.cnblogs.com/Blue-Keroro/p/8875898.html">Java 泛型详解</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1033693">10 道 Java 泛型面试题</a></li>
</ul>
<h2 id="十、注解"><a href="#十、注解" class="headerlink" title="十、注解"></a>十、注解</h2><p>Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。</p>
<p><a href="https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html">注解 Annotation 实现原理与自定义注解例子</a></p>
<h2 id="十一、特性"><a href="#十一、特性" class="headerlink" title="十一、特性"></a>十一、特性</h2><h3 id="Java-各版本的新特性"><a href="#Java-各版本的新特性" class="headerlink" title="Java 各版本的新特性"></a>Java 各版本的新特性</h3><p><strong>New highlights in Java SE 8</strong>  </p>
<ol>
<li>Lambda Expressions</li>
<li>Pipelines and Streams</li>
<li>Date and Time API</li>
<li>Default Methods</li>
<li>Type Annotations</li>
<li>Nashhorn JavaScript Engine</li>
<li>Concurrent Accumulators</li>
<li>Parallel operations</li>
<li>PermGen Error Removed</li>
</ol>
<p><strong>New highlights in Java SE 7</strong>  </p>
<ol>
<li>Strings in Switch Statement</li>
<li>Type Inference for Generic Instance Creation</li>
<li>Multiple Exception Handling</li>
<li>Support for Dynamic Languages</li>
<li>Try with Resources</li>
<li>Java nio Package</li>
<li>Binary Literals, Underscore in literals</li>
<li>Diamond Syntax</li>
</ol>
<ul>
<li><a href="http://www.selfgrowth.com/articles/difference-between-java-18-and-java-17">Difference between Java 1.8 and Java 1.7?</a></li>
<li><a href="http://www.importnew.com/19345.html">Java 8 特性</a></li>
</ul>
<h3 id="Java-与-C-的区别"><a href="#Java-与-C-的区别" class="headerlink" title="Java 与 C++ 的区别"></a>Java 与 C++ 的区别</h3><ul>
<li>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。</li>
<li>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。</li>
<li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li>
<li>Java 支持自动垃圾回收，而 C++ 需要手动回收。</li>
<li>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</li>
<li>Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。</li>
<li>Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。</li>
</ul>
<p><a href="http://cs-fundamentals.com/tech-interview/java/differences-between-java-and-cpp.php">What are the main differences between Java and C++?</a></p>
<h3 id="JRE-or-JDK"><a href="#JRE-or-JDK" class="headerlink" title="JRE or JDK"></a>JRE or JDK</h3><ul>
<li>JRE：Java Runtime Environment，Java 运行环境的简称，为 Java 的运行提供了所需的环境。它是一个 JVM 程序，主要包括了 JVM 的标准实现和一些 Java 基本类库。</li>
<li>JDK：Java Development Kit，Java 开发工具包，提供了 Java 的开发及运行环境。JDK 是 Java 开发的核心，集成了 JRE 以及一些其它的工具，比如编译 Java 源码的编译器 javac 等。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>Eckel B. Java 编程思想[M]. 机械工业出版社, 2002.</li>
<li>Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础总结</title>
    <url>/posts/e442970.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>转载自：<a href="https://github.com/CyC2018/CS-Notes#coffee-java">https://github.com/CyC2018/CS-Notes#coffee-java</a></p>
<span id="more"></span>

<ul>
<li><a href="#linux">Linux</a><ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E4%B8%80%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E6%A6%82%E5%BF%B5">一、常用操作以及概念</a><ul>
<li><a href="#%E5%BF%AB%E6%8D%B7%E9%94%AE">快捷键</a></li>
<li><a href="#%E6%B1%82%E5%8A%A9">求助</a></li>
<li><a href="#%E5%85%B3%E6%9C%BA">关机</a></li>
<li><a href="#path">PATH</a></li>
<li><a href="#sudo">sudo</a></li>
<li><a href="#%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7">包管理工具</a></li>
<li><a href="#%E5%8F%91%E8%A1%8C%E7%89%88">发行版</a></li>
<li><a href="#vim-%E4%B8%89%E4%B8%AA%E6%A8%A1%E5%BC%8F">VIM 三个模式</a></li>
<li><a href="#gnu">GNU</a></li>
<li><a href="#%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE">开源协议</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E7%A3%81%E7%9B%98">二、磁盘</a><ul>
<li><a href="#%E7%A3%81%E7%9B%98%E6%8E%A5%E5%8F%A3">磁盘接口</a></li>
<li><a href="#%E7%A3%81%E7%9B%98%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D">磁盘的文件名</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E5%88%86%E5%8C%BA">三、分区</a><ul>
<li><a href="#%E5%88%86%E5%8C%BA%E8%A1%A8">分区表</a></li>
<li><a href="#%E5%BC%80%E6%9C%BA%E6%A3%80%E6%B5%8B%E7%A8%8B%E5%BA%8F">开机检测程序</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">四、文件系统</a><ul>
<li><a href="#%E5%88%86%E5%8C%BA%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">分区与文件系统</a></li>
<li><a href="#%E7%BB%84%E6%88%90">组成</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96">文件读取</a></li>
<li><a href="#%E7%A3%81%E7%9B%98%E7%A2%8E%E7%89%87">磁盘碎片</a></li>
<li><a href="#block">block</a></li>
<li><a href="#inode">inode</a></li>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li>
<li><a href="#%E6%97%A5%E5%BF%97">日志</a></li>
<li><a href="#%E6%8C%82%E8%BD%BD">挂载</a></li>
<li><a href="#%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE">目录配置</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94%E6%96%87%E4%BB%B6">五、文件</a><ul>
<li><a href="#%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7">文件属性</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">文件与目录的基本操作</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9%E6%9D%83%E9%99%90">修改权限</a></li>
<li><a href="#%E9%BB%98%E8%AE%A4%E6%9D%83%E9%99%90">默认权限</a></li>
<li><a href="#%E7%9B%AE%E5%BD%95%E7%9A%84%E6%9D%83%E9%99%90">目录的权限</a></li>
<li><a href="#%E9%93%BE%E6%8E%A5">链接</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9">获取文件内容</a></li>
<li><a href="#%E6%8C%87%E4%BB%A4%E4%B8%8E%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2">指令与文件搜索</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD%E5%8E%8B%E7%BC%A9%E4%B8%8E%E6%89%93%E5%8C%85">六、压缩与打包</a><ul>
<li><a href="#%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E5%90%8D">压缩文件名</a></li>
<li><a href="#%E5%8E%8B%E7%BC%A9%E6%8C%87%E4%BB%A4">压缩指令</a></li>
<li><a href="#%E6%89%93%E5%8C%85">打包</a></li>
</ul>
</li>
<li><a href="#%E4%B8%83bash">七、Bash</a><ul>
<li><a href="#%E7%89%B9%E6%80%A7">特性</a></li>
<li><a href="#%E5%8F%98%E9%87%8F%E6%93%8D%E4%BD%9C">变量操作</a></li>
<li><a href="#%E6%8C%87%E4%BB%A4%E6%90%9C%E7%B4%A2%E9%A1%BA%E5%BA%8F">指令搜索顺序</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8D%E5%AE%9A%E5%90%91">数据流重定向</a></li>
</ul>
</li>
<li><a href="#%E5%85%AB%E7%AE%A1%E9%81%93%E6%8C%87%E4%BB%A4">八、管道指令</a><ul>
<li><a href="#%E6%8F%90%E5%8F%96%E6%8C%87%E4%BB%A4">提取指令</a></li>
<li><a href="#%E6%8E%92%E5%BA%8F%E6%8C%87%E4%BB%A4">排序指令</a></li>
<li><a href="#%E5%8F%8C%E5%90%91%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91">双向输出重定向</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%8D%A2%E6%8C%87%E4%BB%A4">字符转换指令</a></li>
<li><a href="#%E5%88%86%E5%8C%BA%E6%8C%87%E4%BB%A4">分区指令</a></li>
</ul>
</li>
<li><a href="#%E4%B9%9D%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">九、正则表达式</a><ul>
<li><a href="#grep">grep</a></li>
<li><a href="#printf">printf</a></li>
<li><a href="#awk">awk</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86">十、进程管理</a><ul>
<li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B">查看进程</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81">进程状态</a></li>
<li><a href="#sigchld">SIGCHLD</a></li>
<li><a href="#wait">wait()</a></li>
<li><a href="#waitpid">waitpid()</a></li>
<li><a href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B">孤儿进程</a></li>
<li><a href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B">僵尸进程</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a><!-- GFM-TOC -->


</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了便于理解，本文从常用操作和概念开始讲起。虽然已经尽量做到简化，但是涉及到的内容还是有点多。在面试中，Linux 知识点相对于网络和操作系统等知识点而言不是那么重要，只需要重点掌握一些原理和命令即可。为了方便大家准备面试，在此先将一些比较重要的知识点列出来：</p>
<ul>
<li>能简单使用 cat，grep，cut 等命令进行一些操作；</li>
<li>文件系统相关的原理，inode 和 block 等概念，数据恢复；</li>
<li>硬链接与软链接；</li>
<li>进程管理相关，僵尸进程与孤儿进程，SIGCHLD 。</li>
</ul>
<h2 id="一、常用操作以及概念"><a href="#一、常用操作以及概念" class="headerlink" title="一、常用操作以及概念"></a>一、常用操作以及概念</h2><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><ul>
<li>Tab：命令和文件名补全；</li>
<li>Ctrl+C：中断正在运行的程序；</li>
<li>Ctrl+D：结束键盘输入（End Of File，EOF）</li>
</ul>
<h3 id="求助"><a href="#求助" class="headerlink" title="求助"></a>求助</h3><h4 id="1-–help"><a href="#1-–help" class="headerlink" title="1. –help"></a>1. –help</h4><p>指令的基本用法与选项介绍。</p>
<h4 id="2-man"><a href="#2-man" class="headerlink" title="2. man"></a>2. man</h4><p>man 是 manual 的缩写，将指令的具体信息显示出来。</p>
<p>当执行 <code>man date</code> 时，有 DATE(1) 出现，其中的数字代表指令的类型，常用的数字及其类型如下：</p>
<table>
<thead>
<tr>
<th align="center">代号</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td>用户在 shell 环境中可以操作的指令或者可执行文件</td>
</tr>
<tr>
<td align="center">5</td>
<td>配置文件</td>
</tr>
<tr>
<td align="center">8</td>
<td>系统管理员可以使用的管理指令</td>
</tr>
</tbody></table>
<h4 id="3-info"><a href="#3-info" class="headerlink" title="3. info"></a>3. info</h4><p>info 与 man 类似，但是 info 将文档分成一个个页面，每个页面可以跳转。</p>
<h4 id="4-doc"><a href="#4-doc" class="headerlink" title="4. doc"></a>4. doc</h4><p>/usr/share/doc 存放着软件的一整套说明文件。</p>
<h3 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h3><h4 id="1-who"><a href="#1-who" class="headerlink" title="1. who"></a>1. who</h4><p>在关机前需要先使用 who 命令查看有没有其它用户在线。</p>
<h4 id="2-sync"><a href="#2-sync" class="headerlink" title="2. sync"></a>2. sync</h4><p>为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘，因此关机之前需要先进行 sync 同步操作。</p>
<h4 id="3-shutdown"><a href="#3-shutdown" class="headerlink" title="3. shutdown"></a>3. shutdown</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## shutdown [-krhc] 时间 [信息]</span><br><span class="line">-k ： 不会关机，只是发送警告信息，通知所有在线的用户</span><br><span class="line">-r ： 将系统的服务停掉后就重新启动</span><br><span class="line">-h ： 将系统的服务停掉后就立即关机</span><br><span class="line">-c ： 取消已经在进行的 shutdown</span><br></pre></td></tr></table></figure>

<h3 id="PATH"><a href="#PATH" class="headerlink" title="PATH"></a>PATH</h3><p>可以在环境变量 PATH 中声明可执行文件的路径，路径之间用 : 分隔。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin</span><br></pre></td></tr></table></figure>

<h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>sudo 允许一般用户使用 root 可执行的命令，不过只有在 /etc/sudoers 配置文件中添加的用户才能使用该指令。</p>
<h3 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h3><p>RPM 和 DPKG 为最常见的两类软件包管理工具：</p>
<ul>
<li>RPM 全称为 Redhat Package Manager，最早由 Red Hat 公司制定实施，随后被 GNU 开源操作系统接受并成为许多 Linux 系统的既定软件标准。YUM 基于 RPM，具有依赖管理和软件升级功能。</li>
<li>与 RPM 竞争的是基于 Debian 操作系统的 DEB 软件包管理工具 DPKG，全称为 Debian Package，功能方面与 RPM 相似。</li>
</ul>
<h3 id="发行版"><a href="#发行版" class="headerlink" title="发行版"></a>发行版</h3><p>Linux 发行版是 Linux 内核及各种应用软件的集成版本。</p>
<table>
<thead>
<tr>
<th align="center">基于的包管理工具</th>
<th align="center">商业发行版</th>
<th align="center">社区发行版</th>
</tr>
</thead>
<tbody><tr>
<td align="center">RPM</td>
<td align="center">Red Hat</td>
<td align="center">Fedora / CentOS</td>
</tr>
<tr>
<td align="center">DPKG</td>
<td align="center">Ubuntu</td>
<td align="center">Debian</td>
</tr>
</tbody></table>
<h3 id="VIM-三个模式"><a href="#VIM-三个模式" class="headerlink" title="VIM 三个模式"></a>VIM 三个模式</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191209002818626.png"> </div><br>



<ul>
<li>一般指令模式（Command mode）：VIM 的默认模式，可以用于移动游标查看内容；</li>
<li>编辑模式（Insert mode）：按下 “i” 等按键之后进入，可以对文本进行编辑；</li>
<li>指令列模式（Bottom-line mode）：按下 “:” 按键之后进入，用于保存退出等操作。</li>
</ul>
<p>在指令列模式下，有以下命令用于离开或者保存文件。</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">:w</td>
<td align="center">写入磁盘</td>
</tr>
<tr>
<td align="center">:w!</td>
<td align="center">当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关</td>
</tr>
<tr>
<td align="center">:q</td>
<td align="center">离开</td>
</tr>
<tr>
<td align="center">:q!</td>
<td align="center">强制离开不保存</td>
</tr>
<tr>
<td align="center">:wq</td>
<td align="center">写入磁盘后离开</td>
</tr>
<tr>
<td align="center">:wq!</td>
<td align="center">强制写入磁盘后离开</td>
</tr>
</tbody></table>
<h3 id="GNU"><a href="#GNU" class="headerlink" title="GNU"></a>GNU</h3><p>GNU 计划，译为革奴计划，它的目标是创建一套完全自由的操作系统，称为 GNU，其内容软件完全以 GPL 方式发布。其中 GPL 全称为 GNU 通用公共许可协议（GNU General Public License），包含了以下内容：</p>
<ul>
<li>以任何目的运行此程序的自由；</li>
<li>再复制的自由；</li>
<li>改进此程序，并公开发布改进的自由。</li>
</ul>
<h3 id="开源协议"><a href="#开源协议" class="headerlink" title="开源协议"></a>开源协议</h3><ul>
<li><a href="https://choosealicense.com/">Choose an open source license</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html">如何选择开源许可证？</a></li>
</ul>
<h2 id="二、磁盘"><a href="#二、磁盘" class="headerlink" title="二、磁盘"></a>二、磁盘</h2><h3 id="磁盘接口"><a href="#磁盘接口" class="headerlink" title="磁盘接口"></a>磁盘接口</h3><h4 id="1-IDE"><a href="#1-IDE" class="headerlink" title="1. IDE"></a>1. IDE</h4><p>IDE（ATA）全称 Advanced Technology Attachment，接口速度最大为 133MB/s，因为并口线的抗干扰性太差，且排线占用空间较大，不利电脑内部散热，已逐渐被 SATA 所取代。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/924914c0-660c-4e4a-bbc0-1df1146e7516.jpg" width="400"> </div><br>

<h4 id="2-SATA"><a href="#2-SATA" class="headerlink" title="2. SATA"></a>2. SATA</h4><p>SATA 全称 Serial ATA，也就是使用串口的 ATA 接口，抗干扰性强，且对数据线的长度要求比 ATA 低很多，支持热插拔等功能。SATA-II 的接口速度为 300MB/s，而 SATA-III 标准可达到 600MB/s 的传输速度。SATA 的数据线也比 ATA 的细得多，有利于机箱内的空气流通，整理线材也比较方便。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f9f2a16b-4843-44d1-9759-c745772e9bcf.jpg" width> </div><br>

<h4 id="3-SCSI"><a href="#3-SCSI" class="headerlink" title="3. SCSI"></a>3. SCSI</h4><p>SCSI 全称是 Small Computer System Interface（小型机系统接口），SCSI 硬盘广为工作站以及个人电脑以及服务器所使用，因此会使用较为先进的技术，如碟片转速 15000rpm 的高转速，且传输时 CPU 占用率较低，但是单价也比相同容量的 ATA 及 SATA 硬盘更加昂贵。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f0574025-c514-49f5-a591-6d6a71f271f7.jpg" width> </div><br>

<h4 id="4-SAS"><a href="#4-SAS" class="headerlink" title="4. SAS"></a>4. SAS</h4><p>SAS（Serial Attached SCSI）是新一代的 SCSI 技术，和 SATA 硬盘相同，都是采取序列式技术以获得更高的传输速度，可达到 6Gb/s。此外也通过缩小连接线改善系统内部空间等。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6729baa0-57d7-4817-b3aa-518cbccf824c.jpg" width> </div><br>

<h3 id="磁盘的文件名"><a href="#磁盘的文件名" class="headerlink" title="磁盘的文件名"></a>磁盘的文件名</h3><p>Linux 中每个硬件都被当做一个文件，包括磁盘。磁盘以磁盘接口类型进行命名，常见磁盘的文件名如下：</p>
<ul>
<li>IDE 磁盘：/dev/hd[a-d]</li>
<li>SATA/SCSI/SAS 磁盘：/dev/sd[a-p]</li>
</ul>
<p>其中文件名后面的序号的确定与系统检测到磁盘的顺序有关，而与磁盘所插入的插槽位置无关。</p>
<h2 id="三、分区"><a href="#三、分区" class="headerlink" title="三、分区"></a>三、分区</h2><h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3><p>磁盘分区表主要有两种格式，一种是限制较多的 MBR 分区表，一种是较新且限制较少的 GPT 分区表。</p>
<h4 id="1-MBR"><a href="#1-MBR" class="headerlink" title="1. MBR"></a>1. MBR</h4><p>MBR 中，第一个扇区最重要，里面有主要开机记录（Master boot record, MBR）及分区表（partition table），其中主要开机记录占 446 bytes，分区表占 64 bytes。</p>
<p>分区表只有 64 bytes，最多只能存储 4 个分区，这 4 个分区为主分区（Primary）和扩展分区（Extended）。其中扩展分区只有一个，它使用其它扇区来记录额外的分区表，因此通过扩展分区可以分出更多分区，这些分区称为逻辑分区。</p>
<p>Linux 也把分区当成文件，分区文件的命名方式为：磁盘文件名 + 编号，例如 /dev/sda1。注意，逻辑分区的编号从 5 开始。</p>
<h4 id="2-GPT"><a href="#2-GPT" class="headerlink" title="2. GPT"></a>2. GPT</h4><p>扇区是磁盘的最小存储单位，旧磁盘的扇区大小通常为 512 bytes，而最新的磁盘支持 4 k。GPT 为了兼容所有磁盘，在定义扇区上使用逻辑区块地址（Logical Block Address, LBA），LBA 默认大小为 512 bytes。</p>
<p>GPT 第 1 个区块记录了主要开机记录（MBR），紧接着是 33 个区块记录分区信息，并把最后的 33 个区块用于对分区信息进行备份。这 33 个区块第一个为 GPT 表头纪录，这个部份纪录了分区表本身的位置与大小和备份分区的位置，同时放置了分区表的校验码 (CRC32)，操作系统可以根据这个校验码来判断 GPT 是否正确。若有错误，可以使用备份分区进行恢复。</p>
<p>GPT 没有扩展分区概念，都是主分区，每个 LBA 可以分 4 个分区，因此总共可以分 4 * 32 = 128 个分区。</p>
<p>MBR 不支持 2.2 TB 以上的硬盘，GPT 则最多支持到 2<sup>33</sup> TB = 8 ZB。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/GUID_Partition_Table_Scheme.svg.png" width="400"> </div><br>

<h3 id="开机检测程序"><a href="#开机检测程序" class="headerlink" title="开机检测程序"></a>开机检测程序</h3><h4 id="1-BIOS"><a href="#1-BIOS" class="headerlink" title="1. BIOS"></a>1. BIOS</h4><p>BIOS（Basic Input/Output System，基本输入输出系统），它是一个固件（嵌入在硬件中的软件），BIOS 程序存放在断电后内容不会丢失的只读内存中。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/50831a6f-2777-46ea-a571-29f23c85cc21.jpg"> </div><br>

<p>BIOS 是开机的时候计算机执行的第一个程序，这个程序知道可以开机的磁盘，并读取磁盘第一个扇区的主要开机记录（MBR），由主要开机记录（MBR）执行其中的开机管理程序，这个开机管理程序会加载操作系统的核心文件。</p>
<p>主要开机记录（MBR）中的开机管理程序提供以下功能：选单、载入核心文件以及转交其它开机管理程序。转交这个功能可以用来实现多重引导，只需要将另一个操作系统的开机管理程序安装在其它分区的启动扇区上，在启动开机管理程序时，就可以通过选单选择启动当前的操作系统或者转交给其它开机管理程序从而启动另一个操作系统。</p>
<p>下图中，第一扇区的主要开机记录（MBR）中的开机管理程序提供了两个选单：M1、M2，M1 指向了 Windows 操作系统，而 M2 指向其它分区的启动扇区，里面包含了另外一个开机管理程序，提供了一个指向 Linux 的选单。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f900f266-a323-42b2-bc43-218fdb8811a8.jpg" width="600"> </div><br>

<p>安装多重引导，最好先安装 Windows 再安装 Linux。因为安装 Windows 时会覆盖掉主要开机记录（MBR），而 Linux 可以选择将开机管理程序安装在主要开机记录（MBR）或者其它分区的启动扇区，并且可以设置开机管理程序的选单。</p>
<h4 id="2-UEFI"><a href="#2-UEFI" class="headerlink" title="2. UEFI"></a>2. UEFI</h4><p>BIOS 不可以读取 GPT 分区表，而 UEFI 可以。</p>
<h2 id="四、文件系统"><a href="#四、文件系统" class="headerlink" title="四、文件系统"></a>四、文件系统</h2><h3 id="分区与文件系统"><a href="#分区与文件系统" class="headerlink" title="分区与文件系统"></a>分区与文件系统</h3><p>对分区进行格式化是为了在分区上建立文件系统。一个分区通常只能格式化为一个文件系统，但是磁盘阵列等技术可以将一个分区格式化为多个文件系统。</p>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>最主要的几个组成部分如下：</p>
<ul>
<li>inode：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号；</li>
<li>block：记录文件的内容，文件太大时，会占用多个 block。</li>
</ul>
<p>除此之外还包括：</p>
<ul>
<li>superblock：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等；</li>
<li>block bitmap：记录 block 是否被使用的位图。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/BSD_disk.png" width="800"> </div><br>

<h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><p>对于 Ext2 文件系统，当要读取一个文件的内容时，先在 inode 中查找文件内容所在的所有 block，然后把所有 block 的内容读出来。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/12a65cc6-20e0-4706-9fe6-3ba49413d7f6.png" width="500px"> </div><br>

<p>而对于 FAT 文件系统，它没有 inode，每个 block 中存储着下一个 block 的编号。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5b718e86-7102-4bb6-8ca5-d1dd791530c5.png" width="500px"> </div><br>

<h3 id="磁盘碎片"><a href="#磁盘碎片" class="headerlink" title="磁盘碎片"></a>磁盘碎片</h3><p>指一个文件内容所在的 block 过于分散，导致磁盘磁头移动距离过大，从而降低磁盘读写性能。</p>
<h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>在 Ext2 文件系统中所支持的 block 大小有 1K，2K 及 4K 三种，不同的大小限制了单个文件和文件系统的最大大小。</p>
<table>
<thead>
<tr>
<th align="center">大小</th>
<th align="center">1KB</th>
<th align="center">2KB</th>
<th align="center">4KB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">最大单一文件</td>
<td align="center">16GB</td>
<td align="center">256GB</td>
<td align="center">2TB</td>
</tr>
<tr>
<td align="center">最大文件系统</td>
<td align="center">2TB</td>
<td align="center">8TB</td>
<td align="center">16TB</td>
</tr>
</tbody></table>
<p>一个 block 只能被一个文件所使用，未使用的部分直接浪费了。因此如果需要存储大量的小文件，那么最好选用比较小的 block。</p>
<h3 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h3><p>inode 具体包含以下信息：</p>
<ul>
<li>权限 (read/write/excute)；</li>
<li>拥有者与群组 (owner/group)；</li>
<li>容量；</li>
<li>建立或状态改变的时间 (ctime)；</li>
<li>最近读取时间 (atime)；</li>
<li>最近修改时间 (mtime)；</li>
<li>定义文件特性的旗标 (flag)，如 SetUID…；</li>
<li>该文件真正内容的指向 (pointer)。</li>
</ul>
<p>inode 具有以下特点：</p>
<ul>
<li>每个 inode 大小均固定为 128 bytes (新的 ext4 与 xfs 可设定到 256 bytes)；</li>
<li>每个文件都仅会占用一个 inode。</li>
</ul>
<p>inode 中记录了文件内容所在的 block 编号，但是每个 block 非常小，一个大文件随便都需要几十万的 block。而一个 inode 大小有限，无法直接引用这么多 block 编号。因此引入了间接、双间接、三间接引用。间接引用让 inode 记录的引用 block 块记录引用信息。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/inode_with_signatures.jpg" width="600"> </div><br>

<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>建立一个目录时，会分配一个 inode 与至少一个 block。block 记录的内容是目录下所有文件的 inode 编号以及文件名。</p>
<p>可以看到文件的 inode 本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些操作与目录的写权限有关。</p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>如果突然断电，那么文件系统会发生错误，例如断电前只修改了 block bitmap，而还没有将数据真正写入 block 中。</p>
<p>ext3/ext4 文件系统引入了日志功能，可以利用日志来修复文件系统。</p>
<h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p>挂载利用目录作为文件系统的进入点，也就是说，进入目录之后就可以读取文件系统的数据。</p>
<h3 id="目录配置"><a href="#目录配置" class="headerlink" title="目录配置"></a>目录配置</h3><p>为了使不同 Linux 发行版本的目录结构保持一致性，Filesystem Hierarchy Standard (FHS) 规定了 Linux 的目录结构。最基础的三个目录如下：</p>
<ul>
<li>/ (root, 根目录)</li>
<li>/usr (unix software resource)：所有系统默认软件都会安装到这个目录；</li>
<li>/var (variable)：存放系统或程序运行过程中的数据文件。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/linux-filesystem.png" width> </div><br>

<h2 id="五、文件"><a href="#五、文件" class="headerlink" title="五、文件"></a>五、文件</h2><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。</p>
<p>使用 ls 查看一个文件时，会显示一个文件的信息，例如 <code>drwxr-xr-x 3 root root 17 May 6 00:14 .config</code>，对这个信息的解释如下：</p>
<ul>
<li>drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段</li>
<li>3：链接数</li>
<li>root：文件拥有者</li>
<li>root：所属群组</li>
<li>17：文件大小</li>
<li>May 6 00:14：文件最后被修改的时间</li>
<li>.config：文件名</li>
</ul>
<p>常见的文件类型及其含义有：</p>
<ul>
<li>d：目录</li>
<li>-：文件</li>
<li>l：链接文件</li>
</ul>
<p>9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。</p>
<p>文件时间有以下三种：</p>
<ul>
<li>modification time (mtime)：文件的内容更新就会更新；</li>
<li>status time (ctime)：文件的状态（权限、属性）更新就会更新；</li>
<li>access time (atime)：读取文件时就会更新。</li>
</ul>
<h3 id="文件与目录的基本操作"><a href="#文件与目录的基本操作" class="headerlink" title="文件与目录的基本操作"></a>文件与目录的基本操作</h3><h4 id="1-ls"><a href="#1-ls" class="headerlink" title="1. ls"></a>1. ls</h4><p>列出文件或者目录的信息，目录的信息就是其中包含的文件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## ls [-aAdfFhilnrRSt] file|dir</span><br><span class="line">-a ：列出全部的文件</span><br><span class="line">-d ：仅列出目录本身</span><br><span class="line">-l ：以长数据串行列出，包含文件的属性与权限等等数据</span><br></pre></td></tr></table></figure>

<h4 id="2-cd"><a href="#2-cd" class="headerlink" title="2. cd"></a>2. cd</h4><p>更换当前目录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd [相对路径或绝对路径]</span><br></pre></td></tr></table></figure>

<h4 id="3-mkdir"><a href="#3-mkdir" class="headerlink" title="3. mkdir"></a>3. mkdir</h4><p>创建目录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## mkdir [-mp] 目录名称</span><br><span class="line">-m ：配置目录权限</span><br><span class="line">-p ：递归创建目录</span><br></pre></td></tr></table></figure>

<h4 id="4-rmdir"><a href="#4-rmdir" class="headerlink" title="4. rmdir"></a>4. rmdir</h4><p>删除目录，目录必须为空。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">rmdir [-p] 目录名称</span><br><span class="line">-p ：递归删除目录</span><br></pre></td></tr></table></figure>

<h4 id="5-touch"><a href="#5-touch" class="headerlink" title="5. touch"></a>5. touch</h4><p>更新文件时间或者建立新文件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## touch [-acdmt] filename</span><br><span class="line">-a ： 更新 atime</span><br><span class="line">-c ： 更新 ctime，若该文件不存在则不建立新文件</span><br><span class="line">-m ： 更新 mtime</span><br><span class="line">-d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date=&quot;日期或时间&quot;</span><br><span class="line">-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm]</span><br></pre></td></tr></table></figure>

<h4 id="6-cp"><a href="#6-cp" class="headerlink" title="6. cp"></a>6. cp</h4><p>复制文件。如果源文件有两个以上，则目的文件一定要是目录才行。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">cp [-adfilprsu] source destination</span><br><span class="line">-a ：相当于 -dr --preserve=all</span><br><span class="line">-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身</span><br><span class="line">-i ：若目标文件已经存在时，在覆盖前会先询问</span><br><span class="line">-p ：连同文件的属性一起复制过去</span><br><span class="line">-r ：递归复制</span><br><span class="line">-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制</span><br><span class="line">--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了</span><br></pre></td></tr></table></figure>

<h4 id="7-rm"><a href="#7-rm" class="headerlink" title="7. rm"></a>7. rm</h4><p>删除文件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## rm [-fir] 文件或目录</span><br><span class="line">-r ：递归删除</span><br></pre></td></tr></table></figure>

<h4 id="8-mv"><a href="#8-mv" class="headerlink" title="8. mv"></a>8. mv</h4><p>移动文件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## mv [-fiu] source destination</span><br><span class="line">## mv [options] source1 source2 source3 .... directory</span><br><span class="line">-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖</span><br></pre></td></tr></table></figure>

<h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><p>可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## chmod [-R] xyz dirname/filename</span><br></pre></td></tr></table></figure>

<p>示例：将 .bashrc 文件的权限修改为 -rwxr-xr–。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## chmod 754 .bashrc</span><br></pre></td></tr></table></figure>

<p>也可以使用符号来设定权限。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## chmod [ugoa]  [+-=] [rwx] dirname/filename</span><br><span class="line">- u：拥有者</span><br><span class="line">- g：所属群组</span><br><span class="line">- o：其他人</span><br><span class="line">- a：所有人</span><br><span class="line">- +：添加权限</span><br><span class="line">- -：移除权限</span><br><span class="line">- =：设定权限</span><br></pre></td></tr></table></figure>

<p>示例：为 .bashrc 文件的所有用户添加写权限。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## chmod a+w .bashrc</span><br></pre></td></tr></table></figure>

<h3 id="默认权限"><a href="#默认权限" class="headerlink" title="默认权限"></a>默认权限</h3><ul>
<li>文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。</li>
<li>目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。</li>
</ul>
<p>可以通过 umask 设置或者查看默认权限，通常以掩码的形式来表示，例如 002 表示其它用户的权限去除了一个 2 的权限，也就是写权限，因此建立新文件时默认的权限为 -rw-rw-r–。</p>
<h3 id="目录的权限"><a href="#目录的权限" class="headerlink" title="目录的权限"></a>目录的权限</h3><p>文件名不是存储在一个文件的内容中，而是存储在一个文件所在的目录中。因此，拥有文件的 w 权限并不能对文件名进行修改。</p>
<p>目录存储文件列表，一个目录的权限也就是对其文件列表的权限。因此，目录的 r 权限表示可以读取文件列表；w 权限表示可以修改文件列表，具体来说，就是添加删除文件，对文件名进行修改；x 权限可以让该目录成为工作目录，x 权限是 r 和 w 权限的基础，如果不能使一个目录成为工作目录，也就没办法读取文件列表以及对文件列表进行修改了。</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1e46fd03-0cda-4d60-9b1c-0c256edaf6b2.png" width="450px"> </div><br>


<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## ln [-sf] source_filename dist_filename</span><br><span class="line">-s ：默认是实体链接，加 -s 为符号链接</span><br><span class="line">-f ：如果目标文件存在时，先删除目标文件</span><br></pre></td></tr></table></figure>

<h4 id="1-实体链接"><a href="#1-实体链接" class="headerlink" title="1. 实体链接"></a>1. 实体链接</h4><p>在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。</p>
<p>删除任意一个条目，文件还是存在，只要引用数量不为 0。</p>
<p>有以下限制：不能跨越文件系统、不能对目录进行链接。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## ln /etc/crontab .</span><br><span class="line">## ll -i /etc/crontab crontab</span><br><span class="line">34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab</span><br><span class="line">34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab</span><br></pre></td></tr></table></figure>

<h4 id="2-符号链接"><a href="#2-符号链接" class="headerlink" title="2. 符号链接"></a>2. 符号链接</h4><p>符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。</p>
<p>当源文件被删除了，链接文件就打不开了。</p>
<p>因为记录的是路径，所以可以为目录建立符号链接。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## ll -i /etc/crontab /root/crontab2</span><br><span class="line">34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab</span><br><span class="line">53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -&gt; /etc/crontab</span><br></pre></td></tr></table></figure>

<h3 id="获取文件内容"><a href="#获取文件内容" class="headerlink" title="获取文件内容"></a>获取文件内容</h3><h4 id="1-cat"><a href="#1-cat" class="headerlink" title="1. cat"></a>1. cat</h4><p>取得文件内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## cat [-AbEnTv] filename</span><br><span class="line">-n ：打印出行号，连同空白行也会有行号，-b 不会</span><br></pre></td></tr></table></figure>

<h4 id="2-tac"><a href="#2-tac" class="headerlink" title="2. tac"></a>2. tac</h4><p>是 cat 的反向操作，从最后一行开始打印。</p>
<h4 id="3-more"><a href="#3-more" class="headerlink" title="3. more"></a>3. more</h4><p>和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。</p>
<h4 id="4-less"><a href="#4-less" class="headerlink" title="4. less"></a>4. less</h4><p>和 more 类似，但是多了一个向前翻页的功能。</p>
<h4 id="5-head"><a href="#5-head" class="headerlink" title="5. head"></a>5. head</h4><p>取得文件前几行。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## head [-n number] filename</span><br><span class="line">-n ：后面接数字，代表显示几行的意思</span><br></pre></td></tr></table></figure>

<h4 id="6-tail"><a href="#6-tail" class="headerlink" title="6. tail"></a>6. tail</h4><p>是 head 的反向操作，只是取得是后几行。</p>
<h4 id="7-od"><a href="#7-od" class="headerlink" title="7. od"></a>7. od</h4><p>以字符或者十六进制的形式显示二进制文件。</p>
<h3 id="指令与文件搜索"><a href="#指令与文件搜索" class="headerlink" title="指令与文件搜索"></a>指令与文件搜索</h3><h4 id="1-which"><a href="#1-which" class="headerlink" title="1. which"></a>1. which</h4><p>指令搜索。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## which [-a] command</span><br><span class="line">-a ：将所有指令列出，而不是只列第一个</span><br></pre></td></tr></table></figure>

<h4 id="2-whereis"><a href="#2-whereis" class="headerlink" title="2. whereis"></a>2. whereis</h4><p>文件搜索。速度比较快，因为它只搜索几个特定的目录。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## whereis [-bmsu] dirname/filename</span><br></pre></td></tr></table></figure>

<h4 id="3-locate"><a href="#3-locate" class="headerlink" title="3. locate"></a>3. locate</h4><p>文件搜索。可以用关键字或者正则表达式进行搜索。</p>
<p>locate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## locate [-ir] keyword</span><br><span class="line">-r：正则表达式</span><br></pre></td></tr></table></figure>

<h4 id="4-find"><a href="#4-find" class="headerlink" title="4. find"></a>4. find</h4><p>文件搜索。可以使用文件的属性和权限进行搜索。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## find [basedir] [option]</span><br><span class="line">example: find . -name &quot;shadow*&quot;</span><br></pre></td></tr></table></figure>

<p><strong>① 与时间有关的选项</strong>  </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">-mtime  n ：列出在 n 天前的那一天修改过内容的文件</span><br><span class="line">-mtime +n ：列出在 n 天之前 (不含 n 天本身) 修改过内容的文件</span><br><span class="line">-mtime -n ：列出在 n 天之内 (含 n 天本身) 修改过内容的文件</span><br><span class="line">-newer file ： 列出比 file 更新的文件</span><br></pre></td></tr></table></figure>

<p>+4、4 和 -4 的指示的时间范围如下：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/658fc5e7-79c0-4247-9445-d69bf194c539.png" width> </div><br>

<p><strong>② 与文件拥有者和所属群组有关的选项</strong>  </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">-uid n</span><br><span class="line">-gid n</span><br><span class="line">-user name</span><br><span class="line">-group name</span><br><span class="line">-nouser ：搜索拥有者不存在 /etc/passwd 的文件</span><br><span class="line">-nogroup：搜索所属群组不存在于 /etc/group 的文件</span><br></pre></td></tr></table></figure>

<p><strong>③ 与文件权限和名称有关的选项</strong>  </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">-name filename</span><br><span class="line">-size [+-]SIZE：搜寻比 SIZE 还要大 (+) 或小 (-) 的文件。这个 SIZE 的规格有：c: 代表 byte，k: 代表 1024bytes。所以，要找比 50KB 还要大的文件，就是 -size +50k</span><br><span class="line">-type TYPE</span><br><span class="line">-perm mode  ：搜索权限等于 mode 的文件</span><br><span class="line">-perm -mode ：搜索权限包含 mode 的文件</span><br><span class="line">-perm /mode ：搜索权限包含任一 mode 的文件</span><br></pre></td></tr></table></figure>

<h2 id="六、压缩与打包"><a href="#六、压缩与打包" class="headerlink" title="六、压缩与打包"></a>六、压缩与打包</h2><h3 id="压缩文件名"><a href="#压缩文件名" class="headerlink" title="压缩文件名"></a>压缩文件名</h3><p>Linux 底下有很多压缩文件名，常见的如下：</p>
<table>
<thead>
<tr>
<th>扩展名</th>
<th>压缩程序</th>
</tr>
</thead>
<tbody><tr>
<td>*.Z</td>
<td>compress</td>
</tr>
<tr>
<td>*.zip</td>
<td>zip</td>
</tr>
<tr>
<td>*.gz</td>
<td>gzip</td>
</tr>
<tr>
<td>*.bz2</td>
<td>bzip2</td>
</tr>
<tr>
<td>*.xz</td>
<td>xz</td>
</tr>
<tr>
<td>*.tar</td>
<td>tar 程序打包的数据，没有经过压缩</td>
</tr>
<tr>
<td>*.tar.gz</td>
<td>tar 程序打包的文件，经过 gzip 的压缩</td>
</tr>
<tr>
<td>*.tar.bz2</td>
<td>tar 程序打包的文件，经过 bzip2 的压缩</td>
</tr>
<tr>
<td>*.tar.xz</td>
<td>tar 程序打包的文件，经过 xz 的压缩</td>
</tr>
</tbody></table>
<h3 id="压缩指令"><a href="#压缩指令" class="headerlink" title="压缩指令"></a>压缩指令</h3><h4 id="1-gzip"><a href="#1-gzip" class="headerlink" title="1. gzip"></a>1. gzip</h4><p>gzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。</p>
<p>经过 gzip 压缩过，源文件就不存在了。</p>
<p>有 9 个不同的压缩等级可以使用。</p>
<p>可以使用 zcat、zmore、zless 来读取压缩文件的内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ gzip [-cdtv#] filename</span><br><span class="line">-c ：将压缩的数据输出到屏幕上</span><br><span class="line">-d ：解压缩</span><br><span class="line">-t ：检验压缩文件是否出错</span><br><span class="line">-v ：显示压缩比等信息</span><br><span class="line">-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6</span><br></pre></td></tr></table></figure>

<h4 id="2-bzip2"><a href="#2-bzip2" class="headerlink" title="2. bzip2"></a>2. bzip2</h4><p>提供比 gzip 更高的压缩比。</p>
<p>查看命令：bzcat、bzmore、bzless、bzgrep。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ bzip2 [-cdkzv#] filename</span><br><span class="line">-k ：保留源文件</span><br></pre></td></tr></table></figure>

<h4 id="3-xz"><a href="#3-xz" class="headerlink" title="3. xz"></a>3. xz</h4><p>提供比 bzip2 更佳的压缩比。</p>
<p>可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。</p>
<p>查看命令：xzcat、xzmore、xzless、xzgrep。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ xz [-dtlkc#] filename</span><br></pre></td></tr></table></figure>

<h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gzip、bzip2、xz 将打包文件进行压缩。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename...  ==打包压缩</span><br><span class="line">$ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件]              ==查看</span><br><span class="line">$ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录]    ==解压缩</span><br><span class="line">-z ：使用 zip；</span><br><span class="line">-j ：使用 bzip2；</span><br><span class="line">-J ：使用 xz；</span><br><span class="line">-c ：新建打包文件；</span><br><span class="line">-t ：查看打包文件里面有哪些文件；</span><br><span class="line">-x ：解打包或解压缩的功能；</span><br><span class="line">-v ：在压缩/解压缩的过程中，显示正在处理的文件名；</span><br><span class="line">-f : filename：要处理的文件；</span><br><span class="line">-C 目录 ： 在特定目录解压缩。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">使用方式</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td align="center">打包压缩</td>
<td>tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称</td>
</tr>
<tr>
<td align="center">查 看</td>
<td>tar -jtv -f filename.tar.bz2</td>
</tr>
<tr>
<td align="center">解压缩</td>
<td>tar -jxv -f filename.tar.bz2 -C 要解压缩的目录</td>
</tr>
</tbody></table>
<h2 id="七、Bash"><a href="#七、Bash" class="headerlink" title="七、Bash"></a>七、Bash</h2><p>可以通过 Shell 请求内核提供服务，Bash 正是 Shell 的一种。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>命令历史：记录使用过的命令</li>
<li>命令与文件补全：快捷键：tab</li>
<li>命名别名：例如 ll 是 ls -al 的别名</li>
<li>shell scripts</li>
<li>通配符：例如 ls -l /usr/bin/X* 列出 /usr/bin 下面所有以 X 开头的文件</li>
</ul>
<h3 id="变量操作"><a href="#变量操作" class="headerlink" title="变量操作"></a>变量操作</h3><p>对一个变量赋值直接使用 =。</p>
<p>对变量取用需要在变量前加上 $ ，也可以用 ${} 的形式；</p>
<p>输出变量使用 echo 命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ x=abc</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$x</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;x&#125;</span></span><br></pre></td></tr></table></figure>

<p>变量内容如果有空格，必须使用双引号或者单引号。</p>
<ul>
<li>双引号内的特殊字符可以保留原本特性，例如 x=”lang is $LANG”，则 x 的值为 lang is zh_TW.UTF-8；</li>
<li>单引号内的特殊字符就是特殊字符本身，例如 x=’lang is $LANG’，则 x 的值为 lang is $LANG。</li>
</ul>
<p>可以使用 `指令` 或者 $(指令) 的方式将指令的执行结果赋值给变量。例如 version=$(uname -r)，则 version 的值为 4.15.0-22-generic。</p>
<p>可以使用 export 命令将自定义变量转成环境变量，环境变量可以在子程序中使用，所谓子程序就是由当前 Bash 而产生的子 Bash。</p>
<p>Bash 的变量可以声明为数组和整数数字。注意数字类型没有浮点数。如果不进行声明，默认是字符串类型。变量的声明使用 declare 命令：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ declare [-aixr] variable</span><br><span class="line">-a ： 定义为数组类型</span><br><span class="line">-i ： 定义为整数类型</span><br><span class="line">-x ： 定义为环境变量</span><br><span class="line">-r ： 定义为 readonly 类型</span><br></pre></td></tr></table></figure>

<p>使用 [ ] 来对数组进行索引操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ array[1]=a</span><br><span class="line">$ array[2]=b</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;array[1]&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="指令搜索顺序"><a href="#指令搜索顺序" class="headerlink" title="指令搜索顺序"></a>指令搜索顺序</h3><ul>
<li>以绝对或相对路径来执行指令，例如 /bin/ls 或者 ./ls ；</li>
<li>由别名找到该指令来执行；</li>
<li>由 Bash 内置的指令来执行；</li>
<li>按 $PATH 变量指定的搜索路径的顺序找到第一个指令来执行。</li>
</ul>
<h3 id="数据流重定向"><a href="#数据流重定向" class="headerlink" title="数据流重定向"></a>数据流重定向</h3><p>重定向指的是使用文件代替标准输入、标准输出和标准错误输出。</p>
<table>
<thead>
<tr>
<th align="center">1</th>
<th align="center">代码</th>
<th align="center">运算符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">标准输入 (stdin)</td>
<td align="center">0</td>
<td align="center">&lt; 或 &lt;&lt;</td>
</tr>
<tr>
<td align="center">标准输出 (stdout)</td>
<td align="center">1</td>
<td align="center">&gt; 或 &gt;&gt;</td>
</tr>
<tr>
<td align="center">标准错误输出 (stderr)</td>
<td align="center">2</td>
<td align="center">2&gt; 或 2&gt;&gt;</td>
</tr>
</tbody></table>
<p>其中，有一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向。</p>
<p>可以将不需要的标准输出以及标准错误输出重定向到 /dev/null，相当于扔进垃圾箱。</p>
<p>如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出，例如 2&gt;&amp;1 表示将标准错误输出转换为标准输出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ find /home -name .bashrc &gt; list 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<h2 id="八、管道指令"><a href="#八、管道指令" class="headerlink" title="八、管道指令"></a>八、管道指令</h2><p>管道是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用管道。</p>
<p>在命令之间使用 | 分隔各个管道命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls -al /etc | less</span><br></pre></td></tr></table></figure>

<h3 id="提取指令"><a href="#提取指令" class="headerlink" title="提取指令"></a>提取指令</h3><p>cut 对数据进行切分，取出想要的部分。</p>
<p>切分过程一行一行地进行。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ cut</span><br><span class="line">-d ：分隔符</span><br><span class="line">-f ：经过 -d 分隔后，使用 -f n 取出第 n 个区间</span><br><span class="line">-c ：以字符为单位取出区间</span><br></pre></td></tr></table></figure>

<p>示例 1：last 显示登入者的信息，取出用户名。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ last</span><br><span class="line">root pts/1 192.168.201.101 Sat Feb 7 12:35 still logged in</span><br><span class="line">root pts/1 192.168.201.101 Fri Feb 6 12:13 - 18:46 (06:33)</span><br><span class="line">root pts/1 192.168.201.254 Thu Feb 5 22:37 - 23:53 (01:16)</span><br><span class="line"></span><br><span class="line">$ last | cut -d &#x27; &#x27; -f 1</span><br></pre></td></tr></table></figure>

<p>示例 2：将 export 输出的信息，取出第 12 字符以后的所有字符串。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ export</span><br><span class="line">declare -x HISTCONTROL=&quot;ignoredups&quot;</span><br><span class="line">declare -x HISTSIZE=&quot;1000&quot;</span><br><span class="line">declare -x HOME=&quot;/home/dmtsai&quot;</span><br><span class="line">declare -x HOSTNAME=&quot;study.centos.vbird&quot;</span><br><span class="line">.....(其他省略).....</span><br><span class="line"></span><br><span class="line">$ export | cut -c 12-</span><br></pre></td></tr></table></figure>

<h3 id="排序指令"><a href="#排序指令" class="headerlink" title="排序指令"></a>排序指令</h3><p><strong>sort</strong>   用于排序。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ sort [-fbMnrtuk] [file or stdin]</span><br><span class="line">-f ：忽略大小写</span><br><span class="line">-b ：忽略最前面的空格</span><br><span class="line">-M ：以月份的名字来排序，例如 JAN，DEC</span><br><span class="line">-n ：使用数字</span><br><span class="line">-r ：反向排序</span><br><span class="line">-u ：相当于 unique，重复的内容只出现一次</span><br><span class="line">-t ：分隔符，默认为 tab</span><br><span class="line">-k ：指定排序的区间</span><br></pre></td></tr></table></figure>

<p>示例：/etc/passwd 文件内容以 : 来分隔，要求以第三列进行排序。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ cat /etc/passwd | sort -t &#x27;:&#x27; -k 3</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">dmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bash</span><br><span class="line">alex:x:1001:1002::/home/alex:/bin/bash</span><br><span class="line">arod:x:1002:1003::/home/arod:/bin/bash</span><br></pre></td></tr></table></figure>

<p><strong>uniq</strong>   可以将重复的数据只取一个。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ uniq [-ic]</span><br><span class="line">-i ：忽略大小写</span><br><span class="line">-c ：进行计数</span><br></pre></td></tr></table></figure>

<p>示例：取得每个人的登录总次数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ last | cut -d &#x27; &#x27; -f 1 | sort | uniq -c</span><br><span class="line">1</span><br><span class="line">6 (unknown</span><br><span class="line">47 dmtsai</span><br><span class="line">4 reboot</span><br><span class="line">7 root</span><br><span class="line">1 wtmp</span><br></pre></td></tr></table></figure>

<h3 id="双向输出重定向"><a href="#双向输出重定向" class="headerlink" title="双向输出重定向"></a>双向输出重定向</h3><p>输出重定向会将输出内容重定向到文件中，而   <strong>tee</strong>   不仅能够完成这个功能，还能保留屏幕上的输出。也就是说，使用 tee 指令，一个输出会同时传送到文件和屏幕上。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ tee [-a] file</span><br></pre></td></tr></table></figure>

<h3 id="字符转换指令"><a href="#字符转换指令" class="headerlink" title="字符转换指令"></a>字符转换指令</h3><p><strong>tr</strong>   用来删除一行中的字符，或者对字符进行替换。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ tr [-ds] SET1 ...</span><br><span class="line">-d ： 删除行中 SET1 这个字符串</span><br></pre></td></tr></table></figure>

<p>示例，将 last 输出的信息所有小写转换为大写。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ last | tr &#x27;[a-z]&#x27; &#x27;[A-Z]&#x27;</span><br></pre></td></tr></table></figure>

<p>   <strong>col</strong>   将 tab 字符转为空格字符。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ col [-xb]</span><br><span class="line">-x ： 将 tab 键转换成对等的空格键</span><br></pre></td></tr></table></figure>

<p><strong>expand</strong>   将 tab 转换一定数量的空格，默认是 8 个。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ expand [-t] file</span><br><span class="line">-t ：tab 转为空格的数量</span><br></pre></td></tr></table></figure>

<p><strong>join</strong>   将有相同数据的那一行合并在一起。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ join [-ti12] file1 file2</span><br><span class="line">-t ：分隔符，默认为空格</span><br><span class="line">-i ：忽略大小写的差异</span><br><span class="line">-1 ：第一个文件所用的比较字段</span><br><span class="line">-2 ：第二个文件所用的比较字段</span><br></pre></td></tr></table></figure>

<p><strong>paste</strong>   直接将两行粘贴在一起。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ paste [-d] file1 file2</span><br><span class="line">-d ：分隔符，默认为 tab</span><br></pre></td></tr></table></figure>

<h3 id="分区指令"><a href="#分区指令" class="headerlink" title="分区指令"></a>分区指令</h3><p><strong>split</strong>   将一个文件划分成多个文件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ split [-bl] file PREFIX</span><br><span class="line">-b ：以大小来进行分区，可加单位，例如 b, k, m 等</span><br><span class="line">-l ：以行数来进行分区。</span><br><span class="line">- PREFIX ：分区文件的前导名称</span><br></pre></td></tr></table></figure>

<h2 id="九、正则表达式"><a href="#九、正则表达式" class="headerlink" title="九、正则表达式"></a>九、正则表达式</h2><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>g/re/p（globally search a regular expression and print)，使用正则表示式进行全局查找并打印。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ grep [-acinv] [--color=auto] 搜寻字符串 filename</span><br><span class="line">-c ： 统计匹配到行的个数</span><br><span class="line">-i ： 忽略大小写</span><br><span class="line">-n ： 输出行号</span><br><span class="line">-v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行</span><br><span class="line">--color=auto ：找到的关键字加颜色显示</span><br></pre></td></tr></table></figure>

<p>示例：把含有 the 字符串的行提取出来（注意默认会有 –color=auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ grep -n &#x27;the&#x27; regular_express.txt</span><br><span class="line">8:I can&#x27;t finish the test.</span><br><span class="line">12:the symbol &#x27;*&#x27; is represented as start.</span><br><span class="line">15:You are the best is mean you are the no. 1.</span><br><span class="line">16:The world Happy is the same with &quot;glad&quot;.</span><br><span class="line">18:google is the best tools for search keyword</span><br></pre></td></tr></table></figure>

<p>示例：正则表达式 a{m,n} 用来匹配字符 a m~n 次，这里需要将 { 和 } 进行转义，因为它们在 shell 是有特殊意义的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ grep -n &#x27;a\&#123;2,5\&#125;&#x27; regular_express.txt</span><br></pre></td></tr></table></figure>

<h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><p>用于格式化输出。它不属于管道命令，在给 printf 传数据时需要使用 $( ) 形式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ printf &#x27;%10s %5i %5i %5i %8.2f \n&#x27; $(cat printf.txt)</span><br><span class="line">    DmTsai    80    60    92    77.33</span><br><span class="line">     VBird    75    55    80    70.00</span><br><span class="line">       Ken    60    90    70    73.33</span><br></pre></td></tr></table></figure>

<h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>是由 Alfred Aho，Peter Weinberger 和 Brian Kernighan 创造，awk 这个名字就是这三个创始人名字的首字母。</p>
<p>awk 每次处理一行，处理的最小单位是字段，每个字段的命名方式为：$n，n 为字段号，从 1 开始，$0 表示一整行。</p>
<p>示例：取出最近五个登录用户的用户名和 IP。首先用 last -n 5 取出用最近五个登录用户的所有信息，可以看到用户名和 IP 分别在第 1 列和第 3 列，我们用 $1 和 $3 就能取出这两个字段，然后用 print 进行打印。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ last -n 5</span><br><span class="line">dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged in</span><br><span class="line">dmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22)</span><br><span class="line">dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12)</span><br><span class="line">dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14)</span><br><span class="line">dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ last -n 5 | awk &#x27;&#123;print $1 &quot;\t&quot; $3&#125;&#x27;</span><br><span class="line">dmtsai   192.168.1.100</span><br><span class="line">dmtsai   192.168.1.100</span><br><span class="line">dmtsai   192.168.1.100</span><br><span class="line">dmtsai   192.168.1.100</span><br><span class="line">dmtsai   Fri</span><br></pre></td></tr></table></figure>

<p>可以根据字段的某些条件进行匹配，例如匹配字段小于某个值的那一行数据。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ awk &#x27;条件类型 1 &#123;动作 1&#125; 条件类型 2 &#123;动作 2&#125; ...&#x27; filename</span><br></pre></td></tr></table></figure>

<p>示例：/etc/passwd 文件第三个字段为 UID，对 UID 小于 10 的数据进行处理。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ cat /etc/passwd | awk &#x27;BEGIN &#123;FS=&quot;:&quot;&#125; $3 &lt; 10 &#123;print $1 &quot;\t &quot; $3&#125;&#x27;</span><br><span class="line">root 0</span><br><span class="line">bin 1</span><br><span class="line">daemon 2</span><br></pre></td></tr></table></figure>

<p>awk 变量：</p>
<table>
<thead>
<tr>
<th align="center">变量名称</th>
<th>代表意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NF</td>
<td>每一行拥有的字段总数</td>
</tr>
<tr>
<td align="center">NR</td>
<td>目前所处理的是第几行数据</td>
</tr>
<tr>
<td align="center">FS</td>
<td>目前的分隔字符，默认是空格键</td>
</tr>
</tbody></table>
<p>示例：显示正在处理的行号以及每一行有多少字段</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ last -n 5 | awk &#x27;&#123;print $1 &quot;\t lines: &quot; NR &quot;\t columns: &quot; NF&#125;&#x27;</span><br><span class="line">dmtsai lines: 1 columns: 10</span><br><span class="line">dmtsai lines: 2 columns: 10</span><br><span class="line">dmtsai lines: 3 columns: 10</span><br><span class="line">dmtsai lines: 4 columns: 10</span><br><span class="line">dmtsai lines: 5 columns: 9</span><br></pre></td></tr></table></figure>

<h2 id="十、进程管理"><a href="#十、进程管理" class="headerlink" title="十、进程管理"></a>十、进程管理</h2><h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><h4 id="1-ps"><a href="#1-ps" class="headerlink" title="1. ps"></a>1. ps</h4><p>查看某个时间点的进程信息。</p>
<p>示例：查看自己的进程</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## ps -l</span></span><br></pre></td></tr></table></figure>

<p>示例：查看系统所有进程</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## ps aux</span></span><br></pre></td></tr></table></figure>

<p>示例：查看特定的进程</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## ps aux | grep threadx</span></span><br></pre></td></tr></table></figure>

<h4 id="2-pstree"><a href="#2-pstree" class="headerlink" title="2. pstree"></a>2. pstree</h4><p>查看进程树。</p>
<p>示例：查看所有进程树</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## pstree -A</span></span><br></pre></td></tr></table></figure>

<h4 id="3-top"><a href="#3-top" class="headerlink" title="3. top"></a>3. top</h4><p>实时显示进程信息。</p>
<p>示例：两秒钟刷新一次</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## top -d 2</span></span><br></pre></td></tr></table></figure>

<h4 id="4-netstat"><a href="#4-netstat" class="headerlink" title="4. netstat"></a>4. netstat</h4><p>查看占用端口的进程</p>
<p>示例：查看特定端口的进程</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## netstat -anp | grep port</span></span><br></pre></td></tr></table></figure>

<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><table>
<thead>
<tr>
<th align="center">状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">R</td>
<td>running or runnable (on run queue)<br>正在执行或者可执行，此时进程位于执行队列中。</td>
</tr>
<tr>
<td align="center">D</td>
<td>uninterruptible sleep (usually I/O)<br>不可中断阻塞，通常为 IO 阻塞。</td>
</tr>
<tr>
<td align="center">S</td>
<td>interruptible sleep (waiting for an event to complete) <br> 可中断阻塞，此时进程正在等待某个事件完成。</td>
</tr>
<tr>
<td align="center">Z</td>
<td>zombie (terminated but not reaped by its parent)<br>僵死，进程已经终止但是尚未被其父进程获取信息。</td>
</tr>
<tr>
<td align="center">T</td>
<td>stopped (either by a job control signal or because it is being traced) <br> 结束，进程既可以被作业控制信号结束，也可能是正在被追踪。</td>
</tr>
<tr>
<td align="center"><br></td>
<td></td>
</tr>
</tbody></table>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2bab4127-3e7d-48cc-914e-436be859fb05.png" width="490px"> </div><br>

<h3 id="SIGCHLD"><a href="#SIGCHLD" class="headerlink" title="SIGCHLD"></a>SIGCHLD</h3><p>当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中：</p>
<ul>
<li>得到 SIGCHLD 信号；</li>
<li>waitpid() 或者 wait() 调用会返回。</li>
</ul>
<p>其中子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等。</p>
<p>在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程得到子进程信息，父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息。</p>
<div align="center"> <!-- <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/flow.png" width=""/> --> </div><br>

<h3 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *status)</span></span></span><br></pre></td></tr></table></figure>

<p>父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait() 函数会销毁子进程并返回。</p>
<p>如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD。</p>
<p>参数 status 用来保存被收集的子进程退出时的一些状态，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为 NULL。</p>
<h3 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid()"></a>waitpid()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status, <span class="keyword">int</span> options)</span></span></span><br></pre></td></tr></table></figure>

<p>作用和 wait() 完全相同，但是多了两个可由用户控制的参数 pid 和 options。</p>
<p>pid 参数指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号。如果 pid=-1 时，那么和 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。</p>
<p>options 参数主要有 WNOHANG 和 WUNTRACED 两个选项，WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。</p>
<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。</p>
<p>孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。</p>
<p>由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。</p>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。</p>
<p>僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。</p>
<p>系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p>
<p>要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>鸟哥. 鸟 哥 的 Linux 私 房 菜 基 础 篇 第 三 版[J]. 2009.</li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-rpmdpkg/index.html">Linux 平台上的软件包管理</a></li>
<li><a href="http://liubigbin.github.io/2016/03/11/Linux-%E4%B9%8B%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E6%AD%BB%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/">Linux 之守护进程、僵死进程与孤儿进程</a></li>
<li><a href="https://stackoverflow.com/questions/185899/what-is-the-difference-between-a-symbolic-link-and-a-hard-link">What is the difference between a symbolic link and a hard link?</a></li>
<li><a href="https://idea.popcount.org/2012-12-11-linux-process-states/">Linux process states</a></li>
<li><a href="https://en.wikipedia.org/wiki/GUID_Partition_Table">GUID Partition Table</a></li>
<li><a href="https://blog.csdn.net/kevinhg/article/details/7001719">详解 wait 和 waitpid 函数</a></li>
<li><a href="https://blog.csdn.net/tianlesoftware/article/details/6009110">IDE、SATA、SCSI、SAS、FC、SSD 硬盘类型介绍</a></li>
<li><a href="http://www.mpchunter.com/s3000/akai-ib-301s-scsi-interface-for-s2800s3000/">Akai IB-301S SCSI Interface for S2800,S3000</a></li>
<li><a href="https://en.wikipedia.org/wiki/Parallel_ATA">Parallel ATA</a></li>
<li><a href="http://www.thessdreview.com/our-reviews/adata-xpg-sx900-256gb-sata-3-ssd-review-expanded-capacity-and-sandforce-driven-speed/4/">ADATA XPG SX900 256GB SATA 3 SSD Review – Expanded Capacity and SandForce Driven Speed</a></li>
<li><a href="https://blogs.cisco.com/datacenter/decoding-ucs-invicta-part-1">Decoding UCS Invicta – Part 1</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%9B%98">硬盘</a></li>
<li><a href="http://www.differencebetween.info/difference-between-sas-and-sata">Difference between SAS and SATA</a></li>
<li><a href="https://zh.wikipedia.org/wiki/BIOS">BIOS</a></li>
<li><a href="https://www.cs.rutgers.edu/~pxk/416/notes/13-fs-studies.html">File system design case studies</a></li>
<li><a href="https://classes.soe.ucsc.edu/cmps111/Fall08/proj4.shtml">Programming Project #4</a></li>
<li><a href="http://web.cs.ucla.edu/classes/fall14/cs111/scribe/11a/index.html">FILE SYSTEM DESIGN</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
